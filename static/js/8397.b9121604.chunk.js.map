{"version":3,"file":"static/js/8397.b9121604.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/trix/src/util.ts","../../../node_modules/@gmod/trix/src/index.ts","../../../plugins/trix/src/TrixTextSearchAdapter/TrixTextSearchAdapter.ts"],"sourcesContent":["export function sum(array: Uint8Array[]) {\n  let sum = 0\n  for (const entry of array) {\n    sum += entry.length\n  }\n  return sum\n}\nexport function concatUint8Array(args: Uint8Array[]) {\n  const mergedArray = new Uint8Array(sum(args))\n  let offset = 0\n  for (const entry of args) {\n    mergedArray.set(entry, offset)\n    offset += entry.length\n  }\n  return mergedArray\n}\n","import type { GenericFilehandle } from 'generic-filehandle2'\nimport { concatUint8Array } from './util'\n\nconst CHUNK_SIZE = 65536\n\n// this is the number of hex characters to use for the address in ixixx, see\n// https://github.com/GMOD/ixixx-js/blob/master/src/index.ts#L182\nconst ADDRESS_SIZE = 10\n\n// https://stackoverflow.com/a/9229821/2129219\nfunction uniqBy<T>(a: T[], key: (elt: T) => string) {\n  const seen = new Set()\n  return a.filter(item => {\n    const k = key(item)\n    return seen.has(k) ? false : seen.add(k)\n  })\n}\n\nexport default class Trix {\n  constructor(\n    public ixxFile: GenericFilehandle,\n    public ixFile: GenericFilehandle,\n    public maxResults = 20,\n  ) {}\n\n  async search(searchString: string, opts?: { signal?: AbortSignal }) {\n    let resultArr = [] as [string, string][]\n    const searchWords = searchString.split(' ')\n\n    // we only search one word at a time\n    const searchWord = searchWords[0].toLowerCase()\n    const res = await this._getBuffer(searchWord, opts)\n    if (!res) {\n      return []\n    }\n\n    let { end, buffer } = res\n    let done = false\n    const decoder = new TextDecoder('utf8')\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    while (!done) {\n      let foundSomething = false\n      const str = decoder.decode(buffer)\n\n      // slice to lastIndexOf('\\n') to make sure we get complete records\n      // since the buffer fetch could get halfway into a record\n      const lines = str\n        .slice(0, str.lastIndexOf('\\n'))\n        .split('\\n')\n        .filter(f => !!f)\n\n      const hits2 = [] as string[]\n      for (const line of lines) {\n        const word = line.split(' ')[0]\n        const match = word.startsWith(searchWord)\n        if (!foundSomething && match) {\n          foundSomething = true\n        }\n\n        // we are done scanning if we are lexicographically greater than the\n        // search string\n        if (word.slice(0, searchWord.length) > searchWord) {\n          done = true\n        }\n        if (match) {\n          hits2.push(line)\n        }\n      }\n      const hits = hits2.flatMap(line => {\n        const [term, ...parts] = line.split(' ')\n        return parts.map(elt => [term, elt.split(',')[0]] as [string, string])\n      })\n\n      // if we are not done, and we haven't filled up maxResults with hits yet,\n      // then refetch\n      if (resultArr.length + hits.length < this.maxResults && !done) {\n        const res2 = await this.ixFile.read(CHUNK_SIZE, end, opts)\n\n        // early break if empty response\n        if (res2.length === 0) {\n          resultArr = resultArr.concat(hits)\n          break\n        }\n        buffer = concatUint8Array([buffer, res2])\n        end += CHUNK_SIZE\n      }\n\n      // if we have filled up the hits, or we are detected to be done via the\n      // filtering, then return\n      else if (resultArr.length + hits.length >= this.maxResults || done) {\n        resultArr = resultArr.concat(hits)\n        break\n      }\n    }\n\n    // deduplicate results based on the detail column (resultArr[1])\n    return uniqBy(resultArr, elt => elt[1]).slice(0, this.maxResults)\n  }\n\n  private async getIndex(opts?: { signal?: AbortSignal }) {\n    const file = await this.ixxFile.readFile({\n      encoding: 'utf8',\n      ...opts,\n    })\n    return file\n      .split('\\n')\n      .filter(f => !!f)\n      .map(line => {\n        const p = line.length - ADDRESS_SIZE\n        const prefix = line.slice(0, p)\n        const posStr = line.slice(p)\n        const pos = Number.parseInt(posStr, 16)\n        return [prefix, pos] as const\n      })\n  }\n\n  private async _getBuffer(\n    searchWord: string,\n    opts?: { signal?: AbortSignal },\n  ) {\n    let start = 0\n    let end = 65536\n    const indexes = await this.getIndex(opts)\n    for (const [key, value] of indexes) {\n      const trimmedKey = key.slice(0, searchWord.length)\n      if (trimmedKey < searchWord) {\n        start = value\n        end = value + 65536\n      }\n    }\n\n    // Return the buffer and its end position in the file.\n    const len = end - start\n    if (len < 0) {\n      return undefined\n    }\n    const buffer = await this.ixFile.read(len, start, opts)\n    return {\n      buffer,\n      end,\n    }\n  }\n}\n","import Trix from '@gmod/trix'\nimport BaseResult from '@jbrowse/core/TextSearch/BaseResults'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { BaseAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\n\nimport type PluginManager from '@jbrowse/core/PluginManager'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type {\n  BaseTextSearchAdapter,\n  BaseTextSearchArgs,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\n\nfunction decodeURIComponentNoThrow(uri: string) {\n  try {\n    return decodeURIComponent(uri)\n  } catch (e) {\n    // avoid throwing exception on a failure to decode URI component\n    return uri\n  }\n}\n\nfunction shorten(str: string, term: string, w = 15) {\n  const tidx = str.toLowerCase().indexOf(term)\n\n  return str.length < 40\n    ? str\n    : (Math.max(0, tidx - w) > 0 ? '...' : '') +\n        str.slice(Math.max(0, tidx - w), tidx + term.length + w).trim() +\n        (tidx + term.length < str.length ? '...' : '')\n}\n\nexport default class TrixTextSearchAdapter\n  extends BaseAdapter\n  implements BaseTextSearchAdapter\n{\n  indexingAttributes?: string[]\n  trixJs: Trix\n  tracksNames?: string[]\n\n  constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const ixFilePath = readConfObject(config, 'ixFilePath')\n    const ixxFilePath = readConfObject(config, 'ixxFilePath')\n\n    if (!ixFilePath) {\n      throw new Error('must provide out.ix')\n    }\n    if (!ixxFilePath) {\n      throw new Error('must provide out.ixx')\n    }\n    this.trixJs = new Trix(\n      openLocation(ixxFilePath, pluginManager),\n      openLocation(ixFilePath, pluginManager),\n      1500,\n    )\n  }\n\n  /**\n   * Returns list of results\n   * @param args - search options/arguments include: search query\n   * limit of results to return, searchType...prefix | full | exact\", etc.\n   */\n  async searchIndex(args: BaseTextSearchArgs) {\n    const query = args.queryString.toLowerCase()\n    const strs = query.split(' ')\n    const results = await this.trixJs.search(query)\n    const formatted = results\n      // if multi-word search try to filter out relevant items\n      .filter(([, data]) =>\n        strs.every(r =>\n          decodeURIComponentNoThrow(data).toLowerCase().includes(r),\n        ),\n      )\n      .map(([term, data]) => {\n        const result = JSON.parse(data.replaceAll('|', ',')) as string[]\n        const [loc, trackId, ...rest] = result.map(record =>\n          decodeURIComponentNoThrow(record),\n        )\n\n        const labelFieldIdx = rest.findIndex(elt => !!elt)\n        const contextIdx = rest\n          .map(elt => elt.toLowerCase())\n          .findIndex(f => f.includes(term.toLowerCase()))\n\n        const labelField = rest[labelFieldIdx]!\n        const contextField = rest[contextIdx]!\n        const context =\n          contextIdx !== -1 ? shorten(contextField, term) : undefined\n        const label = shorten(labelField, term)\n\n        const displayString =\n          !context || label.toLowerCase() === context.toLowerCase()\n            ? label\n            : `${label} (${context})`\n\n        return new BaseResult({\n          locString: loc,\n          label: labelField,\n          displayString,\n          matchedObject: result.map(record => decodeURIComponent(record)),\n          trackId,\n        })\n      })\n\n    return args.searchType === 'exact'\n      ? formatted.filter(\n          r => r.getLabel().toLowerCase() === args.queryString.toLowerCase(),\n        )\n      : formatted\n  }\n\n  freeResources() {}\n}\n"],"names":["concatUint8Array","args","mergedArray","Uint8Array","array","sum","entry","length","offset","set","Trix","ixxFile","ixFile","maxResults","constructor","search","searchString","opts","resultArr","searchWord","split","toLowerCase","res","this","_getBuffer","end","buffer","done","decoder","TextDecoder","foundSomething","str","decode","lines","slice","lastIndexOf","filter","f","hits2","line","word","match","startsWith","push","hits","flatMap","term","parts","map","elt","res2","read","concat","a","seen","Set","item","k","has","add","uniqBy","getIndex","readFile","encoding","p","prefix","posStr","Number","parseInt","start","indexes","key","value","len","decodeURIComponentNoThrow","uri","decodeURIComponent","e","shorten","w","tidx","indexOf","Math","max","trim","TrixTextSearchAdapter","BaseAdapter","config","getSubAdapter","pluginManager","super","ixFilePath","readConfObject","ixxFilePath","Error","trixJs","openLocation","searchIndex","query","queryString","strs","formatted","data","every","r","includes","result","JSON","parse","replaceAll","loc","trackId","rest","record","labelFieldIdx","findIndex","contextIdx","labelField","contextField","context","undefined","label","displayString","BaseResult","locString","matchedObject","searchType","getLabel","freeResources"],"sourceRoot":""}