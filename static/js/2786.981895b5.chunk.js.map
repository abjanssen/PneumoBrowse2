{"version":3,"file":"static/js/2786.981895b5.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/SNPCoverageRenderer/makeImage.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n  featureSpanPx,\n  renderToAbstractCanvas,\n} from '@jbrowse/core/util'\nimport Flatbush from '@jbrowse/core/util/flatbush'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\nimport {\n  YSCALEBAR_LABEL_OFFSET,\n  getOrigin,\n  getScale,\n} from '@jbrowse/plugin-wiggle'\n\nimport { alphaColor } from '../shared/util.ts'\n\nimport type {\n  ClickMapItem,\n  InterbaseIndicatorItem,\n  RenderArgsDeserializedWithFeatures,\n} from './types.ts'\nimport type { BaseCoverageBin } from '../shared/types.ts'\nimport type { Feature, LastStopTokenCheck } from '@jbrowse/core/util'\n\n// width/height of the triangle above e.g. insertion indicators\nconst INTERBASE_INDICATOR_WIDTH = 7\nconst INTERBASE_INDICATOR_HEIGHT = 4.5\n\n// minimum read depth to draw the insertion indicators, below this the\n// 'statistical significance' is low\nconst MINIMUM_INTERBASE_INDICATOR_READ_DEPTH = 7\n\n// threshold for drawing interbase counts when zoomed out (to avoid skipping\n// significant signals due to pixel collision optimization)\nconst INTERBASE_DRAW_THRESHOLD = 0.1\n\nconst complementBase = {\n  C: 'G',\n  G: 'C',\n  A: 'T',\n  T: 'A',\n} as const\n\nconst fudgeFactor = 0.6\nconst SNP_CLICKMAP_THRESHOLD = 0.04\n\ninterface SecondPassContext {\n  ctx: CanvasRenderingContext2D\n  coverageFeatures: Feature[]\n  region: { start: number; end: number; refName: string; reversed?: boolean }\n  bpPerPx: number\n  colorMap: Record<string, string>\n  toY: (n: number) => number\n  toHeight: (n: number) => number\n  toHeight2: (n: number) => number\n  lastCheck: LastStopTokenCheck\n  extraHorizontallyFlippedOffset: number\n  coords: number[]\n  items: ClickMapItem[]\n  indicatorThreshold: number\n  showInterbaseCounts: boolean\n  showInterbaseIndicators: boolean\n}\n\ninterface SecondPassStats {\n  snpDrawn: number\n  snpSkipped: number\n}\n\ninterface StrandCounts {\n  readonly entryDepth: number\n  readonly '1': number\n  readonly '-1': number\n  readonly '0': number\n}\n\ninterface ModificationCountsParams {\n  readonly base: string\n  readonly isSimplex: boolean\n  readonly refbase: string | undefined\n  readonly snps: Readonly<Record<string, Partial<StrandCounts>>>\n  readonly ref: StrandCounts\n  readonly score0: number\n}\n\ninterface ModificationCountsResult {\n  readonly modifiable: number\n  readonly detectable: number\n}\n\ninterface ReducedFeature {\n  start: number\n  end: number\n  score: number\n  snpinfo: BaseCoverageBin\n  refName: string\n}\n\ninterface SkipFeatureSerialized {\n  uniqueId: string\n  type: 'skip'\n  refName: string\n  start: number\n  end: number\n  strand: number\n  score: number\n  effectiveStrand: number\n}\n\nfunction createInterbaseItem(\n  maxBase: string,\n  count: number,\n  total: number,\n  start: number,\n  maxEntry?: {\n    avgLength?: number\n    minLength?: number\n    maxLength?: number\n    topSequence?: string\n  },\n): InterbaseIndicatorItem {\n  return {\n    type: maxBase as 'insertion' | 'softclip' | 'hardclip',\n    base: maxBase,\n    count,\n    total,\n    avgLength: maxEntry?.avgLength,\n    minLength: maxEntry?.minLength,\n    maxLength: maxEntry?.maxLength,\n    topSequence: maxEntry?.topSequence,\n    start,\n  }\n}\n\nfunction drawStackedBars(\n  ctx: CanvasRenderingContext2D,\n  entries: Record<string, { entryDepth: number }>,\n  colorMap: Record<string, string>,\n  x: number,\n  bottom: number,\n  w: number,\n  h: number,\n  depth: number,\n  startCurr: number,\n) {\n  let curr = startCurr\n  for (const base in entries) {\n    const { entryDepth } = entries[base]!\n    ctx.fillStyle = colorMap[base] || 'black'\n    ctx.fillRect(\n      x,\n      bottom - ((entryDepth + curr) / depth) * h,\n      w,\n      (entryDepth / depth) * h,\n    )\n    curr += entryDepth\n  }\n  return curr\n}\n\nfunction drawCrossHatches(\n  ctx: CanvasRenderingContext2D,\n  ticks: { values: number[] },\n  width: number,\n  toY: (n: number) => number,\n) {\n  ctx.lineWidth = 1\n  ctx.strokeStyle = 'rgba(140,140,140,0.8)'\n  for (const tick of ticks.values) {\n    ctx.beginPath()\n    ctx.moveTo(0, Math.round(toY(tick)))\n    ctx.lineTo(width, Math.round(toY(tick)))\n    ctx.stroke()\n  }\n}\n\nfunction calculateModificationCounts({\n  base,\n  isSimplex,\n  refbase,\n  snps,\n  ref,\n  score0,\n}: ModificationCountsParams): ModificationCountsResult {\n  if (base === 'N') {\n    return { modifiable: score0, detectable: score0 }\n  }\n\n  const cmp = complementBase[base as keyof typeof complementBase]\n\n  const baseCount =\n    (snps[base]?.entryDepth || 0) + (refbase === base ? ref.entryDepth : 0)\n  const complCount =\n    (snps[cmp]?.entryDepth || 0) + (refbase === cmp ? ref.entryDepth : 0)\n\n  const modifiable = baseCount + complCount\n\n  const detectable = isSimplex\n    ? (snps[base]?.['1'] || 0) +\n      (snps[cmp]?.['-1'] || 0) +\n      (refbase === base ? ref['1'] : 0) +\n      (refbase === cmp ? ref['-1'] : 0)\n    : modifiable\n\n  return { modifiable, detectable }\n}\n\nfunction buildClickMap(coords: number[], items: ClickMapItem[]) {\n  const flatbush = new Flatbush(Math.max(items.length, 1))\n  if (coords.length) {\n    for (let i = 0; i < coords.length; i += 4) {\n      flatbush.add(coords[i]!, coords[i + 1]!, coords[i + 2], coords[i + 3])\n    }\n  } else {\n    flatbush.add(0, 0)\n  }\n  flatbush.finish()\n  return {\n    flatbush: flatbush.data,\n    items,\n  }\n}\n\nfunction drawNoncovEvents(\n  passCtx: SecondPassContext,\n  snpinfo: BaseCoverageBin,\n  leftPx: number,\n  score0: number,\n  prevTotal: number,\n  skipDraw: boolean,\n  fstart: number,\n) {\n  const {\n    ctx,\n    colorMap,\n    toHeight2,\n    extraHorizontallyFlippedOffset,\n    coords,\n    items,\n    bpPerPx,\n    indicatorThreshold,\n    showInterbaseCounts,\n    showInterbaseIndicators,\n  } = passCtx\n\n  let totalCount = 0\n  let maxDepth = 0\n  let maxBase = ''\n  let totalHeight = 0\n  const r = 0.6\n  const x = leftPx - r + extraHorizontallyFlippedOffset\n\n  for (const base in snpinfo.noncov) {\n    const { entryDepth } = snpinfo.noncov[base]!\n    totalCount += entryDepth\n    if (entryDepth > maxDepth) {\n      maxDepth = entryDepth\n      maxBase = base\n    }\n  }\n\n  // allow significant interbase signals to be drawn even when skipDraw is true\n  // (similar to SNP drawing logic)\n  const isSignificant =\n    score0 > 0 && totalCount > score0 * INTERBASE_DRAW_THRESHOLD\n  const showCounts = showInterbaseCounts && (!skipDraw || isSignificant)\n\n  if (showCounts) {\n    for (const base in snpinfo.noncov) {\n      const { entryDepth } = snpinfo.noncov[base]!\n      const barHeight = toHeight2(entryDepth)\n      ctx.fillStyle = colorMap[base]!\n      ctx.fillRect(\n        x,\n        INTERBASE_INDICATOR_HEIGHT + totalHeight,\n        r * 2,\n        barHeight,\n      )\n      totalHeight += barHeight\n    }\n  }\n\n  if (totalCount > 0) {\n    const maxEntry = snpinfo.noncov[maxBase]\n\n    if (showCounts) {\n      if (bpPerPx < 50 || isSignificant) {\n        const clickWidth = Math.max(r * 2, 2)\n        coords.push(\n          x,\n          INTERBASE_INDICATOR_HEIGHT,\n          x + clickWidth,\n          INTERBASE_INDICATOR_HEIGHT + totalHeight,\n        )\n        items.push(\n          createInterbaseItem(maxBase, totalCount, score0, fstart, maxEntry),\n        )\n      }\n    }\n\n    if (showInterbaseIndicators && (!skipDraw || isSignificant)) {\n      const indicatorComparatorScore = Math.max(score0, prevTotal)\n      if (\n        totalCount > indicatorComparatorScore * indicatorThreshold &&\n        indicatorComparatorScore > MINIMUM_INTERBASE_INDICATOR_READ_DEPTH\n      ) {\n        ctx.fillStyle = colorMap[maxBase]!\n        ctx.beginPath()\n        const l = leftPx + extraHorizontallyFlippedOffset\n        ctx.moveTo(l - INTERBASE_INDICATOR_WIDTH / 2, 0)\n        ctx.lineTo(l + INTERBASE_INDICATOR_WIDTH / 2, 0)\n        ctx.lineTo(l, INTERBASE_INDICATOR_HEIGHT)\n        ctx.fill()\n\n        const hitboxPadding = 1\n        coords.push(\n          l - INTERBASE_INDICATOR_WIDTH / 2 - hitboxPadding,\n          0,\n          l + INTERBASE_INDICATOR_WIDTH / 2 + hitboxPadding,\n          INTERBASE_INDICATOR_HEIGHT + hitboxPadding,\n        )\n        items.push(\n          createInterbaseItem(\n            maxBase,\n            totalCount,\n            indicatorComparatorScore,\n            fstart,\n            maxEntry,\n          ),\n        )\n      }\n    }\n  }\n}\n\nfunction drawSecondPassModifications(\n  passCtx: SecondPassContext,\n  visibleModifications: Record<\n    string,\n    { base: string; type: string; color?: string }\n  >,\n  isolatedModification: string | undefined,\n  simplexSet: Set<string>,\n): SecondPassStats {\n  const { ctx, coverageFeatures, region, bpPerPx, toY, toHeight, lastCheck } =\n    passCtx\n\n  let snpDrawn = 0\n  let snpSkipped = 0\n  let lastDrawnX = Number.NEGATIVE_INFINITY\n  let prevTotal = 0\n\n  for (let i = 0, l = coverageFeatures.length; i < l; i++) {\n    checkStopToken2(lastCheck)\n    const feature = coverageFeatures[i]!\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n    const snpinfo = feature.get('snpinfo') as BaseCoverageBin\n    const w = Math.max(rightPx - leftPx, 1)\n    const score0 = feature.get('score')\n    const drawX = Math.round(leftPx)\n    const skipDraw = drawX === lastDrawnX\n\n    let curr = 0\n    const refbase = snpinfo.refbase?.toUpperCase()\n    const { nonmods, mods, snps, ref } = snpinfo\n    const h = toHeight(score0)\n    const bottom = toY(score0) + h\n\n    for (const key in nonmods) {\n      const modKey = key.slice(7)\n      const mod = visibleModifications[modKey]\n      if (!mod || (isolatedModification && mod.type !== isolatedModification)) {\n        continue\n      }\n\n      const { modifiable, detectable } = calculateModificationCounts({\n        base: mod.base,\n        isSimplex: simplexSet.has(mod.type),\n        refbase,\n        snps,\n        ref,\n        score0,\n      })\n\n      const { entryDepth, avgProbability = 0 } = nonmods[key]!\n      const modFraction = (modifiable / score0) * (entryDepth / detectable)\n      const barHeight = modFraction * h\n      if (skipDraw) {\n        snpSkipped++\n      } else {\n        ctx.fillStyle = alphaColor('blue', avgProbability)\n        ctx.fillRect(drawX, bottom - (curr + barHeight), w, barHeight)\n        snpDrawn++\n        lastDrawnX = drawX\n      }\n      curr += barHeight\n    }\n\n    for (const key in mods) {\n      const modKey = key.slice(4)\n      const mod = visibleModifications[modKey]\n      if (!mod || (isolatedModification && mod.type !== isolatedModification)) {\n        continue\n      }\n\n      const { modifiable, detectable } = calculateModificationCounts({\n        base: mod.base,\n        isSimplex: simplexSet.has(mod.type),\n        refbase,\n        snps,\n        ref,\n        score0,\n      })\n\n      const { entryDepth, avgProbability = 0 } = mods[key]!\n      const modFraction = (modifiable / score0) * (entryDepth / detectable)\n      const barHeight = modFraction * h\n      if (skipDraw) {\n        snpSkipped++\n      } else {\n        ctx.fillStyle = alphaColor(mod.color || 'black', avgProbability)\n        ctx.fillRect(drawX, bottom - (curr + barHeight), w, barHeight)\n        snpDrawn++\n        lastDrawnX = drawX\n      }\n      curr += barHeight\n    }\n\n    drawNoncovEvents(\n      passCtx,\n      snpinfo,\n      leftPx,\n      score0,\n      prevTotal,\n      skipDraw,\n      feature.get('start'),\n    )\n    prevTotal = score0\n  }\n\n  return { snpDrawn, snpSkipped }\n}\n\nfunction drawSecondPassMethylation(\n  passCtx: SecondPassContext,\n): SecondPassStats {\n  const {\n    ctx,\n    coverageFeatures,\n    region,\n    bpPerPx,\n    colorMap,\n    toY,\n    toHeight,\n    lastCheck,\n  } = passCtx\n\n  let lastDrawnX = Number.NEGATIVE_INFINITY\n  let prevTotal = 0\n\n  for (let i = 0, l = coverageFeatures.length; i < l; i++) {\n    checkStopToken2(lastCheck)\n    const feature = coverageFeatures[i]!\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n    const snpinfo = feature.get('snpinfo') as BaseCoverageBin\n    const w = Math.max(rightPx - leftPx, 1)\n    const score0 = feature.get('score')\n    const drawX = Math.round(leftPx)\n    const skipDraw = drawX === lastDrawnX\n\n    if (!skipDraw) {\n      const { depth, nonmods, mods } = snpinfo\n      const h = toHeight(score0)\n      const bottom = toY(score0) + h\n      const curr = drawStackedBars(\n        ctx,\n        mods,\n        colorMap,\n        drawX,\n        bottom,\n        w,\n        h,\n        depth,\n        0,\n      )\n      drawStackedBars(ctx, nonmods, colorMap, drawX, bottom, w, h, depth, curr)\n      lastDrawnX = drawX\n    }\n\n    drawNoncovEvents(\n      passCtx,\n      snpinfo,\n      leftPx,\n      score0,\n      prevTotal,\n      skipDraw,\n      feature.get('start'),\n    )\n    prevTotal = score0\n  }\n\n  return { snpDrawn: 0, snpSkipped: 0 }\n}\n\nfunction drawSecondPassSNPs(passCtx: SecondPassContext): SecondPassStats {\n  const {\n    ctx,\n    coverageFeatures,\n    region,\n    bpPerPx,\n    colorMap,\n    toY,\n    toHeight,\n    lastCheck,\n    coords,\n    items,\n  } = passCtx\n\n  let snpDrawn = 0\n  let snpSkipped = 0\n  let lastDrawnX = Number.NEGATIVE_INFINITY\n  let lastDrawnDepth = -1\n  let prevTotal = 0\n\n  for (let i = 0, l = coverageFeatures.length; i < l; i++) {\n    checkStopToken2(lastCheck)\n    const feature = coverageFeatures[i]!\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n    const snpinfo = feature.get('snpinfo') as BaseCoverageBin\n    const w = Math.max(rightPx - leftPx, 1)\n    const score0 = feature.get('score')\n    const drawX = Math.round(leftPx)\n    const skipDraw = drawX === lastDrawnX\n\n    const { depth, snps, refbase } = snpinfo\n    const refbaseUpper = refbase?.toUpperCase()\n    const h = toHeight(score0)\n    const bottom = toY(score0) + h\n    let curr = 0\n\n    for (const base in snps) {\n      const entry = snps[base]!\n      const { entryDepth } = entry\n      const y1 = bottom - ((entryDepth + curr) / depth) * h\n      const barHeight = (entryDepth / depth) * h\n      const isSignificant = entryDepth / score0 >= SNP_CLICKMAP_THRESHOLD\n\n      const sameDepthAtSameX = skipDraw && entryDepth === lastDrawnDepth\n      if ((skipDraw && !isSignificant) || sameDepthAtSameX) {\n        snpSkipped++\n      } else {\n        ctx.fillStyle = colorMap[base] || 'black'\n        ctx.fillRect(drawX, y1, w, barHeight)\n        snpDrawn++\n        lastDrawnX = drawX\n        lastDrawnDepth = entryDepth\n      }\n\n      if (isSignificant) {\n        coords.push(drawX, y1, drawX + w, y1 + barHeight)\n        items.push({\n          type: 'snp',\n          base,\n          count: entryDepth,\n          total: score0,\n          refbase: refbaseUpper,\n          avgQual: entry.avgProbability,\n          fwdCount: entry['1'] || 0,\n          revCount: entry['-1'] || 0,\n          bin: snpinfo,\n          start: feature.get('start'),\n          end: feature.get('end'),\n        })\n      }\n      curr += entryDepth\n    }\n\n    drawNoncovEvents(\n      passCtx,\n      snpinfo,\n      leftPx,\n      score0,\n      prevTotal,\n      skipDraw,\n      feature.get('start'),\n    )\n    prevTotal = score0\n  }\n\n  return { snpDrawn, snpSkipped }\n}\n\nexport async function renderSNPCoverageToCanvas(\n  props: RenderArgsDeserializedWithFeatures,\n) {\n  const { features, regions, bpPerPx, adapterConfig } = props\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const height = props.height\n  const adapterId = adapterConfig.adapterId ?? 'unknown'\n\n  const skipFeatures: SkipFeatureSerialized[] = []\n  const coverageFeatures: Feature[] = []\n\n  for (const feature of features.values()) {\n    if (feature.get('type') === 'skip') {\n      skipFeatures.push({\n        uniqueId: feature.id(),\n        type: 'skip',\n        refName: region.refName,\n        start: feature.get('start'),\n        end: feature.get('end'),\n        strand: feature.get('strand'),\n        score: feature.get('score'),\n        effectiveStrand: feature.get('effectiveStrand'),\n      })\n    } else {\n      coverageFeatures.push(feature)\n    }\n  }\n\n  const { reducedFeatures, coords, items, ...rest } =\n    await renderToAbstractCanvas(width, height, props, ctx =>\n      drawSNPCoverage(ctx, props, coverageFeatures),\n    )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map((f, idx) => ({\n      ...f,\n      uniqueId: `${adapterId}-${f.start}-${idx}`,\n    })),\n    skipFeatures,\n    clickMap: buildClickMap(coords, items),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n\nfunction drawSNPCoverage(\n  ctx: CanvasRenderingContext2D,\n  props: RenderArgsDeserializedWithFeatures,\n  coverageFeatures: Feature[],\n) {\n  const {\n    regions,\n    bpPerPx,\n    colorBy,\n    displayCrossHatches,\n    visibleModifications = {},\n    simplexModifications = [],\n    scaleOpts,\n    height: unadjustedHeight,\n    theme: configTheme,\n    config: cfg,\n    ticks,\n    stopToken,\n  } = props\n  const theme = createJBrowseTheme(configTheme)\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  const offset = YSCALEBAR_LABEL_OFFSET\n  const height = unadjustedHeight - offset * 2\n\n  const opts = { ...scaleOpts, range: [0, height] }\n  const viewScale = getScale(opts)\n\n  const indicatorViewScale = getScale({\n    ...opts,\n    range: [0, height / 2],\n    scaleType: 'linear',\n  })\n  const originY = getOrigin(scaleOpts.scaleType)\n\n  const indicatorThreshold = readConfObject(cfg, 'indicatorThreshold')\n  const showInterbaseCounts = readConfObject(cfg, 'showInterbaseCounts')\n  const showInterbaseIndicators = readConfObject(cfg, 'showInterbaseIndicators')\n\n  const toY = (n: number) => height - (viewScale(n) || 0) + offset\n  const toHeight = (n: number) => toY(originY) - toY(n)\n  const toHeight2 = (n: number) => indicatorViewScale(n) || 0\n\n  const { bases, softclip, hardclip, insertion } = theme.palette\n  const colorMap: Record<string, string> = {\n    A: bases.A.main,\n    C: bases.C.main,\n    G: bases.G.main,\n    T: bases.T.main,\n    insertion,\n    softclip,\n    hardclip,\n    total: readConfObject(cfg, 'color'),\n    mod_NONE: 'blue',\n    cpg_meth: 'red',\n    cpg_unmeth: 'blue',\n  }\n\n  const reducedFeatures: ReducedFeature[] = []\n  let prevReducedLeftPx = Number.NEGATIVE_INFINITY\n\n  const coords: number[] = []\n  const items: ClickMapItem[] = []\n\n  // First pass: draw the gray background\n  ctx.fillStyle = colorMap.total!\n  const lastCheck = createStopTokenChecker(stopToken)\n  for (let i = 0, l = coverageFeatures.length; i < l; i++) {\n    checkStopToken2(lastCheck)\n    const feature = coverageFeatures[i]!\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n    const w = rightPx - leftPx + fudgeFactor\n    const score = feature.get('score') as number\n    ctx.fillRect(leftPx, toY(score), w, toHeight(score))\n\n    if (leftPx > prevReducedLeftPx + 1) {\n      reducedFeatures.push({\n        start: feature.get('start'),\n        end: feature.get('end'),\n        score,\n        snpinfo: feature.get('snpinfo'),\n        refName: region.refName,\n      })\n      prevReducedLeftPx = leftPx\n    }\n  }\n\n  const extraHorizontallyFlippedOffset = region.reversed ? 1 / bpPerPx : 0\n\n  const passCtx: SecondPassContext = {\n    ctx,\n    coverageFeatures,\n    region,\n    bpPerPx,\n    colorMap,\n    toY,\n    toHeight,\n    toHeight2,\n    lastCheck,\n    extraHorizontallyFlippedOffset,\n    coords,\n    items,\n    indicatorThreshold,\n    showInterbaseCounts,\n    showInterbaseIndicators,\n  }\n\n  // Second pass: draw colored data based on colorBy mode\n  if (colorBy.type === 'modifications') {\n    const isolatedModification = colorBy.modifications?.isolatedModification\n    const simplexSet = new Set(simplexModifications)\n    drawSecondPassModifications(\n      passCtx,\n      visibleModifications,\n      isolatedModification,\n      simplexSet,\n    )\n  } else if (colorBy.type === 'methylation') {\n    drawSecondPassMethylation(passCtx)\n  } else {\n    drawSecondPassSNPs(passCtx)\n  }\n\n  if (displayCrossHatches) {\n    drawCrossHatches(ctx, ticks, width, toY)\n  }\n\n  return { reducedFeatures, coords, items }\n}\n"],"names":["INTERBASE_INDICATOR_HEIGHT","complementBase","C","G","A","T","createInterbaseItem","maxBase","count","total","start","maxEntry","type","base","avgLength","minLength","maxLength","topSequence","drawStackedBars","ctx","entries","colorMap","x","bottom","w","h","depth","startCurr","curr","entryDepth","fillStyle","fillRect","calculateModificationCounts","isSimplex","refbase","snps","ref","score0","modifiable","detectable","cmp","buildClickMap","coords","items","flatbush","Flatbush","Math","max","length","i","add","finish","data","drawNoncovEvents","passCtx","snpinfo","leftPx","prevTotal","skipDraw","fstart","toHeight2","extraHorizontallyFlippedOffset","bpPerPx","indicatorThreshold","showInterbaseCounts","showInterbaseIndicators","totalCount","maxDepth","totalHeight","noncov","isSignificant","showCounts","barHeight","r","clickWidth","push","indicatorComparatorScore","beginPath","l","moveTo","INTERBASE_INDICATOR_WIDTH","lineTo","fill","hitboxPadding","async","renderSNPCoverageToCanvas","props","features","regions","adapterConfig","region","width","end","height","adapterId","skipFeatures","coverageFeatures","feature","values","get","uniqueId","id","refName","strand","score","effectiveStrand","reducedFeatures","rest","renderToAbstractCanvas","colorBy","displayCrossHatches","visibleModifications","simplexModifications","scaleOpts","unadjustedHeight","theme","configTheme","config","cfg","ticks","stopToken","createJBrowseTheme","offset","YSCALEBAR_LABEL_OFFSET","opts","range","viewScale","getScale","indicatorViewScale","scaleType","originY","getOrigin","readConfObject","toY","n","toHeight","bases","softclip","hardclip","insertion","palette","main","mod_NONE","cpg_meth","cpg_unmeth","prevReducedLeftPx","Number","NEGATIVE_INFINITY","lastCheck","createStopTokenChecker","checkStopToken2","rightPx","featureSpanPx","reversed","isolatedModification","modifications","simplexSet","lastDrawnX","drawX","round","toUpperCase","nonmods","mods","key","mod","slice","has","avgProbability","snpSkipped","alphaColor","color","drawSecondPassModifications","Set","drawSecondPassMethylation","lastDrawnDepth","refbaseUpper","entry","y1","avgQual","fwdCount","revCount","bin","drawSecondPassSNPs","lineWidth","strokeStyle","tick","stroke","drawCrossHatches","drawSNPCoverage","serialized","map","f","idx","clickMap","rpcResult","collectTransferables"],"ignoreList":[],"sourceRoot":""}