{"version":3,"file":"static/js/8085.9a1bb1d7.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/PileupRenderer/renderers/cigarUtil.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processDepthPrefixSum.ts","../../../plugins/alignments/src/SNPCoverageAdapter/util.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processModifications.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processReferenceCpGs.ts","../../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBinsPrefixSum.ts","../../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts","../../../plugins/alignments/src/ModificationParser/getModProbabilities.ts","../../../plugins/alignments/src/ModificationParser/getMethBins.ts","../../../plugins/alignments/src/MismatchParser/getNextRefPos.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts","../../../plugins/alignments/src/ModificationParser/getModPositions.ts"],"sourcesContent":["import { parseCigar2 } from '../../MismatchParser/index.ts'\n\n// CIGAR operation indices (from BAM spec) - used in packed Uint32Array format\nexport const CIGAR_M = 0\nexport const CIGAR_I = 1\nexport const CIGAR_D = 2\nexport const CIGAR_N = 3\nexport const CIGAR_S = 4\nexport const CIGAR_H = 5\nexport const CIGAR_P = 6\nexport const CIGAR_EQ = 7\nexport const CIGAR_X = 8\n\n// Bitmasks for CIGAR operation categories (use with: (1 << op) & MASK)\n// Alignment match ops (M=0, ==7) - may contain mismatches, need MD tag\nexport const CIGAR_M_EQ_MASK = 0b10000001 // (1<<0)|(1<<7) = 129\n// Match/mismatch ops that consume both ref and seq (M=0, ==7, X=8)\nexport const CIGAR_MATCH_MASK = 0b110000001 // (1<<0)|(1<<7)|(1<<8) = 385\n// Seq-only ops (S=4, I=1)\nexport const CIGAR_SEQ_ONLY_MASK = 0b10010 // (1<<1)|(1<<4) = 18\n// Ref-skip ops (D=2, N=3)\nexport const CIGAR_REF_SKIP_MASK = 0b1100 // (1<<2)|(1<<3) = 12\n// Ref-consuming ops (M=0, D=2, ==7, X=8)\nexport const CIGAR_REF_CONSUMING_MASK = 0b110000101 // (1<<0)|(1<<2)|(1<<7)|(1<<8) = 389\n\n// BAM 4-bit encoded sequence lookup table\nexport const SEQRET = '=ACMGRSVTWYHKDBN'\n\n// Numeric decoder - returns char codes directly (lowercase for case-insensitive comparison)\n// '=' = 61, 'a' = 97, 'c' = 99, 'm' = 109, 'g' = 103, 'r' = 114, 's' = 115, 'v' = 118,\n// 't' = 116, 'w' = 119, 'y' = 121, 'h' = 104, 'k' = 107, 'd' = 100, 'b' = 98, 'n' = 110\nexport const SEQRET_NUMERIC_DECODER = new Uint8Array([\n  61, 97, 99, 109, 103, 114, 115, 118, 116, 119, 121, 104, 107, 100, 98, 110,\n])\n\n// Pre-computed char lookup for ASCII codes (avoids String.fromCharCode in hot loops)\nexport const CHAR_FROM_CODE: string[] = Array.from({ length: 128 }, (_, i) =>\n  String.fromCharCode(i),\n)\n\n// Helper to ensure we have Uint32Array (packed format)\nexport function getCigarOps(\n  cigar: Uint32Array | string | undefined,\n): ArrayLike<number> {\n  return typeof cigar === 'string' ? parseCigar2(cigar) : cigar || []\n}\n","import type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion } from '@jbrowse/core/util/types'\n\n/**\n * SoA (Structure of Arrays) output for coverage depth.\n * Much more memory efficient than object-per-position.\n *\n * For a 100kb region, this uses ~1.2MB (3 × 100k × 4 bytes)\n * vs ~40MB+ for 100k objects with nested properties.\n */\nexport interface CoverageDepthSoA {\n  regionStart: number\n  regionSize: number\n  /** Coverage depth at each position */\n  depth: Int32Array\n  /** Forward strand (+1) read count at each position */\n  strandPlus: Int32Array\n  /** Reverse strand (-1) read count at each position */\n  strandMinus: Int32Array\n}\n\n// Reusable buffers - avoids allocation on every call\n// Size for up to 1MB regions (should cover most use cases)\nconst MAX_REGION_SIZE = 1_000_000\n\nconst depthChanges = new Int32Array(MAX_REGION_SIZE + 1)\nconst strandPlusChanges = new Int32Array(MAX_REGION_SIZE + 1)\nconst strandMinusChanges = new Int32Array(MAX_REGION_SIZE + 1)\n\n/**\n * Process feature depth using prefix sums algorithm.\n *\n * Complexity: O(features + regionSize) instead of O(features × avgReadLength)\n *\n * For 300x coverage with 50kb long reads over 100kb region:\n * - Original: O(600 × 50000) = 30M iterations\n * - This: O(600 + 100000) = 100k iterations\n */\nexport function processDepthPrefixSum(\n  features: Feature[],\n  region: AugmentedRegion,\n): CoverageDepthSoA {\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionSize = regionEnd - regionStart\n\n  if (regionSize > MAX_REGION_SIZE) {\n    throw new Error(\n      `Region size ${regionSize} exceeds maximum ${MAX_REGION_SIZE}`,\n    )\n  }\n\n  // Clear only the portion we need (faster than creating new arrays)\n  depthChanges.fill(0, 0, regionSize + 1)\n  strandPlusChanges.fill(0, 0, regionSize + 1)\n  strandMinusChanges.fill(0, 0, regionSize + 1)\n\n  // Pass 1: Record depth changes at boundaries - O(features)\n  for (const feature of features) {\n    const fstart = feature.get('start')\n    const fend = feature.get('end')\n    const fstrand = feature.get('strand') as -1 | 0 | 1\n\n    // Clamp to visible region\n    const visStart = Math.max(fstart, regionStart) - regionStart\n    const visEnd = Math.min(fend, regionEnd) - regionStart\n\n    if (visStart < visEnd) {\n      // Increment at start, decrement at end\n      depthChanges[visStart]!++\n      depthChanges[visEnd]!--\n\n      if (fstrand === 1) {\n        strandPlusChanges[visStart]!++\n        strandPlusChanges[visEnd]!--\n      } else if (fstrand === -1) {\n        strandMinusChanges[visStart]!++\n        strandMinusChanges[visEnd]!--\n      }\n    }\n  }\n\n  // Pass 2: Compute prefix sums - O(regionSize)\n  const depth = new Int32Array(regionSize)\n  const strandPlus = new Int32Array(regionSize)\n  const strandMinus = new Int32Array(regionSize)\n\n  let d = 0\n  let sp = 0\n  let sm = 0\n\n  for (let i = 0; i < regionSize; i++) {\n    d += depthChanges[i]!\n    sp += strandPlusChanges[i]!\n    sm += strandMinusChanges[i]!\n\n    depth[i] = d\n    strandPlus[i] = sp\n    strandMinus[i] = sm\n  }\n\n  return {\n    regionStart,\n    regionSize,\n    depth,\n    strandPlus,\n    strandMinus,\n  }\n}\n","import { INTERBASE_MASK } from '../shared/forEachMismatchTypes.ts'\n\nimport type {\n  ColorBy,\n  PreBaseCoverageBin,\n  PreBaseCoverageBinSubtypes,\n  PreBinEntry,\n} from '../shared/types.ts'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\n\nexport interface Opts {\n  bpPerPx?: number\n  colorBy?: ColorBy\n  stopToken?: StopToken\n  /** When true, only compute depth (skip mismatch/modification processing) */\n  statsEstimationMode?: boolean\n}\n\n// Uses bitwise check: converts type to bit position, then ANDs with INTERBASE_MASK\n// INTERBASE_MASK = 0b110010 = (1<<1)|(1<<4)|(1<<5) for insertion, softclip, hardclip\nexport function mismatchLen(type: number, length: number) {\n  return ((1 << type) & INTERBASE_MASK) === 0 ? length : 1\n}\n\n// Uses bitwise check: converts type to bit position, then ANDs with INTERBASE_MASK\n// INTERBASE_MASK = 0b110010 = (1<<1)|(1<<4)|(1<<5) for insertion, softclip, hardclip\nexport function isInterbase(type: number) {\n  return ((1 << type) & INTERBASE_MASK) !== 0\n}\n\nexport function createPreBinEntry(): PreBinEntry {\n  return {\n    entryDepth: 0,\n    probabilityTotal: 0,\n    probabilityCount: 0,\n    lengthTotal: 0,\n    lengthCount: 0,\n    lengthMin: Infinity,\n    lengthMax: -Infinity,\n    '-1': 0,\n    '0': 0,\n    '1': 0,\n  }\n}\n\nexport function createEmptyBin(): PreBaseCoverageBin {\n  return {\n    depth: 0,\n    readsCounted: 0,\n    snps: {},\n    ref: createPreBinEntry(),\n    mods: {},\n    nonmods: {},\n    delskips: {},\n    noncov: {},\n  }\n}\n\nexport function inc(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  length?: number,\n  sequence?: string,\n) {\n  const entry = (bin[type][field] ??= createPreBinEntry())\n  entry.entryDepth++\n  entry[strand]++\n  if (length !== undefined) {\n    entry.lengthTotal += length\n    entry.lengthCount++\n    entry.lengthMin = Math.min(entry.lengthMin, length)\n    entry.lengthMax = Math.max(entry.lengthMax, length)\n  }\n  if (sequence !== undefined) {\n    entry.sequenceCounts ??= new Map()\n    entry.sequenceCounts.set(\n      sequence,\n      (entry.sequenceCounts.get(sequence) ?? 0) + 1,\n    )\n  }\n}\n\nexport function incWithProbabilities(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  probability: number,\n) {\n  const entry = (bin[type][field] ??= createPreBinEntry())\n  entry.entryDepth++\n  entry.probabilityTotal += probability\n  entry.probabilityCount++\n  entry[strand]++\n}\n","import { max, sum } from '@jbrowse/core/util'\n\nimport { createEmptyBin, incWithProbabilities } from './util.ts'\nimport { parseCigar2 } from '../MismatchParser/index.ts'\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition.ts'\n\nimport type { ColorBy, PreBaseCoverageBin } from '../shared/types.ts'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport function processModifications({\n  feature,\n  colorBy,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  colorBy?: ColorBy\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const fend = feature.get('end')\n  const twoColor = colorBy?.modifications?.twoColor\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  const seq = feature.get('seq') as string | undefined\n  const modificationThreshold = colorBy?.modifications?.threshold ?? 10\n  const thresholdFraction = modificationThreshold / 100\n\n  if (!seq) {\n    return\n  }\n\n  const cigarOps =\n    feature.get('NUMERIC_CIGAR') ?? parseCigar2(feature.get('CIGAR'))\n  const regionStart = region.start\n  const regionEnd = region.end\n\n  // Get only the maximum probability modification at each position\n  // this is a hole-y array, does not work with normal for loop\n  // eslint-disable-next-line unicorn/no-array-for-each\n  getMaxProbModAtEachPosition(feature, cigarOps)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      const refPos = pos + fstart\n\n      // Skip positions outside visible region (early check before other work)\n      if (refPos < regionStart || refPos >= fend) {\n        return\n      }\n      const epos = refPos - regionStart\n      if (epos < 0 || epos >= regionEnd - regionStart) {\n        return\n      }\n\n      if (isolatedModification && type !== isolatedModification) {\n        return\n      }\n\n      // Check if modification probability exceeds threshold\n      if (prob < thresholdFraction) {\n        return\n      }\n\n      const bin = (bins[epos] ??= createEmptyBin())\n      bin.refbase = regionSequence[epos]\n\n      const s = 1 - sum(allProbs)\n      if (twoColor && s > max(allProbs)) {\n        incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s)\n      } else {\n        incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob)\n      }\n    },\n  )\n}\n","import { createEmptyBin, incWithProbabilities } from './util.ts'\nimport { parseCigar2 } from '../MismatchParser/index.ts'\nimport { getMethBins } from '../ModificationParser/getMethBins.ts'\nimport { DELETION_TYPE } from '../shared/forEachMismatchTypes.ts'\n\nimport type {\n  FeatureWithMismatchIterator,\n  PreBaseCoverageBin,\n} from '../shared/types.ts'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nfunction processCpG(\n  bins: PreBaseCoverageBin[],\n  binIdx: number,\n  fstrand: -1 | 0 | 1,\n  isMeth: boolean,\n  prob: number,\n  isDel: boolean,\n) {\n  if (isMeth) {\n    const bin = (bins[binIdx] ??= createEmptyBin())\n    incWithProbabilities(bin, fstrand, 'mods', 'cpg_meth', prob)\n    bin.ref.entryDepth--\n    bin.ref[fstrand]--\n  } else {\n    if (!isDel) {\n      const bin = (bins[binIdx] ??= createEmptyBin())\n      incWithProbabilities(bin, fstrand, 'nonmods', 'cpg_unmeth', 1 - prob)\n      bin.ref.entryDepth--\n      bin.ref[fstrand]--\n    }\n  }\n}\n\nexport function processReferenceCpGs({\n  feature,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: FeatureWithMismatchIterator\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const r = regionSequence.toLowerCase()\n  if (seq) {\n    const cigarOps =\n      feature.get('NUMERIC_CIGAR') ?? parseCigar2(feature.get('CIGAR'))\n    const { methBins, methProbs } = getMethBins(feature, cigarOps)\n    const isDeleted = new Array(methBins.length).fill(false)\n    feature.forEachMismatch((type, start, length) => {\n      if (type === DELETION_TYPE) {\n        const end = start + length\n        for (let i = start; i < end; i++) {\n          isDeleted[i] = true\n        }\n      }\n    })\n    const regionStart = region.start\n    const regionEnd = region.end\n\n    // Calculate visible range within feature\n    const visStart = Math.max(0, regionStart - fstart)\n    const visEnd = Math.min(fend - fstart, regionEnd - fstart)\n\n    // methylation based coloring takes into account both reference sequence\n    // CpG detection and reads\n    for (let i = visStart; i < visEnd; i++) {\n      const j = i + fstart\n      const l1 = r[j - regionStart + 1]\n      const l2 = r[j - regionStart + 2]\n      if (l1 === 'c' && l2 === 'g') {\n        const idx0 = j - regionStart\n        const idx1 = j - regionStart + 1\n        const b0 = methBins[i]\n        const b1 = methBins[i + 1]\n        const p0 = methProbs[i] || 0\n        const p1 = methProbs[i + 1] || 0\n        const isMeth = !!((b0 && p0 > 0.5) || (b1 && p1 > 0.5))\n        const isDel0 = isDeleted[i]\n        const isDel1 = isDeleted[i + 1]\n\n        processCpG(bins, idx0, fstrand, isMeth, p0, !!isDel0)\n        processCpG(bins, idx1, fstrand, isMeth, p1, !!isDel1)\n      }\n    }\n  }\n}\n","import { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport { processDepthPrefixSum } from './processDepthPrefixSum.ts'\nimport { processModifications } from './processModifications.ts'\nimport { processReferenceCpGs } from './processReferenceCpGs.ts'\nimport { isInterbase, mismatchLen } from './util.ts'\nimport { CHAR_FROM_CODE } from '../PileupRenderer/renderers/cigarUtil.ts'\nimport {\n  DELSKIP_MASK,\n  INSERTION_TYPE,\n  MISMATCH_MAP,\n  MISMATCH_REV_MAP,\n  SKIP_TYPE,\n} from '../shared/forEachMismatchTypes.ts'\n\nimport type { Opts } from './util.ts'\nimport type {\n  FeatureWithMismatchIterator,\n  Mismatch,\n  PreBaseCoverageBin,\n  PreBinEntry,\n  SkipMap,\n} from '../shared/types.ts'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\n// Type with lazy sub-objects (undefined until needed)\nexport interface LazyBin {\n  refbase?: string\n  depth: number\n  readsCounted: number\n  ref: PreBinEntry\n  snps?: Record<string, PreBinEntry>\n  mods?: Record<string, PreBinEntry>\n  nonmods?: Record<string, PreBinEntry>\n  delskips?: Record<string, PreBinEntry>\n  noncov?: Record<string, PreBinEntry>\n}\n\n// Result format - sparse bins array with regionStart for computing positions\nexport interface CoverageBinsResult {\n  bins: (LazyBin | undefined)[]\n  regionStart: number\n  skipmap: SkipMap\n}\n\n// Finalize a lazy bin before returning to renderer\nexport function finalizeLazyBin(bin: LazyBin): PreBaseCoverageBin {\n  bin.snps ??= {}\n  bin.mods ??= {}\n  bin.nonmods ??= {}\n  bin.delskips ??= {}\n  bin.noncov ??= {}\n  return bin as PreBaseCoverageBin\n}\n\n// Reusable change arrays for deletion prefix sums\nconst MAX_REGION_SIZE = 1_000_000\nconst deletionChanges = new Int32Array(MAX_REGION_SIZE + 1)\n\ninterface SparseSnpEntry {\n  base: string\n  strand: -1 | 0 | 1\n  altbase?: string\n}\n\ninterface SparseNoncovEntry {\n  strand: -1 | 0 | 1\n  type: 'insertion' | 'softclip' | 'hardclip'\n  length: number\n  sequence?: string\n}\n\nfunction finalizeBinEntry(entry: PreBinEntry) {\n  const { probabilityTotal, probabilityCount, lengthTotal, lengthCount } = entry\n  if (probabilityCount) {\n    entry.avgProbability = probabilityTotal / probabilityCount\n  }\n  if (lengthCount) {\n    entry.avgLength = lengthTotal / lengthCount\n    entry.minLength = entry.lengthMin\n    entry.maxLength = entry.lengthMax\n  }\n  if (entry.sequenceCounts?.size) {\n    let maxCount = 0\n    let topSeq: string | undefined\n    for (const [seq, count] of entry.sequenceCounts) {\n      if (count > maxCount) {\n        maxCount = count\n        topSeq = seq\n      }\n    }\n    entry.topSequence = topSeq\n    entry.sequenceCounts = undefined\n  }\n}\n\n/**\n * Generate coverage bins using prefix sums algorithm.\n *\n * This is ~100-1000x faster than the original per-base iteration approach,\n * especially for high-coverage or long-read data.\n *\n * Returns structure-of-arrays format for efficient rendering.\n */\nexport async function generateCoverageBinsPrefixSum({\n  fetchSequence,\n  features,\n  region,\n  opts,\n}: {\n  features: FeatureWithMismatchIterator[]\n  region: Region\n  opts: Opts\n  fetchSequence?: (arg: Region) => Promise<string | undefined>\n}): Promise<CoverageBinsResult> {\n  const { stopToken, colorBy, statsEstimationMode } = opts\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionSize = regionEnd - regionStart\n\n  // Step 1: Compute depth using prefix sums - O(features + regionSize)\n  checkStopToken(stopToken)\n  const depthSoA = processDepthPrefixSum(features, region)\n\n  // In statsEstimationMode, skip all mismatch/modification processing. This is a\n  // performance optimization for when only the depth of coverage is needed, for\n  // example, for an overview of the data or when calculating statistics. Just\n  // return depth-only bins for fast coverage estimation\n  if (statsEstimationMode) {\n    const bins: (LazyBin | undefined)[] = []\n    for (let i = 0; i < regionSize; i++) {\n      const depth = depthSoA.depth[i]!\n      if (depth === 0) {\n        continue\n      }\n      bins[i] = {\n        depth,\n        readsCounted: depth,\n        ref: {\n          entryDepth: depth,\n          '-1': depthSoA.strandMinus[i]!,\n          '0': 0,\n          '1': depthSoA.strandPlus[i]!,\n          probabilityTotal: 0,\n          probabilityCount: 0,\n          lengthTotal: 0,\n          lengthCount: 0,\n          lengthMin: Infinity,\n          lengthMax: -Infinity,\n        },\n      }\n    }\n    return { bins, regionStart, skipmap: {} }\n  }\n\n  // Step 2: Process mismatches with prefix sums for deletions\n  checkStopToken(stopToken)\n  // Clear deletion changes buffer\n  deletionChanges.fill(0, 0, regionSize + 1)\n\n  const snpEvents: { pos: number; entry: SparseSnpEntry }[] = []\n  const noncovEvents: { pos: number; entry: SparseNoncovEntry }[] = []\n  const skipmap: SkipMap = {}\n\n  for (let i = 0, l = features.length; i < l; i++) {\n    processFeature(region, features[i]!, skipmap, noncovEvents, snpEvents)\n  }\n  // Clear feature reference to avoid retaining last feature in memory\n  featureCtx.feature = undefined\n\n  // Compute deletion depth prefix sums\n  const deletionDepth = new Int32Array(regionSize)\n  let dd = 0\n  for (let i = 0; i < regionSize; i++) {\n    dd += deletionChanges[i]!\n    deletionDepth[i] = dd\n  }\n\n  // Step 3: Handle modifications if needed (still per-feature, but modifications are rare)\n  let regionSequence: string | undefined\n  const modBins: PreBaseCoverageBin[] = []\n  const start2 = Math.max(0, regionStart - 1)\n  const diff = regionStart - start2\n\n  if (colorBy?.type === 'modifications' && fetchSequence) {\n    checkStopToken(stopToken)\n    regionSequence =\n      (await fetchSequence({\n        ...region,\n        start: start2,\n        end: regionEnd + 1,\n      })) || ''\n    const slicedSequence = regionSequence.slice(diff)\n\n    for (const feature of features) {\n      processModifications({\n        feature,\n        colorBy,\n        bins: modBins,\n        region,\n        regionSequence: slicedSequence,\n      })\n    }\n  } else if (colorBy?.type === 'methylation' && fetchSequence) {\n    checkStopToken(stopToken)\n    regionSequence ??=\n      (await fetchSequence({\n        ...region,\n        start: start2,\n        end: regionEnd + 1,\n      })) || ''\n\n    for (const feature of features) {\n      processReferenceCpGs({\n        feature,\n        bins: modBins,\n        region,\n        regionSequence,\n      })\n    }\n  }\n\n  // Step 4: Build final bins array - only create objects for positions with data\n  checkStopToken(stopToken)\n  const bins: (LazyBin | undefined)[] = []\n\n  // First pass: create bins only where we have depth > 0 or other data\n  for (let i = 0; i < regionSize; i++) {\n    const depth = depthSoA.depth[i]!\n    const delDepth = deletionDepth[i]!\n\n    // Skip empty positions (sparse optimization)\n    if (depth === 0 && delDepth === 0) {\n      continue\n    }\n\n    bins[i] = {\n      depth: depth - delDepth,\n      readsCounted: depth,\n      ref: {\n        entryDepth: depth,\n        '-1': depthSoA.strandMinus[i]!,\n        '0': 0,\n        '1': depthSoA.strandPlus[i]!,\n        probabilityTotal: 0,\n        probabilityCount: 0,\n        lengthTotal: 0,\n        lengthCount: 0,\n        lengthMin: Infinity,\n        lengthMax: -Infinity,\n      },\n      delskips:\n        delDepth > 0 ? { deletion: createDeletionEntry(delDepth) } : undefined,\n    }\n  }\n\n  // Apply SNP events\n  for (let i = 0, l = snpEvents.length; i < l; i++) {\n    const evt = snpEvents[i]!\n    const pos = evt.pos\n    const entry = evt.entry\n\n    let bin = bins[pos]\n    if (!bin) {\n      bin = {\n        depth: 0,\n        readsCounted: 0,\n        ref: {\n          entryDepth: 0,\n          '-1': 0,\n          '0': 0,\n          '1': 0,\n          probabilityTotal: 0,\n          probabilityCount: 0,\n          lengthTotal: 0,\n          lengthCount: 0,\n          lengthMin: Infinity,\n          lengthMax: -Infinity,\n        },\n      }\n      bins[pos] = bin\n    }\n    const base = entry.base\n    const strand = entry.strand\n    const snps = (bin.snps ??= {})\n    let snpEntry = snps[base]\n    if (!snpEntry) {\n      snpEntry = {\n        entryDepth: 0,\n        '-1': 0,\n        '0': 0,\n        '1': 0,\n        probabilityTotal: 0,\n        probabilityCount: 0,\n        lengthTotal: 0,\n        lengthCount: 0,\n        lengthMin: Infinity,\n        lengthMax: -Infinity,\n      }\n      snps[base] = snpEntry\n    }\n    snpEntry.entryDepth++\n    snpEntry[strand]++\n    bin.ref.entryDepth--\n    bin.ref[strand]--\n    if (entry.altbase) {\n      bin.refbase = entry.altbase\n    }\n  }\n\n  // Apply noncov events (insertions, clips)\n  for (let i = 0, l = noncovEvents.length; i < l; i++) {\n    const evt = noncovEvents[i]!\n    const pos = evt.pos\n    const entry = evt.entry\n\n    let bin = bins[pos]\n    if (!bin) {\n      bin = {\n        depth: 0,\n        readsCounted: 0,\n        ref: {\n          entryDepth: 0,\n          '-1': 0,\n          '0': 0,\n          '1': 0,\n          probabilityTotal: 0,\n          probabilityCount: 0,\n          lengthTotal: 0,\n          lengthCount: 0,\n          lengthMin: Infinity,\n          lengthMax: -Infinity,\n        },\n      }\n      bins[pos] = bin\n    }\n    const strand = entry.strand\n    const type = entry.type\n    const length = entry.length\n    const noncov = (bin.noncov ??= {})\n    let noncovEntry = noncov[type]\n    if (!noncovEntry) {\n      noncovEntry = {\n        entryDepth: 0,\n        '-1': 0,\n        '0': 0,\n        '1': 0,\n        probabilityTotal: 0,\n        probabilityCount: 0,\n        lengthTotal: 0,\n        lengthCount: 0,\n        lengthMin: Infinity,\n        lengthMax: -Infinity,\n      }\n      noncov[type] = noncovEntry\n    }\n    noncovEntry.entryDepth++\n    noncovEntry[strand]++\n    noncovEntry.lengthTotal += length\n    noncovEntry.lengthCount++\n    noncovEntry.lengthMin = Math.min(noncovEntry.lengthMin, length)\n    noncovEntry.lengthMax = Math.max(noncovEntry.lengthMax, length)\n    const seq = entry.sequence\n    if (seq !== undefined) {\n      noncovEntry.sequenceCounts ??= new Map()\n      noncovEntry.sequenceCounts.set(\n        seq,\n        (noncovEntry.sequenceCounts.get(seq) ?? 0) + 1,\n      )\n    }\n  }\n\n  // Merge modification bins - only into bins that already have depth data\n  // (matching original behavior where processModifications/processReferenceCpGs\n  // only added to existing bins)\n  for (let i = 0, l = modBins.length; i < l; i++) {\n    const modBin = modBins[i]\n    if (modBin) {\n      const bin = bins[i]\n      if (bin) {\n        if (Object.keys(modBin.mods).length > 0) {\n          bin.mods = Object.assign(bin.mods ?? {}, modBin.mods)\n        }\n        if (Object.keys(modBin.nonmods).length > 0) {\n          bin.nonmods = Object.assign(bin.nonmods ?? {}, modBin.nonmods)\n        }\n        if (modBin.refbase !== undefined) {\n          bin.refbase = modBin.refbase\n        }\n      }\n    }\n  }\n\n  // Finalize entries\n  for (let i = 0, l = bins.length; i < l; i++) {\n    const bin = bins[i]\n    if (bin) {\n      if (bin.mods) {\n        for (const key in bin.mods) {\n          finalizeBinEntry(bin.mods[key]!)\n        }\n      }\n      if (bin.nonmods) {\n        for (const key in bin.nonmods) {\n          finalizeBinEntry(bin.nonmods[key]!)\n        }\n      }\n      if (bin.noncov) {\n        for (const key in bin.noncov) {\n          finalizeBinEntry(bin.noncov[key]!)\n        }\n      }\n    }\n  }\n\n  return { bins, regionStart, skipmap }\n}\n\nfunction createDeletionEntry(depth: number): PreBinEntry {\n  return {\n    entryDepth: depth,\n    '-1': 0,\n    '0': 0,\n    '1': 0,\n    probabilityTotal: 0,\n    probabilityCount: 0,\n    lengthTotal: 0,\n    lengthCount: 0,\n    lengthMin: Infinity,\n    lengthMax: -Infinity,\n  }\n}\n\n// Shared context to avoid closure allocation per feature\nconst featureCtx = {\n  fstart: 0,\n  fstrand: 0 as -1 | 0 | 1,\n  regionStart: 0,\n  regionEnd: 0,\n  regionSize: 0,\n  feature: undefined as FeatureWithMismatchIterator | Feature | undefined,\n  skipmap: undefined as SkipMap | undefined,\n  noncovEvents: undefined as\n    | { pos: number; entry: SparseNoncovEntry }[]\n    | undefined,\n  snpEvents: undefined as { pos: number; entry: SparseSnpEntry }[] | undefined,\n}\n\nfunction mismatchHandler(\n  type: number,\n  start: number,\n  refLen: number,\n  base: string,\n  _qual: number | undefined,\n  altbase: number | undefined,\n  interbaseLen: number | undefined,\n) {\n  const {\n    fstart,\n    fstrand,\n    regionStart,\n    regionEnd,\n    regionSize,\n    feature,\n    skipmap,\n    noncovEvents,\n    snpEvents,\n  } = featureCtx\n  const mstart = fstart + start\n  const mlen = mismatchLen(type, refLen)\n  const mend = mstart + mlen\n\n  if ((1 << type) & DELSKIP_MASK) {\n    const visStart = Math.max(mstart, regionStart) - regionStart\n    const visEnd = Math.min(mend, regionEnd) - regionStart\n\n    if (visStart < visEnd) {\n      deletionChanges[visStart]!++\n      deletionChanges[visEnd]!--\n    }\n\n    if (type === SKIP_TYPE) {\n      const tags = feature!.get('tags') as Record<string, string> | undefined\n      const xs = tags?.XS || tags?.TS\n      const ts = tags?.ts\n      const effectiveStrand =\n        xs === '+'\n          ? 1\n          : xs === '-'\n            ? -1\n            : (ts === '+' ? 1 : ts === '-' ? -1 : 0) * fstrand\n      const hash = `${mstart}_${mend}_${effectiveStrand}`\n      if (skipmap![hash] === undefined) {\n        skipmap![hash] = {\n          start: mstart,\n          end: mend,\n          strand: fstrand,\n          effectiveStrand,\n          score: 0,\n        }\n      }\n      skipmap![hash].score++\n    }\n  } else if (type === INSERTION_TYPE) {\n    const epos = mstart - regionStart\n    if (epos >= 0 && epos < regionSize) {\n      noncovEvents!.push({\n        pos: epos,\n        entry: {\n          strand: fstrand,\n          type: 'insertion',\n          length: interbaseLen!,\n          sequence: base,\n        },\n      })\n    }\n  } else if (isInterbase(type)) {\n    const epos = mstart - regionStart\n    if (epos >= 0 && epos < regionSize) {\n      noncovEvents!.push({\n        pos: epos,\n        entry: {\n          strand: fstrand,\n          type: MISMATCH_MAP[type]! as 'hardclip' | 'softclip',\n          length: interbaseLen!,\n        },\n      })\n    }\n  } else {\n    const epos = mstart - regionStart\n    if (epos >= 0 && epos < regionSize) {\n      snpEvents!.push({\n        pos: epos,\n        entry: {\n          base,\n          strand: fstrand,\n          altbase: CHAR_FROM_CODE[altbase!],\n        },\n      })\n    }\n  }\n}\n\nfunction processFeature(\n  region: Region,\n  feature: FeatureWithMismatchIterator | Feature,\n  skipmap: SkipMap,\n  noncovEvents: { pos: number; entry: SparseNoncovEntry }[],\n  snpEvents: { pos: number; entry: SparseSnpEntry }[],\n) {\n  featureCtx.fstart = feature.get('start')\n  featureCtx.fstrand = feature.get('strand') as -1 | 0 | 1\n  featureCtx.regionStart = region.start\n  featureCtx.regionEnd = region.end\n  featureCtx.regionSize = region.end - region.start\n  featureCtx.feature = feature\n  featureCtx.skipmap = skipmap\n  featureCtx.noncovEvents = noncovEvents\n  featureCtx.snpEvents = snpEvents\n\n  if ('forEachMismatch' in feature) {\n    feature.forEachMismatch(mismatchHandler)\n  } else {\n    const mismatches = feature.get('mismatches') as Mismatch[] | undefined\n    if (mismatches) {\n      for (const m of mismatches) {\n        let base: string\n        let cliplen: number | undefined\n        if (m.type === 'mismatch') {\n          base = m.base\n        } else if (m.type === 'insertion') {\n          base = m.insertedBases ?? ''\n          cliplen = m.insertlen\n        } else if (m.type === 'softclip' || m.type === 'hardclip') {\n          base = ''\n          cliplen = m.cliplen\n        } else {\n          base = ''\n        }\n        mismatchHandler(\n          MISMATCH_REV_MAP[m.type],\n          m.start,\n          m.length,\n          base,\n          m.type === 'mismatch' ? m.qual : undefined,\n          m.type === 'mismatch' ? m.altbase?.charCodeAt(0) : undefined,\n          cliplen,\n        )\n      }\n    }\n  }\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  aggregateQuantitativeStats,\n  blankStats,\n} from '@jbrowse/core/data_adapters/BaseAdapter/stats'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { rectifyStats } from '@jbrowse/core/util/stats'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport { fetchSequence } from '../util.ts'\nimport {\n  finalizeLazyBin,\n  generateCoverageBinsPrefixSum,\n} from './generateCoverageBinsPrefixSum.ts'\n\nimport type { CoverageBinsResult } from './generateCoverageBinsPrefixSum.ts'\nimport type {\n  ColorBy,\n  FeatureWithMismatchIterator,\n  FilterBy,\n} from '../shared/types.ts'\nimport type {\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\ninterface SNPCoverageOptions extends BaseOptions {\n  filterBy?: FilterBy\n  colorBy?: ColorBy\n  staticBlocks?: Region[]\n  statsEstimationMode?: boolean\n}\n\nfunction makeFilterByKey(filterBy?: FilterBy) {\n  return filterBy\n    ? `${filterBy.flagExclude}|${filterBy.flagInclude}|${filterBy.readName ?? ''}|${filterBy.tagFilter?.tag ?? ''}|${filterBy.tagFilter?.value ?? ''}`\n    : ''\n}\n\nfunction makeRegionFilterKey(region: Region, opts: SNPCoverageOptions) {\n  return `${region.refName}:${region.start}-${region.end}|${makeFilterByKey(opts.filterBy)}|${opts.trackInstanceId || ''}`\n}\n\nfunction makeCacheKey(region: Region, opts: SNPCoverageOptions) {\n  const { colorBy } = opts\n\n  const colorByKey = colorBy\n    ? `${colorBy.type}|${colorBy.tag ?? ''}|${colorBy.modifications?.twoColor ?? ''}|${colorBy.modifications?.isolatedModification ?? ''}|${colorBy.modifications?.threshold ?? ''}`\n    : ''\n\n  return `${makeRegionFilterKey(region, opts)}|${colorByKey}`\n}\n\nfunction computeStatsFromBins(\n  result: CoverageBinsResult,\n  targetStart: number,\n  targetEnd: number,\n) {\n  const { bins, regionStart } = result\n  let scoreMin = Number.MAX_VALUE\n  let scoreMax = Number.MIN_VALUE\n  let scoreSum = 0\n  let scoreSumSquares = 0\n  let featureCount = 0\n\n  for (let i = 0, l = bins.length; i < l; i++) {\n    const bin = bins[i]\n    if (bin) {\n      const pos = regionStart + i\n      if (pos >= targetStart && pos < targetEnd) {\n        const score = bin.depth\n        scoreMin = Math.min(scoreMin, score)\n        scoreMax = Math.max(scoreMax, score)\n        scoreSum += score\n        scoreSumSquares += score * score\n        featureCount++\n      }\n    }\n  }\n\n  return {\n    scoreMin: featureCount > 0 ? scoreMin : 0,\n    scoreMax: featureCount > 0 ? scoreMax : 0,\n    scoreSum,\n    scoreSumSquares,\n    featureCount,\n    basesCovered: featureCount,\n  }\n}\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  private sequenceAdapterP?: Promise<BaseSequenceAdapter | undefined>\n\n  private subadapterRef?: BaseFeatureDataAdapter\n\n  // Cache for coverage results (keyed by region+filterBy+colorBy)\n  // Stats estimation uses empty colorBy key, full rendering includes colorBy\n  private cache = new QuickLRU<string, CoverageBinsResult>({\n    maxSize: 50,\n    maxAge: 5 * 60 * 1000, // 5 minute TTL\n  })\n\n  private lastBpPerPx?: number\n\n  /**\n   * Override to propagate sequenceAdapterConfig to the subadapter\n   */\n  setSequenceAdapterConfig(config: Record<string, unknown>) {\n    super.setSequenceAdapterConfig(config)\n    // Propagate to subadapter if it exists\n    if (this.subadapterRef) {\n      this.subadapterRef.setSequenceAdapterConfig(config)\n    }\n  }\n\n  protected async configure() {\n    const subadapterConfigBase = this.getConf('subadapter')\n\n    // Initialize from config if not set externally via setSequenceAdapterConfig\n    this.sequenceAdapterConfig ??= this.getConf('sequenceAdapter')\n\n    // Use the base subadapter config to ensure consistent cache keys\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfigBase)\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    const subadapter = dataAdapter.dataAdapter as BaseFeatureDataAdapter\n    this.subadapterRef = subadapter\n\n    // Propagate sequenceAdapterConfig to the subadapter\n    if (this.sequenceAdapterConfig) {\n      subadapter.setSequenceAdapterConfig(this.sequenceAdapterConfig)\n    }\n\n    return { subadapter }\n  }\n\n  async getSequenceAdapter() {\n    const config = this.sequenceAdapterConfig ?? this.getConf('sequenceAdapter')\n    if (!config || !this.getSubAdapter) {\n      return undefined\n    }\n    this.sequenceAdapterP ??= this.getSubAdapter(config)\n      .then(r => {\n        const adapter = r.dataAdapter as BaseSequenceAdapter\n        // verify adapter has getSequence method (e.g. ChromSizesAdapter doesn't)\n        return 'getSequence' in adapter ? adapter : undefined\n      })\n      .catch((e: unknown) => {\n        this.sequenceAdapterP = undefined\n        throw e\n      })\n    return this.sequenceAdapterP\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { bins, regionStart, skipmap } = await this.getCoverageBins(\n        region,\n        opts,\n      )\n\n      const { refName } = region\n      const adapterId = this.id\n\n      // Emit coverage features using lightweight inline feature objects\n      for (let i = 0, l = bins.length; i < l; i++) {\n        const bin = bins[i]\n        if (bin) {\n          const start = regionStart + i\n          const snpinfo = finalizeLazyBin(bin)\n          const score = bin.depth\n          observer.next({\n            get: (field: string): any => {\n              switch (field) {\n                case 'start':\n                  return start\n                case 'end':\n                  return start + 1\n                case 'score':\n                  return score\n                case 'snpinfo':\n                  return snpinfo\n                case 'refName':\n                  return refName\n                default:\n                  return undefined\n              }\n            },\n            id: () => `${adapterId}-${start}`,\n            toJSON: () => ({\n              uniqueId: `${adapterId}-${start}`,\n              start,\n              end: start + 1,\n              score,\n              snpinfo,\n              refName,\n            }),\n          })\n        }\n      }\n\n      // Emit skip features for arc rendering\n      for (const [key, skip] of Object.entries(skipmap)) {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              refName,\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              effectiveStrand: skip.effectiveStrand,\n            },\n          }),\n        )\n      }\n\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  private async getCoverageBins(\n    region: Region,\n    opts: SNPCoverageOptions = {},\n  ): Promise<CoverageBinsResult> {\n    const { bpPerPx, statsEstimationMode } = opts\n\n    // Clear cache when bpPerPx changes (zoom level changed)\n    // Only compare when both values are defined to avoid clearing on stats calls\n    if (\n      bpPerPx !== undefined &&\n      this.lastBpPerPx !== undefined &&\n      this.lastBpPerPx !== bpPerPx\n    ) {\n      this.cache.clear()\n    }\n    if (bpPerPx !== undefined) {\n      this.lastBpPerPx = bpPerPx\n    }\n\n    // For statsEstimationMode, check for any cached result with same region+filterBy\n    if (statsEstimationMode) {\n      const regionFilterKey = makeRegionFilterKey(region, opts)\n\n      // Check cache for any entry matching this region+filterBy (any colorBy)\n      for (const key of this.cache.keys()) {\n        if (key.startsWith(`${regionFilterKey}|`)) {\n          const cached = this.cache.get(key)\n          if (cached) {\n            // console.log(\n            //   `[SNPCoverageAdapter] cache HIT for statsEstimation ${region.refName}:${region.start}-${region.end}`,\n            // )\n            return cached\n          }\n        }\n      }\n\n      // console.log(\n      //   `[SNPCoverageAdapter] cache MISS for statsEstimation ${region.refName}:${region.start}-${region.end}`,\n      // )\n      const { subadapter } = await this.configure()\n      const features = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n      const result = await generateCoverageBinsPrefixSum({\n        features: features as FeatureWithMismatchIterator[],\n        region,\n        opts,\n      })\n      // Cache with empty colorBy key for stats-only results\n      const statsKey = `${regionFilterKey}|`\n      this.cache.set(statsKey, result)\n      // console.log(\n      //   `[SNPCoverageAdapter] cached statsEstimation result`,\n      // )\n      return result\n    }\n\n    const cacheKey = makeCacheKey(region, opts)\n    const cached = this.cache.get(cacheKey)\n    if (cached) {\n      // console.log(\n      //   `[SNPCoverageAdapter] cache HIT for ${region.refName}:${region.start}-${region.end}`,\n      // )\n      return cached\n    }\n    // console.log(\n    //   `[SNPCoverageAdapter] cache MISS for ${region.refName}:${region.start}-${region.end}`,\n    // )\n\n    const { subadapter } = await this.configure()\n    const sequenceAdapter = await this.getSequenceAdapter()\n\n    const features = await firstValueFrom(\n      subadapter.getFeatures(region, opts).pipe(toArray()),\n    )\n\n    const result = await generateCoverageBinsPrefixSum({\n      features: features as FeatureWithMismatchIterator[],\n      region,\n      opts,\n      fetchSequence: sequenceAdapter\n        ? (region: Region) => fetchSequence(region, sequenceAdapter)\n        : undefined,\n    })\n\n    this.cache.set(cacheKey, result)\n    // console.log(\n    //   `[SNPCoverageAdapter] cached full result: ${formatBytes(estimateBinsByteSize(result))} (total cache: ${formatBytes(this.estimateCacheBytes())})`,\n    // )\n    return result\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getMultiRegionQuantitativeStats(\n    regions: Region[] = [],\n    opts: SNPCoverageOptions = {},\n  ) {\n    if (!regions.length) {\n      return blankStats()\n    }\n\n    const { staticBlocks } = opts\n\n    // If staticBlocks provided, use them for caching and subselect for dynamic regions\n    if (staticBlocks?.length) {\n      // Fetch data for all static blocks (these will be cached)\n      const staticBlockData = await Promise.all(\n        staticBlocks.map(block =>\n          this.getCoverageBins(block, {\n            ...opts,\n            statsEstimationMode: true,\n          }).then(bins => ({ block, bins })),\n        ),\n      )\n\n      // For each dynamic region, find overlapping static blocks and compute stats\n      const regionStats = regions.map(region => {\n        const overlappingBlocks = staticBlockData.filter(\n          ({ block }) =>\n            block.refName === region.refName &&\n            block.start < region.end &&\n            block.end > region.start,\n        )\n\n        if (overlappingBlocks.length === 0) {\n          return rectifyStats({\n            scoreMin: 0,\n            scoreMax: 0,\n            scoreSum: 0,\n            scoreSumSquares: 0,\n            featureCount: 0,\n            basesCovered: 0,\n          })\n        }\n\n        // Compute stats from overlapping blocks, subselecting to region bounds\n        const blockStats = overlappingBlocks.map(({ bins }) =>\n          rectifyStats(computeStatsFromBins(bins, region.start, region.end)),\n        )\n\n        return aggregateQuantitativeStats(blockStats)\n      })\n\n      return aggregateQuantitativeStats(regionStats)\n    }\n\n    // Fallback: fetch directly for each dynamic region (original behavior)\n    const stats = await Promise.all(\n      regions.map(region => this.getRegionQuantitativeStats(region, opts)),\n    )\n    return aggregateQuantitativeStats(stats)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n\n  freeResources(region: Region) {\n    const prefix = `${region.refName}:`\n    for (const key of this.cache.keys()) {\n      if (key.startsWith(prefix)) {\n        this.cache.delete(key)\n      }\n    }\n  }\n}\n","import { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getModProbabilities(feature: Feature) {\n  // ML stores probabilities as array of numerics and MP is scaled phred scores\n  // https://github.com/samtools/hts-specs/pull/418/files#diff-e765c6479316309f56b636f88189cdde8c40b854c7bdcce9ee7fe87a4e76febcR596\n  //\n  // - if we have ML or Ml, it is an 8bit probability, divide by 255\n  //\n  // - if we have MP or Mp it is phred scaled ASCII, which can go up to 90 but\n  // has very high likelihood basecalls at that point, we really only care about\n  // low qual calls <20 approx\n  const m = (getTagAlt(feature, 'ML', 'Ml') as number[] | string) || []\n  if (m) {\n    const result = []\n    if (typeof m === 'string') {\n      const parts = m.split(',')\n      for (let i = 0, l = parts.length; i < l; i++) {\n        result.push(+parts[i]! / 255)\n      }\n    } else {\n      for (let i = 0, l = m.length; i < l; i++) {\n        result.push(m[i]! / 255)\n      }\n    }\n    return result\n  } else {\n    const mp = getTagAlt(feature, 'MP', 'Mp') as string | undefined\n    if (mp) {\n      const result = []\n      for (let i = 0, l = mp.length; i < l; i++) {\n        const phred = mp.charCodeAt(i) - 33\n        result.push(Math.min(1, phred / 50))\n      }\n      return result\n    }\n    return undefined\n  }\n}\n","import { getModPositions } from './getModPositions.ts'\nimport { getModProbabilities } from './getModProbabilities.ts'\nimport { getNextRefPos } from '../MismatchParser/index.ts'\nimport { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getMethBins(feature: Feature, cigarOps: ArrayLike<number>) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const flen = fend - fstart\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string | undefined) || ''\n  const methBins = []\n  const hydroxyMethBins = []\n  const methProbs = []\n  const hydroxyMethProbs = []\n  const seq = feature.get('seq') as string | undefined\n  if (seq) {\n    const probabilities = getModProbabilities(feature)\n    const modifications = getModPositions(mm, seq, fstrand)\n    let probIndex = 0\n\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n        // Skip positions outside the feature bounds\n        if (ref < 0 || ref >= flen) {\n          continue\n        }\n\n        // Calculate probability index based on strand\n        const isReverseStrand = fstrand === -1\n        const idx2 =\n          probIndex + (isReverseStrand ? positions.length - 1 - idx : idx)\n        const prob = probabilities?.[idx2] || 0\n\n        // Store modification data in appropriate bins\n        if (type === 'm') {\n          methBins[ref] = 1\n          methProbs[ref] = prob\n        } else if (type === 'h') {\n          hydroxyMethBins[ref] = 1\n          hydroxyMethProbs[ref] = prob\n        }\n      }\n      probIndex += positions.length\n    }\n  }\n  return {\n    methBins,\n    hydroxyMethBins,\n    methProbs,\n    hydroxyMethProbs,\n  }\n}\n","// get relative reference sequence positions for positions given relative to\n// the read sequence\n\nimport {\n  CIGAR_D,\n  CIGAR_EQ,\n  CIGAR_I,\n  CIGAR_M,\n  CIGAR_N,\n  CIGAR_S,\n  CIGAR_X,\n} from '../PileupRenderer/renderers/cigarUtil.ts'\n\n// Handles both packed Uint32Array and unpacked number[] formats\nexport function getNextRefPos(\n  cigarOps: ArrayLike<number>,\n  positions: number[],\n) {\n  let readPos = 0\n  let refPos = 0\n  let currPos = 0\n  const ret = []\n\n  for (\n    let i = 0, l = cigarOps.length, l2 = positions.length;\n    i < l && currPos < l2;\n    i++\n  ) {\n    const packed = cigarOps[i]!\n    const len = packed >> 4\n    const op = packed & 0xf\n    if (op === CIGAR_S || op === CIGAR_I) {\n      for (let j = 0; j < len && currPos < l2; j++) {\n        if (positions[currPos] === readPos + j) {\n          currPos++\n        }\n      }\n      readPos += len\n    } else if (op === CIGAR_D || op === CIGAR_N) {\n      refPos += len\n    } else if (op === CIGAR_M || op === CIGAR_X || op === CIGAR_EQ) {\n      for (let j = 0; j < len && currPos < l2; j++) {\n        if (positions[currPos] === readPos + j) {\n          ret.push({\n            ref: refPos + j,\n            idx: currPos,\n          })\n          currPos++\n        }\n      }\n      readPos += len\n      refPos += len\n    }\n  }\n\n  return ret\n}\n","import { getNextRefPos } from '../MismatchParser/index.ts'\nimport { getModPositions } from '../ModificationParser/getModPositions.ts'\nimport { getModProbabilities } from '../ModificationParser/getModProbabilities.ts'\nimport { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  ops: ArrayLike<number>,\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n","import { revcom } from '@jbrowse/core/util'\n\nimport { modificationRegex } from './consts.ts'\n\n/**\n * Parse MM tag to extract modification positions on the read sequence.\n *\n *\n * @param mm - MM tag string (e.g., \"C+m,2,2,1;A+a,0,3\")\n * @param fseq - Read sequence\n * @param fstrand - Read strand (-1, 0, or 1)\n * @returns Array of modification objects with positions\n */\nexport function getModPositions(mm: string, fseq: string, fstrand: number) {\n  const seq = fstrand === -1 ? revcom(fseq) : fseq\n  const seqLength = seq.length\n  const mods = mm.split(';')\n  const result = []\n\n  for (const mod of mods) {\n    // Empty string\n    if (mod === '') {\n      continue\n    }\n\n    const split = mod.split(',')\n    const basemod = split[0]!\n    const matches = modificationRegex.exec(basemod)\n    if (!matches) {\n      throw new Error(`bad format for MM tag: \"${mod}\"`)\n    }\n    const [, base, strand, typestr] = matches\n\n    // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so split,\n    // and they can also be chemical codes (ChEBI) e.g. C+16061\n    const types = typestr!.split(/(\\d+|.)/)\n\n    // Note: Negative strand modifications (e.g., T-a) are now supported\n    // They are processed the same way as positive strand modifications\n    // The strand information is preserved for simplex/duplex detection\n\n    // this logic based on parse_mm.pl from hts-specs\n    for (const type of types) {\n      if (type === '') {\n        continue\n      }\n\n      const splitLength = split.length\n      let currPos = 0\n\n      // For reverse strand, pre-allocate array and fill backwards to avoid reverse()\n      // This is worthwhile because we avoid an O(n) reverse() operation\n      const positions = fstrand === -1 ? new Array(splitLength - 1) : []\n      let writeIndex = fstrand === -1 ? splitLength - 2 : 0\n\n      for (let i = 1; i < splitLength; i++) {\n        let delta = +split[i]!\n        do {\n          if (base === 'N' || base === seq[currPos]) {\n            delta--\n          }\n          currPos++\n        } while (delta >= 0 && currPos < seqLength)\n\n        // Calculate and store position\n        if (fstrand === -1) {\n          const pos = seqLength - currPos\n          if (pos >= 0) {\n            // avoid negative-number-positions in array, seen in #4629 cause\n            // unknown, could warrant some further investigation\n            positions[writeIndex--] = pos\n          } else {\n            // Position is negative (edge case from #4629)\n            // Don't write anything, don't decrement writeIndex\n            // This leaves a gap at the beginning of the array that we'll slice off\n          }\n        } else {\n          positions[writeIndex++] = currPos - 1\n        }\n      }\n\n      // For reverse strand, slice off any unfilled slots at the beginning\n      // (happens when some positions were negative and skipped)\n      const validPositions =\n        fstrand === -1 ? positions.slice(writeIndex + 1) : positions\n\n      result.push({\n        type,\n        base: base!,\n        strand: strand!,\n        positions: validPositions,\n      })\n    }\n  }\n\n  return result\n}\n"],"names":["CIGAR_M","CIGAR_I","CIGAR_D","CIGAR_N","CIGAR_S","CIGAR_H","CIGAR_EQ","CIGAR_X","CIGAR_M_EQ_MASK","CIGAR_REF_CONSUMING_MASK","SEQRET","SEQRET_NUMERIC_DECODER","Uint8Array","CHAR_FROM_CODE","Array","from","length","_","i","String","fromCharCode","getCigarOps","cigar","parseCigar2","depthChanges","Int32Array","MAX_REGION_SIZE","strandPlusChanges","strandMinusChanges","incWithProbabilities","bin","strand","type","field","probability","entry","entryDepth","probabilityTotal","probabilityCount","lengthTotal","lengthCount","lengthMin","Infinity","lengthMax","processModifications","feature","colorBy","region","bins","regionSequence","fstart","get","fstrand","fend","twoColor","modifications","isolatedModification","seq","thresholdFraction","threshold","cigarOps","regionStart","start","regionEnd","end","getMaxProbModAtEachPosition","forEach","allProbs","prob","pos","refPos","epos","depth","readsCounted","snps","ref","mods","nonmods","delskips","noncov","refbase","s","sum","max","processCpG","binIdx","isMeth","isDel","processReferenceCpGs","r","toLowerCase","methBins","methProbs","getMethBins","isDeleted","fill","forEachMismatch","DELETION_TYPE","visStart","Math","visEnd","min","j","l1","l2","idx0","idx1","b0","b1","p0","p1","isDel0","isDel1","finalizeLazyBin","deletionChanges","finalizeBinEntry","avgProbability","avgLength","minLength","maxLength","sequenceCounts","size","topSeq","maxCount","count","topSequence","undefined","async","generateCoverageBinsPrefixSum","fetchSequence","features","opts","stopToken","statsEstimationMode","regionSize","checkStopToken","depthSoA","Error","strandPlus","strandMinus","d","sp","sm","processDepthPrefixSum","skipmap","snpEvents","noncovEvents","l","processFeature","featureCtx","deletionDepth","dd","modBins","start2","diff","slicedSequence","slice","delDepth","deletion","createDeletionEntry","evt","base","snpEntry","altbase","noncovEntry","sequence","Map","set","modBin","Object","keys","assign","key","mismatchHandler","refLen","_qual","interbaseLen","mstart","mlen","INTERBASE_MASK","mismatchLen","mend","DELSKIP_MASK","SKIP_TYPE","tags","xs","XS","TS","ts","effectiveStrand","hash","score","INSERTION_TYPE","push","isInterbase","MISMATCH_MAP","mismatches","m","cliplen","insertedBases","insertlen","MISMATCH_REV_MAP","qual","charCodeAt","makeRegionFilterKey","refName","filterBy","flagExclude","flagInclude","readName","tagFilter","tag","value","trackInstanceId","SNPCoverageAdapter","BaseFeatureDataAdapter","cache","QuickLRU","maxSize","maxAge","setSequenceAdapterConfig","config","super","this","subadapterRef","configure","subadapterConfigBase","getConf","sequenceAdapterConfig","dataAdapter","getSubAdapter","subadapter","getSequenceAdapter","sequenceAdapterP","then","adapter","catch","e","getFeatures","ObservableCreate","getCoverageBins","adapterId","id","snpinfo","observer","next","toJSON","uniqueId","skip","entries","SimpleFeature","data","complete","bpPerPx","lastBpPerPx","clear","regionFilterKey","startsWith","cached","firstValueFrom","pipe","toArray","result","statsKey","cacheKey","colorByKey","makeCacheKey","sequenceAdapter","getMultiRegionFeatureDensityStats","regions","getMultiRegionQuantitativeStats","blankStats","staticBlocks","staticBlockData","Promise","all","map","block","regionStats","overlappingBlocks","filter","rectifyStats","scoreMin","scoreMax","scoreSum","scoreSumSquares","featureCount","basesCovered","blockStats","targetStart","targetEnd","Number","MAX_VALUE","MIN_VALUE","computeStatsFromBins","aggregateQuantitativeStats","stats","getRegionQuantitativeStats","getRefNames","freeResources","prefix","delete","getModProbabilities","getTagAlt","parts","split","mp","phred","flen","mm","hydroxyMethBins","hydroxyMethProbs","probabilities","getModPositions","probIndex","positions","idx","getNextRefPos","idx2","readPos","currPos","ret","packed","len","op","ops","maxProbModForPosition","old","fseq","revcom","seqLength","mod","basemod","matches","modificationRegex","exec","typestr","types","splitLength","writeIndex","delta","validPositions"],"ignoreList":[],"sourceRoot":""}