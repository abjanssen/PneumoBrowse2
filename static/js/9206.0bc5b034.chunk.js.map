{"version":3,"file":"static/js/9206.0bc5b034.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts","../../../plugins/sequence/src/IndexedFastaAdapter/IndexedFastaAdapter.ts","../../../node_modules/@gmod/indexedfasta/src/indexedFasta.ts","../../../node_modules/@gmod/indexedfasta/src/bgzipIndexedFasta.ts","../../../plugins/sequence/src/BgzipFastaAdapter/BgzipFastaAdapter.ts"],"sourcesContent":["// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter<V> {\n  callbacks = new Set<(arg: V) => void>()\n  currentMessage?: V\n\n  addCallback(callback: (arg: V) => void = () => {}): void {\n    this.callbacks.add(callback)\n    if (this.currentMessage) {\n      callback(this.currentMessage)\n    }\n  }\n\n  callback(message: V) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController.ts'\nimport AggregateStatusReporter from './AggregateStatusReporter.ts'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U, V> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: (arg: V) => void,\n) => Promise<U>\n\ninterface Entry<U, V> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter<V>\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U, V = string> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U, V>>\n  private fillCallback: FillCallback<T, U, V>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U, V>\n    cache: Cache<Entry<U, V>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U, V>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter<V>()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U, V> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: V) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch((error: unknown) => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      (error: unknown) => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n","import AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport { IndexedFasta } from '@gmod/indexedfasta'\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { SimpleFeature, updateStatus2 } from '@jbrowse/core/util'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { FileLocation, NoAssemblyRegion } from '@jbrowse/core/util/types'\n\ninterface T {\n  refName: string\n  start: number\n  end: number\n  fasta: IndexedFasta\n}\n\nexport default class IndexedFastaAdapter extends BaseSequenceAdapter {\n  protected setupP?: Promise<{ fasta: IndexedFasta }>\n\n  private seqCache = new AbortablePromiseCache<T, string | undefined>({\n    cache: new QuickLRU({ maxSize: 200 }),\n    fill: async (args: T) => {\n      const { refName, start, end, fasta } = args\n      // TODO:ABORT\n      return fasta.getSequence(refName, start, end)\n    },\n  })\n\n  public async getRefNames(_opts?: BaseOptions) {\n    const { fasta } = await this.setup()\n    // TODO:ABORT\n    return fasta.getSequenceNames()\n  }\n\n  public async getRegions(_opts?: BaseOptions) {\n    const { fasta } = await this.setup()\n    // TODO:ABORT\n    const seqSizes = await fasta.getSequenceSizes()\n    return Object.keys(seqSizes).map(refName => ({\n      refName,\n      start: 0,\n      end: seqSizes[refName]!,\n    }))\n  }\n\n  public async setupPre() {\n    const fastaLocation = this.getConf('fastaLocation') as FileLocation\n    const faiLocation = this.getConf('faiLocation') as FileLocation\n\n    return {\n      fasta: new IndexedFasta({\n        fasta: openLocation(fastaLocation, this.pluginManager),\n        fai: openLocation(faiLocation, this.pluginManager),\n      }),\n    }\n  }\n\n  public async getHeader() {\n    const loc = this.getConf('metadataLocation')\n    return loc.uri === '' || loc.uri === '/path/to/fa.metadata.yaml'\n      ? null\n      : openLocation(loc, this.pluginManager).readFile('utf8')\n  }\n\n  public async setup() {\n    if (!this.setupP) {\n      this.setupP = this.setupPre().catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  public getFeatures(region: NoAssemblyRegion, opts?: BaseOptions) {\n    const { statusCallback = () => {}, stopToken } = opts || {}\n    const { refName, start, end } = region\n    return ObservableCreate<Feature>(async observer => {\n      await updateStatus2(\n        'Downloading sequence',\n        statusCallback,\n        stopToken,\n        async () => {\n          const { fasta } = await this.setup()\n          // TODO:ABORT\n          const size = await fasta.getSequenceSize(refName)\n          const regionEnd = Math.min(size || 0, end)\n          const chunks = []\n          const chunkSize = 128000\n\n          const s = start - (start % chunkSize)\n          const e = end + (chunkSize - (end % chunkSize))\n          for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {\n            const r = {\n              refName,\n              start: chunkStart,\n              end: chunkStart + chunkSize,\n            }\n\n            checkStopToken(stopToken)\n\n            const res = await this.seqCache.get(JSON.stringify(r), {\n              ...r,\n              fasta,\n            })\n            if (!res) {\n              break\n            }\n            chunks.push(res)\n          }\n          const seq = chunks\n            .filter(f => !!f)\n            .join('')\n            .slice(start - s)\n            .slice(0, end - start)\n          if (seq) {\n            observer.next(\n              new SimpleFeature({\n                id: `${refName}-${start}-${regionEnd}`,\n                data: {\n                  refName,\n                  start,\n                  end: regionEnd,\n                  seq,\n                },\n              }),\n            )\n          }\n        },\n      )\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n}\n","import { LocalFile } from 'generic-filehandle2'\n\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\ninterface BaseOpts {\n  signal?: AbortSignal\n}\n\ninterface IndexEntry {\n  offset: number\n  lineBytes: number\n  lineLength: number\n  length: number\n}\n\nfunction _faiOffset(idx: IndexEntry, pos: number) {\n  return (\n    idx.offset +\n    idx.lineBytes * Math.floor(pos / idx.lineLength) +\n    (pos % idx.lineLength)\n  )\n}\n\nasync function readFAI(fai: GenericFilehandle, opts: BaseOpts = {}) {\n  const decoder = new TextDecoder('utf8')\n  return Object.fromEntries(\n    decoder\n      .decode((await fai.readFile(opts)) as unknown as Uint8Array)\n      .split(/\\r?\\n/)\n      .map(r => r.trim())\n      .filter(f => !!f)\n      .map(line => line.split('\\t'))\n      .map(row => {\n        if (row[0]?.startsWith('>')) {\n          throw new Error(\n            'found > in sequence name, might have supplied FASTA file for the FASTA index',\n          )\n        }\n        return [\n          row[0]!,\n          {\n            name: row[0]!,\n            length: +row[1]!,\n            start: 0,\n            end: +row[1]!,\n            offset: +row[2]!,\n            lineLength: +row[3]!,\n            lineBytes: +row[4]!,\n          },\n        ] as const\n      }),\n  )\n}\n\nexport default class IndexedFasta {\n  fasta: GenericFilehandle\n  fai: GenericFilehandle\n  indexes?: ReturnType<typeof readFAI>\n\n  constructor({\n    fasta,\n    fai,\n    path,\n    faiPath,\n  }: {\n    fasta?: GenericFilehandle\n    fai?: GenericFilehandle\n    path?: string\n    faiPath?: string\n  }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass filehandle for fasta or path to localfile')\n    }\n\n    if (fai) {\n      this.fai = fai\n    } else if (faiPath) {\n      this.fai = new LocalFile(faiPath)\n    } else if (path) {\n      this.fai = new LocalFile(`${path}.fai`)\n    } else {\n      throw new Error('Need to pass filehandle for  or path to localfile')\n    }\n  }\n\n  async _getIndexes(opts?: BaseOpts) {\n    if (!this.indexes) {\n      this.indexes = readFAI(this.fai, opts).catch((e: unknown) => {\n        this.indexes = undefined\n        throw e\n      })\n    }\n    return this.indexes\n  }\n\n  /**\n   * @returns array of string sequence names that are present in the index, in\n   * which the array index indicates the sequence ID, and the value is the\n   * sequence name\n   */\n  async getSequenceNames(opts?: BaseOpts) {\n    return Object.keys(await this._getIndexes(opts))\n  }\n\n  /**\n   * @returns array of string sequence names that are present in the index, in\n   * which the array index indicates the sequence ID, and the value is the\n   * sequence name\n   */\n  async getSequenceSizes(opts?: BaseOpts) {\n    const returnObject = {} as Record<string, number>\n    const idx = await this._getIndexes(opts)\n    for (const val of Object.values(idx)) {\n      returnObject[val.name] = val.length\n    }\n    return returnObject\n  }\n\n  /**\n   * @returns array of string sequence names that are present in the index, in\n   * which the array index indicates the sequence ID, and the value is the\n   * sequence name\n   */\n  async getSequenceSize(seqName: string, opts?: BaseOpts) {\n    const idx = await this._getIndexes(opts)\n    return idx[seqName]?.length\n  }\n\n  /**\n   * @param name\n   *\n   * @returns true if the file contains the given reference sequence name\n   */\n  async hasReferenceSequence(name: string, opts?: BaseOpts) {\n    return !!(await this._getIndexes(opts))[name]\n  }\n\n  /**\n   * @param seqName\n   * @param min\n   * @param max\n   */\n  async getResiduesByName(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts))[seqName]\n    return indexEntry\n      ? this._fetchFromIndexEntry(indexEntry, min, max, opts)\n      : undefined\n  }\n\n  //alias for getResiduesByName\n  async getSequence(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    return this.getResiduesByName(seqName, min, max, opts)\n  }\n\n  async _fetchFromIndexEntry(\n    indexEntry: IndexEntry,\n    min = 0,\n    max?: number,\n    opts?: BaseOpts,\n  ) {\n    let end = max\n    if (min < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    if (end === undefined || end > indexEntry.length) {\n      end = indexEntry.length\n    }\n    if (min >= end) {\n      return ''\n    }\n\n    const position = _faiOffset(indexEntry, min)\n    const readlen = _faiOffset(indexEntry, end) - position\n\n    const decoder = new TextDecoder('utf8')\n    return decoder\n      .decode(await this.fasta.read(readlen, position, opts))\n      .replace(/\\s+/g, '')\n  }\n}\n","import { BgzfFilehandle } from '@gmod/bgzf-filehandle'\nimport { LocalFile } from 'generic-filehandle2'\n\nimport IndexedFasta from './indexedFasta.ts'\n\n\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport default class BgzipIndexedFasta extends IndexedFasta {\n  constructor({\n    fasta,\n    path,\n    fai,\n    faiPath,\n    gzi,\n    gziPath,\n  }: {\n    fasta?: GenericFilehandle\n    path?: string\n    fai?: GenericFilehandle\n    faiPath?: string\n    gzi?: GenericFilehandle\n    gziPath?: string\n  }) {\n    super({ fasta, path, fai, faiPath })\n    if (fasta && gzi) {\n      // @ts-expect-error\n      this.fasta = new BgzfFilehandle({\n        filehandle: fasta,\n        gziFilehandle: gzi,\n      })\n    } else if (path && gziPath) {\n      // @ts-expect-error\n      this.fasta = new BgzfFilehandle({\n        filehandle: new LocalFile(path),\n        gziFilehandle: new LocalFile(gziPath),\n      })\n    }\n  }\n}\n","import { BgzipIndexedFasta } from '@gmod/indexedfasta'\nimport { openLocation } from '@jbrowse/core/util/io'\n\nimport IndexedFasta from '../IndexedFastaAdapter/IndexedFastaAdapter'\n\nimport type { FileLocation } from '@jbrowse/core/util/types'\n\nexport default class BgzipFastaAdapter extends IndexedFasta {\n  public async setupPre() {\n    const fastaLocation = this.getConf('fastaLocation')\n    const faiLocation = this.getConf('faiLocation')\n    const gziLocation = this.getConf('gziLocation')\n    const fastaOpts = {\n      fasta: openLocation(fastaLocation as FileLocation, this.pluginManager),\n      fai: openLocation(faiLocation as FileLocation, this.pluginManager),\n      gzi: openLocation(gziLocation as FileLocation, this.pluginManager),\n    }\n\n    return { fasta: new BgzipIndexedFasta(fastaOpts) }\n  }\n}\n"],"names":["NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","addSignal","signal","this","aborted","Error","add","handleAborted","addEventListener","delete","size","abort","AggregateStatusReporter","callbacks","addCallback","callback","currentMessage","message","elt","AbortablePromiseCache","constructor","fill","cache","TypeError","get","set","fillCallback","isAbortException","exception","name","code","evict","key","entry","data","statusCallback","aborter","statusReporter","newEntry","promise","settled","then","catch","error","console","checkSinglePromise","checkForSingleAbort","Object","assign","result","has","AbortSignal","cacheEntry","cachedEntry","clear","keyIter","keys","deleteCount","next","done","value","IndexedFastaAdapter","BaseSequenceAdapter","seqCache","QuickLRU","maxSize","async","refName","start","end","fasta","args","getSequence","getRefNames","_opts","setup","getSequenceNames","getRegions","seqSizes","getSequenceSizes","map","setupPre","fastaLocation","getConf","faiLocation","IndexedFasta","openLocation","pluginManager","fai","getHeader","loc","uri","readFile","setupP","e","undefined","getFeatures","region","opts","stopToken","ObservableCreate","updateStatus2","getSequenceSize","regionEnd","Math","min","chunks","chunkSize","s","chunkStart","r","checkStopToken","res","JSON","stringify","push","seq","filter","f","join","slice","observer","SimpleFeature","id","complete","_faiOffset","idx","pos","offset","lineBytes","floor","lineLength","path","faiPath","_getIndexes","indexes","decoder","TextDecoder","fromEntries","decode","split","trim","line","row","startsWith","length","readFAI","returnObject","val","values","seqName","hasReferenceSequence","getResiduesByName","max","indexEntry","_fetchFromIndexEntry","position","readlen","read","replace","BgzipIndexedFasta","gzi","gziPath","super","filehandle","gziFilehandle","BgzipFastaAdapter","gziLocation","fastaOpts"],"sourceRoot":""}