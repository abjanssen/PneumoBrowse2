"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[9718],{89718(e,t,r){function i(e){try{return decodeURIComponent(e)}catch(t){return e}}r.d(t,{Ay:()=>p,An:()=>m});class n{constructor(e,t,r,i,n){let o=0,s=0;for(;o<e.length&&s<9;)"\t"===e[o]&&(s+=1),o+=1;const a=9===s?o-1:o,l=e.slice(0,a).split("\t"),c=e.slice(a+1),[p,h,u,m,f,d,D]=l,b="."===D?void 0:D.split(";");if(n&&!l[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");this.CHROM=p,this.POS=+h,this.ID="."===u?void 0:u.split(";"),this.REF=m,this.ALT="."===f?void 0:f.split(","),this.QUAL="."===d?void 0:+d,this.FILTER=1===b?.length&&"PASS"===b[0]?"PASS":b,this.INFO=void 0===l[7]||"."===l[7]?{}:this.parseInfo(l[7],t),this.FORMAT=l[8],this.formatMeta=r,this.rest=c,this.sampleNames=i}parseInfo(e,t){const r={},n=e.includes("%"),o=e.split(";"),s=o.length;for(let e=0;e<s;e++){const s=o[e],a=s.indexOf("="),l=-1===a?s:s.slice(0,a),c=-1===a?void 0:s.slice(a+1),p=t[l]?.Type;if("Flag"===p)r[l]=!0;else if(c){const e="Integer"===p||"Float"===p,t=c.split(","),o=t.length;if(n){const n=[];for(let r=0;r<o;r++){const o=t[r];if("."===o)n.push(void 0);else{const t=i(o);n.push(e?Number(t):t)}}r[l]=n}else{const i=[];for(let r=0;r<o;r++){const n=t[r];"."===n?i.push(void 0):i.push(e?Number(n):n)}r[l]=i}}else r[l]=!0}return r}SAMPLES(){const e={},t=this.FORMAT;if(t){const r=this.rest.split("\t"),i=t.split(":"),n=[];for(let e=0;e<i.length;e++){const t=this.formatMeta[i[e]]?.Type;n.push("Integer"===t||"Float"===t)}const o=i.length,s=this.sampleNames.length;for(let t=0;t<s;t++){const s=this.sampleNames[t],a={},l=r[t],c=l.length;let p=0,h=0;for(let e=0;e<=c;e++)if(e===c||":"===l[e]){const t=l.slice(p,e);if(""===t||"."===t)a[i[h]]=void 0;else{const e=t.split(","),r=[];if(n[h])for(let t=0;t<e.length;t++){const i=e[t];r.push("."===i?void 0:+i)}else for(let t=0;t<e.length;t++){const i=e[t];r.push("."===i?void 0:i)}a[i[h]]=r}if(p=e+1,h+=1,h>=o)break}e[s]=a}}return e}GENOTYPES(){return function(e,t,r){const i=Object.create(null),n=r.length,o=t.length;let s=0;if("GT"===e){for(let e=0;e<n;e++){const n=s;for(;s<o&&9!==t.charCodeAt(s);)s++;i[r[e]]=t.slice(n,s),s++}return i}const a=e.indexOf("GT");if(-1===a)return i;if(0===a){for(let e=0;e<n;e++){const n=s;for(;s<o&&58!==t.charCodeAt(s)&&9!==t.charCodeAt(s);)s++;for(i[r[e]]=t.slice(n,s);s<o&&9!==t.charCodeAt(s);)s++;s++}return i}let l=0;for(let t=0;t<a;t++)58===e.charCodeAt(t)&&l++;for(let e=0;e<n;e++){const n=s;let a=s;for(;a<o&&9!==t.charCodeAt(a);)a++;let c=0,p=n;for(let o=n;o<=a;o++)if(o===a||58===t.charCodeAt(o)){if(c===l){i[r[e]]=t.slice(p,o);break}c++,p=o+1}s=a+1}return i}(this.FORMAT??"",this.rest,this.sampleNames)}processGenotypes(e){!function(e,t,r,i){const n=t.length;let o=0;if("GT"===e){for(let e=0;e<r;e++){const e=o;for(;o<n&&9!==t.charCodeAt(o);)o++;i(t,e,o),o++}return}const s=e.indexOf("GT");if(-1===s)return;if(0===s){for(let e=0;e<r;e++){const e=o;for(;o<n&&58!==t.charCodeAt(o)&&9!==t.charCodeAt(o);)o++;for(i(t,e,o);o<n&&9!==t.charCodeAt(o);)o++;o++}return}let a=0;for(let t=0;t<s;t++)58===e.charCodeAt(t)&&a++;for(let e=0;e<r;e++){const e=o;let r=o;for(;r<n&&9!==t.charCodeAt(r);)r++;let s=0,l=e;for(let n=e;n<=r;n++)if(n===r||58===t.charCodeAt(n)){if(s===a){i(t,l,n);break}s++,l=n+1}o=r+1}}(this.FORMAT??"",this.rest,this.sampleNames.length,e)}toJSON(){return{CHROM:this.CHROM,POS:this.POS,ID:this.ID,REF:this.REF,ALT:this.ALT,QUAL:this.QUAL,FILTER:this.FILTER,INFO:this.INFO,FORMAT:this.FORMAT}}}function o(e,t){const r=e.indexOf(t);return[e.slice(0,r),e.slice(r+1)]}const s={AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},a={AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},l={DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},c={PASS:{Description:"Passed all filters"}};class p{constructor({header:e,strict:t=!0}){if(!e.length)throw new Error("empty header received");const r=e.split(/[\r\n]+/).filter(Boolean);if(!r.length)throw new Error("no non-empty header lines specified");let i;this.strict=t,this.metadata={INFO:{...s},FORMAT:{...a},ALT:{...l},FILTER:{...c}};for(let e=0;e<r.length;e++){const t=r[e];if(!t.startsWith("#"))throw new Error(`Bad line in header:\n${t}`);t.startsWith("##")?this.parseMetadata(t):i=t}if(!i)throw new Error("No format line found in header");const n=i.trim().split("\t"),o=n.slice(0,8),p=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(n.length<8)throw new Error(`VCF header missing columns:\n${i}`);if(o.length!==p.length||!o.every((e,t)=>e===p[t]))throw new Error(`VCF column headers not correct:\n${i}`);this.samples=n.slice(9)}parseMetadata(e){const t=/^##(.+?)=(.*)/.exec(e.trim());if(!t)throw new Error(`Line is not a valid metadata line: ${e}`);const[r,i]=t.slice(1,3),n=r;if(i?.startsWith("<")){n in this.metadata||(this.metadata[n]={});const[e,t]=this.parseStructuredMetaVal(i);e?this.metadata[n][e]=t:this.metadata[n]=t}else this.metadata[n]=i}parseStructuredMetaVal(e){const t=function(e){const t=function(e){const t=[],r=[];let i=!1,n=!1;const o=e.length;for(let s=0;s<o;s++){const o=e[s];'"'===o?(i=!i,r.push(o)):"["===o?(n=!0,r.push(o)):"]"===o?(n=!1,r.push(o)):","!==o||i||n?r.push(o):(t.push(r.join("").trim()),r.length=0)}return r.length>0&&t.push(r.join("").trim()),t}(e.slice(1,-1)),r=[];for(let e=0;e<t.length;e++){const i=t[e],[n,s]=o(i,"=");if(s&&s.startsWith("[")&&s.endsWith("]")){const e=s.slice(1,-1).split(",");for(let t=0;t<e.length;t++)e[t]=e[t].trim();r.push([n,e])}else s&&s.startsWith('"')&&s.endsWith('"')?r.push([n,s.slice(1,-1)]):r.push([n,s])}return Object.fromEntries(r)}(e),r=t.ID;return delete t.ID,"Number"in t&&(Number.isNaN(Number(t.Number))||(t.Number=Number(t.Number))),[r,t]}getMetadata(...e){let t=this.metadata;const r=e.length;for(let i=0;i<r;i++)if(t=t[e[i]],!t)return t;return t}parseLine(e){return new n(e,this.metadata.INFO,this.metadata.FORMAT,this.samples,this.strict)}}const h=/<(.*)>(.*)/,u=/(.*)<(.*)>/;function m(e){const t=e[0],r=e[e.length-1];if("["===t||"]"===t||"["===r||"]"===r){const t=e.split(/[[\]]/),r=e.includes("[")?"right":"left";let i,n,o;const s=t.length;for(let e=0;e<s;e++){const r=t[e];r&&(r.includes(":")?(o=r,i=n?"right":"left"):n=r)}if(!(o&&i&&n))throw new Error(`Invalid breakend: ${e}`);return{MatePosition:o,Join:i,Replacement:n,MateDirection:r}}if("."===t)return{Join:"left",SingleBreakend:!0,Replacement:e.slice(1)};if("."===r)return{Join:"right",SingleBreakend:!0,Replacement:e.slice(0,-1)};if("<"===t){const t=h.exec(e);if(!t)throw new Error(`failed to parse ${e}`);const r=t[2];return r?{Join:"left",Replacement:r,MateDirection:"right",MatePosition:`<${t[1]}>:1`}:void 0}if(e.includes("<")){const t=u.exec(e);if(!t)throw new Error(`failed to parse ${e}`);const r=t[1];return r?{Join:"right",Replacement:r,MateDirection:"right",MatePosition:`<${t[2]}>:1`}:void 0}}}}]);
//# sourceMappingURL=9718.a3f82ef8.chunk.js.map