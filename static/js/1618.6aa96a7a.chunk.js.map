{"version":3,"file":"static/js/1618.6aa96a7a.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/wiggle/src/XYPlotRenderer/renderXYPlot.ts","webpack://@jbrowse/web/../../plugins/wiggle/src/drawXY.ts"],"sourcesContent":["import { renderToAbstractCanvas, updateStatus } from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\n\nimport { drawXY } from '../drawXY.ts'\nimport { getColorCallback, serializeWiggleFeature } from '../util.ts'\n\nimport type { RenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderXYPlot(\n  renderProps: RenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    config,\n    height,\n    regions,\n    bpPerPx,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const colorCallback = getColorCallback(config)\n\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx =>\n        drawXY(ctx, {\n          ...renderProps,\n          colorCallback,\n          features,\n        }),\n      ),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { fillRectCtx, getOrigin, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, Region } from '@jbrowse/core/util'\nimport type { Colord } from '@jbrowse/core/util/colord'\nimport type {\n  LastStopTokenCheck,\n  StopToken,\n} from '@jbrowse/core/util/stopToken'\n\nfunction lighten(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 + amount)\n  return colord({\n    ...hslColor,\n    l: clamp(l, 0, 100),\n  })\n}\n\nfunction darken(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 - amount)\n  return colord({\n    ...hslColor,\n    l: clamp(l, 0, 100),\n  })\n}\n\nconst fudgeFactor = 0.3\nconst clipHeight = 2\n\nexport function drawXY(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    bpPerPx: number\n    regions: Region[]\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    config: AnyConfigurationModel\n    displayCrossHatches: boolean\n    inverted: boolean\n    offset?: number\n    lastCheck?: LastStopTokenCheck\n    stopToken?: StopToken\n    colorCallback: (f: Feature, score: number) => string\n  },\n) {\n  const {\n    features,\n    bpPerPx,\n    regions,\n    scaleOpts,\n    height: unadjustedHeight,\n    config,\n    ticks,\n    displayCrossHatches,\n    offset = 0,\n    colorCallback,\n    inverted,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  // Extract region values once to avoid repeated property access in hot loop\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionReversed = region.reversed\n\n  // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the\n  // wiggle display, and makes the height of the actual drawn area add\n  // \"padding\" to the top and bottom of the display\n  const height = unadjustedHeight - offset * 2\n\n  const filled = readConfObject(config, 'filled')\n  const clipColor = readConfObject(config, 'clipColor')\n  const summaryScoreMode = readConfObject(config, 'summaryScoreMode')\n  const pivotValue = readConfObject(config, 'bicolorPivotValue')\n  const minSize = readConfObject(config, 'minSize')\n\n  const scale = getScale({ ...scaleOpts, range: [0, height], inverted })\n  const originY = getOrigin(scaleOpts.scaleType)\n  const domain = scale.domain()\n  const niceMin = domain[0]!\n  const niceMax = domain[1]!\n\n  // Precompute scale values for fast toY calculation\n  const isLog = scaleOpts.scaleType === 'log'\n  const log2 = Math.log(2)\n  const domainSpan = niceMax - niceMin\n  const linearRatio = domainSpan !== 0 ? height / domainSpan : 0\n  const logMin = isLog ? Math.log(niceMin) / log2 : 0\n  const logMax = isLog ? Math.log(niceMax) / log2 : 0\n  const logSpan = logMax - logMin\n  const logRatio = logSpan !== 0 ? height / logSpan : 0\n  const effectiveRange = inverted ? [height, 0] : [0, height]\n  const rangeFlipped = effectiveRange[0] === height\n\n  // Inlined toY - avoids d3-scale function call overhead\n  const toY = isLog\n    ? (n: number) => {\n        const logVal = Math.log(n) / log2\n        const scaled = (logVal - logMin) * logRatio\n        const result = rangeFlipped ? scaled : height - scaled\n        return clamp(result, 0, height) + offset\n      }\n    : (n: number) => {\n        const scaled = (n - niceMin) * linearRatio\n        const result = rangeFlipped ? scaled : height - scaled\n        return clamp(result, 0, height) + offset\n      }\n\n  const toOrigin = (n: number) => toY(originY) - toY(n)\n  const getHeight = (n: number) => (filled ? toOrigin(n) : Math.max(minSize, 1))\n\n  // Precompute for inline px calculation (avoids featureSpanPx function call overhead)\n  const inverseBpPerPx = 1 / bpPerPx\n\n  let hasClipping = false\n\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n  const crossingOrigin = niceMin < pivotValue && niceMax > pivotValue\n\n  // we handle whiskers separately to render max row, min row, and avg in three\n  // passes. this reduces subpixel rendering issues. note: for stylistic\n  // reasons, clipping indicator is only drawn for score, not min/max score\n  if (summaryScoreMode === 'whiskers') {\n    let lastCol: string | undefined\n    let lastMix: string | undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      if (feature.get('summary')) {\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const max = feature.get('maxScore')\n        const c = colorCallback(feature, max)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = lighten(colord(c), 0.4).toHex())\n        fillRectCtx(leftPx, toY(max), w, getHeight(max), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n    lastMix = undefined\n    lastCol = undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const score = feature.get('score')\n      const max = feature.get('maxScore')\n      const min = feature.get('minScore')\n      const summary = feature.get('summary')\n      const c = colorCallback(feature, score)\n      const effectiveC =\n        crossingOrigin && summary\n          ? c === lastCol\n            ? lastMix\n            : (lastMix = colord(colorCallback(feature, max))\n                .mix(colord(colorCallback(feature, min)))\n                .toString())\n          : c\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n      if (\n        Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n        rightPx - leftPx > 1\n      ) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, effectiveC)\n      lastCol = c\n    }\n    lastMix = undefined\n    lastCol = undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n\n      if (feature.get('summary')) {\n        const min = feature.get('minScore')\n        const c = colorCallback(feature, min)\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = darken(colord(c), 0.4).toHex())\n\n        fillRectCtx(leftPx, toY(min), w, getHeight(min), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n  } else {\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      if (\n        Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n        rightPx - leftPx > 1\n      ) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n\n      const score = feature.get('score')\n      const c = colorCallback(feature, score)\n\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n\n      if (summaryScoreMode === 'max') {\n        const s = feature.get('summary') ? feature.get('maxScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else if (summaryScoreMode === 'min') {\n        const s = feature.get('summary') ? feature.get('minScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else {\n        fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, c)\n      }\n    }\n  }\n\n  // second pass: draw clipping\n  // avoid persisting the red fillstyle with save/restore\n  ctx.save()\n  if (hasClipping) {\n    ctx.fillStyle = clipColor\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const w = rightPx - leftPx + fudgeFactor\n      const score = feature.get('score')\n      if (score > niceMax) {\n        fillRectCtx(leftPx, offset, w, clipHeight, ctx)\n      } else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n        fillRectCtx(leftPx, unadjustedHeight, w, clipHeight, ctx)\n      }\n    }\n  }\n  ctx.restore()\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    for (const tick of ticks.values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n\n  return {\n    reducedFeatures,\n  }\n}\n"],"names":["async","renderXYPlot","renderProps","features","config","height","regions","bpPerPx","statusCallback","region","width","end","start","colorCallback","getColorCallback","reducedFeatures","rest","updateStatus","renderToAbstractCanvas","ctx","drawXY","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables","lighten","color","amount","hslColor","toHsl","l","colord","clamp","darken","fudgeFactor","props","scaleOpts","unadjustedHeight","ticks","displayCrossHatches","offset","inverted","stopToken","lastCheck","createStopTokenChecker","regionStart","regionEnd","regionReversed","reversed","filled","readConfObject","clipColor","summaryScoreMode","pivotValue","minSize","scale","getScale","range","originY","getOrigin","scaleType","domain","niceMin","niceMax","isLog","log2","Math","log","domainSpan","linearRatio","logMin","logSpan","logRatio","rangeFlipped","toY","n","scaled","result","getHeight","toOrigin","max","inverseBpPerPx","hasClipping","prevLeftPx","Number","NEGATIVE_INFINITY","crossingOrigin","lastCol","lastMix","feature","values","checkStopToken2","fStart","get","fEnd","leftPx","rightPx","w","c","effectiveC","toHex","fillRectCtx","undefined","score","min","summary","mix","toString","floor","push","s","save","fillStyle","restore","lineWidth","strokeStyle","tick","beginPath","moveTo","round","lineTo","stroke"],"sourceRoot":""}