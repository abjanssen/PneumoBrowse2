{"version":3,"file":"static/js/8965.904b6fe3.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/MCScanAnchorsAdapter/MCScanAnchorsAdapter.ts","../../../plugins/comparative-adapters/src/util.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport {\n  doesIntersect2,\n  SimpleFeature,\n  Feature,\n  Region,\n} from '@jbrowse/core/util'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { readFile, parseBed } from '../util'\n\ninterface BareFeature {\n  strand: number\n  refName: string\n  start: number\n  end: number\n  score: number\n  name: string\n}\n\ntype Row = [BareFeature, BareFeature, number, number]\n\nexport default class MCScanAnchorsAdapter extends BaseFeatureDataAdapter {\n  private setupP?: Promise<{\n    assemblyNames: string[]\n    feats: Row[]\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  async setup(opts: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n  async setupPre(opts: BaseOptions) {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n\n    const pm = this.pluginManager\n    const bed1 = openLocation(this.getConf('bed1Location'), pm)\n    const bed2 = openLocation(this.getConf('bed2Location'), pm)\n    const mcscan = openLocation(this.getConf('mcscanAnchorsLocation'), pm)\n    const [bed1text, bed2text, mcscantext] = await Promise.all(\n      [bed1, bed2, mcscan].map(r => readFile(r, opts)),\n    )\n\n    const bed1Map = parseBed(bed1text!)\n    const bed2Map = parseBed(bed2text!)\n    const feats = mcscantext!\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f && f !== '###')\n      .map((line, index) => {\n        const [name1, name2, score] = line.split('\\t')\n        const r1 = bed1Map.get(name1)\n        const r2 = bed2Map.get(name2)\n        if (!r1 || !r2) {\n          throw new Error(`feature not found, ${name1} ${name2} ${r1} ${r2}`)\n        }\n        return [r1, r2, +score!, index] as Row\n      })\n\n    return {\n      assemblyNames,\n      feats,\n    }\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures so is not\n    // really that important, and has to be true or else getFeatures is never\n    // called (BaseFeatureDataAdapter filters it out)\n    return true\n  }\n\n  getAssemblyNames() {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    return assemblyNames\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    // @ts-expect-error\n    const r1 = opts.regions?.[0].assemblyName\n    const { feats } = await this.setup(opts)\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    if (idx !== -1) {\n      const set = new Set<string>()\n      for (const feat of feats) {\n        set.add(idx === 0 ? feat[0].refName : feat[1].refName)\n      }\n      return [...set]\n    }\n    console.warn('Unable to do ref renaming on adapter')\n    return []\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { assemblyNames, feats } = await this.setup(opts)\n\n      // The index of the assembly name in the region list corresponds to\n      // the adapter in the subadapters list\n      const index = assemblyNames.indexOf(region.assemblyName)\n      if (index !== -1) {\n        const flip = index === 0\n        feats.forEach(f => {\n          const [r1, r2, score, rowNum] = f\n          const [f1, f2] = !flip ? [r2, r1] : [r1, r2]\n          if (\n            f1.refName === region.refName &&\n            doesIntersect2(region.start, region.end, f1.start, f1.end)\n          ) {\n            observer.next(\n              new SimpleFeature({\n                ...f1,\n                uniqueId: `${index}-${rowNum}`,\n                syntenyId: rowNum,\n\n                // note: strand would be -1 if the two features are on opposite\n                // strands, indicating inverted alignment\n                strand: f1.strand * f2.strand,\n                assemblyName: assemblyNames[+!flip],\n                score,\n                mate: {\n                  ...f2,\n                  assemblyName: assemblyNames[+flip],\n                },\n              }),\n            )\n          }\n        })\n      }\n\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n  freeResources(/* { region } */): void {}\n}\n","import { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport { fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport type { Buffer } from 'buffer'\n\nimport { PAFRecord } from './PAFAdapter/util'\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f || f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start!,\n            end: +end!,\n            score: +score!,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  const buf = await fetchAndMaybeUnzip(file, opts)\n  const decoder = new TextDecoder('utf8')\n  return decoder.decode(buf)\n}\n\nexport function zip(a: number[], b: number[]) {\n  return a.map((e, i) => [e, b[i]] as [number, number])\n}\n\nexport function parseLineByLine<T>(\n  buffer: Buffer,\n  cb: (line: string) => T | undefined,\n): T[] {\n  let blockStart = 0\n  const entries: T[] = []\n  const decoder = new TextDecoder('utf8')\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf('\\n', blockStart)\n    if (n === -1) {\n      break\n    }\n    const b = buffer.subarray(blockStart, n)\n    const line = decoder.decode(b).trim()\n    if (line) {\n      const entry = cb(line)\n      if (entry) {\n        entries.push(entry)\n      }\n    }\n\n    blockStart = n + 1\n  }\n  return entries\n}\n\nexport function parsePAFLine(line: string) {\n  const [\n    qname,\n    ,\n    qstart,\n    qend,\n    strand,\n    tname,\n    ,\n    tstart,\n    tend,\n    numMatches,\n    blockLen,\n    mappingQual,\n    ...fields\n  ] = line.split('\\t')\n\n  const rest = Object.fromEntries(\n    fields.map(field => {\n      const r = field.indexOf(':')\n      const fieldName = field.slice(0, r)\n      const fieldValue = field.slice(r + 3)\n      return [fieldName, fieldValue]\n    }),\n  )\n\n  return {\n    tname,\n    tstart: +tstart!,\n    tend: +tend!,\n    qname,\n    qstart: +qstart!,\n    qend: +qend!,\n    strand: strand === '-' ? -1 : 1,\n    extra: {\n      numMatches: +numMatches!,\n      blockLen: +blockLen!,\n      mappingQual: +mappingQual!,\n      ...rest,\n    },\n  } as PAFRecord\n}\n\nexport function flipCigar(cigar: string[]) {\n  const arr = []\n  for (let i = cigar.length - 2; i >= 0; i -= 2) {\n    arr.push(cigar[i])\n    const op = cigar[i + 1]\n    if (op === 'D') {\n      arr.push('I')\n    } else if (op === 'I') {\n      arr.push('D')\n    } else {\n      arr.push(op)\n    }\n  }\n  return arr\n}\n\nexport function swapIndelCigar(cigar: string) {\n  return cigar.replaceAll('D', 'K').replaceAll('I', 'D').replaceAll('K', 'I')\n}\n"],"names":["MCScanAnchorsAdapter","BaseFeatureDataAdapter","setup","opts","this","setupP","setupPre","catch","e","undefined","assemblyNames","getConf","pm","pluginManager","bed1","openLocation","bed2","mcscan","bed1text","bed2text","mcscantext","Promise","all","map","r","readFile","bed1Map","parseBed","bed2Map","feats","split","filter","f","line","index","name1","name2","score","r1","get","r2","Error","hasDataForRefName","getAssemblyNames","getRefNames","regions","assemblyName","idx","indexOf","set","Set","feat","add","refName","console","warn","getFeatures","region","ObservableCreate","async","flip","forEach","rowNum","f1","f2","doesIntersect2","start","end","observer","next","SimpleFeature","uniqueId","syntenyId","strand","mate","complete","freeResources","text","Map","startsWith","name","file","buf","fetchAndMaybeUnzip","TextDecoder","decode","zip","a","b","i","parseLineByLine","buffer","cb","blockStart","entries","decoder","length","n","subarray","trim","entry","push","parsePAFLine","qname","qstart","qend","tname","tstart","tend","numMatches","blockLen","mappingQual","fields","extra","Object","fromEntries","field","slice","flipCigar","cigar","arr","op","swapIndelCigar","replaceAll"],"sourceRoot":""}