{"version":3,"file":"static/js/8510.9ce4ecba.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../packages/core/src/util/parseLineByLine.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/gtf-nostream@1.3.4/node_modules/gtf-nostream/src/util.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/gtf-nostream@1.3.4/node_modules/gtf-nostream/src/parse.ts","webpack://@jbrowse/web/../../plugins/gtf/src/util.ts","webpack://@jbrowse/web/../../plugins/gtf/src/GtfAdapter/GtfAdapter.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/gtf-nostream@1.3.4/node_modules/gtf-nostream/src/api.ts"],"sourcesContent":["import { getProgressDisplayStr } from './index.ts'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n","//@ts-nocheck\n/** @module util */\n\n// Forks @gmod/gff-js and adapts it to parse and format GTF.\n\nconst fieldNames = [\n  'seq_name',\n  'source',\n  'featureType',\n  'start',\n  'end',\n  'score',\n  'strand',\n  'frame',\n  'attributes',\n]\n\n// TODO: check about enconding/escaping in gtf 9th column\n/**\n * Unescape a string/text value used in a GTF attribute.\n * Textual attributes should be surrounded by double quotes\n * source info:\n * https://mblab.wustl.edu/GTF22.html\n * https://en.wikipedia.org/wiki/Gene_transfer_format\n *\n * @param {String} s\n * @returns {String}\n */\nexport function unescape(s) {\n  if (s === null) {\n    return null\n  }\n  return String(s).replace(/%([0-9A-Fa-f]{2})/g, (_, seq) =>\n    String.fromCharCode(parseInt(seq, 16)),\n  )\n}\n\n/**\n * Escape a value for use in a GTF attribute value.\n *\n * @param {String} s\n * @returns {String}\n */\nfunction _escape(regex, s) {\n  return String(s).replace(regex, ch => {\n    let hex = ch.charCodeAt(0).toString(16).toUpperCase()\n\n    // lol, apparently there's no native function for fixed-width hex output\n    if (hex.length < 2) {\n      hex = `0${hex}`\n    }\n    return `%${hex}`\n  })\n}\n\nexport function escape(s) {\n  // eslint-disable-next-line no-control-regex\n  return _escape(/[\\n;\\r\\t=%&,\\x00-\\x1f\\x7f-\\xff]/g, s)\n}\n\n/**\n * Escape a value for use in a GTF column value.\n *\n * @param {String} s\n * @returns {String}\n */\nexport function escapeColumn(s) {\n  // eslint-disable-next-line no-control-regex\n  return _escape(/[\\n\\r\\t%\\x00-\\x1f\\x7f-\\xff]/g, s)\n}\n\n/**\n * Parse the 9th column (attributes) of a GTF feature line.\n *\n * @param {String} attrString\n * @returns {Object}\n */\nexport function parseAttributes(attrString) {\n  if (!(attrString && attrString.length) || attrString === '.') {\n    return {}\n  }\n\n  const attrs = {}\n\n  attrString\n    .replace(/\\r?\\n$/, '')\n    .slice(0, -1) // need to remove the last semicolon in the attributes\n    .split(';')\n    .forEach(attribute => {\n      if (!attribute) {\n        return\n      }\n      const attr = attribute.trim().split(' ')\n      if (!(attr[1] && attr[1].length)) {\n        return\n      }\n\n      attr[0] = attr[0].trim()\n      let arec = attrs[attr[0].trim()]\n      if (!arec) {\n        arec = []\n        attrs[attr[0]] = arec\n      }\n\n      // arec.push(unescape(attr[1].trim()))\n      arec.push(\n        ...attr[1]\n          .split(',')\n          .map(s => s.trim())\n          .map(unescape),\n      )\n    })\n  return attrs\n}\n\n/**\n * Parse a GTF feature line.\n *\n * @param {String} line\n * returns the parsed line in an object\n */\nexport function parseFeature(line) {\n  // assumed that there are no comments at the end of a line\n  // split the line into columns and replace '.' with null in each column\n  const f = line.split('\\t').map(a => (a === '.' ? null : a))\n\n  // unescape only the seq_name, source, and feature columns\n  f[0] = unescape(f[0])\n  f[1] = unescape(f[1])\n  f[2] = unescape(f[2])\n\n  f[8] = parseAttributes(f[8])\n  const parsed = {}\n  for (let i = 0; i < fieldNames.length; i += 1) {\n    parsed[fieldNames[i]] = f[i] === '.' ? null : f[i]\n  }\n  if (parsed.start !== null) {\n    parsed.start = parseInt(parsed.start, 10)\n  }\n  if (parsed.end !== null) {\n    parsed.end = parseInt(parsed.end, 10)\n  }\n  if (parsed.score !== null) {\n    parsed.score = parseFloat(parsed.score, 10)\n  }\n  if (parsed.strand != null) {\n    parsed.strand = parsed.strand\n  }\n  return parsed\n}\n\n/**\n * Parse a GTF directive/comment line.\n *\n * @param {String} line\n * @returns {Object} the information in the directive\n */\nexport function parseDirective(line) {\n  const match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line)\n  // const match = /^\\s*\\#\\#\\s*(\\S+)\\s*(.*)/.exec(line)\n  if (!match) {\n    return null\n  }\n\n  // let [, name, contents] = match\n  const name = match[1]\n  let contents = match[2]\n  const parsed = { directive: name }\n  if (contents.length) {\n    contents = contents.replace(/\\r?\\n$/, '')\n    parsed.value = contents\n  }\n\n  // do a little additional parsing for sequence-region and genome-build directives\n  if (name === 'sequence-region') {\n    const [seqId, contentStart, contentEnd] = contents.split(/\\s+/, 3)\n    parsed.seq_id = seqId\n    parsed.start = contentStart && contentStart.replace(/\\D/g, '')\n    parsed.end = contentEnd && contentEnd.replace(/\\D/g, '')\n  } else if (name === 'genome-build') {\n    const [source, buildname] = contents.split(/\\s+/, 2)\n    parsed.source = source\n    parsed.buildname = buildname\n  }\n\n  return parsed\n}\n\n/**\n * Format an attributes object into a string suitable for the 9th column of GTF.\n *\n * @param {Object} attrs\n */\nexport function formatAttributes(attrs) {\n  const attrOrder = []\n  Object.keys(attrs).forEach(tag => {\n    const val = attrs[tag]\n    let valstring\n    // eslint-disable-next-line no-prototype-builtins\n    if (val.hasOwnProperty('toString')) {\n      valstring = escape(val.toString())\n    } else if (Array.isArray(val.values)) {\n      valstring = val.values.map(escape).join(',')\n    } else if (Array.isArray(val)) {\n      valstring = val.map(escape).join(',')\n    } else {\n      valstring = escape(val)\n    }\n    attrOrder.push(`${escape(tag)} ${valstring}`)\n  })\n  return attrOrder.length ? attrOrder.join('; ').concat(';') : '.'\n}\n\nconst translateStrand = ['-', '.', '+']\n\nfunction _formatSingleFeature(f, seenFeature) {\n  const attrString =\n    f.attributes === null || f.attributes === undefined\n      ? '.'\n      : formatAttributes(f.attributes)\n\n  const fields = []\n  for (let i = 0; i < 8; i += 1) {\n    const val = f[fieldNames[i]]\n    // deserialize strand\n    if (i === 6) {\n      fields[i] =\n        val === null || val === undefined\n          ? '.'\n          : translateStrand[val + 1] || val\n    } else {\n      fields[i] =\n        val === null || val === undefined ? '.' : escapeColumn(String(val))\n    }\n  }\n  fields[8] = attrString\n\n  const formattedString = `${fields.join('\\t')}\\n`\n\n  // if we have already output this exact feature, skip it\n  if (seenFeature[formattedString]) {\n    return ''\n  }\n\n  // eslint-disable-next-line no-param-reassign\n  seenFeature[formattedString] = true\n  return formattedString\n}\n\nfunction _formatFeature(feature, seenFeature) {\n  if (Array.isArray(feature)) {\n    return feature.map(f => _formatFeature(f, seenFeature)).join('')\n  }\n\n  const strings = [_formatSingleFeature(feature, seenFeature)]\n  ;['child_features', 'derived_features'].forEach(multiSlot => {\n    if (feature[multiSlot]) {\n      strings.push(\n        ...feature[multiSlot].map(f => _formatFeature(f, seenFeature)),\n      )\n    }\n  })\n  return strings.join('')\n}\n\n/**\n * Format a feature object or array of\n * feature objects into one or more lines of GTF.\n *\n * @param {Object|Array[Object]} featureOrFeatures\n */\nexport function formatFeature(featureOrFeatures) {\n  const seen = {}\n  return _formatFeature(featureOrFeatures, seen)\n}\n\n/**\n * Format a directive into a line of GTF.\n *\n * @param {Object} directive\n * @returns {String}\n */\nexport function formatDirective(directive) {\n  let str = `##${directive.directive}`\n  if (directive.value) {\n    str += ` ${directive.value}`\n  }\n  str += '\\n'\n  return str\n}\n\n/**\n * Format a comment into a GTF comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param {Object} comment\n * @returns {String}\n */\nexport function formatComment(comment) {\n  return `# ${comment.comment}\\n`\n}\n\n/**\n * Format a sequence object as FASTA\n *\n * @param {Object} seq\n * @returns {String} formatted single FASTA sequence\n */\nexport function formatSequence(seq) {\n  return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\\n${\n    seq.sequence\n  }\\n`\n}\n\n/**\n * Format a directive, comment, or feature,\n * or array of such items, into one or more lines of GTF.\n *\n * @param {Object|Array} itemOrItems\n */\nexport function formatItem(itemOrItems) {\n  function formatSingleItem(item) {\n    if (item[0] || item.attributes) {\n      return formatFeature(item)\n    }\n    if (item.directive) {\n      return formatDirective(item)\n    }\n    if (item.sequence) {\n      return formatSequence(item)\n    }\n    if (item.comment) {\n      return formatComment(item)\n    }\n    return '# (invalid item found during format)\\n'\n  }\n\n  if (Array.isArray(itemOrItems)) {\n    return itemOrItems.map(item => formatSingleItem(item))\n  }\n  return formatSingleItem(itemOrItems)\n}\n","//@ts-nocheck\nimport * as GTF from './util'\n\nconst containerAttributes = {\n  Parent: 'child_features',\n  Derives_from: 'derived_features',\n}\n\nexport default class Parser {\n  constructor(args) {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    const nullFunc = () => {}\n\n    Object.assign(this, {\n      featureCallback: args.featureCallback || nullFunc,\n      endCallback: args.endCallback || nullFunc,\n      commentCallback: args.commentCallback || nullFunc,\n      errorCallback: args.errorCallback || nullFunc,\n      directiveCallback: args.directiveCallback || nullFunc,\n      sequenceCallback: args.sequenceCallback || nullFunc,\n\n      // number of lines to buffer\n      bufferSize: args.bufferSize === undefined ? 1000 : args.bufferSize,\n\n      // features that we have to keep on hand for now because they\n      // might be referenced by something else\n      _underConstructionTopLevel: [],\n      // index of the above by ID\n      _underConstructionById: {},\n\n      _completedReferences: {},\n\n      // features that reference something we have not seen yet\n      // structured as:\n      // {  'some_id' : {\n      //     'Parent' : [ orphans that have a Parent attr referencing it ],\n      //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n      //    }\n      // }\n      _underConstructionOrphans: {},\n\n      // if this is true, the parser ignores the\n      // rest of the lines in the file.\n      eof: false,\n\n      lineNumber: 0,\n    })\n  }\n\n  addLine(line) {\n    if (this.eof) {\n      // otherwise, if we are done, ignore this line\n      return\n    }\n\n    this.lineNumber += 1\n\n    if (/^\\s*[^#\\s>]/.test(line)) {\n      // feature line, most common case\n      this._bufferLine(line)\n      return\n    }\n\n    const match = /^\\s*(#+)(.*)/.exec(line)\n    if (match) {\n      // directive or comment\n      // eslint-disable-next-line prefer-const\n      let [, hashsigns, contents] = match\n\n      if (hashsigns.length === 3) {\n        // sync directive, all forward-references are resolved.\n        this._emitAllUnderConstructionFeatures()\n      } else if (hashsigns.length === 2) {\n        const directive = GTF.parseDirective(line)\n\n        this._emitItem(directive)\n      } else {\n        contents = contents.replace(/\\s*/, '')\n        this._emitItem({ comment: contents })\n      }\n    } else if (/^\\s*$/.test(line)) {\n      // blank line, do nothing\n    } else {\n      // it's a parse error\n      const errLine = line.replace(/\\r?\\n?$/g, '')\n      throw new Error(`GTF parse error.  Cannot parse '${errLine}'.`)\n    }\n  }\n\n  _emitItem(i) {\n    if (i[0]) {\n      this.featureCallback(i)\n    } else if (i.directive) {\n      this.directiveCallback(i)\n    } else if (i.comment) {\n      this.commentCallback(i)\n    }\n  }\n\n  finish() {\n    this._emitAllUnderConstructionFeatures()\n    this.endCallback()\n  }\n\n  _enforceBufferSizeLimit(additionalItemCount = 0) {\n    const _unbufferItem = item => {\n      if (\n        item?.[0]?.attributes?.ID?.[0]\n      ) {\n        const ids = item[0].attributes.ID\n        ids.forEach(id => {\n          delete this._underConstructionById[id]\n          delete this._completedReferences[id]\n        })\n        item.forEach(i => {\n          if (i.child_features) {\n            i.child_features.forEach(c => { _unbufferItem(c) })\n          }\n          if (i.derived_features) {\n            i.derived_features.forEach(d => { _unbufferItem(d) })\n          }\n        })\n      }\n    }\n\n    while (\n      this._underConstructionTopLevel.length + additionalItemCount >\n      this.bufferSize\n    ) {\n      const item = this._underConstructionTopLevel.shift()\n      this._emitItem(item)\n      _unbufferItem(item)\n    }\n  }\n\n  /**\n   * return all under-construction features, called when we know\n   * there will be no additional data to attach to them\n   * @private\n   */\n  _emitAllUnderConstructionFeatures() {\n    this._underConstructionTopLevel.forEach(this._emitItem.bind(this))\n\n    this._underConstructionTopLevel = []\n    this._underConstructionById = {}\n    this._completedReferences = {}\n\n    // if we have any orphans hanging around still, this is a\n    // problem. die with a parse error\n    if (\n      Object.values(this._underConstructionOrphans).filter(\n        entry => Object.keys(entry).length,\n      ).length\n    ) {\n      throw new Error(\n        `some features reference other features that do not exist in the file (or in the same '###' scope). ${JSON.stringify(\n          this._underConstructionOrphans,\n        )}`,\n      )\n    }\n  }\n\n  // do the right thing with a newly-parsed feature line\n  _bufferLine(line) {\n    const featureLine = GTF.parseFeature(line)\n    featureLine.child_features = []\n    featureLine.derived_features = []\n    // featureLine._lineNumber = this.lineNumber //< debugging aid\n\n    const featureNumber = this.lineNumber // no such thing as unique ID in GTF. make one up.\n    const isTranscript = featureLine.featureType === 'transcript' // trying to support the Cufflinks convention of adding a transcript line\n    // NOTE: a feature is an arrayref of one or more feature lines.\n    const ids = isTranscript\n      ? featureLine.attributes.transcript_id || []\n      : [featureNumber]\n    const parents = isTranscript\n      ? []\n      : featureLine.attributes.transcript_id || []\n    const derives = featureLine.attributes.Derives_from || []\n\n    if (!ids.length && !parents.length && !derives.length) {\n      // if it has no IDs and does not refer to anything, we can just\n      // output it\n      this._emitItem([featureLine])\n      return\n    }\n\n    function createTranscript(feature) {\n      const result = JSON.parse(JSON.stringify(feature))\n      result.featureType = 'transcript'\n      return GTF.formatFeature(result)\n    }\n\n    parents.forEach(parent => {\n      const underConst = this._underConstructionById[parent]\n      if (!underConst) {\n        this._bufferLine(createTranscript(featureLine))\n      }\n    })\n\n    let feature\n    ids.forEach(id => {\n      const existing = this._underConstructionById[id]\n      if (existing) {\n        existing.push(featureLine)\n        feature = existing\n      } else {\n        // haven't seen it yet, so buffer it so we can attach\n        // child features to it\n        feature = [featureLine]\n\n        this._enforceBufferSizeLimit(1)\n        if (!parents.length && !derives.length) {\n          this._underConstructionTopLevel.push(feature)\n        }\n        this._underConstructionById[id] = feature\n\n        // see if we have anything buffered that refers to it\n        this._resolveReferencesTo(feature, id)\n      }\n    })\n\n    // try to resolve all its references\n    this._resolveReferencesFrom(\n      feature || [featureLine],\n      { Parent: parents, Derives_from: derives },\n      ids,\n    )\n  }\n\n  _resolveReferencesTo(feature, id) {\n    const references = this._underConstructionOrphans[id]\n    if (!references) {\n      return\n    }\n\n    Object.keys(references).forEach(attrname => {\n      const pname = containerAttributes[attrname] || attrname.toLowerCase()\n      feature.forEach(loc => {\n        loc[pname].push(...references[attrname])\n        delete references[attrname]\n      })\n    })\n  }\n\n  _parseError(message) {\n    this.eof = true\n    this.errorCallback(`${this.lineNumber}: ${message}`)\n  }\n\n  _resolveReferencesFrom(feature, references, ids) {\n    // this is all a bit more awkward in javascript than it was in perl\n    function postSet(obj, slot1, slot2) {\n      let subObj = obj[slot1]\n      if (!subObj) {\n        subObj = {}\n         \n        obj[slot1] = subObj\n      }\n      const returnVal = subObj[slot2] || false\n      subObj[slot2] = true\n      return returnVal\n    }\n\n    function expandFeature(parentFeature, childFeature) {\n       \n      parentFeature[0].start = Math.min(\n        parentFeature[0].start,\n        childFeature[0].start,\n      )\n       \n      parentFeature[0].end = Math.max(parentFeature[0].end, childFeature[0].end)\n    }\n\n    Object.entries(references).forEach(([attrname, toIds]) => {\n      let pname\n      toIds.forEach(toId => {\n        const otherFeature = this._underConstructionById[toId]\n        if (otherFeature) {\n          expandFeature(otherFeature, feature)\n          if (!pname) {\n            pname = containerAttributes[attrname] || attrname.toLowerCase()\n          }\n\n          if (\n            !ids.filter(id =>\n              postSet(this._completedReferences, id, `${attrname},${toId}`),\n            ).length\n          ) {\n            otherFeature.forEach(location => {\n              location[pname].push(feature)\n            })\n          }\n        } else {\n          if (!this._underConstructionOrphans[toId]) {\n            this._underConstructionOrphans[toId] = {}\n          }\n          if (!this._underConstructionOrphans[toId][attrname]) {\n            this._underConstructionOrphans[toId][attrname] = []\n          }\n          this._underConstructionOrphans[toId][attrname].push(feature)\n        }\n      })\n    })\n  }\n}\n","export type Strand = '+' | '-' | '.' | '?'\nexport interface FeatureLoc {\n  [key: string]: unknown\n  start: number\n  end: number\n  strand: Strand\n  seq_name: string\n  child_features?: FeatureLoc[][]\n  data: unknown\n  derived_features: unknown\n  attributes: Record<string, unknown[]>\n}\n\nexport function featureData(data: FeatureLoc, id?: string) {\n  const f: Record<string, unknown> = { ...data }\n  ;(f.start as number) -= 1 // convert to interbase\n  f.strand = { '+': 1, '-': -1, '.': 0, '?': undefined }[data.strand] // convert strand\n  f.phase = Number(data.frame)\n  f.refName = data.seq_name\n  if (data.score === null) {\n    f.score = undefined\n  }\n  if (data.frame === null) {\n    f.score = undefined\n  }\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_name',\n    'score',\n    'featureType',\n    'source',\n    'frame',\n    'strand',\n  ])\n  for (const a of Object.keys(data.attributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (data.attributes[a]) {\n      let attr = data.attributes[a] as string[] | string\n      if (Array.isArray(attr) && attr.length === 1) {\n        // gtf uses double quotes for text values in the attributes column,\n        // remove them\n        attr = attr[0]!.replaceAll(/^\"|\"$/g, '')\n      }\n      f[b] = attr\n    }\n  }\n  f.refName = f.seq_name\n  f.type = f.featureType\n\n  // the SimpleFeature constructor takes care of recursively inflating subfeatures\n  if (data.child_features && data.child_features.length > 0) {\n    f.subfeatures = data.child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    )\n  }\n\n  f.child_features = undefined\n  f.data = undefined\n  f.derived_features = undefined\n  f._linehash = undefined\n  f.attributes = undefined\n  f.seq_name = undefined\n  f.featureType = undefined\n  f.frame = undefined\n\n  if (f.transcript_id) {\n    f.name = f.transcript_id\n  }\n  if (id !== undefined) {\n    f.uniqueId = id\n  }\n  return f\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  IntervalTree,\n  SimpleFeature,\n  doesIntersect2,\n  fetchAndMaybeUnzip,\n  max,\n  min,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { parseStringSync } from 'gtf-nostream'\n\nimport { featureData } from '../util.ts'\n\nimport type { FeatureLoc } from '../util.ts'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\nimport type { Region } from '@jbrowse/core/util/types'\nimport type { Observer } from 'rxjs'\n\ntype StatusCallback = (arg: string) => void\n\ntype SimpleFeat = SimpleFeatureSerialized\n\nexport default class GtfAdapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree<SimpleFeat>> = {}\n\n  gtfFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<\n      string,\n      (sc?: StatusCallback) => IntervalTree<SimpleFeat>\n    >\n  }>\n\n  private async loadDataP(opts?: BaseOptions) {\n    const loc = openLocation(this.getConf('gtfLocation'), this.pluginManager)\n    const buffer = await fetchAndMaybeUnzip(loc, opts)\n    const headerLines = [] as string[]\n    const featureMap = {} as Record<string, string>\n\n    parseLineByLine(\n      buffer,\n      line => {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else if (line.startsWith('>')) {\n          return false\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = ''\n          }\n          featureMap[refName] += `${line}\\n`\n        }\n        return true\n      },\n      opts?.statusCallback,\n    )\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing GTF data')\n            const intervalTree = new IntervalTree<SimpleFeat>()\n            for (const obj of (parseStringSync(lines) as FeatureLoc[][])\n              .flat()\n              .map((f, i) => featureData(f, `${this.id}-${refName}-${i}`))) {\n              intervalTree.insert(\n                [obj.start as number, obj.end as number],\n                obj as SimpleFeatureSerialized,\n              )\n            }\n\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header: headerLines.join('\\n'),\n      intervalTreeMap,\n    }\n  }\n\n  private async loadData(opts: BaseOptions = {}) {\n    if (!this.gtfFeatures) {\n      this.gtfFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.gtfFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gtfFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.loadData(opts)\n    return Object.keys(intervalTreeMap)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        await this.getFeaturesHelper({\n          query,\n          opts,\n          observer,\n          allowRedispatch: true,\n        })\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n\n  public async getFeaturesHelper({\n    query,\n    opts,\n    observer,\n    allowRedispatch,\n    originalQuery = query,\n  }: {\n    query: Region\n    opts: BaseOptions\n    observer: Observer<Feature>\n    allowRedispatch: boolean\n    originalQuery?: Region\n  }) {\n    const aggregateField = this.getConf('aggregateField') as string\n    const { start, end, refName } = query\n    const { intervalTreeMap } = await this.loadData(opts)\n    const feats = intervalTreeMap[refName]?.(opts.statusCallback).search([\n      start,\n      end,\n    ])\n    if (feats) {\n      if (allowRedispatch && feats.length) {\n        let minStart = Number.POSITIVE_INFINITY\n        let maxEnd = Number.NEGATIVE_INFINITY\n        let hasAnyAggregateField = false\n        for (const feat of feats) {\n          if (feat.start < minStart) {\n            minStart = feat.start\n          }\n          if (feat.end > maxEnd) {\n            maxEnd = feat.end\n          }\n          if (feat[aggregateField]) {\n            hasAnyAggregateField = true\n          }\n        }\n\n        if (\n          hasAnyAggregateField &&\n          (maxEnd > query.end || minStart < query.start)\n        ) {\n          await this.getFeaturesHelper({\n            query: {\n              ...query,\n              // re-query with 500kb added onto start and end, in order to catch\n              // gene subfeatures that may not overlap your view\n              start: minStart - 500_000,\n              end: maxEnd + 500_000,\n            },\n            opts,\n            observer,\n            allowRedispatch: false,\n            originalQuery: query,\n          })\n          return\n        }\n      }\n\n      const parentAggregation = {} as Record<string, SimpleFeatureSerialized[]>\n      for (const feat of feats) {\n        const aggr = feat[aggregateField] as string\n        if (!parentAggregation[aggr]) {\n          parentAggregation[aggr] = []\n        }\n\n        if (aggr) {\n          parentAggregation[aggr].push(feat)\n        } else {\n          observer.next(\n            new SimpleFeature({\n              id: feat.uniqueId,\n              data: feat,\n            }),\n          )\n        }\n      }\n\n      for (const [name, subfeatures] of Object.entries(parentAggregation)) {\n        const s = min(subfeatures.map(f => f.start))\n        const e = max(subfeatures.map(f => f.end))\n        if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n          const { uniqueId, strand } = subfeatures[0]!\n          observer.next(\n            new SimpleFeature({\n              id: `${uniqueId}-parent`,\n              data: {\n                type: 'gene',\n                subfeatures,\n                strand,\n                name,\n                start: s,\n                end: e,\n                refName: query.refName,\n              },\n            }),\n          )\n        }\n      }\n    }\n    observer.complete()\n  }\n}\n","import Parser from './parse'\n\nexport function parseStringSync(str: string): unknown[] {\n  if (!str) {\n    return []\n  }\n\n  const items: unknown[] = []\n\n  const parser = new Parser({\n    // @ts-expect-error\n    featureCallback: item => items.push(item),\n    // @ts-expect-error\n    errorCallback: err => {\n      throw err\n    },\n  })\n\n  for (const line of str.split(/\\r?\\n/)) {\n    parser.addLine(line)\n  }\n  parser.finish()\n\n  return items\n}\n"],"names":["parseLineByLine","buffer","lineCallback","statusCallback","decoder","TextDecoder","blockStart","i","length","n","indexOf","lineEnd","b","subarray","line","decode","trim","getProgressDisplayStr","fieldNames","unescape","s","String","replace","_","seq","fromCharCode","parseInt","_escape","regex","ch","hex","charCodeAt","toString","toUpperCase","escape","escapeColumn","translateStrand","_formatSingleFeature","f","seenFeature","attrString","attributes","undefined","attrs","attrOrder","Object","keys","forEach","tag","val","valstring","hasOwnProperty","Array","isArray","values","map","join","push","concat","formatAttributes","fields","formattedString","_formatFeature","feature","strings","multiSlot","formatFeature","featureOrFeatures","containerAttributes","Parent","Derives_from","Parser","constructor","args","nullFunc","assign","this","featureCallback","endCallback","commentCallback","errorCallback","directiveCallback","sequenceCallback","bufferSize","_underConstructionTopLevel","_underConstructionById","_completedReferences","_underConstructionOrphans","eof","lineNumber","addLine","test","_bufferLine","match","exec","hashsigns","contents","_emitAllUnderConstructionFeatures","directive","name","parsed","value","seqId","contentStart","contentEnd","split","seq_id","start","end","source","buildname","GTF","_emitItem","comment","errLine","Error","finish","_enforceBufferSizeLimit","additionalItemCount","_unbufferItem","item","_c","_b","_a","ID","id","child_features","c","derived_features","d","shift","bind","filter","entry","JSON","stringify","featureLine","a","slice","attribute","attr","arec","parseAttributes","score","parseFloat","strand","featureNumber","isTranscript","featureType","ids","transcript_id","parents","derives","parent","result","parse","createTranscript","existing","_resolveReferencesTo","_resolveReferencesFrom","references","attrname","pname","toLowerCase","loc","_parseError","message","entries","toIds","toId","otherFeature","parentFeature","childFeature","Math","min","max","obj","slot1","slot2","subObj","returnVal","postSet","location","featureData","data","phase","Number","frame","refName","seq_name","defaultFields","Set","has","replaceAll","type","subfeatures","flatMap","childLocs","childLoc","_linehash","uniqueId","GtfAdapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","loadDataP","opts","openLocation","getConf","pluginManager","fetchAndMaybeUnzip","headerLines","featureMap","startsWith","ret","intervalTreeMap","fromEntries","lines","sc","intervalTree","IntervalTree","str","items","parser","err","parseStringSync","flat","insert","header","loadData","gtfFeatures","catch","e","getRefNames","getHeader","getFeatures","query","ObservableCreate","async","getFeaturesHelper","observer","allowRedispatch","error","stopToken","originalQuery","aggregateField","feats","search","minStart","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","hasAnyAggregateField","feat","parentAggregation","aggr","next","SimpleFeature","doesIntersect2","complete"],"sourceRoot":""}