{"version":3,"file":"static/js/2947.d3373a1f.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/ModificationParser/getModPositions.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processDepth.ts","../../../plugins/alignments/src/SNPCoverageAdapter/util.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processMismatches.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processModifications.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processReferenceCpGs.ts","../../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts","../../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBins.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts","../../../plugins/alignments/src/ModificationParser/getModProbabilities.ts","../../../plugins/alignments/src/ModificationParser/getMethBins.ts"],"sourcesContent":["import { revcom } from '@jbrowse/core/util'\n\nimport { modificationRegex } from './consts'\n\nexport function getModPositions(mm: string, fseq: string, fstrand: number) {\n  const seq = fstrand === -1 ? revcom(fseq) : fseq\n  const mods = mm.split(';')\n  const result = []\n  for (const mod of mods) {\n    // Empty string\n    if (mod === '') {\n      continue\n    }\n\n    const split = mod.split(',')\n    const basemod = split[0]!\n    const matches = modificationRegex.exec(basemod)\n    if (!matches) {\n      throw new Error(`bad format for MM tag: \"${mod}\"`)\n    }\n    const [, base, strand, typestr] = matches\n\n    // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so split,\n    // and they can also be chemical codes (ChEBI) e.g. C+16061\n    const types = typestr!.split(/(\\d+|.)/)\n\n    if (strand === '-') {\n      console.warn('unsupported negative strand modifications')\n      result.push({\n        type: 'unsupported',\n        positions: [] as number[],\n        base: base!,\n        strand: strand,\n      })\n    }\n\n    // this logic based on parse_mm.pl from hts-specs\n    for (const type of types) {\n      if (type === '') {\n        continue\n      }\n      let currPos = 0\n      const positions = []\n      for (let i = 1, l = split.length; i < l; i++) {\n        let delta = +split[i]!\n        do {\n          if (base === 'N' || base === seq[currPos]) {\n            delta--\n          }\n          currPos++\n        } while (delta >= 0 && currPos < seq.length)\n        if (fstrand === -1) {\n          const pos = seq.length - currPos\n          if (pos >= 0) {\n            // avoid negative-number-positions in array, seen in #4629 cause\n            // unknown, could warrant some further investigation\n            positions.unshift(pos)\n          }\n        } else {\n          positions.push(currPos - 1)\n        }\n      }\n\n      result.push({\n        type,\n        base: base!,\n        strand: strand!,\n        positions,\n      })\n    }\n  }\n  return result\n}\n","import type { PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion } from '@jbrowse/core/util/types'\n\nexport function processDepth({\n  feature,\n  bins,\n  region,\n}: {\n  feature: Feature\n  bins: PreBaseCoverageBin[]\n  region: AugmentedRegion\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const regionLength = region.end - region.start\n  for (let j = fstart; j < fend + 1; j++) {\n    const i = j - region.start\n    if (i >= 0 && i < regionLength) {\n      if (bins[i] === undefined) {\n        bins[i] = {\n          depth: 0,\n          readsCounted: 0,\n          ref: {\n            probabilities: [],\n            entryDepth: 0,\n            '-1': 0,\n            0: 0,\n            1: 0,\n          },\n          snps: {},\n          mods: {},\n          nonmods: {},\n          delskips: {},\n          noncov: {},\n        }\n      }\n      if (j !== fend) {\n        bins[i].depth++\n        bins[i].readsCounted++\n        bins[i].ref.entryDepth++\n        bins[i].ref[fstrand]++\n      }\n    }\n  }\n}\n","import type {\n  ColorBy,\n  Mismatch,\n  PreBaseCoverageBin,\n  PreBaseCoverageBinSubtypes,\n} from '../shared/types'\n\nexport interface Opts {\n  bpPerPx?: number\n  colorBy?: ColorBy\n  stopToken?: string\n}\n\nexport function mismatchLen(mismatch: Mismatch) {\n  return !isInterbase(mismatch.type) ? mismatch.length : 1\n}\n\nexport function isInterbase(type: string) {\n  return type === 'softclip' || type === 'hardclip' || type === 'insertion'\n}\n\nexport function inc(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin[strand]++\n}\n\nexport function incWithProbabilities(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  probability: number,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin.probabilities.push(probability)\n  thisBin[strand]++\n}\n","import { inc, isInterbase, mismatchLen } from './util'\n\nimport type { Mismatch, PreBaseCoverageBin, SkipMap } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion } from '@jbrowse/core/util/types'\n\nexport function processMismatches({\n  feature,\n  region,\n  bins,\n  skipmap,\n}: {\n  region: AugmentedRegion\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  skipmap: SkipMap\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n\n  // normal SNP based coloring\n  for (const mismatch of mismatches) {\n    const mstart = fstart + mismatch.start\n    const mlen = mismatchLen(mismatch)\n    const mend = mstart + mlen\n    for (let j = mstart; j < mstart + mlen; j++) {\n      const epos = j - region.start\n      if (epos >= 0 && epos < bins.length) {\n        const bin = bins[epos]!\n        const { base, altbase, type } = mismatch\n        const interbase = isInterbase(type)\n\n        if (type === 'deletion' || type === 'skip') {\n          inc(bin, fstrand, 'delskips', type)\n          bin.depth--\n        } else if (!interbase) {\n          inc(bin, fstrand, 'snps', base)\n          bin.ref.entryDepth--\n          bin.ref[fstrand]--\n          bin.refbase = altbase\n        } else {\n          inc(bin, fstrand, 'noncov', type)\n        }\n      }\n    }\n\n    if (mismatch.type === 'skip') {\n      // for upper case XS and TS: reports the literal strand of the genomic\n      // transcript\n      const tags = feature.get('tags')\n      const xs = tags?.XS || tags?.TS\n      // for lower case ts from minimap2: genomic transcript flipped by read\n      // strand\n      const ts = tags?.ts\n      const effectiveStrand =\n        xs === '+'\n          ? 1\n          : xs === '-'\n            ? -1\n            : (ts === '+' ? 1 : xs === '-' ? -1 : 0) * fstrand\n      const hash = `${mstart}_${mend}_${effectiveStrand}`\n      if (skipmap[hash] === undefined) {\n        skipmap[hash] = {\n          feature: feature,\n          start: mstart,\n          end: mend,\n          strand: fstrand,\n          effectiveStrand,\n          score: 0,\n        }\n      }\n      skipmap[hash].score++\n    }\n  }\n}\n","import { max, sum } from '@jbrowse/core/util'\n\nimport { incWithProbabilities } from './util'\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition'\n\nimport type { ColorBy, PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport function processModifications({\n  feature,\n  colorBy,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  colorBy?: ColorBy\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const fend = feature.get('end')\n  const twoColor = colorBy?.modifications?.twoColor\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n\n  // this is a hole-y array, does not work with normal for loop\n  // eslint-disable-next-line unicorn/no-array-for-each\n  getMaxProbModAtEachPosition(feature)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      if (isolatedModification && type !== isolatedModification) {\n        return\n      }\n      const epos = pos + fstart - region.start\n      if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n        if (bins[epos] === undefined) {\n          bins[epos] = {\n            depth: 0,\n            readsCounted: 0,\n            snps: {},\n            ref: {\n              probabilities: [],\n              entryDepth: 0,\n              '-1': 0,\n              0: 0,\n              1: 0,\n            },\n            mods: {},\n            nonmods: {},\n            delskips: {},\n            noncov: {},\n          }\n        }\n\n        const s = 1 - sum(allProbs)\n        const bin = bins[epos]\n        bin.refbase = regionSequence[epos]\n        if (twoColor && s > max(allProbs)) {\n          incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s)\n        } else {\n          incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob)\n        }\n      }\n      pos++\n    },\n  )\n}\n","import { doesIntersect2 } from '@jbrowse/core/util'\n\nimport { parseCigar } from '../MismatchParser'\nimport { incWithProbabilities } from './util'\nimport { getMethBins } from '../ModificationParser/getMethBins'\n\nimport type { Mismatch, PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport function processReferenceCpGs({\n  feature,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n  const r = regionSequence.toLowerCase()\n  if (seq) {\n    const cigarOps = parseCigar(feature.get('CIGAR'))\n    const { methBins, methProbs } = getMethBins(feature, cigarOps)\n    const dels = mismatches.filter(f => f.type === 'deletion')\n\n    // methylation based coloring takes into account both reference sequence\n    // CpG detection and reads\n    for (let i = 0; i < fend - fstart; i++) {\n      const j = i + fstart\n      const l1 = r[j - region.start + 1]\n      const l2 = r[j - region.start + 2]\n      if (l1 === 'c' && l2 === 'g') {\n        const bin0 = bins[j - region.start]\n        const bin1 = bins[j - region.start + 1]\n        const b0 = methBins[i]\n        const b1 = methBins[i + 1]\n        const p0 = methProbs[i]\n        const p1 = methProbs[i + 1]\n\n        // color\n        if (\n          (b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n          (b1 && (p1 !== undefined ? p1 > 0.5 : true))\n        ) {\n          if (bin0) {\n            incWithProbabilities(bin0, fstrand, 'mods', 'cpg_meth', p0 || 0)\n            bin0.ref.entryDepth--\n            bin0.ref[fstrand]--\n          }\n          if (bin1) {\n            incWithProbabilities(bin1, fstrand, 'mods', 'cpg_meth', p1 || 0)\n            bin1.ref.entryDepth--\n            bin1.ref[fstrand]--\n          }\n        } else {\n          if (bin0) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j,\n                  j + 1,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin0,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p0 || 0),\n              )\n              bin0.ref.entryDepth--\n              bin0.ref[fstrand]--\n            }\n          }\n          if (bin1) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j + 1,\n                  j + 2,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin1,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p1 || 0),\n              )\n              bin1.ref.entryDepth--\n              bin1.ref[fstrand]--\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport { fetchSequence } from '../util'\nimport { generateCoverageBins } from './generateCoverageBins'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  protected async configure() {\n    const subadapterConfig = this.getConf('subadapter')\n    const sequenceConf = subadapterConfig.sequenceAdapter\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfig)\n\n    const sequenceAdapter = sequenceConf\n      ? await this.getSubAdapter?.(sequenceConf)\n      : undefined\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    return {\n      subadapter: dataAdapter.dataAdapter as BaseFeatureDataAdapter,\n      sequenceAdapter: sequenceAdapter?.dataAdapter as\n        | BaseFeatureDataAdapter\n        | undefined,\n    }\n  }\n\n  async fetchSequence(region: Region) {\n    const { sequenceAdapter } = await this.configure()\n    if (!sequenceAdapter) {\n      return undefined\n    }\n    return fetchSequence(region, sequenceAdapter)\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { subadapter } = await this.configure()\n      const features = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n\n      const { bins, skipmap } = await generateCoverageBins({\n        features,\n        region,\n        opts,\n        fetchSequence: (region: Region) => this.fetchSequence(region),\n      })\n\n      let index = 0\n      for (const bin of bins) {\n        // bins is a holey array\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (bin) {\n          const start = region.start + index\n          observer.next(\n            new SimpleFeature({\n              id: `${this.id}-${start}`,\n              data: {\n                score: bin.depth,\n                snpinfo: bin,\n                start,\n                end: start + 1,\n                refName: region.refName,\n              },\n            }),\n          )\n        }\n        index++\n      }\n\n      // make fake features from the coverage\n      for (const [key, skip] of Object.entries(skipmap)) {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              effectiveStrand: skip.effectiveStrand,\n            },\n          }),\n        )\n      }\n\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n}\n","import { sum } from '@jbrowse/core/util'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport { processDepth } from './processDepth'\nimport { processMismatches } from './processMismatches'\nimport { processModifications } from './processModifications'\nimport { processReferenceCpGs } from './processReferenceCpGs'\n\nimport type { Opts } from './util'\nimport type { PreBaseCoverageBin, SkipMap } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport async function generateCoverageBins({\n  fetchSequence,\n  features,\n  region,\n  opts,\n}: {\n  features: Feature[]\n  region: Region\n  opts: Opts\n  fetchSequence: (arg: Region) => Promise<string>\n}) {\n  const { stopToken, colorBy } = opts\n  const skipmap = {} as SkipMap\n  const bins = [] as PreBaseCoverageBin[]\n  const start2 = Math.max(0, region.start - 1)\n  const diff = region.start - start2\n\n  let start = performance.now()\n  for (const feature of features) {\n    if (performance.now() - start > 400) {\n      checkStopToken(stopToken)\n      start = performance.now()\n    }\n    processDepth({\n      feature,\n      bins,\n      region,\n    })\n\n    if (colorBy?.type === 'modifications') {\n      const regionSequence =\n        (await fetchSequence({\n          ...region,\n          start: start2,\n          end: region.end + 1,\n        })) || ''\n      processModifications({\n        feature,\n        colorBy,\n        bins,\n        region,\n        regionSequence: regionSequence.slice(diff),\n      })\n    } else if (colorBy?.type === 'methylation') {\n      const regionSequence =\n        (await fetchSequence({\n          ...region,\n          start: start2,\n          end: region.end + 1,\n        })) || ''\n      processReferenceCpGs({\n        feature,\n        bins,\n        region,\n        regionSequence,\n      })\n    }\n    processMismatches({ feature, skipmap, bins, region })\n  }\n\n  for (const bin of bins) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (bin) {\n      bin.mods = Object.fromEntries(\n        Object.entries(bin.mods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n      bin.nonmods = Object.fromEntries(\n        Object.entries(bin.nonmods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n    }\n  }\n\n  return {\n    bins,\n    skipmap,\n  }\n}\n","import { getNextRefPos, parseCigar } from '../MismatchParser'\nimport { getModPositions } from '../ModificationParser/getModPositions'\nimport { getModProbabilities } from '../ModificationParser/getModProbabilities'\nimport { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  cigarOps?: string[],\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const ops = cigarOps || parseCigar(feature.get('CIGAR'))\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n","import { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getModProbabilities(feature: Feature) {\n  // ML stores probabilities as array of numerics and MP is scaled phred scores\n  // https://github.com/samtools/hts-specs/pull/418/files#diff-e765c6479316309f56b636f88189cdde8c40b854c7bdcce9ee7fe87a4e76febcR596\n  //\n  // - if we have ML or Ml, it is an 8bit probability, divide by 255\n  //\n  // - if we have MP or Mp it is phred scaled ASCII, which can go up to 90 but\n  // has very high likelihood basecalls at that point, we really only care about\n  // low qual calls <20 approx\n  const m = (getTagAlt(feature, 'ML', 'Ml') as number[] | string) || []\n  if (m) {\n    const result = []\n    if (typeof m === 'string') {\n      const parts = m.split(',')\n      for (let i = 0, l = parts.length; i < l; i++) {\n        result.push(+parts[i]! / 255)\n      }\n    } else {\n      for (let i = 0, l = m.length; i < l; i++) {\n        result.push(m[i]! / 255)\n      }\n    }\n    return result\n  } else {\n    const mp = getTagAlt(feature, 'MP', 'Mp') as string | undefined\n    if (mp) {\n      const result = []\n      for (let i = 0, l = mp.length; i < l; i++) {\n        const phred = mp.charCodeAt(i) - 33\n        result.push(Math.min(1, phred / 50))\n      }\n      return result\n    }\n    return undefined\n  }\n}\n","import { getNextRefPos } from '../MismatchParser'\nimport { getModPositions } from './getModPositions'\nimport { getModProbabilities } from './getModProbabilities'\nimport { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getMethBins(feature: Feature, cigarOps: string[]) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const flen = fend - fstart\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string | undefined) || ''\n  const methBins = []\n  const hydroxyMethBins = []\n  const methProbs = []\n  const hydroxyMethProbs = []\n  const seq = feature.get('seq') as string | undefined\n  if (seq) {\n    const probabilities = getModProbabilities(feature)\n    const modifications = getModPositions(mm, seq, fstrand)\n    let probIndex = 0\n\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n        // Skip positions outside the feature bounds\n        if (ref < 0 || ref >= flen) {\n          continue\n        }\n\n        // Calculate probability index based on strand\n        const isReverseStrand = fstrand === -1\n        const idx2 =\n          probIndex + (isReverseStrand ? positions.length - 1 - idx : idx)\n        const prob = probabilities?.[idx2] || 0\n\n        // Store modification data in appropriate bins\n        if (type === 'm') {\n          methBins[ref] = 1\n          methProbs[ref] = prob\n        } else if (type === 'h') {\n          hydroxyMethBins[ref] = 1\n          hydroxyMethProbs[ref] = prob\n        }\n      }\n      probIndex += positions.length\n    }\n  }\n  return {\n    methBins,\n    hydroxyMethBins,\n    methProbs,\n    hydroxyMethProbs,\n  }\n}\n"],"names":["getModPositions","mm","fseq","fstrand","seq","revcom","mods","split","result","mod","basemod","matches","modificationRegex","exec","Error","base","strand","typestr","types","console","warn","push","type","positions","currPos","i","l","length","delta","pos","unshift","processDepth","feature","bins","region","fstart","get","fend","regionLength","end","start","j","undefined","depth","readsCounted","ref","probabilities","entryDepth","snps","nonmods","delskips","noncov","mismatchLen","mismatch","isInterbase","inc","bin","field","thisBin","incWithProbabilities","probability","processMismatches","skipmap","mismatches","mstart","mlen","mend","epos","altbase","interbase","refbase","tags","xs","XS","TS","ts","effectiveStrand","hash","score","processModifications","colorBy","regionSequence","twoColor","modifications","isolatedModification","getMaxProbModAtEachPosition","forEach","allProbs","prob","s","sum","max","processReferenceCpGs","r","toLowerCase","cigarOps","parseCigar","methBins","methProbs","getMethBins","dels","filter","f","l1","l2","bin0","bin1","b0","b1","p0","p1","some","d","doesIntersect2","SNPCoverageAdapter","BaseFeatureDataAdapter","configure","subadapterConfig","this","getConf","sequenceConf","sequenceAdapter","dataAdapter","getSubAdapter","subadapter","fetchSequence","getFeatures","opts","ObservableCreate","async","features","firstValueFrom","pipe","toArray","stopToken","start2","Math","diff","performance","now","checkStopToken","slice","Object","fromEntries","entries","map","key","val","avgProbability","generateCoverageBins","index","observer","next","SimpleFeature","id","data","snpinfo","refName","skip","complete","getMultiRegionFeatureDensityStats","regions","getRefNames","getTagAlt","ops","getModProbabilities","maxProbModForPosition","probIndex","idx","getNextRefPos","old","m","parts","mp","phred","charCodeAt","min","flen","hydroxyMethBins","hydroxyMethProbs","idx2"],"sourceRoot":""}