{"version":3,"file":"static/js/1456.75a32de9.chunk.js","mappings":"6MAKO,SAASA,EAA2CC,ICkIpD,SACLA,EACAC,IAGAC,EAAAA,EAAAA,aACEF,GACAG,EAAAA,EAAAA,SAAQC,UACN,UACQH,GACR,CAAE,MAAOI,IACHC,EAAAA,EAAAA,SAAQN,IACVA,EAAKO,SAASF,EAElB,GD1IF,CAAEG,MAAO,MC6Ib,CDlJEC,CACET,EACAI,gBE6BGA,eAA2BJ,GAChC,MAAMU,GAAYC,EAAAA,EAAAA,iBAAgBX,IAC5B,WAAEY,IAAeC,EAAAA,EAAAA,YAAWb,GAC5Bc,GAAOC,EAAAA,EAAAA,mBAAkBf,GAE/B,IACGc,EAAKE,aACNhB,EAAKiB,QACJjB,EAAKkB,6CAEN,OAGFlB,EAAKmB,YAAW,GAChB,MAAMC,QAAaR,EAAWS,KAAKX,EAAW,kBAAmB,CAC/DA,YACAY,QAASR,EAAKS,aAAaC,cAC3BC,cAAezB,EAAKyB,gBAGtBzB,EAAK0B,aAAYC,EAAAA,EAAAA,GAAOP,EAAKQ,GAAKA,EAAEC,OACpC7B,EAAKmB,YAAW,EAClB,CFlDYW,CAAY9B,IAIxB,C","sources":["../../../plugins/arc/src/LinearPairedArcDisplay/afterAttach.tsx","../../../plugins/arc/src/LinearPairedArcDisplay/util.ts","../../../plugins/arc/src/LinearPairedArcDisplay/fetchChains.ts"],"sourcesContent":["import { fetchChains } from './fetchChains.ts'\nimport { createAutorun } from './util.ts'\n\nimport type { IAnyStateTreeNode } from '@jbrowse/mobx-state-tree'\n\nexport function doAfterAttach<T extends IAnyStateTreeNode>(self: T) {\n  createAutorun(\n    self,\n    async () => {\n      await fetchChains(self)\n    },\n    { delay: 1000 },\n  )\n}\n","import { addDisposer, isAlive } from '@jbrowse/mobx-state-tree'\nimport { autorun } from 'mobx'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport type { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { AugmentedRegion, Feature } from '@jbrowse/core/util'\nimport type { IAnyStateTreeNode } from '@jbrowse/mobx-state-tree'\nimport type { IAutorunOptions } from 'mobx'\n\n// get tag from BAM or CRAM feature, where CRAM uses feature.get('tags') and\n// BAM does not\nexport function getTag(feature: Feature, tag: string) {\n  return feature.get('tags')[tag]\n}\n\n// use fallback alt tag, used in situations where upper case/lower case tags\n// exist e.g. Mm/MM for base modifications\nexport function getTagAlt(feature: Feature, tag: string, alt: string) {\n  return getTag(feature, tag) ?? getTag(feature, alt)\n}\n\n// orientation definitions from igv.js, see also\n// https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\nexport const orientationTypes = {\n  fr: {\n    F1R2: 'LR',\n    F2R1: 'LR',\n\n    F1F2: 'LL',\n    F2F1: 'LL',\n\n    R1R2: 'RR',\n    R2R1: 'RR',\n\n    R1F2: 'RL',\n    R2F1: 'RL',\n  } as Record<string, string>,\n\n  rf: {\n    R1F2: 'LR',\n    R2F1: 'LR',\n\n    R1R2: 'LL',\n    R2R1: 'LL',\n\n    F1F2: 'RR',\n    F2F1: 'RR',\n\n    F1R2: 'RL',\n    F2R1: 'RL',\n  } as Record<string, string>,\n\n  ff: {\n    F2F1: 'LR',\n    R1R2: 'LR',\n\n    F2R1: 'LL',\n    R1F2: 'LL',\n\n    R2F1: 'RR',\n    F1R2: 'RR',\n\n    R2R1: 'RL',\n    F1F2: 'RL',\n  } as Record<string, string>,\n}\n\nexport const pairMap = {\n  LR: 'color_pair_lr',\n  LL: 'color_pair_ll',\n  RR: 'color_pair_rr',\n  RL: 'color_pair_rl',\n} as const\n\nexport function getColorWGBS(strand: number, base: string) {\n  if (strand === 1) {\n    if (base === 'C') {\n      return '#f00'\n    }\n    if (base === 'T') {\n      return '#00f'\n    }\n  } else if (strand === -1) {\n    if (base === 'G') {\n      return '#f00'\n    }\n    if (base === 'A') {\n      return '#00f'\n    }\n  }\n  return '#888'\n}\n\n// fetches region sequence augmenting by +/- 1bp for CpG on either side of\n// requested region\nexport async function fetchSequence(\n  region: AugmentedRegion,\n  adapter: BaseFeatureDataAdapter,\n) {\n  const { start, end, originalRefName, refName } = region\n\n  const feats = await firstValueFrom(\n    adapter\n      .getFeatures({\n        ...region,\n        refName: originalRefName || refName,\n        end: end + 1,\n        start: Math.max(0, start - 1),\n      })\n      .pipe(toArray()),\n  )\n  return feats[0]?.get('seq')\n}\n\n// has to check underlying C-G (aka CpG) on the reference sequence\nexport function shouldFetchReferenceSequence(type?: string) {\n  return type === 'methylation'\n}\n\n// adapted from IGV\n// https://github.com/igvteam/igv/blob/e803e3af2d8c9ea049961dfd4628146bdde9a574/src/main/java/org/broad/igv/sam/mods/BaseModificationColors.java#L27\nexport const modificationColors = {\n  m: 'rgb(255,0,0)',\n  h: 'rgb(11, 132, 165)',\n  o: 'rgb(111, 78, 129)',\n  f: 'rgb(246, 200, 95)',\n  c: 'rgb(157, 216, 102)',\n  g: 'rgb(255, 160, 86)',\n  e: 'rgb(141, 221, 208)',\n  b: 'rgb(202, 71, 47)',\n} as Record<string, string>\n\ntype DisplayModel = IAnyStateTreeNode & { setError: (arg: unknown) => void }\n\nexport function createAutorun(\n  self: DisplayModel,\n  cb: () => Promise<void>,\n  opts?: IAutorunOptions,\n) {\n  addDisposer(\n    self,\n    autorun(async () => {\n      try {\n        await cb()\n      } catch (e) {\n        if (isAlive(self)) {\n          self.setError(e)\n        }\n      }\n    }, opts),\n  )\n}\nexport function randomColor() {\n  return `hsl(${Math.random() * 200}, 50%, 50%)`\n}\n","import { dedupe, getContainingView, getSession } from '@jbrowse/core/util'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\n\nimport type { LinearArcDisplayModel } from './model.ts'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface ReducedFeature {\n  name: string\n  strand: number\n  refName: string\n  start: number\n  end: number\n  id: string\n  flags: number\n  tlen: number\n  pair_orientation: string\n  next_ref?: string\n  next_pos?: number\n  clipLengthAtStartOfRead: number\n  SA?: string\n}\n\nexport interface ChainStats {\n  max: number\n  min: number\n  upper: number\n  lower: number\n}\n\nexport interface ChainData {\n  chains: ReducedFeature[][]\n  stats?: ChainStats\n}\n\nexport async function fetchChains(self: LinearArcDisplayModel) {\n  const sessionId = getRpcSessionId(self)\n  const { rpcManager } = getSession(self)\n  const view = getContainingView(self) as LGV\n\n  if (\n    !view.initialized ||\n    self.error ||\n    !self.featureDensityStatsReadyAndRegionNotTooLarge\n  ) {\n    return\n  }\n\n  self.setLoading(true)\n  const ret = (await rpcManager.call(sessionId, 'CoreGetFeatures', {\n    sessionId,\n    regions: view.staticBlocks.contentBlocks,\n    adapterConfig: self.adapterConfig,\n  })) as Feature[]\n\n  self.setFeatures(dedupe(ret, r => r.id()))\n  self.setLoading(false)\n}\n"],"names":["doAfterAttach","self","cb","addDisposer","autorun","async","e","isAlive","setError","delay","createAutorun","sessionId","getRpcSessionId","rpcManager","getSession","view","getContainingView","initialized","error","featureDensityStatsReadyAndRegionNotTooLarge","setLoading","ret","call","regions","staticBlocks","contentBlocks","adapterConfig","setFeatures","dedupe","r","id","fetchChains"],"ignoreList":[],"sourceRoot":""}