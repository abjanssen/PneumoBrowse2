{"version":3,"file":"static/js/3050.c19b193d.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/variants/src/LDRenderer/makeImageData.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/d3-scale@4.0.2/node_modules/d3-scale/src/sequential.js"],"sourcesContent":["import Flatbush from '@jbrowse/core/util/flatbush'\nimport { checkStopToken2 } from '@jbrowse/core/util/stopToken'\nimport { interpolateRgbBasis } from '@mui/x-charts-vendor/d3-interpolate'\nimport { scaleSequential } from '@mui/x-charts-vendor/d3-scale'\n\nimport type { LDFlatbushItem } from './types.ts'\nimport type { LDMatrixResult } from '../VariantRPC/getLDMatrix.ts'\nimport type { LastStopTokenCheck, Region } from '@jbrowse/core/util'\n\nexport interface MakeImageDataResult {\n  flatbush: ArrayBufferLike\n  items: LDFlatbushItem[]\n  maxScore: number\n  w: number\n}\n\nexport interface MakeImageDataProps {\n  ldData: LDMatrixResult\n  regions: Region[]\n  bpPerPx: number\n  stopTokenCheck?: LastStopTokenCheck\n  yScalar: number\n  colorScheme?: string\n  useGenomicPositions?: boolean\n  signedLD?: boolean\n}\n\n// Color schemes for different LD metrics\nconst colorSchemes = {\n  // Red scale for R² (traditional LD plot colors) - 0 to 1\n  r2: interpolateRgbBasis([\n    'rgb(255, 255, 255)',\n    'rgb(255, 224, 224)',\n    'rgb(255, 192, 192)',\n    'rgb(255, 128, 128)',\n    'rgb(255, 64, 64)',\n    'rgb(255, 0, 0)',\n    'rgb(208, 0, 0)',\n    'rgb(160, 0, 0)',\n  ]),\n  // Blue scale for D' - 0 to 1\n  dprime: interpolateRgbBasis([\n    'rgb(255, 255, 255)',\n    'rgb(224, 224, 255)',\n    'rgb(192, 192, 255)',\n    'rgb(128, 128, 255)',\n    'rgb(64, 64, 255)',\n    'rgb(0, 0, 255)',\n    'rgb(0, 0, 208)',\n    'rgb(0, 0, 160)',\n  ]),\n  // Diverging scale for signed R (correlation) - -1 to 1\n  // Blue (negative) -> White (zero) -> Red (positive)\n  rSigned: interpolateRgbBasis([\n    'rgb(0, 0, 160)',\n    'rgb(0, 0, 208)',\n    'rgb(0, 0, 255)',\n    'rgb(64, 64, 255)',\n    'rgb(128, 128, 255)',\n    'rgb(192, 192, 255)',\n    'rgb(224, 224, 255)',\n    'rgb(255, 255, 255)',\n    'rgb(255, 224, 224)',\n    'rgb(255, 192, 192)',\n    'rgb(255, 128, 128)',\n    'rgb(255, 64, 64)',\n    'rgb(255, 0, 0)',\n    'rgb(208, 0, 0)',\n    'rgb(160, 0, 0)',\n  ]),\n  // Diverging scale for signed D' - -1 to 1\n  // Green (negative) -> White (zero) -> Blue (positive)\n  dprimeSigned: interpolateRgbBasis([\n    'rgb(0, 100, 0)',\n    'rgb(0, 128, 0)',\n    'rgb(0, 160, 0)',\n    'rgb(64, 192, 64)',\n    'rgb(128, 224, 128)',\n    'rgb(192, 240, 192)',\n    'rgb(224, 248, 224)',\n    'rgb(255, 255, 255)',\n    'rgb(224, 224, 255)',\n    'rgb(192, 192, 255)',\n    'rgb(128, 128, 255)',\n    'rgb(64, 64, 255)',\n    'rgb(0, 0, 255)',\n    'rgb(0, 0, 208)',\n    'rgb(0, 0, 160)',\n  ]),\n}\n\nexport function makeImageData(\n  ctx: CanvasRenderingContext2D,\n  props: MakeImageDataProps,\n): MakeImageDataResult | undefined {\n  const {\n    ldData,\n    regions,\n    bpPerPx,\n    stopTokenCheck,\n    yScalar,\n    useGenomicPositions = false,\n    signedLD = false,\n  } = props\n\n  const { snps, ldValues, metric } = ldData\n  const n = snps.length\n\n  if (n === 0) {\n    return undefined\n  }\n\n  checkStopToken2(stopTokenCheck)\n\n  // Get the region for coordinate calculations\n  const region = regions[0]\n  if (!region) {\n    return undefined\n  }\n\n  // Select color scheme based on metric and whether signed\n  let colorInterpolator\n  if (signedLD) {\n    colorInterpolator =\n      metric === 'dprime' ? colorSchemes.dprimeSigned : colorSchemes.rSigned\n  } else {\n    colorInterpolator =\n      metric === 'dprime' ? colorSchemes.dprime : colorSchemes.r2\n  }\n  // Domain is -1 to 1 for signed, 0 to 1 for unsigned\n  const scale = scaleSequential(colorInterpolator).domain(\n    signedLD ? [-1, 1] : [0, 1],\n  )\n\n  // Calculate view width in pixels\n  const viewWidthPx = (region.end - region.start) / bpPerPx\n  const sqrt2 = Math.sqrt(2)\n\n  // Calculate uniform cell width (used when useGenomicPositions is false)\n  // After 45° rotation, n cells of width w have diagonal span of n * w * sqrt(2)\n  // We want this to equal viewWidthPx, so: w = viewWidthPx / (n * sqrt(2))\n  const uniformW = viewWidthPx / (n * sqrt2)\n\n  // Calculate genomic boundaries for each SNP (used when useGenomicPositions is true)\n  // We use midpoints between adjacent SNPs so each SNP's cell extends halfway\n  // to its neighbors, preventing extremely large cells when SNPs are far apart\n  // We divide by sqrt(2) because the canvas is rotated 45 degrees\n  const boundaries: number[] = []\n  if (useGenomicPositions) {\n    for (let i = 0; i < n; i++) {\n      const snpPos = snps[i]!.start\n      const prevPos = i > 0 ? snps[i - 1]!.start : region.start\n      // Boundary is midpoint between this SNP and the previous one\n      const boundaryPos = (prevPos + snpPos) / 2\n      const pixelPos = (boundaryPos - region.start) / bpPerPx / sqrt2\n      boundaries.push(pixelPos)\n    }\n    // Final boundary: small fixed offset past the last SNP\n    const lastSnpPos = snps[n - 1]!.start\n    const finalBoundary = lastSnpPos + 50 * bpPerPx\n    boundaries.push((finalBoundary - region.start) / bpPerPx / sqrt2)\n  }\n\n  // Apply yScalar for height adjustment (like HiC)\n  if (yScalar) {\n    ctx.scale(1, yScalar)\n  }\n  ctx.save()\n\n  // Just rotate, like HiC does\n  ctx.rotate(-Math.PI / 4)\n\n  // Build Flatbush index and items array\n  const coords: number[] = []\n  const items: LDFlatbushItem[] = []\n\n  // Draw the lower triangular matrix\n  // ldValues is stored as: [ld(1,0), ld(2,0), ld(2,1), ld(3,0), ld(3,1), ld(3,2), ...]\n  let ldIdx = 0\n\n  for (let i = 1; i < n; i++) {\n    for (let j = 0; j < i; j++) {\n      const ldVal = ldValues[ldIdx] ?? 0\n\n      // Color based on LD value\n      ctx.fillStyle = scale(ldVal)\n\n      let x: number\n      let y: number\n      let cellW: number\n      let cellH: number\n\n      if (useGenomicPositions) {\n        // Use genomic positions for cell boundaries\n        x = boundaries[j]!\n        y = boundaries[i]!\n        cellW = boundaries[j + 1]! - x\n        cellH = boundaries[i + 1]! - y\n      } else {\n        // Use uniform cell positioning\n        x = j * uniformW\n        y = i * uniformW\n        cellW = uniformW\n        cellH = uniformW\n      }\n\n      ctx.fillRect(x, y, cellW, cellH)\n\n      // Store for Flatbush (in unrotated coordinates)\n      coords.push(x, y, x + cellW, y + cellH)\n      items.push({\n        i,\n        j,\n        ldValue: ldVal,\n        snp1: snps[i]!,\n        snp2: snps[j]!,\n      })\n\n      ldIdx++\n      checkStopToken2(stopTokenCheck)\n    }\n  }\n\n  ctx.restore()\n\n  // Build Flatbush spatial index\n  const flatbush = new Flatbush(Math.max(items.length, 1))\n  if (coords.length) {\n    for (let k = 0; k < coords.length; k += 4) {\n      flatbush.add(coords[k]!, coords[k + 1]!, coords[k + 2], coords[k + 3])\n    }\n  } else {\n    flatbush.add(0, 0, 0, 0)\n  }\n  flatbush.finish()\n\n  return {\n    flatbush: flatbush.data,\n    items,\n    maxScore: signedLD ? 1 : 1, // LD values are -1 to 1 (signed) or 0 to 1 (unsigned)\n    w: uniformW, // Return uniform width for backward compatibility\n  }\n}\n","import {interpolate, interpolateRound} from \"d3-interpolate\";\nimport {identity} from \"./continuous.js\";\nimport {initInterpolator} from \"./init.js\";\nimport {linearish} from \"./linear.js\";\nimport {loggish} from \"./log.js\";\nimport {symlogish} from \"./symlog.js\";\nimport {powish} from \"./pow.js\";\n\nfunction transformer() {\n  var x0 = 0,\n      x1 = 1,\n      t0,\n      t1,\n      k10,\n      transform,\n      interpolator = identity,\n      clamp = false,\n      unknown;\n\n  function scale(x) {\n    return x == null || isNaN(x = +x) ? unknown : interpolator(k10 === 0 ? 0.5 : (x = (transform(x) - t0) * k10, clamp ? Math.max(0, Math.min(1, x)) : x));\n  }\n\n  scale.domain = function(_) {\n    return arguments.length ? ([x0, x1] = _, t0 = transform(x0 = +x0), t1 = transform(x1 = +x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0), scale) : [x0, x1];\n  };\n\n  scale.clamp = function(_) {\n    return arguments.length ? (clamp = !!_, scale) : clamp;\n  };\n\n  scale.interpolator = function(_) {\n    return arguments.length ? (interpolator = _, scale) : interpolator;\n  };\n\n  function range(interpolate) {\n    return function(_) {\n      var r0, r1;\n      return arguments.length ? ([r0, r1] = _, interpolator = interpolate(r0, r1), scale) : [interpolator(0), interpolator(1)];\n    };\n  }\n\n  scale.range = range(interpolate);\n\n  scale.rangeRound = range(interpolateRound);\n\n  scale.unknown = function(_) {\n    return arguments.length ? (unknown = _, scale) : unknown;\n  };\n\n  return function(t) {\n    transform = t, t0 = t(x0), t1 = t(x1), k10 = t0 === t1 ? 0 : 1 / (t1 - t0);\n    return scale;\n  };\n}\n\nexport function copy(source, target) {\n  return target\n      .domain(source.domain())\n      .interpolator(source.interpolator())\n      .clamp(source.clamp())\n      .unknown(source.unknown());\n}\n\nexport default function sequential() {\n  var scale = linearish(transformer()(identity));\n\n  scale.copy = function() {\n    return copy(scale, sequential());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nexport function sequentialLog() {\n  var scale = loggish(transformer()).domain([1, 10]);\n\n  scale.copy = function() {\n    return copy(scale, sequentialLog()).base(scale.base());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nexport function sequentialSymlog() {\n  var scale = symlogish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, sequentialSymlog()).constant(scale.constant());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nexport function sequentialPow() {\n  var scale = powish(transformer());\n\n  scale.copy = function() {\n    return copy(scale, sequentialPow()).exponent(scale.exponent());\n  };\n\n  return initInterpolator.apply(scale, arguments);\n}\n\nexport function sequentialSqrt() {\n  return sequentialPow.apply(null, arguments).exponent(0.5);\n}\n"],"names":["colorSchemes","r2","interpolateRgbBasis","dprime","rSigned","dprimeSigned","makeImageData","ctx","props","ldData","regions","bpPerPx","stopTokenCheck","yScalar","useGenomicPositions","signedLD","snps","ldValues","metric","n","length","checkStopToken2","region","colorInterpolator","scale","scaleSequential","domain","viewWidthPx","end","start","sqrt2","Math","sqrt","uniformW","boundaries","i","snpPos","pixelPos","push","finalBoundary","save","rotate","PI","coords","items","ldIdx","j","ldVal","x","y","cellW","cellH","fillStyle","fillRect","ldValue","snp1","snp2","restore","flatbush","Flatbush","max","k","add","finish","data","maxScore","w","transformer","t0","t1","k10","transform","unknown","x0","x1","interpolator","identity","clamp","isNaN","min","range","interpolate","_","r0","r1","arguments","rangeRound","interpolateRound","t","copy","source","target","sequential","linearish","initInterpolator","apply","sequentialLog","loggish","base"],"sourceRoot":""}