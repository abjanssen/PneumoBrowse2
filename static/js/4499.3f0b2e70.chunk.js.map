{"version":3,"file":"static/js/4499.3f0b2e70.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/bgzf-filehandle/src/unzip-pako.ts","../../../node_modules/@gmod/bgzf-filehandle/src/gziIndex.ts","../../../node_modules/@gmod/bgzf-filehandle/src/bgzFilehandle.ts","../../../node_modules/@flatten-js/interval-tree/dist/main.mjs"],"sourcesContent":["import { Buffer } from 'buffer'\n//@ts-ignore\nimport { Z_SYNC_FLUSH, Inflate } from 'pako'\n\ninterface VirtualOffset {\n  blockPosition: number\n  dataPosition: number\n}\ninterface Chunk {\n  minv: VirtualOffset\n  maxv: VirtualOffset\n}\n\n// browserify-zlib, which is the zlib shim used by default in webpacked code,\n// does not properly uncompress bgzf chunks that contain more than\n// one bgzf block, so export an unzip function that uses pako directly\n// if we are running in a browser.\nasync function unzip(inputData: Buffer) {\n  try {\n    let strm\n    let pos = 0\n    let i = 0\n    const chunks = []\n    let totalSize = 0\n    let inflator\n    do {\n      const remainingInput = inputData.subarray(pos)\n      inflator = new Inflate()\n      //@ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      pos += strm.next_in\n      chunks[i] = inflator.result as Uint8Array\n      totalSize += chunks[i].length\n      i += 1\n    } while (strm.avail_in)\n\n    const result = new Uint8Array(totalSize)\n    for (let i = 0, offset = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset)\n      offset += chunks[i].length\n    }\n    return Buffer.from(result)\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\n// similar to pakounzip, except it does extra counting\n// to return the positions of compressed and decompressed\n// data offsets\nasync function unzipChunk(inputData: Buffer) {\n  try {\n    let strm\n    let cpos = 0\n    let dpos = 0\n    const blocks = []\n    const cpositions = []\n    const dpositions = []\n    do {\n      const remainingInput = inputData.slice(cpos)\n      const inflator = new Inflate()\n      // @ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      const buffer = Buffer.from(inflator.result)\n      blocks.push(buffer)\n\n      cpositions.push(cpos)\n      dpositions.push(dpos)\n\n      cpos += strm.next_in\n      dpos += buffer.length\n    } while (strm.avail_in)\n\n    const buffer = Buffer.concat(blocks)\n    return { buffer, cpositions, dpositions }\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\n// similar to unzipChunk above but slices (0,minv.dataPosition) and\n// (maxv.dataPosition,end) off\nasync function unzipChunkSlice(inputData: Buffer, chunk: Chunk) {\n  try {\n    let strm\n    const { minv, maxv } = chunk\n    let cpos = minv.blockPosition\n    let dpos = minv.dataPosition\n    const chunks = []\n    const cpositions = []\n    const dpositions = []\n\n    let totalSize = 0\n    let i = 0\n    do {\n      const remainingInput = inputData.subarray(cpos - minv.blockPosition)\n      const inflator = new Inflate()\n      // @ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      const buffer = inflator.result\n      chunks.push(buffer as Uint8Array)\n      let len = buffer.length\n\n      cpositions.push(cpos)\n      dpositions.push(dpos)\n      if (chunks.length === 1 && minv.dataPosition) {\n        // this is the first chunk, trim it\n        chunks[0] = chunks[0].subarray(minv.dataPosition)\n        len = chunks[0].length\n      }\n      const origCpos = cpos\n      cpos += strm.next_in\n      dpos += len\n\n      if (origCpos >= maxv.blockPosition) {\n        // this is the last chunk, trim it and stop decompressing\n        // note if it is the same block is minv it subtracts that already\n        // trimmed part of the slice length\n\n        chunks[i] = chunks[i].subarray(\n          0,\n          maxv.blockPosition === minv.blockPosition\n            ? maxv.dataPosition - minv.dataPosition + 1\n            : maxv.dataPosition + 1,\n        )\n\n        cpositions.push(cpos)\n        dpositions.push(dpos)\n        totalSize += chunks[i].length\n        break\n      }\n      totalSize += chunks[i].length\n      i++\n    } while (strm.avail_in)\n\n    const result = new Uint8Array(totalSize)\n    for (let i = 0, offset = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset)\n      offset += chunks[i].length\n    }\n    const buffer = Buffer.from(result)\n\n    return { buffer, cpositions, dpositions }\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\nfunction nodeUnzip() {\n  throw new Error('nodeUnzip not implemented.')\n}\n\nexport { unzip, unzipChunk, unzipChunkSlice, unzip as pakoUnzip, nodeUnzip }\n","import Long from 'long'\nimport { Buffer } from 'buffer'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\n// const COMPRESSED_POSITION = 0\nconst UNCOMPRESSED_POSITION = 1\n\nexport default class GziIndex {\n  filehandle: GenericFilehandle\n\n  index?: any\n\n  constructor({\n    filehandle,\n    path,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('either filehandle or path must be defined')\n    }\n  }\n\n  _readLongWithOverflow(buf: Buffer, offset = 0, unsigned = true) {\n    //@ts-ignore\n    const long = Long.fromBytesLE(buf.slice(offset, offset + 8), unsigned)\n    if (\n      long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n      long.lessThan(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new TypeError('integer overflow')\n    }\n\n    return long.toNumber()\n  }\n\n  _getIndex() {\n    if (!this.index) {\n      this.index = this._readIndex()\n    }\n    return this.index\n  }\n\n  async _readIndex() {\n    let buf = Buffer.allocUnsafe(8)\n    await this.filehandle.read(buf, 0, 8, 0)\n    const numEntries = this._readLongWithOverflow(buf, 0, true)\n    if (!numEntries) {\n      return [[0, 0]]\n    }\n\n    const entries = new Array(numEntries + 1)\n    entries[0] = [0, 0]\n\n    // TODO rewrite this to make an index-index that stays in memory\n    const bufSize = 8 * 2 * numEntries\n    if (bufSize > Number.MAX_SAFE_INTEGER) {\n      throw new TypeError('integer overflow')\n    }\n    buf = Buffer.allocUnsafe(bufSize)\n    await this.filehandle.read(buf, 0, bufSize, 8)\n    for (let entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {\n      const compressedPosition = this._readLongWithOverflow(\n        buf,\n        entryNumber * 16,\n      )\n      const uncompressedPosition = this._readLongWithOverflow(\n        buf,\n        entryNumber * 16 + 8,\n      )\n      entries[entryNumber + 1] = [compressedPosition, uncompressedPosition]\n    }\n\n    return entries\n  }\n\n  async getLastBlock() {\n    const entries = await this._getIndex()\n    if (!entries.length) {\n      return undefined\n    }\n    return entries[entries.length - 1]\n  }\n\n  async getRelevantBlocksForRead(length: number, position: number) {\n    const endPosition = position + length\n    if (length === 0) {\n      return []\n    }\n    const entries = await this._getIndex()\n    const relevant = []\n\n    // binary search to find the block that the\n    // read starts in and extend forward from that\n    const compare = (entry: any, nextEntry: any) => {\n      const uncompressedPosition = entry[UNCOMPRESSED_POSITION]\n      const nextUncompressedPosition = nextEntry\n        ? nextEntry[UNCOMPRESSED_POSITION]\n        : Infinity\n      // block overlaps read start\n      if (\n        uncompressedPosition <= position &&\n        nextUncompressedPosition > position\n      ) {\n        return 0\n        // block is before read start\n      }\n      if (uncompressedPosition < position) {\n        return -1\n      }\n      // block is after read start\n      return 1\n    }\n\n    let lowerBound = 0\n    let upperBound = entries.length - 1\n    let searchPosition = Math.floor(entries.length / 2)\n\n    let comparison = compare(\n      entries[searchPosition],\n      entries[searchPosition + 1],\n    )\n    while (comparison !== 0) {\n      if (comparison > 0) {\n        upperBound = searchPosition - 1\n      } else if (comparison < 0) {\n        lowerBound = searchPosition + 1\n      }\n      searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound\n      comparison = compare(entries[searchPosition], entries[searchPosition + 1])\n    }\n\n    // here's where we read forward\n    relevant.push(entries[searchPosition])\n    let i = searchPosition + 1\n    for (; i < entries.length; i += 1) {\n      relevant.push(entries[i])\n      if (entries[i][UNCOMPRESSED_POSITION] >= endPosition) {\n        break\n      }\n    }\n    if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {\n      relevant.push([])\n    }\n    return relevant\n  }\n}\n","import { Buffer } from 'buffer'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\n// locals\nimport { unzip } from './unzip'\nimport GziIndex from './gziIndex'\n\nexport default class BgzFilehandle {\n  filehandle: GenericFilehandle\n  gzi: GziIndex\n\n  constructor({\n    filehandle,\n    path,\n    gziFilehandle,\n    gziPath,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n    gziFilehandle?: GenericFilehandle\n    gziPath?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('either filehandle or path must be defined')\n    }\n\n    if (!gziFilehandle && !gziPath && !path) {\n      throw new TypeError('either gziFilehandle or gziPath must be defined')\n    }\n\n    this.gzi = new GziIndex({\n      filehandle: gziFilehandle,\n      path: !gziFilehandle && !gziPath && path ? gziPath : `${path}.gzi`,\n    })\n  }\n\n  async stat() {\n    const compressedStat = await this.filehandle.stat()\n    return Object.assign(compressedStat, {\n      size: await this.getUncompressedFileSize(),\n      blocks: undefined,\n      blksize: undefined,\n    })\n  }\n\n  async getUncompressedFileSize() {\n    // read the last block's ISIZE (see gzip RFC),\n    // and add it to its uncompressedPosition\n    const [, uncompressedPosition] = await this.gzi.getLastBlock()\n\n    const { size } = await this.filehandle.stat()\n\n    const buf = Buffer.allocUnsafe(4)\n    // note: there should be a 28-byte EOF marker (an empty block) at\n    // the end of the file, so we skip backward past that\n    const { bytesRead } = await this.filehandle.read(buf, 0, 4, size - 28 - 4)\n    if (bytesRead !== 4) {\n      throw new Error('read error')\n    }\n    const lastBlockUncompressedSize = buf.readUInt32LE(0)\n    return uncompressedPosition + lastBlockUncompressedSize\n  }\n\n  async _readAndUncompressBlock(\n    blockBuffer: Buffer,\n    [compressedPosition]: [number],\n    [nextCompressedPosition]: [number],\n  ) {\n    let next = nextCompressedPosition\n    if (!next) {\n      next = (await this.filehandle.stat()).size\n    }\n\n    // read the compressed data into the block buffer\n    const blockCompressedLength = next - compressedPosition\n\n    await this.filehandle.read(\n      blockBuffer,\n      0,\n      blockCompressedLength,\n      compressedPosition,\n    )\n\n    // uncompress it\n    const unzippedBuffer = await unzip(\n      blockBuffer.slice(0, blockCompressedLength),\n    )\n\n    return unzippedBuffer as Buffer\n  }\n\n  async read(buf: Buffer, offset: number, length: number, position: number) {\n    // get the block positions for this read\n    const blockPositions = await this.gzi.getRelevantBlocksForRead(\n      length,\n      position,\n    )\n    const blockBuffer = Buffer.allocUnsafe(32768 * 2)\n    // uncompress the blocks and read from them one at a time to keep memory usage down\n    let destinationOffset = offset\n    let bytesRead = 0\n    for (\n      let blockNum = 0;\n      blockNum < blockPositions.length - 1;\n      blockNum += 1\n    ) {\n      // eslint-disable-next-line no-await-in-loop\n      const uncompressedBuffer = await this._readAndUncompressBlock(\n        blockBuffer,\n        blockPositions[blockNum],\n        blockPositions[blockNum + 1],\n      )\n      const [, uncompressedPosition] = blockPositions[blockNum]\n      const sourceOffset =\n        uncompressedPosition >= position ? 0 : position - uncompressedPosition\n      const sourceEnd =\n        Math.min(\n          position + length,\n          uncompressedPosition + uncompressedBuffer.length,\n        ) - uncompressedPosition\n      if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {\n        uncompressedBuffer.copy(buf, destinationOffset, sourceOffset, sourceEnd)\n        destinationOffset += sourceEnd - sourceOffset\n        bytesRead += sourceEnd - sourceOffset\n      }\n    }\n\n    return { bytesRead, buffer: buf }\n  }\n}\n","/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval is a pair of numbers or a pair of any comparable objects on which may be defined predicates\n * *equal*, *less* and method *max(p1, p1)* that returns maximum in a pair.\n * When interval is an object rather than a pair of numbers, this object should have properties *low*, *high*, *max*\n * and implement methods *less_than(), equal_to(), intersect(), not_intersect(), clone(), output()*.\n * Two static methods *comparable_max(), comparable_less_than()* define how to compare values in pair. <br/>\n * This interface is described in typescript definition file *index.d.ts*\n *\n * Axis aligned rectangle is an example of such interval.\n * We may look at rectangle as an interval between its low left and top right corners.\n * See **Box** class in [flatten-js](https://github.com/alexbol99/flatten-js) library as the example\n * of Interval interface implementation\n * @type {Interval}\n */\nconst Interval = class Interval {\n    /**\n     * Accept two comparable values and creates new instance of interval\n     * Predicate Interval.comparable_less(low, high) supposed to return true on these values\n     * @param low\n     * @param high\n     */\n    constructor(low, high) {\n        this.low = low;\n        this.high = high;\n    }\n\n    /**\n     * Clone interval\n     * @returns {Interval}\n     */\n    clone() {\n        return new Interval(this.low, this.high);\n    }\n\n    /**\n     * Propery max returns clone of this interval\n     * @returns {Interval}\n     */\n    get max() {\n        return this.clone();   // this.high;\n    }\n\n    /**\n     * Predicate returns true is this interval less than other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    less_than(other_interval) {\n        return this.low < other_interval.low ||\n            this.low === other_interval.low && this.high < other_interval.high;\n    }\n\n    /**\n     * Predicate returns true is this interval equals to other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    equal_to(other_interval) {\n        return this.low === other_interval.low && this.high === other_interval.high;\n    }\n\n    /**\n     * Predicate returns true if this interval intersects other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    intersect(other_interval) {\n        return !this.not_intersect(other_interval);\n    }\n\n    /**\n     * Predicate returns true if this interval does not intersect other interval\n     * @param other_interval\n     * @returns {boolean}\n     */\n    not_intersect(other_interval) {\n        return (this.high < other_interval.low || other_interval.high < this.low);\n    }\n\n    /**\n     * Returns new interval merged with other interval\n     * @param {Interval} other_interval - Other interval to merge with\n     * @returns {Interval}\n     */\n    merge(other_interval) {\n        return new Interval(\n            this.low === undefined ?\n                other_interval.low : (this.low < other_interval.low ? this.low : other_interval.low),\n            this.high === undefined ?\n                other_interval.high : (this.high > other_interval.high ? this.high : other_interval.high)\n        );\n    }\n\n    /**\n     * Returns how key should return\n     */\n    output() {\n        return [this.low, this.high];\n    }\n\n    /**\n     * Function returns maximum between two comparable values\n     * @param interval1\n     * @param interval2\n     * @returns {Interval}\n     */\n    static comparable_max(interval1, interval2) {\n        return interval1.merge(interval2);\n    }\n\n    /**\n     * Predicate returns true if first value less than second value\n     * @param val1\n     * @param val2\n     * @returns {boolean}\n     */\n    static comparable_less_than(val1, val2 ) {\n        return val1 < val2;\n    }\n};\n\n/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\nconst RB_TREE_COLOR_RED = 0;\nconst RB_TREE_COLOR_BLACK = 1;\n\n/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n\nclass Node {\n    constructor(key = undefined, value = undefined,\n                left = null, right = null, parent = null, color = RB_TREE_COLOR_BLACK) {\n        this.left = left;                     // reference to left child node\n        this.right = right;                   // reference to right child node\n        this.parent = parent;                 // reference to parent node\n        this.color = color;\n\n        this.item = {key: key, value: value};   // key is supposed to be instance of Interval\n\n        /* If not, this should by an array of two numbers */\n        if (key && key instanceof Array && key.length === 2) {\n            if (!Number.isNaN(key[0]) && !Number.isNaN(key[1])) {\n                let [low, high] = key;\n                if (low > high) [low, high] = [high, low];\n                this.item.key = new Interval(low, high);\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil() {\n        return (this.item.key === undefined && this.item.value === undefined &&\n            this.left === null && this.right === null && this.color === RB_TREE_COLOR_BLACK);\n    }\n\n    _value_less_than(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.less_than ?\n            this.item.value.less_than(other_node.item.value) :\n            this.item.value < other_node.item.value;\n    }\n\n    less_than(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.less_than(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.less_than(other_node.item.key) ||\n                this.item.key.equal_to((other_node.item.key)) && this._value_less_than(other_node)\n        }\n    }\n\n    _value_equal(other_node) {\n        return this.item.value && other_node.item.value && this.item.value.equal_to ?\n            this.item.value.equal_to(other_node.item.value) :\n            this.item.value === other_node.item.value;\n    }\n    equal_to(other_node) {\n        // if tree stores only keys\n        if (this.item.value === this.item.key && other_node.item.value === other_node.item.key) {\n            return this.item.key.equal_to(other_node.item.key);\n        }\n        else {    // if tree stores keys and values\n            return this.item.key.equal_to(other_node.item.key) && this._value_equal(other_node);\n        }\n    }\n\n    intersect(other_node) {\n        return this.item.key.intersect(other_node.item.key);\n    }\n\n    copy_data(other_node) {\n        this.item.key = other_node.item.key;\n        this.item.value = other_node.item.value;\n    }\n\n    update_max() {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n        if (this.right && this.right.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.right.max);\n        }\n        if (this.left && this.left.max) {\n            const comparable_max = this.item.key.constructor.comparable_max;  // static method\n            this.max = comparable_max(this.max, this.left.max);\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree, if this.left.max < other_node.item.key.low\n    not_intersect_left_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let high = this.left.max.high !== undefined ? this.left.max.high : this.left.max;\n        return comparable_less_than(high, search_node.item.key.low);\n    }\n\n    // Other_node does not intersect right subtree if other_node.item.key.high < this.right.key.low\n    not_intersect_right_subtree(search_node) {\n        const comparable_less_than = this.item.key.constructor.comparable_less_than;  // static method\n        let low = this.right.max.low !== undefined ? this.right.max.low : this.right.item.key.low;\n        return comparable_less_than(search_node.item.key.high, low);\n    }\n}\n\n/**\n * Created by Alex Bol on 3/31/2017.\n */\n\n// const nil_node = new Node();\n\n/**\n * Implementation of interval binary search tree <br/>\n * Interval tree stores items which are couples of {key:interval, value: value} <br/>\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values <br />\n * @type {IntervalTree}\n */\nclass IntervalTree {\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size() {\n        let count = 0;\n        this.tree_walk(this.root, () => count++);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(\n            node.item.key.output ? node.item.key.output() : node.item.key\n        ));\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push(node.item.value));\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items() {\n        let res = [];\n        this.tree_walk(this.root, (node) => res.push({\n            key: node.item.key.output ? node.item.key.output() : node.item.key,\n            value: node.item.value\n        }));\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty() {\n        return (this.root == null || this.root === this.nil_node);\n    }\n\n    /**\n     * Clear tree\n     */\n    clear() {\n        this.root = null;\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param {Interval} key - interval object or array of two numbers [low, high]\n     * @param {any} value - value representing any object (optional)\n     * @returns {Node} returns reference to inserted node as an object {key:interval, value: value}\n     */\n    insert(key, value = key) {\n        if (key === undefined) return;\n        let insert_node = new Node(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object to be checked\n     * @returns {boolean} true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key, value = key) {\n        let search_node = new Node(key, value);\n        return !!this.tree_search(this.root, search_node);\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param {Interval} key - interval correspondent to keys stored in the tree\n     * @param {any} value - value object\n     * @returns {boolean} true if item {key, value} deleted, false if not found\n     */\n    remove(key, value = key) {\n        let search_node = new Node(key, value);\n        let delete_node = this.tree_search(this.root, search_node);\n        if (delete_node) {\n            this.tree_delete(delete_node);\n        }\n        return delete_node;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval <br/>\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param {Interval} interval - search interval, or tuple [low, high]\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    search(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let search_node = new Node(interval);\n        let resp_nodes = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        return resp_nodes.map(node => outputMapperFn(node.item.value, node.item.key))\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param {Interval} interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval) {\n        let search_node = new Node(interval);\n        return this.tree_find_any_interval(this.root, search_node);\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function. <br/>\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor(key,value) - function to be called for each tree item\n     */\n    forEach(visitor) {\n        this.tree_walk(this.root, (node) => visitor(node.item.key, node.item.value));\n    }\n\n    /**\n     * Value Mapper. Walk through every node and map node value to another value\n     * @param callback(value,key) - function to be called for each tree item\n     */\n    map(callback) {\n        const tree = new IntervalTree();\n        this.tree_walk(this.root, (node) => tree.insert(node.item.key, callback(node.item.value, node.item.key)));\n        return tree;\n    }\n\n    /**\n     * @param {Interval} interval - optional if the iterator is intended to start from the beginning\n     * @param outputMapperFn(value,key) - optional function that maps (value, key) to custom output\n     * @returns {Iterator}\n     */\n    *iterate(interval, outputMapperFn = (value, key) => value === key ? key.output() : value) {\n        let node;\n        if (interval) {\n            node = this.tree_search_nearest_forward(this.root, new Node(interval));\n        } else if (this.root) {\n            node = this.local_minimum(this.root);\n        }\n        while (node) {\n            yield outputMapperFn(node.item.value, node.item.key);\n            node = this.tree_successor(node);\n        }\n    }\n\n    recalc_max(node) {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    tree_insert(insert_node) {\n        let current_node = this.root;\n        let parent_node = null;\n\n        if (this.root == null || this.root === this.nil_node) {\n            this.root = insert_node;\n        }\n        else {\n            while (current_node !== this.nil_node) {\n                parent_node = current_node;\n                if (insert_node.less_than(current_node)) {\n                    current_node = current_node.left;\n                }\n                else {\n                    current_node = current_node.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node)) {\n                parent_node.left = insert_node;\n            }\n            else {\n                parent_node.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n// After insertion insert_node may have red-colored parent, and this is a single possible violation\n// Go upwords to the root and re-color until violation will be resolved\n    insert_fixup(insert_node) {\n        let current_node;\n        let uncle_node;\n\n        current_node = insert_node;\n        while (current_node !== this.root && current_node.parent.color === RB_TREE_COLOR_RED) {\n            if (current_node.parent === current_node.parent.parent.left) {   // parent is left child of grandfather\n                uncle_node = current_node.parent.parent.right;              // right brother of parent\n                if (uncle_node.color === RB_TREE_COLOR_RED) {             // Case 1. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {                                                    // Case 2 & 3. Uncle is black\n                    if (current_node === current_node.parent.right) {     // Case 2. Current if right child\n                        // This case is transformed into Case 3.\n                        current_node = current_node.parent;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 3. Current is left child.\n                    // Re-color father and grandfather, rotate grandfather right\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent.parent);\n                }\n            }\n            else {                                                         // parent is right child of grandfather\n                uncle_node = current_node.parent.parent.left;              // left brother of parent\n                if (uncle_node.color === RB_TREE_COLOR_RED) {             // Case 4. Uncle is red\n                    // re-color father and uncle into black\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent.parent;\n                }\n                else {\n                    if (current_node === current_node.parent.left) {             // Case 5. Current is left child\n                        // Transform into case 6\n                        current_node = current_node.parent;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;    // Case 6. Current is right child.\n                    // Re-color father and grandfather, rotate grandfather left\n                    current_node.parent.parent.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent.parent);\n                }\n            }\n        }\n\n        this.root.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_delete(delete_node) {\n        let cut_node;   // node to be cut - either delete_node or successor_node  (\"y\" from 14.4)\n        let fix_node;   // node to fix rb tree property   (\"x\" from 14.4)\n\n        if (delete_node.left === this.nil_node || delete_node.right === this.nil_node) {  // delete_node has less then 2 children\n            cut_node = delete_node;\n        }\n        else {                                                    // delete_node has 2 children\n            cut_node = this.tree_successor(delete_node);\n        }\n\n        // fix_node if single child of cut_node\n        if (cut_node.left !== this.nil_node) {\n            fix_node = cut_node.left;\n        }\n        else {\n            fix_node = cut_node.right;\n        }\n\n        // remove cut_node from parent\n        /*if (fix_node != this.nil_node) {*/\n            fix_node.parent = cut_node.parent;\n        /*}*/\n\n        if (cut_node === this.root) {\n            this.root = fix_node;\n        }\n        else {\n            if (cut_node === cut_node.parent.left) {\n                cut_node.parent.left = fix_node;\n            }\n            else {\n                cut_node.parent.right = fix_node;\n            }\n            cut_node.parent.update_max();        // update max property of the parent\n        }\n\n        this.recalc_max(fix_node);              // update max property upward from fix_node to root\n\n        // COPY DATA !!!\n        // Delete_node becomes cut_node, it means that we cannot hold reference\n        // to node in outer structure and we will have to delete by key, additional search need\n        if (cut_node !== delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();           // update max property of the cut node at the new place\n            this.recalc_max(delete_node);       // update max property upward from delete_node to root\n        }\n\n        if (/*fix_node != this.nil_node && */cut_node.color === RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    delete_fixup(fix_node) {\n        let current_node = fix_node;\n        let brother_node;\n\n        while (current_node !== this.root && current_node.parent != null && current_node.color === RB_TREE_COLOR_BLACK) {\n            if (current_node === current_node.parent.left) {          // fix node is left child\n                brother_node = current_node.parent.right;\n                if (brother_node.color === RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_left(current_node.parent);\n                    brother_node = current_node.parent.right;                      // update brother\n                }\n                // Derive to cases 2..4: brother is black\n                if (brother_node.left.color === RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color === RB_TREE_COLOR_BLACK) {  // case 2: both nephews black\n                    brother_node.color = RB_TREE_COLOR_RED;              // re-color brother\n                    current_node = current_node.parent;                  // continue iteration\n                }\n                else {\n                    if (brother_node.right.color === RB_TREE_COLOR_BLACK) {   // case 3: left nephew red, right nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;          // re-color brother\n                        brother_node.left.color = RB_TREE_COLOR_BLACK;   // re-color nephew\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent.right;                     // update brother\n                        // Derive to case 4: left nephew black, right nephew red\n                    }\n                    // case 4: left nephew black, right nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent);\n                    current_node = this.root;                         // exit from loop\n                }\n            }\n            else {                                             // fix node is right child\n                brother_node = current_node.parent.left;\n                if (brother_node.color === RB_TREE_COLOR_RED) {   // Case 1. Brother is red\n                    brother_node.color = RB_TREE_COLOR_BLACK;         // re-color brother\n                    current_node.parent.color = RB_TREE_COLOR_RED;    // re-color father\n                    this.rotate_right(current_node.parent);\n                    brother_node = current_node.parent.left;                        // update brother\n                }\n                // Go to cases 2..4\n                if (brother_node.left.color === RB_TREE_COLOR_BLACK &&\n                    brother_node.right.color === RB_TREE_COLOR_BLACK) {   // case 2\n                    brother_node.color = RB_TREE_COLOR_RED;             // re-color brother\n                    current_node = current_node.parent;                              // continue iteration\n                }\n                else {\n                    if (brother_node.left.color === RB_TREE_COLOR_BLACK) {  // case 3: right nephew red, left nephew black\n                        brother_node.color = RB_TREE_COLOR_RED;            // re-color brother\n                        brother_node.right.color = RB_TREE_COLOR_BLACK;    // re-color nephew\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent.left;                        // update brother\n                        // Derive to case 4: right nephew black, left nephew red\n                    }\n                    // case 4: right nephew black, left nephew red\n                    brother_node.color = current_node.parent.color;\n                    current_node.parent.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent);\n                    current_node = this.root;                               // force exit from loop\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    tree_search(node, search_node) {\n        if (node == null || node === this.nil_node)\n            return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        }\n        else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    tree_search_nearest_forward(node, search_node) {\n        let best;\n        let curr = node;\n        while (curr && curr !== this.nil_node) {\n            if (curr.less_than(search_node)) {\n                if (curr.intersect(search_node)) {\n                    best = curr;\n                    curr = curr.left;\n                } else {\n                    curr = curr.right;\n                }\n            } else {\n                if (!best || curr.less_than(best)) best = curr;\n                curr = curr.left;\n            }\n        }\n        return best || null;\n    }\n\n    // Original search_interval method; container res support push() insertion\n    // Search all intervals intersecting given one\n    tree_search_interval(node, search_node, res) {\n        if (node != null && node !== this.nil_node) {\n            // if (node->left != this.nil_node && node->left->max >= low) {\n            if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            // if (low <= node->high && node->low <= high) {\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            // if (node->right != this.nil_node && node->low <= high) {\n            if (node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    tree_find_any_interval(node, search_node) {\n        let found = false;\n        if (node != null && node !== this.nil_node) {\n            if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            if (!found && node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    local_minimum(node) {\n        let node_min = node;\n        while (node_min.left != null && node_min.left !== this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    // not in use\n    local_maximum(node) {\n        let node_max = node;\n        while (node_max.right != null && node_max.right !== this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    tree_successor(node) {\n        let node_successor;\n        let current_node;\n        let parent_node;\n\n        if (node.right !== this.nil_node) {\n            node_successor = this.local_minimum(node.right);\n        }\n        else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right === current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    //           |            right-rotate(T,y)       |\n    //           y            ---------------.       x\n    //          / \\                                  / \\\n    //         x   c          left-rotate(T,x)      a   y\n    //        / \\             <---------------         / \\\n    //       a   b                                    b   c\n\n    rotate_left(x) {\n        let y = x.right;\n\n        x.right = y.left;           // b goes to x.right\n\n        if (y.left !== this.nil_node) {\n            y.left.parent = x;     // x becomes parent of b\n        }\n        y.parent = x.parent;       // move parent\n\n        if (x === this.root) {\n            this.root = y;           // y becomes root\n        }\n        else {                        // y becomes child of x.parent\n            if (x === x.parent.left) {\n                x.parent.left = y;\n            }\n            else {\n                x.parent.right = y;\n            }\n        }\n        y.left = x;                 // x becomes left child of y\n        x.parent = y;               // and y becomes parent of x\n\n        if (x != null && x !== this.nil_node) {\n            x.update_max();\n        }\n\n        y = x.parent;\n        if (y != null && y !== this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    rotate_right(y) {\n        let x = y.left;\n\n        y.left = x.right;           // b goes to y.left\n\n        if (x.right !== this.nil_node) {\n            x.right.parent = y;        // y becomes parent of b\n        }\n        x.parent = y.parent;          // move parent\n\n        if (y === this.root) {        // x becomes root\n            this.root = x;\n        }\n        else {                        // y becomes child of x.parent\n            if (y === y.parent.left) {\n                y.parent.left = x;\n            }\n            else {\n                y.parent.right = x;\n            }\n        }\n        x.right = y;                 // y becomes right child of x\n        y.parent = x;               // and x becomes parent of y\n\n        if (y !== null && y !== this.nil_node) {\n            y.update_max();\n        }\n\n        x = y.parent;\n        if (x != null && x !== this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    tree_walk(node, action) {\n        if (node != null && node !== this.nil_node) {\n            this.tree_walk(node.left, action);\n            // arr.push(node.toArray());\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /* Return true if all red nodes have exactly two black child nodes */\n    testRedBlackProperty() {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color === RB_TREE_COLOR_RED) {\n                if (!(node.left.color === RB_TREE_COLOR_BLACK && node.right.color === RB_TREE_COLOR_BLACK)) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /* Throw error if not every path from root to bottom has same black height */\n    testBlackHeightProperty(node) {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color === RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left !== this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left);\n        }\n        else {\n            heightLeft = 1;\n        }\n        if (node.right !== this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right);\n        }\n        else {\n            heightRight = 1;\n        }\n        if (heightLeft !== heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    }\n}\n\nexport { Interval, Node, IntervalTree as default };\n"],"names":["async","unzip","inputData","strm","pos","i","chunks","inflator","totalSize","remainingInput","subarray","Inflate","push","Z_SYNC_FLUSH","err","Error","msg","next_in","result","length","avail_in","Uint8Array","offset","set","from","e","match","unzipChunkSlice","chunk","minv","maxv","cpos","blockPosition","dpos","dataPosition","cpositions","dpositions","buffer","len","origCpos","GziIndex","constructor","filehandle","path","this","TypeError","_readLongWithOverflow","buf","unsigned","long","slice","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","_getIndex","index","_readIndex","allocUnsafe","read","numEntries","entries","Array","bufSize","entryNumber","compressedPosition","uncompressedPosition","getLastBlock","getRelevantBlocksForRead","position","endPosition","relevant","compare","entry","nextEntry","nextUncompressedPosition","Infinity","lowerBound","upperBound","searchPosition","Math","floor","comparison","ceil","BgzFilehandle","gziFilehandle","gziPath","gzi","stat","compressedStat","Object","assign","size","getUncompressedFileSize","blocks","undefined","blksize","bytesRead","readUInt32LE","_readAndUncompressBlock","blockBuffer","nextCompressedPosition","next","blockCompressedLength","blockPositions","destinationOffset","blockNum","uncompressedBuffer","sourceOffset","sourceEnd","min","copy","Interval","low","high","clone","max","less_than","other_interval","equal_to","intersect","not_intersect","merge","output","comparable_max","interval1","interval2","comparable_less_than","val1","val2","Node","key","value","left","right","parent","color","item","isNaN","isNil","_value_less_than","other_node","_value_equal","copy_data","update_max","not_intersect_left_subtree","search_node","not_intersect_right_subtree","IntervalTree","root","nil_node","count","tree_walk","keys","res","node","values","items","isEmpty","clear","insert","insert_node","tree_insert","recalc_max","exist","tree_search","remove","delete_node","tree_delete","search","interval","outputMapperFn","resp_nodes","tree_search_interval","map","intersect_any","tree_find_any_interval","forEach","visitor","callback","tree","iterate","tree_search_nearest_forward","local_minimum","tree_successor","node_current","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","cut_node","fix_node","delete_fixup","brother_node","best","curr","found","node_min","local_maximum","node_max","node_successor","x","y","action","testRedBlackProperty","testBlackHeightProperty","height","heightLeft","heightRight"],"sourceRoot":""}