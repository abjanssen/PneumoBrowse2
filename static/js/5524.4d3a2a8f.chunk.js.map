{"version":3,"file":"static/js/5524.4d3a2a8f.chunk.js","mappings":"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","sources":["../../../plugins/wiggle/src/drawXY.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp, featureSpanPx } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n// required to import this for typescript purposes\nimport mix from 'colord/plugins/mix' // eslint-disable-line @typescript-eslint/no-unused-vars\n\nimport { fillRectCtx, getOrigin, getScale } from './util'\n\nimport type { ScaleOpts } from './util'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, Region } from '@jbrowse/core/util'\nimport type { Colord } from '@jbrowse/core/util/colord'\n\nfunction lighten(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 + amount)\n  return colord({ ...hslColor, l: clamp(l, 0, 100) })\n}\n\nfunction darken(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 - amount)\n  return colord({ ...hslColor, l: clamp(l, 0, 100) })\n}\n\nconst fudgeFactor = 0.3\nconst clipHeight = 2\n\nexport function drawXY(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    stopToken?: string\n    features: Map<string, Feature> | Feature[]\n    bpPerPx: number\n    regions: Region[]\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    config: AnyConfigurationModel\n    displayCrossHatches: boolean\n    inverted: boolean\n    offset?: number\n    colorCallback: (f: Feature, score: number) => string\n  },\n) {\n  const {\n    features,\n    bpPerPx,\n    regions,\n    scaleOpts,\n    height: unadjustedHeight,\n    config,\n    ticks,\n    displayCrossHatches,\n    offset = 0,\n    colorCallback,\n    inverted,\n  } = props\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the\n  // wiggle display, and makes the height of the actual drawn area add\n  // \"padding\" to the top and bottom of the display\n  const height = unadjustedHeight - offset * 2\n\n  const filled = readConfObject(config, 'filled')\n  const clipColor = readConfObject(config, 'clipColor')\n  const summaryScoreMode = readConfObject(config, 'summaryScoreMode')\n  const pivotValue = readConfObject(config, 'bicolorPivotValue')\n  const minSize = readConfObject(config, 'minSize')\n\n  const scale = getScale({ ...scaleOpts, range: [0, height], inverted })\n  const originY = getOrigin(scaleOpts.scaleType)\n  const domain = scale.domain()\n  const niceMin = domain[0]!\n  const niceMax = domain[1]!\n\n  const toY = (n: number) => clamp(height - (scale(n) || 0), 0, height) + offset\n  const toOrigin = (n: number) => toY(originY) - toY(n)\n  const getHeight = (n: number) => (filled ? toOrigin(n) : Math.max(minSize, 1))\n  let hasClipping = false\n\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n  const crossingOrigin = niceMin < pivotValue && niceMax > pivotValue\n\n  let start = performance.now()\n\n  // we handle whiskers separately to render max row, min row, and avg in three\n  // passes. this reduces subpixel rendering issues. note: for stylistic\n  // reasons, clipping indicator is only drawn for score, not min/max score\n  if (summaryScoreMode === 'whiskers') {\n    let lastCol: string | undefined\n    let lastMix: string | undefined\n    start = performance.now()\n    for (const feature of features.values()) {\n      if (performance.now() - start > 400) {\n        checkStopToken()\n        start = performance.now()\n      }\n      const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n      if (feature.get('summary')) {\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const max = feature.get('maxScore')\n        const c = colorCallback(feature, max)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = lighten(colord(c), 0.4).toHex())\n        fillRectCtx(leftPx, toY(max), w, getHeight(max), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n    lastMix = undefined\n    lastCol = undefined\n    start = performance.now()\n    for (const feature of features.values()) {\n      if (performance.now() - start > 400) {\n        checkStopToken()\n        start = performance.now()\n      }\n      const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n      const score = feature.get('score')\n      const max = feature.get('maxScore')\n      const min = feature.get('minScore')\n      const summary = feature.get('summary')\n      const c = colorCallback(feature, score)\n      const effectiveC =\n        crossingOrigin && summary\n          ? c === lastCol\n            ? lastMix\n            : (lastMix = colord(colorCallback(feature, max))\n                .mix(colord(colorCallback(feature, min)))\n                .toString())\n          : c\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n      // create reduced features, avoiding multiple features per px\n      if (Math.floor(leftPx) !== Math.floor(prevLeftPx)) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, effectiveC)\n      lastCol = c\n    }\n    lastMix = undefined\n    lastCol = undefined\n    start = performance.now()\n    for (const feature of features.values()) {\n      if (performance.now() - start > 400) {\n        checkStopToken()\n        start = performance.now()\n      }\n      const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n\n      if (feature.get('summary')) {\n        const min = feature.get('minScore')\n        const c = colorCallback(feature, min)\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = darken(colord(c), 0.4).toHex())\n\n        fillRectCtx(leftPx, toY(min), w, getHeight(min), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n  } else {\n    start = performance.now()\n    for (const feature of features.values()) {\n      if (performance.now() - start > 400) {\n        checkStopToken()\n        start = performance.now()\n      }\n      const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n\n      // create reduced features, avoiding multiple features per px\n      if (Math.floor(leftPx) !== Math.floor(prevLeftPx)) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n\n      const score = feature.get('score')\n      const c = colorCallback(feature, score)\n\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n\n      if (summaryScoreMode === 'max') {\n        const s = feature.get('summary') ? feature.get('maxScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else if (summaryScoreMode === 'min') {\n        const s = feature.get('summary') ? feature.get('minScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else {\n        fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, c)\n      }\n    }\n  }\n\n  // second pass: draw clipping\n  // avoid persisting the red fillstyle with save/restore\n  ctx.save()\n  if (hasClipping) {\n    ctx.fillStyle = clipColor\n    start = performance.now()\n    for (const feature of features.values()) {\n      if (performance.now() - start > 400) {\n        checkStopToken()\n        start = performance.now()\n      }\n      const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n      const w = rightPx - leftPx + fudgeFactor\n      const score = feature.get('score')\n      if (score > niceMax) {\n        fillRectCtx(leftPx, offset, w, clipHeight, ctx)\n      } else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n        fillRectCtx(leftPx, unadjustedHeight, w, clipHeight, ctx)\n      }\n    }\n  }\n  ctx.restore()\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    ticks.values.forEach(tick => {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    })\n  }\n\n  return { reducedFeatures }\n}\n"],"names":["lighten","color","amount","hslColor","toHsl","l","colord","clamp","darken","fudgeFactor","clipHeight","drawXY","ctx","props","features","bpPerPx","regions","scaleOpts","height","unadjustedHeight","config","ticks","displayCrossHatches","offset","colorCallback","inverted","region","width","end","start","filled","readConfObject","clipColor","summaryScoreMode","pivotValue","minSize","scale","getScale","range","originY","getOrigin","scaleType","domain","niceMin","niceMax","toY","n","getHeight","toOrigin","Math","max","hasClipping","prevLeftPx","Number","NEGATIVE_INFINITY","reducedFeatures","crossingOrigin","performance","now","lastCol","lastMix","feature","values","checkStopToken","leftPx","rightPx","featureSpanPx","get","w","c","effectiveC","toHex","fillRectCtx","undefined","score","min","summary","mix","toString","floor","push","s","save","fillStyle","restore","lineWidth","strokeStyle","forEach","tick","beginPath","moveTo","round","lineTo","stroke"],"sourceRoot":""}