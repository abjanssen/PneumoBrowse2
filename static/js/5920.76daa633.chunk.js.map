{"version":3,"file":"static/js/5920.76daa633.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/chunk.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/long.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/util.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/indexFile.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/virtualOffset.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/bai.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/csi.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/nullFilehandle.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/cigar.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/record.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/constants.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/sam.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/bamFile.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+bam@7.1.17_buffer@6.0.3/node_modules/@gmod/bam/src/htsget.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/crc@4.3.2_buffer@6.0.3/node_modules/crc/mjs/calculators/crc32.js"],"sourcesContent":["import { Offset } from './virtualOffset.ts'\n\n// little class representing a chunk in the index\nexport default class Chunk {\n  public buffer?: Uint8Array<ArrayBuffer>\n\n  constructor(\n    public minv: Offset,\n    public maxv: Offset,\n    public bin: number,\n    public _fetchedSize?: number,\n  ) {}\n\n  toUniqueString() {\n    return `${this.minv.toString()}..${this.maxv.toString()} (bin ${\n      this.bin\n    }, fetchedSize ${this.fetchedSize()})`\n  }\n\n  toString() {\n    return this.toUniqueString()\n  }\n\n  compareTo(b: Chunk) {\n    return (\n      this.minv.compareTo(b.minv) ||\n      this.maxv.compareTo(b.maxv) ||\n      this.bin - b.bin\n    )\n  }\n\n  fetchedSize() {\n    if (this._fetchedSize !== undefined) {\n      return this._fetchedSize\n    }\n    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition\n  }\n}\n","export const TWO_PWR_16_DBL = 1 << 16\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL\n\n// avoids dependency on long.js\nexport function longFromBytesToUnsigned(source: Uint8Array, i = 0) {\n  const low =\n    source[i]! |\n    (source[i + 1]! << 8) |\n    (source[i + 2]! << 16) |\n    (source[i + 3]! << 24)\n  const high =\n    source[i + 4]! |\n    (source[i + 5]! << 8) |\n    (source[i + 6]! << 16) |\n    (source[i + 7]! << 24)\n  return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0)\n}\n","import Chunk from './chunk.ts'\nimport { longFromBytesToUnsigned } from './long.ts'\nimport { Offset, VirtualOffset } from './virtualOffset.ts'\n\nexport function canMergeBlocks(chunk1: Chunk, chunk2: Chunk) {\n  return (\n    chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n    chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000\n  )\n}\n\nexport interface TagFilter {\n  tag: string\n  value?: string\n}\n\nexport interface FilterBy {\n  flagInclude?: number\n  flagExclude?: number\n  tagFilter?: TagFilter\n}\n\nexport interface BamOpts {\n  viewAsPairs?: boolean\n  pairAcrossChr?: boolean\n  maxInsertSize?: number\n  signal?: AbortSignal\n  filterBy?: FilterBy\n}\n\nexport interface BaseOpts {\n  signal?: AbortSignal\n}\n\nexport function makeOpts(obj: AbortSignal | BaseOpts = {}): BaseOpts {\n  return 'aborted' in obj ? ({ signal: obj } as BaseOpts) : obj\n}\n\nexport function optimizeChunks(chunks: Chunk[], lowest?: Offset) {\n  const n = chunks.length\n  if (n === 0) {\n    return chunks\n  }\n\n  // Pre-filter chunks below lowest threshold before sorting\n  let filtered: Chunk[]\n  if (lowest) {\n    const lowestBlock = lowest.blockPosition\n    const lowestData = lowest.dataPosition\n    filtered = []\n    for (let i = 0; i < n; i++) {\n      const chunk = chunks[i]!\n      const maxv = chunk.maxv\n      const cmp =\n        maxv.blockPosition - lowestBlock || maxv.dataPosition - lowestData\n      if (cmp > 0) {\n        filtered.push(chunk)\n      }\n    }\n    if (filtered.length === 0) {\n      return filtered\n    }\n  } else {\n    filtered = chunks\n  }\n\n  filtered.sort((c0, c1) => {\n    const dif = c0.minv.blockPosition - c1.minv.blockPosition\n    return dif !== 0 ? dif : c0.minv.dataPosition - c1.minv.dataPosition\n  })\n\n  const mergedChunks: Chunk[] = []\n  let lastChunk = filtered[0]!\n  mergedChunks.push(lastChunk)\n\n  let lastMinBlock = lastChunk.minv.blockPosition\n  let lastMaxBlock = lastChunk.maxv.blockPosition\n\n  for (let i = 1; i < filtered.length; i++) {\n    const chunk = filtered[i]!\n    const chunkMinBlock = chunk.minv.blockPosition\n    const chunkMaxBlock = chunk.maxv.blockPosition\n    // Inlined canMergeBlocks: check if chunks are close enough to merge\n    if (\n      chunkMinBlock - lastMaxBlock < 65000 &&\n      chunkMaxBlock - lastMinBlock < 5000000\n    ) {\n      const chunkMaxv = chunk.maxv\n      const lastMaxv = lastChunk.maxv\n      const cmp =\n        chunkMaxBlock - lastMaxBlock ||\n        chunkMaxv.dataPosition - lastMaxv.dataPosition\n      if (cmp > 0) {\n        lastChunk.maxv = chunkMaxv\n        lastMaxBlock = chunkMaxBlock\n      }\n    } else {\n      mergedChunks.push(chunk)\n      lastChunk = chunk\n      lastMinBlock = chunkMinBlock\n      lastMaxBlock = chunkMaxBlock\n    }\n  }\n\n  return mergedChunks\n}\n\nexport function parsePseudoBin(bytes: Uint8Array, offset: number) {\n  return {\n    lineCount: longFromBytesToUnsigned(bytes, offset),\n  }\n}\n\nexport function findFirstData(\n  firstDataLine: VirtualOffset | undefined,\n  virtualOffset: VirtualOffset,\n) {\n  return firstDataLine\n    ? firstDataLine.compareTo(virtualOffset) > 0\n      ? virtualOffset\n      : firstDataLine\n    : virtualOffset\n}\n\nexport function parseNameBytes(\n  namesBytes: Uint8Array,\n  renameRefSeq: (arg: string) => string = s => s,\n) {\n  let currRefId = 0\n  let currNameStart = 0\n  const refIdToName = []\n  const refNameToId: Record<string, number> = {}\n  for (let i = 0; i < namesBytes.length; i += 1) {\n    if (!namesBytes[i]) {\n      if (currNameStart < i) {\n        let refName = ''\n        for (let j = currNameStart; j < i; j++) {\n          refName += String.fromCharCode(namesBytes[j]!)\n        }\n        refName = renameRefSeq(refName)\n        refIdToName[currRefId] = refName\n        refNameToId[refName] = currRefId\n      }\n      currNameStart = i + 1\n      currRefId += 1\n    }\n  }\n  return { refNameToId, refIdToName }\n}\n\nexport function concatUint8Array(args: Uint8Array[]) {\n  let totalLength = 0\n  for (const entry of args) {\n    totalLength += entry.length\n  }\n  const mergedArray = new Uint8Array(totalLength)\n  let offset = 0\n  for (const entry of args) {\n    mergedArray.set(entry, offset)\n    offset += entry.length\n  }\n  return mergedArray\n}\n\nexport async function gen2array<T>(gen: AsyncIterable<T[]>): Promise<T[]> {\n  const out: T[] = []\n  for await (const x of gen) {\n    for (const item of x) {\n      out.push(item)\n    }\n  }\n  return out\n}\n\nexport function filterReadFlag(\n  flags: number,\n  flagInclude: number,\n  flagExclude: number,\n) {\n  if ((flags & flagInclude) !== flagInclude) {\n    return true\n  }\n  if (flags & flagExclude) {\n    return true\n  }\n  return false\n}\n\nexport function filterTagValue(readVal: unknown, filterVal?: string) {\n  return filterVal === '*'\n    ? readVal === undefined\n    : `${readVal}` !== `${filterVal}`\n}\n\nexport function filterCacheKey(filterBy?: FilterBy) {\n  if (!filterBy) {\n    return ''\n  }\n  const { flagInclude = 0, flagExclude = 0, tagFilter } = filterBy\n  const tagPart = tagFilter ? `:${tagFilter.tag}=${tagFilter.value ?? '*'}` : ''\n  return `:f${flagInclude}x${flagExclude}${tagPart}`\n}\n","import Chunk from './chunk.ts'\nimport { BaseOpts, optimizeChunks } from './util.ts'\n\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport interface Region {\n  refId: number\n  start: number\n  end: number\n}\n\nexport default abstract class IndexFile {\n  public filehandle: GenericFilehandle\n  public renameRefSeq: (s: string) => string\n\n  constructor({\n    filehandle,\n    renameRefSeq = (n: string) => n,\n  }: {\n    filehandle: GenericFilehandle\n    renameRefSeq?: (a: string) => string\n  }) {\n    this.filehandle = filehandle\n    this.renameRefSeq = renameRefSeq\n  }\n  public abstract lineCount(refId: number): Promise<number>\n  public abstract indexCov(\n    refId: number,\n    start?: number,\n    end?: number,\n  ): Promise<{ start: number; end: number; score: number }[]>\n\n  public abstract blocksForRange(\n    chrId: number,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ): Promise<Chunk[]>\n\n  async estimatedBytesForRegions(regions: Region[], opts?: BaseOpts) {\n    const blockResults = await Promise.all(\n      regions.map(r => this.blocksForRange(r.refId, r.start, r.end, opts)),\n    )\n\n    // Deduplicate and merge overlapping blocks across all regions\n    const mergedBlocks = optimizeChunks(blockResults.flat())\n\n    let total = 0\n    for (const block of mergedBlocks) {\n      total += block.fetchedSize()\n    }\n    return total\n  }\n}\n","export interface Offset {\n  blockPosition: number\n  dataPosition: number\n  toString(): string\n  compareTo(arg: Offset): number\n}\n\nexport class VirtualOffset {\n  public blockPosition: number\n  public dataPosition: number\n  constructor(blockPosition: number, dataPosition: number) {\n    this.blockPosition = blockPosition // < offset of the compressed data block\n    this.dataPosition = dataPosition // < offset into the uncompressed data\n  }\n\n  toString() {\n    return `${this.blockPosition}:${this.dataPosition}`\n  }\n\n  compareTo(b: VirtualOffset) {\n    return (\n      this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition\n    )\n  }\n}\nexport function fromBytes(bytes: Uint8Array, offset = 0, bigendian = false) {\n  if (bigendian) {\n    throw new Error('big-endian virtual file offsets not implemented')\n  }\n\n  return new VirtualOffset(\n    bytes[offset + 7]! * 0x10000000000 +\n      bytes[offset + 6]! * 0x100000000 +\n      bytes[offset + 5]! * 0x1000000 +\n      bytes[offset + 4]! * 0x10000 +\n      bytes[offset + 3]! * 0x100 +\n      bytes[offset + 2]!,\n    (bytes[offset + 1]! << 8) | bytes[offset]!,\n  )\n}\n","import QuickLRU from '@jbrowse/quick-lru'\n\nimport Chunk from './chunk.ts'\nimport IndexFile from './indexFile.ts'\nimport {\n  BaseOpts,\n  findFirstData,\n  optimizeChunks,\n  parsePseudoBin,\n} from './util.ts'\nimport { VirtualOffset, fromBytes } from './virtualOffset.ts'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nfunction roundDown(n: number, multiple: number) {\n  return n - (n % multiple)\n}\nfunction roundUp(n: number, multiple: number) {\n  return n - (n % multiple) + multiple\n}\n\nexport interface IndexCovEntry {\n  start: number\n  end: number\n  score: number\n}\n\nfunction reg2bins(beg: number, end: number) {\n  end -= 1\n  return [\n    [0, 0],\n    [1 + (beg >> 26), 1 + (end >> 26)],\n    [9 + (beg >> 23), 9 + (end >> 23)],\n    [73 + (beg >> 20), 73 + (end >> 20)],\n    [585 + (beg >> 17), 585 + (end >> 17)],\n    [4681 + (beg >> 14), 4681 + (end >> 14)],\n  ] as const\n}\n\nexport default class BAI extends IndexFile {\n  public setupP?: ReturnType<BAI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices(refId)?.stats?.lineCount || 0\n  }\n\n  async _parse(_opts?: BaseOpts) {\n    const bytes = await this.filehandle.readFile()\n    const dataView = new DataView(bytes.buffer)\n\n    // check BAI magic numbers\n    if (dataView.getUint32(0, true) !== BAI_MAGIC) {\n      throw new Error('Not a BAI file')\n    }\n\n    const refCount = dataView.getInt32(4, true)\n    const depth = 5\n    const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7\n\n    // read the indexes for each reference sequence\n    let curr = 8\n    let firstDataLine: VirtualOffset | undefined\n\n    const offsets = [] as number[]\n    for (let i = 0; i < refCount; i++) {\n      offsets.push(curr)\n      const binCount = dataView.getInt32(curr, true)\n\n      curr += 4\n\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = dataView.getUint32(curr, true)\n        curr += 4\n        if (bin === binLimit + 1) {\n          curr += 4\n          curr += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = dataView.getInt32(curr, true)\n          curr += 4\n          for (let k = 0; k < chunkCount; k++) {\n            curr += 8\n            curr += 8\n          }\n        }\n      }\n\n      const linearCount = dataView.getInt32(curr, true)\n      curr += 4\n      // as we're going through the linear index, figure out the smallest\n      // virtual offset in the indexes, which tells us where the BAM header\n      // ends\n      const linearIndex = new Array<VirtualOffset>(linearCount)\n      for (let j = 0; j < linearCount; j++) {\n        const offset = fromBytes(bytes, curr)\n        curr += 8\n        firstDataLine = findFirstData(firstDataLine, offset)\n        linearIndex[j] = offset\n      }\n    }\n    const indicesCache = new QuickLRU<number, ReturnType<typeof getIndices>>({\n      maxSize: 5,\n    })\n\n    function getIndices(refId: number) {\n      let curr = offsets[refId]\n      if (curr === undefined) {\n        return undefined\n      }\n      const binCount = dataView.getInt32(curr, true)\n      let stats\n\n      curr += 4\n      const binIndex: Record<number, Chunk[]> = {}\n\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = dataView.getUint32(curr, true)\n        curr += 4\n        if (bin === binLimit + 1) {\n          curr += 4\n          stats = parsePseudoBin(bytes, curr + 16)\n          curr += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = dataView.getInt32(curr, true)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k++) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      const linearCount = dataView.getInt32(curr, true)\n      curr += 4\n      // as we're going through the linear index, figure out the smallest\n      // virtual offset in the indexes, which tells us where the BAM header\n      // ends\n      const linearIndex = new Array<VirtualOffset>(linearCount)\n      for (let j = 0; j < linearCount; j++) {\n        const offset = fromBytes(bytes, curr)\n        curr += 8\n        firstDataLine = findFirstData(firstDataLine, offset)\n        linearIndex[j] = offset\n      }\n\n      return {\n        binIndex,\n        linearIndex,\n        stats,\n      }\n    }\n\n    return {\n      bai: true,\n      firstDataLine,\n      maxBlockSize: 1 << 16,\n      indices: (refId: number) => {\n        if (!indicesCache.has(refId)) {\n          const result = getIndices(refId)\n          if (result) {\n            indicesCache.set(refId, result)\n          }\n          return result\n        }\n        return indicesCache.get(refId)\n      },\n      refCount,\n    }\n  }\n\n  async indexCov(\n    seqId: number,\n    start?: number,\n    end?: number,\n    opts?: BaseOpts,\n  ): Promise<IndexCovEntry[]> {\n    const v = 16384\n    const range = start !== undefined\n    const indexData = await this.parse(opts)\n    const seqIdx = indexData.indices(seqId)\n\n    if (!seqIdx) {\n      return []\n    }\n    const { linearIndex, stats } = seqIdx\n    if (linearIndex.length === 0) {\n      return []\n    }\n    const e = end === undefined ? (linearIndex.length - 1) * v : roundUp(end, v)\n    const s = start === undefined ? 0 : roundDown(start, v)\n    const depths = range\n      ? new Array((e - s) / v)\n      : new Array(linearIndex.length - 1)\n    const totalSize = linearIndex[linearIndex.length - 1]!.blockPosition\n    if (e > (linearIndex.length - 1) * v) {\n      throw new Error('query outside of range of linear index')\n    }\n    let currentPos = linearIndex[s / v]!.blockPosition\n    for (let i = s / v, j = 0; i < e / v; i++, j++) {\n      depths[j] = {\n        score: linearIndex[i + 1]!.blockPosition - currentPos,\n        start: i * v,\n        end: i * v + v,\n      }\n      currentPos = linearIndex[i + 1]!.blockPosition\n    }\n    return depths.map(d => ({\n      ...d,\n      score: (d.score * (stats?.lineCount || 0)) / totalSize,\n    }))\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices(refId)\n\n    if (!ba) {\n      return []\n    }\n\n    // List of bin #s that overlap min, max\n    const overlappingBins = reg2bins(min, max)\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    const { binIndex } = ba\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        const binChunks = binIndex[bin]\n        if (binChunks) {\n          for (let i = 0, l = binChunks.length; i < l; i++) {\n            chunks.push(binChunks[i]!)\n          }\n        }\n      }\n    }\n\n    // Use the linear index to find minimum file position of chunks that could\n    // contain alignments in the region. Linear index entries are monotonically\n    // non-decreasing, so the first entry at minLin is the minimum.\n    const { linearIndex } = ba\n    const nintv = linearIndex.length\n    const minLin = Math.min(min >> 14, nintv - 1)\n    const lowest = linearIndex[minLin]\n\n    return optimizeChunks(chunks, lowest)\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices(seqId)?.binIndex\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\nimport QuickLRU from '@jbrowse/quick-lru'\n\nimport Chunk from './chunk.ts'\nimport IndexFile from './indexFile.ts'\nimport {\n  findFirstData,\n  optimizeChunks,\n  parseNameBytes,\n  parsePseudoBin,\n} from './util.ts'\nimport { VirtualOffset, fromBytes } from './virtualOffset.ts'\n\nimport type { BaseOpts } from './util.ts'\n\nconst CSI1_MAGIC = 21582659 // CSI\\1\nconst CSI2_MAGIC = 38359875 // CSI\\2\n\nfunction lshift(num: number, bits: number) {\n  return num * 2 ** bits\n}\nfunction rshift(num: number, bits: number) {\n  return Math.floor(num / 2 ** bits)\n}\n\nexport default class CSI extends IndexFile {\n  private maxBinNumber = 0\n  private depth = 0\n  private minShift = 0\n\n  public setupP?: ReturnType<CSI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices(refId)?.stats?.lineCount || 0\n  }\n\n  async indexCov() {\n    return []\n  }\n\n  parseAuxData(bytes: Uint8Array, offset: number) {\n    const dataView = new DataView(bytes.buffer)\n    const formatFlags = dataView.getUint32(offset, true)\n    const coordinateType =\n      formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    const format = (\n      { 0: 'generic', 1: 'SAM', 2: 'VCF' } as Record<number, string>\n    )[formatFlags & 0xf]\n    if (!format) {\n      throw new Error(`invalid Tabix preset format flags ${formatFlags}`)\n    }\n    const columnNumbers = {\n      ref: dataView.getInt32(offset + 4, true),\n      start: dataView.getInt32(offset + 8, true),\n      end: dataView.getInt32(offset + 12, true),\n    }\n    const metaValue = dataView.getInt32(offset + 16, true)\n    const metaChar = metaValue ? String.fromCharCode(metaValue) : ''\n    const skipLines = dataView.getInt32(offset + 20, true)\n    const nameSectionLength = dataView.getInt32(offset + 24, true)\n\n    return {\n      columnNumbers,\n      coordinateType,\n      metaValue,\n      metaChar,\n      skipLines,\n      format,\n      formatFlags,\n      ...parseNameBytes(\n        bytes.subarray(offset + 28, offset + 28 + nameSectionLength),\n        this.renameRefSeq,\n      ),\n    }\n  }\n\n  // fetch and parse the index\n  async _parse(opts: { signal?: AbortSignal }) {\n    const buffer = await this.filehandle.readFile(opts)\n    const bytes = await unzip(buffer)\n\n    const dataView = new DataView(bytes.buffer)\n    let csiVersion\n    const magic = dataView.getUint32(0, true)\n\n    if (magic === CSI1_MAGIC) {\n      csiVersion = 1\n    } else if (magic === CSI2_MAGIC) {\n      csiVersion = 2\n    } else {\n      throw new Error(`Not a CSI file ${magic}`)\n      // TODO: do we need to support big-endian CSI files?\n    }\n\n    this.minShift = dataView.getInt32(4, true)\n    this.depth = dataView.getInt32(8, true)\n    this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7\n    const maxBinNumber = this.maxBinNumber\n    const auxLength = dataView.getInt32(12, true)\n    const aux = auxLength >= 30 ? this.parseAuxData(bytes, 16) : undefined\n    const refCount = dataView.getInt32(16 + auxLength, true)\n\n    // read the indexes for each reference sequence\n    let curr = 16 + auxLength + 4\n    let firstDataLine: VirtualOffset | undefined\n    const offsets = [] as number[]\n    for (let i = 0; i < refCount; i++) {\n      offsets.push(curr)\n      const binCount = dataView.getInt32(curr, true)\n      curr += 4\n      for (let j = 0; j < binCount; j++) {\n        const bin = dataView.getUint32(curr, true)\n        curr += 4\n        if (bin > this.maxBinNumber) {\n          curr += 28 + 16\n        } else {\n          curr += 8\n          const chunkCount = dataView.getInt32(curr, true)\n          curr += 4\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n          }\n        }\n      }\n    }\n\n    const indicesCache = new QuickLRU<number, ReturnType<typeof getIndices>>({\n      maxSize: 5,\n    })\n\n    function getIndices(refId: number) {\n      let curr = offsets[refId]\n      if (curr === undefined) {\n        return undefined\n      }\n      // the binning index\n      const binCount = dataView.getInt32(curr, true)\n      curr += 4\n      const binIndex: Record<string, Chunk[]> = {}\n      let pseudoBinStats\n      for (let j = 0; j < binCount; j++) {\n        const bin = dataView.getUint32(curr, true)\n        curr += 4\n        if (bin > maxBinNumber) {\n          pseudoBinStats = parsePseudoBin(bytes, curr + 28)\n          curr += 28 + 16\n        } else {\n          firstDataLine = findFirstData(firstDataLine, fromBytes(bytes, curr))\n          curr += 8\n          const chunkCount = dataView.getInt32(curr, true)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      return {\n        binIndex,\n        stats: pseudoBinStats,\n      }\n    }\n\n    return {\n      csiVersion,\n      firstDataLine,\n      indices: (refId: number) => {\n        if (!indicesCache.has(refId)) {\n          const result = getIndices(refId)\n          if (result) {\n            indicesCache.set(refId, result)\n          }\n          return result\n        }\n        return indicesCache.get(refId)\n      },\n      refCount,\n      csi: true,\n      maxBlockSize: 1 << 16,\n      ...aux,\n    }\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    const ba = indexData.indices(refId)\n\n    if (!ba) {\n      return []\n    }\n    const overlappingBins = this.reg2bins(min, max)\n\n    if (overlappingBins.length === 0) {\n      return []\n    }\n\n    const chunks = []\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    const { binIndex } = ba\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        const binChunks = binIndex[bin]\n        if (binChunks) {\n          for (let i = 0, l = binChunks.length; i < l; i++) {\n            chunks.push(binChunks[i]!)\n          }\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, new VirtualOffset(0, 0))\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end)\n   * (zero-based half-open)\n   */\n  reg2bins(beg: number, end: number) {\n    beg -= 1 // < convert to 1-based closed\n    if (beg < 1) {\n      beg = 1\n    }\n    if (end > 2 ** 50) {\n      end = 2 ** 34\n    } // 17 GiB ought to be enough for anybody\n    end -= 1\n    let l = 0\n    let t = 0\n    let s = this.minShift + this.depth * 3\n    const bins = []\n    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n      const b = t + rshift(beg, s)\n      const e = t + rshift(end, s)\n      if (e - b + bins.length > this.maxBinNumber) {\n        throw new Error(\n          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,\n        )\n      }\n      bins.push([b, e] as const)\n    }\n    return bins\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices(seqId)?.binIndex\n  }\n}\n","export default class NullFilehandle {\n  public read(): Promise<any> {\n    throw new Error('never called')\n  }\n  public stat(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public readFile(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public close(): Promise<any> {\n    throw new Error('never called')\n  }\n}\n","export const CIGAR_MATCH = 0\nexport const CIGAR_INS = 1\nexport const CIGAR_DEL = 2\nexport const CIGAR_REF_SKIP = 3\nexport const CIGAR_SOFT_CLIP = 4\nexport const CIGAR_HARD_CLIP = 5\nexport const CIGAR_PAD = 6\nexport const CIGAR_EQUAL = 7\nexport const CIGAR_DIFF = 8\n","import { CIGAR_REF_SKIP, CIGAR_SOFT_CLIP } from './cigar.ts'\nimport Constants from './constants.ts'\n\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('')\n\n// precomputed pair orientation strings indexed by ((flags >> 4) & 0xF) | (isize > 0 ? 16 : 0)\n// bits 0-3 encode flag bits 0x10(reverse),0x20(mate reverse),0x40(read1),0x80(read2)\n// bit 4 encodes whether isize > 0\n// prettier-ignore\nconst PAIR_ORIENTATION_TABLE = [\n  'F F ','F R ','R F ','R R ','F2F1','F2R1','R2F1','R2R1',\n  'F1F2','F1R2','R1F2','R1R2','F2F1','F2R1','R2F1','R2R1',\n  'F F ','R F ','F R ','R R ','F1F2','R1F2','F1R2','R1R2',\n  'F2F1','R2F1','F2R1','R2R1','F1F2','R1F2','F1R2','R1R2',\n]\nconst ASCII_CIGAR_CODES = [\n  77, 73, 68, 78, 83, 72, 80, 61, 88, 63, 63, 63, 63, 63, 63, 63,\n]\n\n// Bitmask for ops that consume ref: M=0, D=2, N=3, P=6, ==7, X=8\n// Binary: 0b111001101 = 0x1CD\nconst CIGAR_CONSUMES_REF_MASK = 0x1cd\n\nexport interface Bytes {\n  start: number\n  end: number\n  byteArray: Uint8Array\n}\n\ninterface CIGAR_AND_LENGTH {\n  length_on_ref: number\n  NUMERIC_CIGAR: Uint32Array | number[]\n}\n\nexport default class BamRecord {\n  public fileOffset: number\n  private bytes: Bytes\n  private _dataView: DataView\n\n  private _cachedFlags?: number\n  private _cachedRefId?: number\n  private _cachedStart?: number\n  private _cachedEnd?: number\n  private _cachedTags?: Record<string, unknown>\n  private _cachedCigarAndLength?: CIGAR_AND_LENGTH\n  private _cachedNUMERIC_MD?: Uint8Array | null\n  private _cachedTagsStart?: number\n\n  constructor(args: { bytes: Bytes; fileOffset: number }) {\n    this.bytes = args.bytes\n    this.fileOffset = args.fileOffset\n    this._dataView = new DataView(this.bytes.byteArray.buffer)\n  }\n\n  get byteArray() {\n    return this.bytes.byteArray\n  }\n\n  get flags() {\n    if (this._cachedFlags === undefined) {\n      this._cachedFlags =\n        (this._dataView.getInt32(this.bytes.start + 16, true) & 0xffff0000) >>\n        16\n    }\n    return this._cachedFlags\n  }\n  get ref_id() {\n    if (this._cachedRefId === undefined) {\n      this._cachedRefId = this._dataView.getInt32(this.bytes.start + 4, true)\n    }\n    return this._cachedRefId\n  }\n\n  get start() {\n    if (this._cachedStart === undefined) {\n      this._cachedStart = this._dataView.getInt32(this.bytes.start + 8, true)\n    }\n    return this._cachedStart\n  }\n\n  get end() {\n    if (this._cachedEnd === undefined) {\n      this._cachedEnd = this.start + this.length_on_ref\n    }\n    return this._cachedEnd\n  }\n\n  get mq() {\n    const mq = (this.bin_mq_nl & 0xff00) >> 8\n    return mq === 255 ? undefined : mq\n  }\n\n  get score() {\n    return this.mq\n  }\n\n  get qual() {\n    if (this.isSegmentUnmapped()) {\n      return null\n    } else {\n      const p =\n        this.b0 +\n        this.read_name_length +\n        this.num_cigar_bytes +\n        this.num_seq_bytes\n      return this.byteArray.subarray(p, p + this.seq_length)\n    }\n  }\n\n  get strand() {\n    return this.isReverseComplemented() ? -1 : 1\n  }\n\n  get b0() {\n    return this.bytes.start + 36\n  }\n\n  get tagsStart() {\n    if (this._cachedTagsStart === undefined) {\n      this._cachedTagsStart =\n        this.b0 +\n        this.read_name_length +\n        this.num_cigar_bytes +\n        this.num_seq_bytes +\n        this.seq_length\n    }\n    return this._cachedTagsStart\n  }\n  // batch fromCharCode: fastest for typical name lengths (see benchmarks/string-building.bench.ts)\n  get name() {\n    const len = this.read_name_length - 1\n    const start = this.b0\n    const ba = this.byteArray\n    const codes = new Array(len)\n    for (let i = 0; i < len; i++) {\n      codes[i] = ba[start + i]!\n    }\n    return String.fromCharCode(...codes)\n  }\n\n  get NUMERIC_MD() {\n    if (this._cachedNUMERIC_MD === undefined) {\n      const result = this.getTagRaw('MD')\n      this._cachedNUMERIC_MD = result instanceof Uint8Array ? result : null\n    }\n    return this._cachedNUMERIC_MD === null ? undefined : this._cachedNUMERIC_MD\n  }\n\n  get tags() {\n    if (this._cachedTags === undefined) {\n      this._cachedTags = this._computeTags()\n    }\n    return this._cachedTags\n  }\n\n  getTag(tagName: string) {\n    if (this._cachedTags !== undefined) {\n      return this._cachedTags[tagName]\n    }\n    return this._findTag(tagName, false)\n  }\n\n  getTagRaw(tagName: string) {\n    return this._findTag(tagName, true)\n  }\n\n  private _findTag(tagName: string, raw: boolean) {\n    const tag1 = tagName.charCodeAt(0)\n    const tag2 = tagName.charCodeAt(1)\n\n    let p = this.tagsStart\n\n    const blockEnd = this.bytes.end\n    const ba = this.byteArray\n    while (p < blockEnd) {\n      const currentTag1 = ba[p]!\n      const currentTag2 = ba[p + 1]!\n      const type = ba[p + 2]!\n      p += 3\n\n      const isMatch = currentTag1 === tag1 && currentTag2 === tag2\n\n      switch (type) {\n        case 0x41: // 'A'\n          if (isMatch) {\n            return String.fromCharCode(ba[p]!)\n          }\n          p += 1\n          break\n        case 0x69: // 'i'\n          if (isMatch) {\n            return this._dataView.getInt32(p, true)\n          }\n          p += 4\n          break\n        case 0x49: // 'I'\n          if (isMatch) {\n            return this._dataView.getUint32(p, true)\n          }\n          p += 4\n          break\n        case 0x63: // 'c'\n          if (isMatch) {\n            return this._dataView.getInt8(p)\n          }\n          p += 1\n          break\n        case 0x43: // 'C'\n          if (isMatch) {\n            return this._dataView.getUint8(p)\n          }\n          p += 1\n          break\n        case 0x73: // 's'\n          if (isMatch) {\n            return this._dataView.getInt16(p, true)\n          }\n          p += 2\n          break\n        case 0x53: // 'S'\n          if (isMatch) {\n            return this._dataView.getUint16(p, true)\n          }\n          p += 2\n          break\n        case 0x66: // 'f'\n          if (isMatch) {\n            return this._dataView.getFloat32(p, true)\n          }\n          p += 4\n          break\n        case 0x5a: // 'Z'\n        case 0x48: {\n          // 'H'\n          if (isMatch) {\n            const start = p\n            while (p < blockEnd && ba[p] !== 0) {\n              p++\n            }\n            if (raw) {\n              return ba.subarray(start, p)\n            }\n            const value = []\n            for (let i = start; i < p; i++) {\n              value.push(String.fromCharCode(ba[i]!))\n            }\n            return value.join('')\n          }\n          while (p <= blockEnd && ba[p++] !== 0) {}\n          break\n        }\n        case 0x42: {\n          // 'B'\n          const Btype = ba[p++]!\n          const limit = this._dataView.getInt32(p, true)\n          p += 4\n          const absOffset = ba.byteOffset + p\n          if (isMatch) {\n            if (Btype === 0x69) {\n              // 'i'\n              if (absOffset % 4 === 0) {\n                return new Int32Array(ba.buffer, absOffset, limit)\n              }\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getInt32(p + i * 4, true)\n              }\n              return arr\n            } else if (Btype === 0x49) {\n              // 'I'\n              if (absOffset % 4 === 0) {\n                return new Uint32Array(ba.buffer, absOffset, limit)\n              }\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getUint32(p + i * 4, true)\n              }\n              return arr\n            } else if (Btype === 0x73) {\n              // 's'\n              if (absOffset % 2 === 0) {\n                return new Int16Array(ba.buffer, absOffset, limit)\n              }\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getInt16(p + i * 2, true)\n              }\n              return arr\n            } else if (Btype === 0x53) {\n              // 'S'\n              if (absOffset % 2 === 0) {\n                return new Uint16Array(ba.buffer, absOffset, limit)\n              }\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getUint16(p + i * 2, true)\n              }\n              return arr\n            } else if (Btype === 0x63) {\n              // 'c'\n              return new Int8Array(ba.buffer, absOffset, limit)\n            } else if (Btype === 0x43) {\n              // 'C'\n              return new Uint8Array(ba.buffer, absOffset, limit)\n            } else if (Btype === 0x66) {\n              // 'f'\n              if (absOffset % 4 === 0) {\n                return new Float32Array(ba.buffer, absOffset, limit)\n              }\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getFloat32(p + i * 4, true)\n              }\n              return arr\n            }\n          }\n          if (Btype === 0x69 || Btype === 0x49 || Btype === 0x66) {\n            p += limit << 2\n          } else if (Btype === 0x73 || Btype === 0x53) {\n            p += limit << 1\n          } else if (Btype === 0x63 || Btype === 0x43) {\n            p += limit\n          }\n          break\n        }\n      }\n    }\n    return undefined\n  }\n\n  private _computeTags() {\n    let p = this.tagsStart\n\n    const blockEnd = this.bytes.end\n    const ba = this.byteArray\n    const tags = {} as Record<string, unknown>\n    while (p < blockEnd) {\n      const tag = String.fromCharCode(ba[p]!, ba[p + 1]!)\n      const type = ba[p + 2]!\n      p += 3\n\n      switch (type) {\n        case 0x41: // 'A'\n          tags[tag] = String.fromCharCode(ba[p]!)\n          p += 1\n          break\n        case 0x69: // 'i'\n          tags[tag] = this._dataView.getInt32(p, true)\n          p += 4\n          break\n        case 0x49: // 'I'\n          tags[tag] = this._dataView.getUint32(p, true)\n          p += 4\n          break\n        case 0x63: // 'c'\n          tags[tag] = this._dataView.getInt8(p)\n          p += 1\n          break\n        case 0x43: // 'C'\n          tags[tag] = this._dataView.getUint8(p)\n          p += 1\n          break\n        case 0x73: // 's'\n          tags[tag] = this._dataView.getInt16(p, true)\n          p += 2\n          break\n        case 0x53: // 'S'\n          tags[tag] = this._dataView.getUint16(p, true)\n          p += 2\n          break\n        case 0x66: // 'f'\n          tags[tag] = this._dataView.getFloat32(p, true)\n          p += 4\n          break\n        case 0x5a: // 'Z'\n        case 0x48: {\n          // 'H'\n          const value = []\n          while (p <= blockEnd) {\n            const cc = ba[p++]!\n            if (cc !== 0) {\n              value.push(String.fromCharCode(cc))\n            } else {\n              break\n            }\n          }\n          tags[tag] = value.join('')\n          break\n        }\n        case 0x42: {\n          // 'B'\n          const Btype = ba[p++]!\n          const limit = this._dataView.getInt32(p, true)\n          p += 4\n          const absOffset = ba.byteOffset + p\n          if (Btype === 0x69) {\n            // 'i'\n            if (absOffset % 4 === 0) {\n              tags[tag] = new Int32Array(ba.buffer, absOffset, limit)\n            } else {\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getInt32(p + i * 4, true)\n              }\n              tags[tag] = arr\n            }\n            p += limit << 2\n          } else if (Btype === 0x49) {\n            // 'I'\n            if (absOffset % 4 === 0) {\n              tags[tag] = new Uint32Array(ba.buffer, absOffset, limit)\n            } else {\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getUint32(p + i * 4, true)\n              }\n              tags[tag] = arr\n            }\n            p += limit << 2\n          } else if (Btype === 0x73) {\n            // 's'\n            if (absOffset % 2 === 0) {\n              tags[tag] = new Int16Array(ba.buffer, absOffset, limit)\n            } else {\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getInt16(p + i * 2, true)\n              }\n              tags[tag] = arr\n            }\n            p += limit << 1\n          } else if (Btype === 0x53) {\n            // 'S'\n            if (absOffset % 2 === 0) {\n              tags[tag] = new Uint16Array(ba.buffer, absOffset, limit)\n            } else {\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getUint16(p + i * 2, true)\n              }\n              tags[tag] = arr\n            }\n            p += limit << 1\n          } else if (Btype === 0x63) {\n            // 'c'\n            tags[tag] = new Int8Array(ba.buffer, absOffset, limit)\n            p += limit\n          } else if (Btype === 0x43) {\n            // 'C'\n            tags[tag] = new Uint8Array(ba.buffer, absOffset, limit)\n            p += limit\n          } else if (Btype === 0x66) {\n            // 'f'\n            if (absOffset % 4 === 0) {\n              tags[tag] = new Float32Array(ba.buffer, absOffset, limit)\n            } else {\n              const arr: number[] = new Array(limit)\n              for (let i = 0; i < limit; i++) {\n                arr[i] = this._dataView.getFloat32(p + i * 4, true)\n              }\n              tags[tag] = arr\n            }\n            p += limit << 2\n          }\n          break\n        }\n        default:\n          console.error('Unknown BAM tag type', type)\n          break\n      }\n    }\n    return tags\n  }\n\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  get cigarAndLength() {\n    if (this._cachedCigarAndLength === undefined) {\n      this._cachedCigarAndLength = this._computeCigarAndLength()\n    }\n    return this._cachedCigarAndLength\n  }\n\n  // Benchmark results for CIGAR parsing strategies (see benchmarks/cigar-lifecycle.bench.ts):\n  //\n  // Aligned data:\n  //   - Plain array is 1.6-1.8x faster than Uint32Array for small CIGARs (50 ops)\n  //   - Uint32Array view is 1.3-2.2x faster for large CIGARs (200 ops)\n  //   - Crossover point is around 50-100 ops\n  //\n  // Unaligned data (requires slice+copy for Uint32Array):\n  //   - Plain array is 3.7-6.1x faster for typical sizes (50-200 ops)\n  //   - Plain array is 9-10x faster for small CIGARs (1-7 ops)\n  //   - Uint32Array slice+copy only wins at extreme sizes (10000 ops: 1.4x faster)\n  //\n  // Using |0 to force 32-bit integers in plain array path:\n  //   - 1.67x faster for medium CIGARs (50 ops)\n  //   - Neutral for small CIGARs (1-7 ops)\n  //\n  // Strategy: use plain array with |0 for small aligned (50 ops) and all unaligned,\n  // Uint32Array view only for large aligned CIGARs.\n  private _computeCigarAndLength() {\n    if (this.isSegmentUnmapped()) {\n      return {\n        length_on_ref: 0,\n        NUMERIC_CIGAR: new Uint32Array(0),\n      }\n    }\n\n    const numCigarOps = this.num_cigar_ops\n    let p = this.b0 + this.read_name_length\n\n    // check for CG tag by inspecting whether the CIGAR field contains a clip\n    // that consumes entire seqLen\n    const cigop = this._dataView.getInt32(p, true)\n    const lop = cigop >> 4\n    const op = cigop & 0xf\n    if (op === CIGAR_SOFT_CLIP && lop === this.seq_length) {\n      // if there is a CG the second CIGAR field will be a N tag the represents\n      // the length on ref\n      p += 4\n      const cigop = this._dataView.getInt32(p, true)\n      const lop = cigop >> 4\n      const op = cigop & 0xf\n      if (op !== CIGAR_REF_SKIP) {\n        console.warn('CG tag with no N tag')\n      }\n      const cgArray = this.tags.CG as Uint32Array\n      return {\n        NUMERIC_CIGAR: cgArray,\n        length_on_ref: lop,\n      }\n    }\n\n    const absOffset = this.byteArray.byteOffset + p\n    const isAligned = absOffset % 4 === 0\n\n    if (isAligned && numCigarOps > 50) {\n      const cigarView = new Uint32Array(\n        this.byteArray.buffer,\n        absOffset,\n        numCigarOps,\n      )\n      let lref = 0\n      for (let c = 0; c < numCigarOps; ++c) {\n        const cigop = cigarView[c]!\n        lref += (cigop >> 4) * ((CIGAR_CONSUMES_REF_MASK >> (cigop & 0xf)) & 1)\n      }\n      return {\n        NUMERIC_CIGAR: cigarView,\n        length_on_ref: lref,\n      }\n    }\n\n    const cigarArray: number[] = new Array(numCigarOps)\n    let lref = 0\n    for (let c = 0; c < numCigarOps; ++c) {\n      const cigop = this._dataView.getInt32(p + c * 4, true) | 0\n      cigarArray[c] = cigop\n      lref += (cigop >> 4) * ((CIGAR_CONSUMES_REF_MASK >> (cigop & 0xf)) & 1)\n    }\n    return {\n      NUMERIC_CIGAR: cigarArray,\n      length_on_ref: lref,\n    }\n  }\n\n  get length_on_ref() {\n    return this.cigarAndLength.length_on_ref\n  }\n\n  get NUMERIC_CIGAR() {\n    return this.cigarAndLength.NUMERIC_CIGAR\n  }\n\n  get CIGAR() {\n    const numeric = this.NUMERIC_CIGAR\n    let result = ''\n    for (let i = 0, l = numeric.length; i < l; i++) {\n      const packed = numeric[i]!\n      const length = packed >> 4\n      const opCode = ASCII_CIGAR_CODES[packed & 0xf]!\n      result += length + String.fromCharCode(opCode)\n    }\n    return result\n  }\n\n  get num_cigar_ops() {\n    return this.flag_nc & 0xffff\n  }\n\n  get num_cigar_bytes() {\n    return this.num_cigar_ops << 2\n  }\n\n  get read_name_length() {\n    return this.bin_mq_nl & 0xff\n  }\n\n  get num_seq_bytes() {\n    return (this.seq_length + 1) >> 1\n  }\n\n  get NUMERIC_SEQ() {\n    const p = this.b0 + this.read_name_length + this.num_cigar_bytes\n    return this.byteArray.subarray(p, p + this.num_seq_bytes)\n  }\n\n  get seq() {\n    const numeric = this.NUMERIC_SEQ\n    const len = this.seq_length\n    const buf = new Array(len)\n    let i = 0\n    const fullBytes = len >> 1\n\n    for (let j = 0; j < fullBytes; ++j) {\n      const sb = numeric[j]!\n      buf[i++] = SEQRET_DECODER[(sb & 0xf0) >> 4]\n      buf[i++] = SEQRET_DECODER[sb & 0x0f]\n    }\n\n    if (i < len) {\n      const sb = numeric[fullBytes]!\n      buf[i] = SEQRET_DECODER[(sb & 0xf0) >> 4]\n    }\n\n    return buf.join('')\n  }\n\n  // adapted from igv.js\n  // uses precomputed lookup table indexed by flag bits + isize sign\n  get pair_orientation() {\n    const f = this.flags\n    // combined check: unmapped (0x4) clear, mate unmapped (0x8) clear\n    if (f & 0xc || this.ref_id !== this.next_refid) {\n      return undefined\n    }\n    return PAIR_ORIENTATION_TABLE[\n      ((f >> 4) & 0xf) | (this.template_length > 0 ? 16 : 0)\n    ]\n  }\n\n  get bin_mq_nl() {\n    return this._dataView.getInt32(this.bytes.start + 12, true)\n  }\n\n  get flag_nc() {\n    return this._dataView.getInt32(this.bytes.start + 16, true)\n  }\n\n  get seq_length() {\n    return this._dataView.getInt32(this.bytes.start + 20, true)\n  }\n\n  get next_refid() {\n    return this._dataView.getInt32(this.bytes.start + 24, true)\n  }\n\n  get next_pos() {\n    return this._dataView.getInt32(this.bytes.start + 28, true)\n  }\n\n  get template_length() {\n    return this._dataView.getInt32(this.bytes.start + 32, true)\n  }\n\n  seqAt(idx: number): string | undefined {\n    if (idx < this.seq_length) {\n      const byteIndex = idx >> 1\n      const sb =\n        this.byteArray[\n          this.b0 + this.read_name_length + this.num_cigar_bytes + byteIndex\n        ]!\n\n      return idx % 2 === 0\n        ? SEQRET_DECODER[(sb & 0xf0) >> 4]\n        : SEQRET_DECODER[sb & 0x0f]\n    } else {\n      return undefined\n    }\n  }\n\n  toJSON() {\n    const data: Record<string, any> = {}\n    for (const k of Object.keys(this)) {\n      if (k.startsWith('_') || k === 'bytes') {\n        continue\n      }\n      // @ts-ignore\n      data[k] = this[k]\n    }\n\n    return data\n  }\n}\n","export default {\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n}\n","export function parseHeaderText(text: string) {\n  const lines = text.split(/\\r?\\n/)\n  const data: { tag: string; data: { tag: string; value: string }[] }[] = []\n  for (const line of lines) {\n    const [tag, ...fields] = line.split(/\\t/)\n    if (tag) {\n      data.push({\n        tag: tag.slice(1),\n        data: fields.map(f => {\n          const r = f.indexOf(':')\n          const fieldTag = f.slice(0, r)\n          const value = f.slice(r + 1)\n          return { tag: fieldTag, value }\n        }),\n      })\n    }\n  }\n  return data\n}\n","import { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle'\nimport QuickLRU from '@jbrowse/quick-lru'\nimport crc32 from 'crc/calculators/crc32'\nimport { LocalFile, RemoteFile } from 'generic-filehandle2'\n\nimport BAI from './bai.ts'\nimport Chunk from './chunk.ts'\nimport CSI from './csi.ts'\nimport NullFilehandle from './nullFilehandle.ts'\nimport BAMFeature from './record.ts'\nimport { parseHeaderText } from './sam.ts'\nimport {\n  filterCacheKey,\n  filterReadFlag,\n  filterTagValue,\n  makeOpts,\n} from './util.ts'\n\nimport type { Bytes } from './record.ts'\nimport type { BamOpts, BaseOpts, FilterBy } from './util.ts'\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport interface BamRecordLike {\n  ref_id: number\n  start: number\n  end: number\n  name: string\n  fileOffset: number\n  next_pos: number\n  next_refid: number\n  flags: number\n  tags: Record<string, unknown>\n}\n\nexport type BamRecordClass<T extends BamRecordLike = BAMFeature> = new (args: {\n  bytes: Bytes\n  fileOffset: number\n}) => T\n\nexport const BAM_MAGIC = 21840194\n\nconst blockLen = 1 << 16\n\ninterface ChunkEntry<T> {\n  minBlock: number\n  maxBlock: number\n  features: T[]\n}\n\nexport default class BamFile<T extends BamRecordLike = BAMFeature> {\n  public renameRefSeq: (a: string) => string\n  public bam: GenericFilehandle\n  public header?: string\n  public chrToIndex?: Record<string, number>\n  public indexToChr?: { refName: string; length: number }[]\n  public index?: BAI | CSI\n  public htsget = false\n  public headerP?: ReturnType<BamFile<T>['getHeaderPre']>\n\n  // Cache for parsed features by chunk\n  // When a new chunk overlaps a cached chunk, we evict the cached one\n  public chunkFeatureCache = new QuickLRU<string, ChunkEntry<T>>({\n    maxSize: 100,\n  })\n\n  private RecordClass: BamRecordClass<T>\n\n  constructor({\n    bamFilehandle,\n    bamPath,\n    bamUrl,\n    baiPath,\n    baiFilehandle,\n    baiUrl,\n    csiPath,\n    csiFilehandle,\n    csiUrl,\n    htsget,\n    renameRefSeqs = n => n,\n    recordClass,\n  }: {\n    bamFilehandle?: GenericFilehandle\n    bamPath?: string\n    bamUrl?: string\n    baiPath?: string\n    baiFilehandle?: GenericFilehandle\n    baiUrl?: string\n    csiPath?: string\n    csiFilehandle?: GenericFilehandle\n    csiUrl?: string\n    renameRefSeqs?: (a: string) => string\n    htsget?: boolean\n    recordClass?: BamRecordClass<T>\n  }) {\n    this.renameRefSeq = renameRefSeqs\n    this.RecordClass = (recordClass ?? BAMFeature) as BamRecordClass<T>\n\n    if (bamFilehandle) {\n      this.bam = bamFilehandle\n    } else if (bamPath) {\n      this.bam = new LocalFile(bamPath)\n    } else if (bamUrl) {\n      this.bam = new RemoteFile(bamUrl)\n    } else if (htsget) {\n      this.htsget = true\n      this.bam = new NullFilehandle()\n    } else {\n      throw new Error('unable to initialize bam')\n    }\n    if (csiFilehandle) {\n      this.index = new CSI({ filehandle: csiFilehandle })\n    } else if (csiPath) {\n      this.index = new CSI({ filehandle: new LocalFile(csiPath) })\n    } else if (csiUrl) {\n      this.index = new CSI({ filehandle: new RemoteFile(csiUrl) })\n    } else if (baiFilehandle) {\n      this.index = new BAI({ filehandle: baiFilehandle })\n    } else if (baiPath) {\n      this.index = new BAI({ filehandle: new LocalFile(baiPath) })\n    } else if (baiUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(baiUrl) })\n    } else if (bamPath) {\n      this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) })\n    } else if (bamUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) })\n    } else if (htsget) {\n      this.htsget = true\n    } else {\n      throw new Error('unable to infer index format')\n    }\n  }\n\n  async getHeaderPre(origOpts?: BaseOpts) {\n    const opts = makeOpts(origOpts)\n    if (!this.index) {\n      return undefined\n    }\n    const indexData = await this.index.parse(opts)\n\n    // firstDataLine is not defined in cases where there is no data in the file\n    // (just bam header and nothing else)\n    const buffer =\n      indexData.firstDataLine === undefined\n        ? await this.bam.readFile()\n        : // the logic indexData.firstDataLine is a virtualOffset telling us\n          // where the data is. It is in the middle of a virtualOffset\n          // (provided by the bgzip block offset at blockPosition + the\n          // virtualOffset dataPosition, so we add one extra blockLen to make\n          // sure we consume the full header)\n          await this.bam.read(\n            indexData.firstDataLine.blockPosition + blockLen,\n            0,\n          )\n    const uncba = await unzip(buffer)\n    const dataView = new DataView(uncba.buffer)\n\n    if (dataView.getInt32(0, true) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = dataView.getInt32(4, true)\n    const decoder = new TextDecoder('utf8')\n    this.header = decoder.decode(uncba.subarray(8, 8 + headLen))\n\n    const { chrToIndex, indexToChr } = this._parseRefSeqs(uncba, headLen + 8)\n    this.chrToIndex = chrToIndex\n    this.indexToChr = indexToChr\n    return parseHeaderText(this.header)\n  }\n\n  getHeader(opts?: BaseOpts) {\n    if (!this.headerP) {\n      this.headerP = this.getHeaderPre(opts).catch((e: unknown) => {\n        this.headerP = undefined\n        throw e\n      })\n    }\n    return this.headerP\n  }\n\n  async getHeaderText(opts: BaseOpts = {}) {\n    await this.getHeader(opts)\n    return this.header\n  }\n\n  _parseRefSeqs(\n    uncba: Uint8Array,\n    start: number,\n  ): {\n    chrToIndex: Record<string, number>\n    indexToChr: { refName: string; length: number }[]\n  } {\n    const dataView = new DataView(uncba.buffer)\n    const nRef = dataView.getInt32(start, true)\n    let p = start + 4\n\n    const chrToIndex: Record<string, number> = {}\n    const indexToChr: { refName: string; length: number }[] = []\n    const decoder = new TextDecoder('utf8')\n\n    for (let i = 0; i < nRef; i += 1) {\n      if (p + 8 > uncba.length) {\n        throw new Error(\n          `Insufficient data for reference sequences: need more than ${uncba.length} bytes`,\n        )\n      }\n\n      const lName = dataView.getInt32(p, true)\n      const refName = this.renameRefSeq(\n        decoder.decode(uncba.subarray(p + 4, p + 4 + lName - 1)),\n      )\n      const lRef = dataView.getInt32(p + lName + 4, true)\n\n      chrToIndex[refName] = i\n      indexToChr.push({\n        refName,\n        length: lRef,\n      })\n\n      p = p + 8 + lName\n    }\n\n    return { chrToIndex, indexToChr }\n  }\n\n  async getRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    await this.getHeader(opts)\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined || !this.index) {\n      return []\n    }\n    const chunks = await this.index.blocksForRange(chrId, min - 1, max, opts)\n    return this._fetchChunkFeaturesDirect(chunks, chrId, min, max, opts)\n  }\n\n  private chunkCacheKey(chunk: Chunk, filterBy?: FilterBy) {\n    const { minv, maxv } = chunk\n    return `${minv.blockPosition}:${minv.dataPosition}-${maxv.blockPosition}:${maxv.dataPosition}${filterCacheKey(filterBy)}`\n  }\n\n  private blocksOverlap(\n    minBlock1: number,\n    maxBlock1: number,\n    minBlock2: number,\n    maxBlock2: number,\n  ) {\n    return minBlock1 <= maxBlock2 && maxBlock1 >= minBlock2\n  }\n\n  // Evict any cached chunks that overlap with the given block range\n  private evictOverlappingChunks(minBlock: number, maxBlock: number) {\n    for (const [key, entry] of this.chunkFeatureCache) {\n      if (\n        this.blocksOverlap(minBlock, maxBlock, entry.minBlock, entry.maxBlock)\n      ) {\n        this.chunkFeatureCache.delete(key)\n      }\n    }\n  }\n\n  private async _fetchChunkFeaturesDirect(\n    chunks: Chunk[],\n    chrId: number,\n    min: number,\n    max: number,\n    opts: BamOpts = {},\n  ) {\n    const { viewAsPairs, filterBy } = opts\n    const { flagInclude = 0, flagExclude = 0, tagFilter } = filterBy || {}\n    const result: T[] = []\n\n    for (let ci = 0, cl = chunks.length; ci < cl; ci++) {\n      const chunk = chunks[ci]!\n      const cacheKey = this.chunkCacheKey(chunk, filterBy)\n      const minBlock = chunk.minv.blockPosition\n      const maxBlock = chunk.maxv.blockPosition\n\n      let records: T[]\n      const cached = this.chunkFeatureCache.get(cacheKey)\n      if (cached) {\n        records = cached.features\n      } else {\n        this.evictOverlappingChunks(minBlock, maxBlock)\n        const { data, cpositions, dpositions } = await this._readChunk({\n          chunk,\n          opts,\n        })\n        const allRecords = await this.readBamFeatures(\n          data,\n          cpositions,\n          dpositions,\n          chunk,\n        )\n        if (filterBy) {\n          records = []\n          for (let i = 0, l = allRecords.length; i < l; i++) {\n            const record = allRecords[i]!\n            if (filterReadFlag(record.flags, flagInclude, flagExclude)) {\n              continue\n            }\n            if (\n              tagFilter &&\n              filterTagValue(record.tags[tagFilter.tag], tagFilter.value)\n            ) {\n              continue\n            }\n            records.push(record)\n          }\n        } else {\n          records = allRecords\n        }\n        this.chunkFeatureCache.set(cacheKey, {\n          minBlock,\n          maxBlock,\n          features: records,\n        })\n      }\n\n      let done = false\n      for (let i = 0, l = records.length; i < l; i++) {\n        const feature = records[i]!\n        if (feature.ref_id === chrId) {\n          if (feature.start >= max) {\n            done = true\n            break\n          } else if (feature.end >= min) {\n            result.push(feature)\n          }\n        }\n      }\n      if (done) {\n        break\n      }\n    }\n\n    if (viewAsPairs) {\n      const pairs = await this.fetchPairs(chrId, result, opts)\n      for (let i = 0, l = pairs.length; i < l; i++) {\n        result.push(pairs[i]!)\n      }\n    }\n\n    return result\n  }\n\n  async fetchPairs(chrId: number, records: T[], opts: BamOpts) {\n    const { pairAcrossChr, maxInsertSize = 200000 } = opts\n    const readNameCounts: Record<string, number> = {}\n    const readIds: Record<number, number> = {}\n\n    for (let i = 0, l = records.length; i < l; i++) {\n      const r = records[i]!\n      const name = r.name\n      readNameCounts[name] = (readNameCounts[name] || 0) + 1\n      readIds[r.fileOffset] = 1\n    }\n\n    const matePromises: Promise<Chunk[]>[] = []\n    for (let i = 0, l = records.length; i < l; i++) {\n      const f = records[i]!\n      const name = f.name\n      if (\n        this.index &&\n        readNameCounts[name] === 1 &&\n        (pairAcrossChr ||\n          (f.next_refid === chrId &&\n            Math.abs(f.start - f.next_pos) < maxInsertSize))\n      ) {\n        matePromises.push(\n          this.index.blocksForRange(\n            f.next_refid,\n            f.next_pos,\n            f.next_pos + 1,\n            opts,\n          ),\n        )\n      }\n    }\n\n    const map = new Map<string, Chunk>()\n    const res = await Promise.all(matePromises)\n    for (let i = 0, l = res.length; i < l; i++) {\n      const chunks = res[i]!\n      for (let j = 0, jl = chunks.length; j < jl; j++) {\n        const m = chunks[j]!\n        const key = m.toString()\n        if (!map.has(key)) {\n          map.set(key, m)\n        }\n      }\n    }\n\n    const mateFeatPromises = await Promise.all(\n      [...map.values()].map(async c => {\n        const { data, cpositions, dpositions, chunk } = await this._readChunk({\n          chunk: c,\n          opts,\n        })\n        const mateRecs = [] as T[]\n        const features = await this.readBamFeatures(\n          data,\n          cpositions,\n          dpositions,\n          chunk,\n        )\n        for (let i = 0, l = features.length; i < l; i++) {\n          const feature = features[i]!\n          if (\n            readNameCounts[feature.name] === 1 &&\n            !readIds[feature.fileOffset]\n          ) {\n            mateRecs.push(feature)\n          }\n        }\n        return mateRecs\n      }),\n    )\n    return mateFeatPromises.flat()\n  }\n\n  async _readChunk({ chunk, opts }: { chunk: Chunk; opts: BaseOpts }) {\n    const buf = await this.bam.read(\n      chunk.fetchedSize(),\n      chunk.minv.blockPosition,\n      opts,\n    )\n\n    const {\n      buffer: data,\n      cpositions,\n      dpositions,\n    } = await unzipChunkSlice(buf, chunk)\n    return { data, cpositions, dpositions, chunk }\n  }\n\n  async readBamFeatures(\n    ba: Uint8Array,\n    cpositions: number[],\n    dpositions: number[],\n    chunk: Chunk,\n  ) {\n    let blockStart = 0\n    const sink = [] as T[]\n    let pos = 0\n\n    const dataView = new DataView(ba.buffer)\n    const hasDpositions = dpositions.length > 0\n    const hasCpositions = cpositions.length > 0\n\n    while (blockStart + 4 < ba.length) {\n      const blockSize = dataView.getInt32(blockStart, true)\n      const blockEnd = blockStart + 4 + blockSize - 1\n\n      if (hasDpositions) {\n        while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]!) {}\n        pos--\n      }\n\n      if (blockEnd < ba.length) {\n        const feature = new this.RecordClass({\n          bytes: {\n            byteArray: ba,\n            start: blockStart,\n            end: blockEnd,\n          },\n          fileOffset: hasCpositions\n            ? cpositions[pos]! * (1 << 8) +\n              (blockStart - dpositions[pos]!) +\n              chunk.minv.dataPosition +\n              1\n            : crc32(ba.subarray(blockStart, blockEnd)) >>> 0,\n        })\n\n        sink.push(feature)\n      }\n\n      blockStart = blockEnd + 1\n    }\n    return sink\n  }\n\n  async hasRefSeq(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? false : this.index?.hasRefSeq(seqId)\n  }\n\n  async lineCount(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined || !this.index ? 0 : this.index.lineCount(seqId)\n  }\n\n  async indexCov(seqName: string, start?: number, end?: number) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? [] : this.index.indexCov(seqId, start, end)\n  }\n\n  async blocksForRange(\n    seqName: string,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined\n      ? []\n      : this.index.blocksForRange(seqId, start, end, opts)\n  }\n\n  clearFeatureCache() {\n    this.chunkFeatureCache.clear()\n  }\n\n  async estimatedBytesForRegions(\n    regions: { refName: string; start: number; end: number }[],\n    opts?: BaseOpts,\n  ) {\n    if (!this.index) {\n      return 0\n    }\n    await this.getHeader(opts)\n    if (!this.chrToIndex) {\n      throw new Error('Header not yet parsed')\n    }\n    return this.index.estimatedBytesForRegions(\n      regions.map(r => {\n        const refId = this.chrToIndex![r.refName]\n        if (refId === undefined) {\n          throw new Error(`Unknown reference name: ${r.refName}`)\n        }\n        return {\n          refId,\n          start: r.start,\n          end: r.end,\n        }\n      }),\n      opts,\n    )\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\n\nimport BamFile, { BAM_MAGIC } from './bamFile.ts'\nimport Chunk from './chunk.ts'\nimport BamRecord from './record.ts'\nimport { parseHeaderText } from './sam.ts'\nimport { concatUint8Array } from './util.ts'\n\nimport type { BamRecordClass, BamRecordLike } from './bamFile.ts'\nimport type { BamOpts, BaseOpts } from './util.ts'\n\ninterface HtsgetChunk {\n  url: string\n  headers?: Record<string, string>\n}\n\nasync function concat(arr: HtsgetChunk[], opts?: Record<string, any>) {\n  const res = await Promise.all(\n    arr.map(async chunk => {\n      const { url, headers } = chunk\n      if (url.startsWith('data:')) {\n        // pass base64 data url to fetch to decode to buffer\n        // https://stackoverflow.com/a/54123275/2129219\n        const res = await fetch(url)\n        if (!res.ok) {\n          throw new Error('failed to decode base64')\n        }\n        const ret = await res.arrayBuffer()\n        return new Uint8Array(ret)\n      } else {\n        // remove referer header, it is not even allowed to be specified\n        // @ts-expect-error\n\n        const { referer, ...rest } = headers\n        const res = await fetch(url, {\n          ...opts,\n          headers: { ...opts?.headers, ...rest },\n        })\n        if (!res.ok) {\n          throw new Error(\n            `HTTP ${res.status} fetching ${url}: ${await res.text()}`,\n          )\n        }\n        return new Uint8Array(await res.arrayBuffer())\n      }\n    }),\n  )\n\n  return concatUint8Array(await Promise.all(res.map(elt => unzip(elt))))\n}\n\nexport default class HtsgetFile<\n  T extends BamRecordLike = BamRecord,\n> extends BamFile<T> {\n  private baseUrl: string\n\n  private trackId: string\n\n  constructor(args: {\n    trackId: string\n    baseUrl: string\n    recordClass?: BamRecordClass<T>\n  }) {\n    super({ htsget: true, recordClass: args.recordClass })\n    this.baseUrl = args.baseUrl\n    this.trackId = args.trackId\n  }\n\n  async getRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    const base = `${this.baseUrl}/${this.trackId}`\n    const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined) {\n      return []\n    }\n    const result = await fetch(url, { ...opts })\n    if (!result.ok) {\n      throw new Error(\n        `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n      )\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls.slice(1), opts)\n\n    const allRecords = await this.readBamFeatures(uncba, [], [], {\n      minv: { dataPosition: 0, blockPosition: 0 },\n      maxv: { dataPosition: 0, blockPosition: 0 },\n    } as Chunk)\n\n    const records: T[] = []\n    for (let i = 0, l = allRecords.length; i < l; i++) {\n      const feature = allRecords[i]!\n      if (feature.ref_id === chrId) {\n        if (feature.start >= max) {\n          break\n        } else if (feature.end >= min) {\n          records.push(feature)\n        }\n      }\n    }\n    return records\n  }\n\n  async getHeader(opts: BaseOpts = {}) {\n    const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`\n    const result = await fetch(url, opts)\n    if (!result.ok) {\n      throw new Error(\n        `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n      )\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls, opts)\n    const dataView = new DataView(uncba.buffer)\n\n    if (dataView.getInt32(0, true) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = dataView.getInt32(4, true)\n\n    const decoder = new TextDecoder('utf8')\n    const headerText = decoder.decode(uncba.subarray(8, 8 + headLen))\n    const samHeader = parseHeaderText(headerText)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ref ID numbers and names\n    const idToName: { refName: string; length: number }[] = []\n    const nameToId: Record<string, number> = {}\n    const sqLines = samHeader.filter(l => l.tag === 'SQ')\n    for (const [refId, sqLine] of sqLines.entries()) {\n      let refName = ''\n      let length = 0\n      for (const item of sqLine.data) {\n        if (item.tag === 'SN') {\n          refName = item.value\n        } else if (item.tag === 'LN') {\n          length = +item.value\n        }\n      }\n      nameToId[refName] = refId\n      idToName[refId] = { refName, length }\n    }\n    this.chrToIndex = nameToId\n    this.indexToChr = idToName\n    return samHeader\n  }\n}\n","// Generated by `./pycrc.py --algorithm=table-driven --model=crc-32 --generate=c`\nlet TABLE = [\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n];\nif (typeof Int32Array !== 'undefined') {\n    TABLE = new Int32Array(TABLE);\n}\nconst crc32 = (current, previous) => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    let crc = previous === 0 ? 0 : ~~previous ^ -1;\n    for (let index = 0; index < current.length; index++) {\n        crc = TABLE[(crc ^ current[index]) & 0xff] ^ (crc >>> 8);\n    }\n    return crc ^ -1;\n};\nexport default crc32;\n"],"names":["Chunk","constructor","minv","maxv","bin","_fetchedSize","toUniqueString","this","toString","fetchedSize","compareTo","b","undefined","blockPosition","longFromBytesToUnsigned","source","i","low","TWO_PWR_16_DBL","optimizeChunks","chunks","lowest","n","length","filtered","lowestBlock","lowestData","dataPosition","chunk","push","sort","c0","c1","dif","mergedChunks","lastChunk","lastMinBlock","lastMaxBlock","chunkMinBlock","chunkMaxBlock","chunkMaxv","lastMaxv","parsePseudoBin","bytes","offset","lineCount","findFirstData","firstDataLine","virtualOffset","parseNameBytes","namesBytes","renameRefSeq","s","currRefId","currNameStart","refIdToName","refNameToId","refName","j","String","fromCharCode","filterReadFlag","flags","flagInclude","flagExclude","filterTagValue","readVal","filterVal","IndexFile","filehandle","estimatedBytesForRegions","regions","opts","mergedBlocks","Promise","all","map","r","blocksForRange","refId","start","end","flat","total","block","VirtualOffset","fromBytes","bigendian","Error","BAI","indexData","parse","indices","stats","_parse","_opts","readFile","dataView","DataView","buffer","getUint32","refCount","getInt32","curr","offsets","binCount","binLimit","chunkCount","k","linearCount","linearIndex","Array","indicesCache","QuickLRU","maxSize","bai","maxBlockSize","has","result","binIndex","u","v","getIndices","set","get","indexCov","seqId","range","seqIdx","e","roundDown","depths","totalSize","currentPos","score","d","min","max","ba","overlappingBins","beg","binChunks","l","nintv","Math","setupP","catch","hasRefSeq","header","lshift","num","bits","rshift","floor","CSI","maxBinNumber","depth","minShift","parseAuxData","formatFlags","coordinateType","format","columnNumbers","ref","metaValue","metaChar","skipLines","nameSectionLength","subarray","unzip","csiVersion","magic","auxLength","aux","pseudoBinStats","csi","reg2bins","t","bins","NullFilehandle","read","stat","close","SEQRET_DECODER","split","PAIR_ORIENTATION_TABLE","ASCII_CIGAR_CODES","BamRecord","args","fileOffset","_dataView","byteArray","_cachedFlags","ref_id","_cachedRefId","_cachedStart","_cachedEnd","length_on_ref","mq","bin_mq_nl","qual","isSegmentUnmapped","p","b0","read_name_length","num_cigar_bytes","num_seq_bytes","seq_length","strand","isReverseComplemented","tagsStart","_cachedTagsStart","name","len","codes","NUMERIC_MD","_cachedNUMERIC_MD","getTagRaw","Uint8Array","tags","_cachedTags","_computeTags","getTag","tagName","_findTag","raw","tag1","charCodeAt","tag2","blockEnd","currentTag1","currentTag2","type","isMatch","getInt8","getUint8","getInt16","getUint16","getFloat32","value","join","Btype","limit","absOffset","byteOffset","Int32Array","arr","Uint32Array","Int16Array","Uint16Array","Int8Array","Float32Array","tag","cc","console","error","isPaired","isProperlyPaired","isMateUnmapped","isMateReverseComplemented","isRead1","isRead2","isSecondary","isFailedQc","isDuplicate","isSupplementary","cigarAndLength","_cachedCigarAndLength","_computeCigarAndLength","NUMERIC_CIGAR","numCigarOps","num_cigar_ops","cigop","lop","warn","CG","cigarView","lref","c","cigarArray","CIGAR","numeric","packed","opCode","flag_nc","NUMERIC_SEQ","seq","buf","fullBytes","sb","pair_orientation","f","next_refid","template_length","next_pos","seqAt","idx","byteIndex","toJSON","data","Object","keys","startsWith","parseHeaderText","text","lines","line","fields","slice","indexOf","BAM_MAGIC","BamFile","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","htsget","renameRefSeqs","recordClass","chunkFeatureCache","RecordClass","BAMFeature","bam","LocalFile","RemoteFile","index","getHeaderPre","origOpts","obj","signal","makeOpts","uncba","headLen","decoder","TextDecoder","decode","chrToIndex","indexToChr","_parseRefSeqs","getHeader","headerP","getHeaderText","nRef","lName","lRef","getRecordsForRange","chr","chrId","_fetchChunkFeaturesDirect","chunkCacheKey","filterBy","tagFilter","filterCacheKey","blocksOverlap","minBlock1","maxBlock1","minBlock2","maxBlock2","evictOverlappingChunks","minBlock","maxBlock","key","entry","delete","viewAsPairs","ci","cl","cacheKey","records","cached","features","cpositions","dpositions","_readChunk","allRecords","readBamFeatures","record","done","feature","pairs","fetchPairs","pairAcrossChr","maxInsertSize","readNameCounts","readIds","matePromises","abs","Map","res","jl","m","values","async","mateRecs","unzipChunkSlice","blockStart","sink","pos","hasDpositions","hasCpositions","crc32","seqName","clearFeatureCache","clear","concat","url","headers","fetch","ok","ret","arrayBuffer","referer","rest","status","totalLength","mergedArray","concatUint8Array","elt","HtsgetFile","super","baseUrl","trackId","json","urls","samHeader","idToName","nameToId","sqLines","filter","sqLine","entries","item","TABLE","current","previous","crc"],"sourceRoot":""}