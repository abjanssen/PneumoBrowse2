{"version":3,"file":"static/js/305.ca994aa3.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts","../../../plugins/gff3/src/featureData.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport gff from '@gmod/gff'\nimport { isGzip, updateStatus } from '@jbrowse/core/util'\n\nimport { featureData } from '../featureData'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  gffFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  private async loadDataP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const buf = (await openLocation(\n      this.getConf('gffLocation'),\n      this.pluginManager,\n    ).readFile(opts)) as Buffer\n    const buffer = isGzip(buf)\n      ? await updateStatus('Unzipping', statusCallback, () => unzip(buf))\n      : buf\n    const headerLines = []\n    const featureMap = {} as Record<string, string>\n    let blockStart = 0\n\n    const decoder =\n      typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined\n\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf('\\n', blockStart)\n      // could be a non-newline ended file, so subarray to end of file if n===-1\n      const b =\n        n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n)\n      const line = (decoder?.decode(b) || b.toString()).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else if (line.startsWith('>')) {\n          break\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = ''\n          }\n          featureMap[refName] += `${line}\\n`\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${Math.floor(blockStart / 1_000_000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1_000_000).toLocaleString('en-US')} MB`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing GFF data')\n            const intervalTree = new IntervalTree()\n            gff\n              .parseStringSync(lines, {\n                parseFeatures: true,\n                parseComments: false,\n                parseDirectives: false,\n                parseSequences: false,\n                disableDerivesFromReferences: true,\n              })\n              .flat()\n              .map(\n                (f, i) =>\n                  new SimpleFeature({\n                    data: featureData(f),\n                    id: `${this.id}-${refName}-${i}`,\n                  }),\n              )\n              .forEach(obj =>\n                intervalTree.insert([obj.get('start'), obj.get('end')], obj),\n              )\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header: headerLines.join('\\n'),\n      intervalTreeMap,\n    }\n  }\n\n  private async loadData(opts: BaseOptions) {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.loadData(opts)\n    return Object.keys(intervalTreeMap)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTreeMap } = await this.loadData(opts)\n        intervalTreeMap[refName]?.(opts.statusCallback)\n          .search([start, end])\n          .forEach(f => {\n            observer.next(f)\n          })\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(/* { region } */) {}\n}\n","import { GFF3FeatureLineWithRefs } from '@gmod/gff'\n\nexport function featureData(data: GFF3FeatureLineWithRefs) {\n  const f: Record<string, unknown> = { ...data }\n  ;(f.start as number) -= 1 // convert to interbase\n  if (data.strand === '+') {\n    f.strand = 1\n  } else if (data.strand === '-') {\n    f.strand = -1\n  } else if (data.strand === '.') {\n    f.strand = 0\n  } else {\n    f.strand = undefined\n  }\n  f.phase = data.phase === null ? undefined : Number(data.phase)\n  f.refName = data.seq_id\n  if (data.score === null) {\n    f.score = undefined\n  }\n\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_id',\n    'score',\n    'type',\n    'source',\n    'phase',\n    'strand',\n  ])\n  const dataAttributes = data.attributes || {}\n  for (const a of Object.keys(dataAttributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (dataAttributes[a]) {\n      let attr: string | string[] | undefined = dataAttributes[a]\n      if (Array.isArray(attr) && attr.length === 1) {\n        ;[attr] = attr\n      }\n      f[b] = attr\n    }\n  }\n  f.refName = f.seq_id\n\n  // the SimpleFeature constructor takes care of recursively inflating\n  // subfeatures\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (data.child_features && data.child_features.length > 0) {\n    f.subfeatures = data.child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    )\n  }\n\n  f.child_features = undefined\n  f.data = undefined\n  // delete f.derived_features\n  f.attributes = undefined\n  f.seq_id = undefined\n  return f\n}\n"],"names":["Gff3Adapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","loadDataP","opts","statusCallback","buf","openLocation","this","getConf","pluginManager","readFile","buffer","isGzip","updateStatus","unzip","headerLines","featureMap","blockStart","decoder","TextDecoder","undefined","i","length","n","indexOf","b","subarray","line","decode","toString","trim","startsWith","push","ret","refName","slice","Math","floor","toLocaleString","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","intervalTree","IntervalTree","gff","parseStringSync","parseFeatures","parseComments","parseDirectives","parseSequences","disableDerivesFromReferences","flat","f","SimpleFeature","data","featureData","id","forEach","obj","insert","get","header","join","loadData","gffFeatures","catch","e","getRefNames","keys","getHeader","getFeatures","query","ObservableCreate","async","start","end","search","observer","next","complete","error","signal","freeResources","strand","phase","Number","seq_id","score","defaultFields","Set","dataAttributes","attributes","a","toLowerCase","has","attr","Array","isArray","child_features","subfeatures","flatMap","childLocs","childLoc"],"sourceRoot":""}