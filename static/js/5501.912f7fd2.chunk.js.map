{"version":3,"file":"static/js/5501.912f7fd2.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../packages/core/src/util/parseLineByLine.ts","webpack://@jbrowse/web/../../plugins/bed/src/BedAdapter/BedAdapter.ts","webpack://@jbrowse/web/../../plugins/bed/src/generateRepeatMaskerFeature.ts","webpack://@jbrowse/web/../../plugins/bed/src/generateUcscTranscript.ts","webpack://@jbrowse/web/../../plugins/bed/src/util.ts","webpack://@jbrowse/web/../../plugins/bed/src/generateBedMethylFeature.ts"],"sourcesContent":["import { getProgressDisplayStr } from './index.ts'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n","import BED from '@gmod/bed'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  IntervalTree,\n  SimpleFeature,\n  fetchAndMaybeUnzip,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport { featureData } from '../util.ts'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nexport default class BedAdapter extends BaseFeatureDataAdapter {\n  protected bedFeatures?: Promise<{\n    header: string\n    features: Record<string, string[]>\n    parser: BED\n    columnNames: string[]\n    scoreColumn: string\n    colRef: number\n    colStart: number\n    colEnd: number\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree<Feature> | undefined> | undefined\n  > = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts?: BaseOptions) {\n    const bedLoc = this.getConf('bedLocation')\n    const buffer = await fetchAndMaybeUnzip(\n      openLocation(bedLoc, this.pluginManager),\n      opts,\n    )\n\n    const headerLines = [] as string[]\n    const features = {} as Record<string, string[]>\n    parseLineByLine(\n      buffer,\n      line => {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else {\n          const tab = line.indexOf('\\t')\n          const refName = line.slice(0, tab)\n          if (!features[refName]) {\n            features[refName] = []\n          }\n          features[refName].push(line)\n        }\n        return true\n      },\n      opts?.statusCallback,\n    )\n\n    const header = headerLines.join('\\n')\n    const autoSql = this.getConf('autoSql') as string\n    const parser = new BED({ autoSql })\n    const columnNames = this.getConf('columnNames')\n    const scoreColumn = this.getConf('scoreColumn')\n    const colRef = this.getConf('colRef')\n    const colStart = this.getConf('colStart')\n    const colEnd = this.getConf('colEnd')\n\n    return {\n      header,\n      features,\n      parser,\n      columnNames,\n      scoreColumn,\n      colRef,\n      colStart,\n      colEnd,\n    }\n  }\n\n  async loadData(opts: BaseOptions = {}) {\n    if (!this.bedFeatures) {\n      this.bedFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { features } = await this.loadData(opts)\n    return Object.keys(features)\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { colRef, colStart, colEnd, features, parser, scoreColumn } =\n      await this.loadData()\n    const lines = features[refName]\n    if (!lines) {\n      return undefined\n    }\n    const names = await this.getNames()\n\n    const intervalTree = new IntervalTree<Feature>()\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i]!\n      const uniqueId = `${this.id}-${refName}-${i}`\n      const feat = new SimpleFeature(\n        featureData({\n          line,\n          colRef,\n          colStart,\n          colEnd,\n          scoreColumn,\n          parser,\n          uniqueId,\n          names,\n        }),\n      )\n      intervalTree.insert([feat.get('start'), feat.get('end')], feat)\n    }\n\n    return intervalTree\n  }\n\n  async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch((e: unknown) => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureIntervalTree(refName)\n      const features = intervalTree?.search([start, end])\n      if (features) {\n        for (const f of features) {\n          observer.next(f)\n        }\n      }\n      observer.complete()\n    }, opts.stopToken)\n  }\n}\n","export function isRepeatMaskerDescriptionField(desc?: string): desc is string {\n  const ret = desc?.trim().split(' ')\n  return [0, 1, 2, 3, 5, 6].every(s =>\n    ret?.[s] !== undefined ? !Number.isNaN(+ret[s]) : false,\n  )\n}\n\nfunction makeRepeatTrackDescription(description?: string) {\n  if (isRepeatMaskerDescriptionField(description)) {\n    const [\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    ] = description.trim().split(' ')\n    return {\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    }\n  }\n  return { description }\n}\n\nexport function generateRepeatMaskerFeature({\n  uniqueId,\n  refName,\n  start,\n  end,\n  description,\n  ...rest\n}: {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  description: string\n  [key: string]: unknown\n}) {\n  const { subfeatures, ...rest2 } = rest\n  return {\n    ...rest2,\n    ...makeRepeatTrackDescription(description),\n    uniqueId,\n    refName,\n    start,\n    end,\n  }\n}\n","import type { MinimalFeature } from './types.ts'\n\nexport function isUcscTranscript({\n  thickStart,\n  blockCount,\n  strand,\n}: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return thickStart && blockCount && strand !== 0\n}\n\n/**\n * Calculate phase for each CDS based on cumulative widths.\n * Phase = (3 - cumulative_cds_width % 3) % 3\n * CDS must be in transcriptional order (5' to 3')\n */\nfunction calculatePhasesFromCds(\n  cdsRegions: { start: number; end: number }[],\n  strand: number,\n) {\n  // Sort in transcriptional order: ascending for +strand, descending for -strand\n  const sorted = [...cdsRegions].sort((a, b) =>\n    strand > 0 ? a.start - b.start : b.start - a.start,\n  )\n\n  const phaseMap = new Map<number, number>()\n  let cumulativeWidth = 0\n\n  for (const cds of sorted) {\n    // Phase is how many bases at the START of this CDS complete the previous codon\n    const phase = (3 - (cumulativeWidth % 3)) % 3\n    phaseMap.set(cds.start, phase)\n    cumulativeWidth += cds.end - cds.start\n  }\n\n  return phaseMap\n}\n\n/**\n * Convert UCSC exonFrames (reading frame 0,1,2) to GFF phase (bases to skip 0,1,2)\n * Frame 0 → phase 0 (first base at codon position 0, skip 0)\n * Frame 1 → phase 2 (first base at codon position 1, skip 2 to next codon)\n * Frame 2 → phase 1 (first base at codon position 2, skip 1 to next codon)\n */\nfunction frameToPhase(frame: number) {\n  return (3 - frame) % 3\n}\n\ninterface UcscTranscriptInput {\n  uniqueId: string\n  strand?: number\n  thickStart: number\n  thickEnd: number\n  refName: string\n  start: number\n  end: number\n  subfeatures: MinimalFeature[]\n  [key: string]: unknown\n}\n\ninterface UcscTranscriptOutput {\n  uniqueId: string\n  strand: number\n  type: string\n  refName: string\n  start: number\n  end: number\n  subfeatures: MinimalFeature[]\n  [key: string]: unknown\n}\n\nexport function generateUcscTranscript(\n  data: UcscTranscriptInput,\n): UcscTranscriptOutput {\n  const { strand = 0, uniqueId, start, end, ...rest } = data\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    refName,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    chromStarts: _4,\n    blockStarts: _5,\n    blockSizes: _6,\n    blockCount: _7,\n    ...rest2\n  } = rest\n\n  // exonFrames from bigGenePred - the @gmod/bed parser returns it in genomic order\n  const exonFrames = (rest2.exonFrames ?? rest2._exonFrames) as\n    | number[]\n    | undefined\n\n  const feats = oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n\n  const fiveUTR = strand > 0 ? 'five_prime_UTR' : 'three_prime_UTR'\n  const threeUTR = strand > 0 ? 'three_prime_UTR' : 'five_prime_UTR'\n\n  const { cdsEndStat, cdsStartStat } = rest2\n  if (cdsStartStat === 'none' && cdsEndStat === 'none') {\n    return {\n      ...rest2,\n      uniqueId,\n      strand,\n      type: 'transcript',\n      refName,\n      start,\n      end,\n      subfeatures: feats.map(e => ({ ...e, type: 'exon' })),\n    }\n  }\n\n  // If exonFrames not available, calculate phases from CDS regions\n  let calculatedPhases: Map<number, number> | undefined\n  if (!exonFrames) {\n    const cdsRegions: { start: number; end: number }[] = []\n    for (const block of feats) {\n      const { start, end } = block\n      if (thickStart < end && thickEnd > start) {\n        cdsRegions.push({\n          start: Math.max(start, thickStart),\n          end: Math.min(end, thickEnd),\n        })\n      }\n    }\n    calculatedPhases = calculatePhasesFromCds(cdsRegions, strand)\n  }\n\n  const subfeatures: MinimalFeature[] = []\n  for (const [i, feat] of feats.entries()) {\n    const block = feat\n    const { start, end } = block\n\n    if (thickStart >= end) {\n      // entire block is 5' UTR\n      subfeatures.push({ type: fiveUTR, start, end, refName })\n    } else if (thickEnd <= start) {\n      // entire block is 3' UTR\n      subfeatures.push({ type: threeUTR, start, end, refName })\n    } else {\n      // block overlaps CDS region - may have UTR on either side\n      if (start < thickStart) {\n        subfeatures.push({ type: fiveUTR, start, end: thickStart, refName })\n      }\n\n      const cdsStart = Math.max(start, thickStart)\n      const cdsEnd = Math.min(end, thickEnd)\n\n      // Get phase from exonFrames (with conversion) or calculated phases\n      let phase = 0\n      if (exonFrames) {\n        const frame = exonFrames[i]\n        if (frame !== undefined && frame >= 0) {\n          phase = frameToPhase(frame)\n        }\n      } else if (calculatedPhases) {\n        phase = calculatedPhases.get(cdsStart) ?? 0\n      }\n\n      subfeatures.push({\n        type: 'CDS',\n        phase,\n        start: cdsStart,\n        end: cdsEnd,\n        refName,\n      })\n\n      if (end > thickEnd) {\n        subfeatures.push({ type: threeUTR, start: thickEnd, end, refName })\n      }\n    }\n  }\n\n  return {\n    ...rest2,\n    uniqueId,\n    strand,\n    type: 'mRNA',\n    refName,\n    start,\n    end,\n    subfeatures,\n  }\n}\n","import {\n  generateBedMethylFeature,\n  isBedMethylFeature,\n} from './generateBedMethylFeature.ts'\nimport {\n  generateRepeatMaskerFeature,\n  isRepeatMaskerDescriptionField,\n} from './generateRepeatMaskerFeature.ts'\nimport {\n  generateUcscTranscript,\n  isUcscTranscript,\n} from './generateUcscTranscript.ts'\n\nimport type { MinimalFeature } from './types.ts'\nimport type BED from '@gmod/bed'\n\nfunction defaultParser(fields: string[], splitLine: string[]) {\n  const obj = {} as Record<string, string>\n  let hasBlockCount = false\n\n  for (const [i, element] of splitLine.entries()) {\n    const field = fields[i]\n    if (field) {\n      obj[field] = element!\n      if (field === 'blockCount') {\n        hasBlockCount = true\n      }\n    }\n  }\n\n  // heuristically try to determine whether to follow 'slow path' as there can\n  // be many features in e.g. GWAS type data\n  if (hasBlockCount) {\n    const {\n      blockStarts,\n      blockCount,\n      chromStarts,\n      thickEnd,\n      thickStart,\n      blockSizes,\n      ...rest\n    } = obj\n\n    return {\n      ...rest,\n      blockStarts: arrayify(blockStarts),\n      chromStarts: arrayify(chromStarts),\n      blockSizes: arrayify(blockSizes),\n      thickStart: thickStart ? +thickStart : undefined,\n      thickEnd: thickEnd ? +thickEnd : undefined,\n      blockCount: blockCount ? +blockCount : undefined,\n    } as Record<string, unknown>\n  }\n\n  return obj\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes?: number[]\n  blockStarts?: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts ?? blockStarts ?? []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] ?? 0) + start\n    const bsize = blockSizes?.[b]\n    if (bsize && bsize > 0) {\n      subfeatures.push({\n        uniqueId: `${uniqueId}-${b}`,\n        start: bmin,\n        end: bmin + bsize,\n        refName,\n        type: 'block',\n      })\n    }\n  }\n  return subfeatures\n}\n\nexport function featureData({\n  line,\n  colRef,\n  colStart,\n  colEnd,\n  scoreColumn,\n  parser,\n  uniqueId,\n  names,\n}: {\n  line: string\n  colRef: number\n  colStart: number\n  colEnd: number\n  scoreColumn: string\n  parser: BED\n  uniqueId: string\n  names?: string[]\n}) {\n  const splitLine = line.split('\\t')\n  const refName = splitLine[colRef]!\n  const start = Number.parseInt(splitLine[colStart]!, 10)\n  const end =\n    Number.parseInt(splitLine[colEnd]!, 10) + (colStart === colEnd ? 1 : 0)\n\n  return featureData2({\n    splitLine,\n    refName,\n    start,\n    end,\n    parser,\n    uniqueId,\n    scoreColumn,\n    names,\n  })\n}\n\nfunction parseStrand(strand: unknown) {\n  if (strand === '-' || strand === -1) {\n    return -1\n  }\n  if (strand === '+' || strand === 1) {\n    return 1\n  }\n  return 0\n}\n\ninterface FeatureData {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  strand?: number | string\n  score?: number\n  type?: string\n  subfeatures?: MinimalFeature[]\n  [key: string]: unknown\n}\n\nexport function featureData2({\n  splitLine,\n  refName,\n  start,\n  end,\n  parser,\n  uniqueId,\n  scoreColumn,\n  names,\n}: {\n  splitLine: string[]\n  refName: string\n  start: number\n  end: number\n  parser: BED\n  uniqueId: string\n  scoreColumn: string\n  names?: string[]\n}): FeatureData {\n  const data = names\n    ? defaultParser(names, splitLine)\n    : parser.parseLine(splitLine, { uniqueId })\n  const {\n    strand: strand2,\n    score: score2,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n\n  const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined\n  const strand = parseStrand(strand2)\n\n  const subfeatures = rest.blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts: rest.chromStarts,\n        blockCount: rest.blockCount,\n        blockSizes: rest.blockSizes,\n        blockStarts: rest.blockStarts,\n      })\n    : undefined\n\n  if (isBedMethylFeature({ splitLine, start, end })) {\n    return generateBedMethylFeature({\n      splitLine,\n      uniqueId,\n      refName,\n      start,\n      end,\n    })\n  }\n\n  if (isRepeatMaskerDescriptionField(rest.description)) {\n    const {\n      chromStarts: _4,\n      blockSizes: _5,\n      blockStarts: _6,\n      blockCount: _7,\n      thickStart: _8,\n      thickEnd: _9,\n      description,\n      ...rest2\n    } = rest\n    return generateRepeatMaskerFeature({\n      ...rest2,\n      description,\n      uniqueId,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    })\n  }\n\n  if (\n    subfeatures &&\n    isUcscTranscript({\n      strand,\n      blockCount: rest.blockCount,\n      thickStart: rest.thickStart,\n    })\n  ) {\n    return generateUcscTranscript({\n      ...rest,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      uniqueId,\n      subfeatures,\n      thickStart: rest.thickStart as number,\n      thickEnd: rest.thickEnd as number,\n    })\n  }\n\n  return {\n    ...rest,\n    uniqueId,\n    score,\n    start,\n    end,\n    strand,\n    refName,\n    subfeatures,\n  }\n}\n\nexport function arrayify(f?: string | number[]) {\n  if (f === undefined) {\n    return undefined\n  }\n  if (typeof f === 'string') {\n    return f.split(',').map(s => +s)\n  }\n  return f\n}\n","// this uses modkit bedMethyl. unclear how to reliably detect minimal 9+2 bedMethyl\nexport function isBedMethylFeature({\n  splitLine,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  start: number\n  end: number\n}) {\n  return (\n    +(splitLine[6] || 0) === start &&\n    +(splitLine[7] || 0) === end &&\n    [9, 10, 11, 12, 13, 14, 15, 16, 17].every(\n      r => splitLine[r] && !Number.isNaN(+splitLine[r]),\n    )\n  )\n}\n\nexport function generateBedMethylFeature({\n  splitLine,\n  uniqueId,\n  refName,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n}) {\n  // see\n  // https://github.com/nanoporetech/modkit?tab=readme-ov-file#description-of-bedmethyl-output\n  const [\n    ,\n    ,\n    ,\n    code,\n    ,\n    strand,\n    ,\n    ,\n    color,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  ] = splitLine\n\n  return {\n    uniqueId,\n    refName,\n    start,\n    end,\n    code,\n    score: +fraction_modified! || 0,\n    strand,\n    color,\n    source: code,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  }\n}\n"],"names":["parseLineByLine","buffer","lineCallback","statusCallback","decoder","TextDecoder","blockStart","i","length","n","indexOf","lineEnd","b","subarray","line","decode","trim","getProgressDisplayStr","BedAdapter","BaseFeatureDataAdapter","intervalTrees","loadDataP","opts","bedLoc","this","getConf","fetchAndMaybeUnzip","openLocation","pluginManager","headerLines","features","startsWith","push","tab","refName","slice","header","join","autoSql","parser","BED","columnNames","scoreColumn","colRef","colStart","colEnd","loadData","bedFeatures","catch","e","undefined","getRefNames","Object","keys","getHeader","getNames","defline","split","filter","f","at","includes","map","field","loadFeatureIntervalTreeHelper","lines","names","intervalTree","IntervalTree","uniqueId","id","feat","SimpleFeature","featureData","insert","get","loadFeatureIntervalTree","getFeatures","query","ObservableCreate","async","start","end","search","observer","next","complete","stopToken","isRepeatMaskerDescriptionField","desc","ret","every","s","Number","isNaN","makeRepeatTrackDescription","description","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","frameToPhase","frame","splitLine","featureData2","parseInt","data","fields","obj","hasBlockCount","element","entries","blockStarts","blockCount","chromStarts","thickEnd","thickStart","blockSizes","rest","arrayify","defaultParser","parseLine","strand","strand2","score","score2","chrom","_1","chromStart","_2","chromEnd","_3","parseStrand","subfeatures","starts","bmin","bsize","type","makeBlocks","r","isBedMethylFeature","code","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","source","generateBedMethylFeature","_4","_5","_6","_7","_8","_9","rest2","generateRepeatMaskerFeature","isUcscTranscript","oldSubfeatures","exonFrames","_exonFrames","feats","child","sort","a","fiveUTR","threeUTR","cdsEndStat","cdsStartStat","calculatedPhases","cdsRegions","block","Math","max","min","sorted","phaseMap","Map","cumulativeWidth","cds","phase","set","calculatePhasesFromCds","cdsStart","cdsEnd","generateUcscTranscript"],"sourceRoot":""}