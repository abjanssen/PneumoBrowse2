{"version":3,"file":"static/js/710.6a9917a8.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/alignments/src/BamAdapter/BamAdapter.ts","webpack://@jbrowse/web/../../plugins/alignments/src/shared/decodeSeq.ts","webpack://@jbrowse/web/../../plugins/alignments/src/BamAdapter/BamSlightlyLazyFeature.ts","webpack://@jbrowse/web/../../plugins/alignments/src/BamAdapter/forEachMismatchNumeric.ts","webpack://@jbrowse/web/../../plugins/alignments/src/PileupRenderer/renderers/cigarUtil.ts"],"sourcesContent":["import { BamFile } from '@gmod/bam'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature.ts'\nimport { parseSamHeader } from '../shared/util.ts'\n\nimport type { FilterBy } from '../shared/types.ts'\nimport type { ParsedSamHeader } from '../shared/util.ts'\nimport type {\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { Region } from '@jbrowse/core/util/types'\n\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n  public samHeader?: ParsedSamHeader\n\n  private setupP?: Promise<ParsedSamHeader>\n\n  protected configureResult?: { bam: BamFile<BamSlightlyLazyFeature> }\n\n  private sequenceAdapterP?: Promise<BaseSequenceAdapter | undefined>\n\n  protected configure() {\n    if (!this.configureResult) {\n      const bamLocation = this.getConf('bamLocation')\n      const location = this.getConf(['index', 'location'])\n      const indexType = this.getConf(['index', 'indexType'])\n      const csi = indexType === 'CSI'\n      this.configureResult = {\n        bam: new BamFile({\n          bamFilehandle: openLocation(bamLocation, this.pluginManager),\n          csiFilehandle: csi\n            ? openLocation(location, this.pluginManager)\n            : undefined,\n          baiFilehandle: !csi\n            ? openLocation(location, this.pluginManager)\n            : undefined,\n          recordClass: BamSlightlyLazyFeature,\n        }),\n      }\n    }\n    return this.configureResult\n  }\n\n  async getSequenceAdapter() {\n    const config = this.sequenceAdapterConfig\n    if (!config || !this.getSubAdapter) {\n      return undefined\n    }\n    this.sequenceAdapterP ??= this.getSubAdapter(config)\n      .then(r => {\n        const adapter = r.dataAdapter as BaseSequenceAdapter\n        // workaround for ChromSizesAdapter which doesn't have getSequence.\n        // sequence adapter is optional for BAM\n        return 'getSequence' in adapter ? adapter : undefined\n      })\n      .catch((e: unknown) => {\n        this.sequenceAdapterP = undefined\n        throw e\n      })\n    return this.sequenceAdapterP\n  }\n\n  async getHeader(_opts?: BaseOptions) {\n    const { bam } = this.configure()\n    return bam.getHeaderText()\n  }\n\n  private async setup(opts?: BaseOptions) {\n    const { statusCallback } = opts || {}\n    this.setupP ??= updateStatus(\n      'Downloading index',\n      statusCallback,\n      async () => {\n        try {\n          const { bam } = this.configure()\n          const rawHeader = await bam.getHeader()\n          this.samHeader = parseSamHeader(rawHeader ?? [])\n          return this.samHeader\n        } catch (e) {\n          this.setupP = undefined\n          this.configureResult = undefined\n          throw e\n        }\n      },\n    )\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { idToName } = await this.setup(opts)\n    return idToName\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy?: FilterBy\n    },\n  ) {\n    const { refName, start, end, originalRefName } = region\n    const { stopToken, filterBy, statusCallback = () => {} } = opts || {}\n    return ObservableCreate<Feature>(async observer => {\n      const { bam } = this.configure()\n      const sequenceAdapter = await this.getSequenceAdapter()\n      await this.setup(opts)\n      checkStopToken(stopToken)\n      const records = await updateStatus(\n        'Downloading alignments',\n        statusCallback,\n        () => bam.getRecordsForRange(refName, start, end, { filterBy }),\n      )\n      checkStopToken(stopToken)\n\n      await updateStatus('Processing alignments', statusCallback, async () => {\n        const { readName } = filterBy || {}\n\n        // Pre-fetch reference sequence for all records that need it\n        let regionSeq: string | undefined\n        let regionStart = Infinity\n        let regionEnd = 0\n        if (sequenceAdapter) {\n          for (const record of records) {\n            if (!record.NUMERIC_MD) {\n              regionStart = Math.min(regionStart, record.start)\n              regionEnd = Math.max(regionEnd, record.end)\n            }\n          }\n          if (regionEnd > 0) {\n            regionSeq = await sequenceAdapter.getSequence({\n              refName: originalRefName || refName,\n              start: regionStart,\n              end: regionEnd,\n            })\n          }\n        }\n\n        for (const record of records) {\n          if (readName && record.name !== readName) {\n            continue\n          }\n\n          // Set adapter reference for id() and refIdToName()\n          record.adapter = this\n\n          // Only fetch reference sequence if MD tag is missing\n          if (!record.NUMERIC_MD && regionSeq) {\n            record.ref = regionSeq.slice(\n              record.start - regionStart,\n              record.end - regionStart,\n            )\n          }\n\n          observer.next(record)\n        }\n        observer.complete()\n      })\n    })\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { bam } = this.configure()\n    // this is a method to avoid calling on htsget adapters\n    if (bam.index) {\n      const bytes = await bam.estimatedBytesForRegions(regions)\n      const fetchSizeLimit = this.getConf('fetchSizeLimit')\n      return {\n        bytes,\n        fetchSizeLimit,\n      }\n    }\n    return super.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  refIdToName(refId: number) {\n    return this.samHeader?.idToName[refId]\n  }\n}\n","// Sequence decoder matching @gmod/bam format\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('')\n\n// Decodes packed NUMERIC_SEQ (Uint8Array) to string\n// Each byte encodes 2 bases in 4-bit nibbles\nexport function decodeSeq(numericSeq: Uint8Array, seqLength: number): string {\n  const buf = new Array(seqLength)\n  let i = 0\n  const fullBytes = seqLength >> 1\n\n  for (let j = 0; j < fullBytes; ++j) {\n    const sb = numericSeq[j]!\n    buf[i++] = SEQRET_DECODER[(sb & 0xf0) >> 4]\n    buf[i++] = SEQRET_DECODER[sb & 0x0f]\n  }\n\n  if (i < seqLength) {\n    const sb = numericSeq[fullBytes]!\n    buf[i] = SEQRET_DECODER[(sb & 0xf0) >> 4]\n  }\n\n  return buf.join('')\n}\n\n// Gets a single base at position idx from NUMERIC_SEQ\nexport function seqAt(\n  numericSeq: Uint8Array,\n  idx: number,\n  seqLength: number,\n): string | undefined {\n  if (idx < seqLength) {\n    const byteIndex = idx >> 1\n    const sb = numericSeq[byteIndex]!\n    return idx % 2 === 0\n      ? SEQRET_DECODER[(sb & 0xf0) >> 4]\n      : SEQRET_DECODER[sb & 0x0f]\n  }\n  return undefined\n}\n","import { BamRecord } from '@gmod/bam'\n\nimport { forEachMismatchNumeric } from './forEachMismatchNumeric.ts'\nimport {\n  CHAR_FROM_CODE,\n  CIGAR_H,\n  CIGAR_S,\n} from '../PileupRenderer/renderers/cigarUtil.ts'\nimport { decodeSeq } from '../shared/decodeSeq.ts'\nimport {\n  HARDCLIP_TYPE,\n  INSERTION_TYPE,\n  MISMATCH_TYPE,\n  SOFTCLIP_TYPE,\n} from '../shared/forEachMismatchTypes.ts'\nimport { convertTagsToPlainArrays } from '../shared/util.ts'\n\nimport type BamAdapter from './BamAdapter.ts'\nimport type { MismatchCallback } from '../shared/forEachMismatchTypes.ts'\nimport type { Mismatch } from '../shared/types.ts'\nimport type { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\n\nexport default class BamSlightlyLazyFeature\n  extends BamRecord\n  implements Feature\n{\n  public adapter!: BamAdapter\n  public ref?: string\n  private _cachedFields?: SimpleFeatureSerialized\n\n  id() {\n    return `${this.adapter.id}-${this.fileOffset}`\n  }\n\n  get seq() {\n    return decodeSeq(this.NUMERIC_SEQ, this.seq_length)\n  }\n\n  // performance profiling showed that using forEachMismatch rather than\n  // computing mismatches array up front was faster, so this is no longer the\n  // primary way mismatches are used\n  get mismatches() {\n    const mismatches: Mismatch[] = []\n    this.forEachMismatch(\n      (type, start, length, base, qual, altbase, cliplen) => {\n        if (type === MISMATCH_TYPE) {\n          mismatches.push({\n            type: 'mismatch',\n            start,\n            length,\n            base,\n            qual: qual !== undefined && qual >= 0 ? qual : undefined,\n            altbase:\n              altbase !== undefined && altbase > 0\n                ? CHAR_FROM_CODE[altbase]\n                : undefined,\n          })\n        } else if (type === INSERTION_TYPE) {\n          mismatches.push({\n            type: 'insertion',\n            start,\n            length,\n            insertlen: cliplen!,\n            insertedBases: base,\n          })\n        } else if (type === SOFTCLIP_TYPE) {\n          mismatches.push({\n            type: 'softclip',\n            start,\n            length,\n            cliplen: cliplen!,\n          })\n        } else if (type === HARDCLIP_TYPE) {\n          mismatches.push({\n            type: 'hardclip',\n            start,\n            length,\n            cliplen: cliplen!,\n          })\n        } else {\n          mismatches.push({\n            type: type === 2 ? 'deletion' : 'skip',\n            start,\n            length,\n          })\n        }\n      },\n    )\n    return mismatches\n  }\n\n  forEachMismatch(callback: MismatchCallback) {\n    forEachMismatchNumeric(\n      this.NUMERIC_CIGAR,\n      this.NUMERIC_SEQ,\n      this.seq_length,\n      this.NUMERIC_MD,\n      this.qual,\n      this.ref,\n      callback,\n    )\n  }\n\n  get qualString() {\n    return this.qual?.join(' ')\n  }\n\n  get clipLengthAtStartOfRead() {\n    const cigar = this.NUMERIC_CIGAR\n    if (cigar.length === 0) {\n      return 0\n    }\n    const packed = this.strand === -1 ? cigar[cigar.length - 1]! : cigar[0]!\n    const op = packed & 0xf\n    if (op === CIGAR_S || op === CIGAR_H) {\n      return packed >> 4\n    }\n    return 0\n  }\n\n  get refName() {\n    return this.adapter.refIdToName(this.ref_id)!\n  }\n  get(field: string): any {\n    switch (field) {\n      case 'mismatches':\n        return this.mismatches\n      case 'name':\n        return this.name\n      case 'start':\n        return this.start\n      case 'refName':\n        return this.refName\n      case 'end':\n        return this.end\n      case 'strand':\n        return this.strand\n      case 'qual':\n        return this.qualString\n      case 'seq':\n        return this.seq\n      case 'tags':\n        return this.tags\n      case 'NUMERIC_SEQ':\n        return this.NUMERIC_SEQ\n      case 'NUMERIC_CIGAR':\n        return this.NUMERIC_CIGAR\n      case 'CIGAR':\n        return this.CIGAR\n      case 'NUMERIC_QUAL':\n        return this.qual\n      case 'NUMERIC_MD':\n        return this.NUMERIC_MD\n      case 'seq_length':\n        return this.seq_length\n      case 'flags':\n        return this.flags\n      case 'pair_orientation':\n        return this.pair_orientation\n      case 'next_ref':\n        return this.next_ref\n      case 'next_pos':\n        return this.next_pos\n      case 'template_length':\n        return this.template_length\n      case 'clipLengthAtStartOfRead':\n        return this.clipLengthAtStartOfRead\n\n      default:\n        return this.fields[field]\n    }\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  get fields(): SimpleFeatureSerialized {\n    if (this._cachedFields === undefined) {\n      this._cachedFields = {\n        start: this.start,\n        name: this.name,\n        end: this.end,\n        score: this.score,\n        strand: this.strand,\n        template_length: this.template_length,\n        flags: this.flags,\n        tags: this.tags,\n        refName: this.refName,\n        type: 'match',\n        pair_orientation: this.pair_orientation,\n        next_ref: this.next_ref,\n        next_pos: this.next_pos,\n        next_segment_position: this.next_segment_position,\n        uniqueId: this.id(),\n      }\n    }\n    return this._cachedFields\n  }\n  get next_ref() {\n    return this.isPaired()\n      ? this.adapter.refIdToName(this.next_refid)\n      : undefined\n  }\n\n  get next_segment_position() {\n    return this.isPaired()\n      ? `${this.adapter.refIdToName(this.next_refid)}:${this.next_pos + 1}`\n      : undefined\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...this.fields,\n      CIGAR: this.CIGAR,\n      seq: this.seq,\n      tags: convertTagsToPlainArrays(this.tags),\n      qual: this.qualString,\n    }\n  }\n}\n","import {\n  CIGAR_D,\n  CIGAR_H,\n  CIGAR_I,\n  CIGAR_M_EQ_MASK,\n  CIGAR_N,\n  CIGAR_S,\n  CIGAR_X,\n  SEQRET,\n  SEQRET_NUMERIC_DECODER,\n} from '../PileupRenderer/renderers/cigarUtil.ts'\nimport {\n  DELETION_TYPE,\n  HARDCLIP_TYPE,\n  INSERTION_TYPE,\n  MISMATCH_TYPE,\n  SKIP_TYPE,\n  SOFTCLIP_TYPE,\n} from '../shared/forEachMismatchTypes.ts'\n\nimport type { MismatchCallback } from '../shared/forEachMismatchTypes.ts'\n\n/**\n * Core mismatch iteration logic for BAM records.\n * Extracted as standalone function for testability.\n *\n * @param cigar - Packed CIGAR operations (Uint32Array)\n * @param numericSeq - Packed sequence (Uint8Array, 4-bit per base)\n * @param seqLength - Length of sequence\n * @param md - MD tag as byte array (or undefined)\n * @param qual - Quality scores (or undefined)\n * @param ref - Reference sequence for comparison when no MD tag\n * @param callback - Called for each mismatch/indel/clip\n */\nexport function forEachMismatchNumeric(\n  cigar: ArrayLike<number>,\n  numericSeq: ArrayLike<number>,\n  seqLength: number,\n  md: ArrayLike<number> | undefined,\n  qual: ArrayLike<number> | null | undefined,\n  ref: string | undefined,\n  callback: MismatchCallback,\n) {\n  // Fast path for reads with no sequence (e.g. secondary alignments with SEQ='*')\n  if (seqLength === 0) {\n    let roffset = 0\n    for (let i = 0, l = cigar.length; i < l; i++) {\n      const packed = cigar[i]!\n      const len = packed >> 4\n      const op = packed & 0xf\n      if ((1 << op) & CIGAR_M_EQ_MASK) {\n        roffset += len\n      } else if (op === CIGAR_I) {\n        callback(INSERTION_TYPE, roffset, 0, '*', -1, 0, len)\n      } else if (op === CIGAR_D) {\n        callback(DELETION_TYPE, roffset, len, '*', -1, 0, 0)\n        roffset += len\n      } else if (op === CIGAR_N) {\n        callback(SKIP_TYPE, roffset, len, 'N', -1, 0, 0)\n        roffset += len\n      } else if (op === CIGAR_S) {\n        callback(SOFTCLIP_TYPE, roffset, 1, `S${len}`, -1, 0, len)\n      } else if (op === CIGAR_H) {\n        callback(HARDCLIP_TYPE, roffset, 1, `H${len}`, -1, 0, len)\n      }\n    }\n    return\n  }\n\n  const mdLength = md?.length ?? 0\n  const hasQual = !!qual\n  const hasMD = md && mdLength > 0\n\n  let roffset = 0\n  let soffset = 0\n  let mdIdx = 0\n  let mdMatchRemaining = 0\n\n  if (hasMD) {\n    while (mdIdx < mdLength) {\n      const c = md[mdIdx]!\n      if (c >= 48 && c <= 57) {\n        mdMatchRemaining = mdMatchRemaining * 10 + (c - 48)\n        mdIdx++\n      } else {\n        break\n      }\n    }\n  }\n\n  for (let i = 0, l = cigar.length; i < l; i++) {\n    const packed = cigar[i]!\n    const len = packed >> 4\n    const op = packed & 0xf\n\n    if ((1 << op) & CIGAR_M_EQ_MASK) {\n      if (hasMD) {\n        let remaining = len\n        let localOffset = 0\n\n        while (remaining > 0) {\n          if (mdMatchRemaining >= remaining) {\n            mdMatchRemaining -= remaining\n            localOffset += remaining\n            remaining = 0\n          } else {\n            localOffset += mdMatchRemaining\n            remaining -= mdMatchRemaining\n            mdMatchRemaining = 0\n\n            if (mdIdx < mdLength && md[mdIdx]! >= 65 && md[mdIdx]! <= 90) {\n              const seqIdx = soffset + localOffset\n              const sb = numericSeq[seqIdx >> 1]!\n              const nibble = (sb >> ((1 - (seqIdx & 1)) << 2)) & 0xf\n\n              callback(\n                MISMATCH_TYPE,\n                roffset + localOffset,\n                1,\n                SEQRET[nibble]!,\n                hasQual ? qual[seqIdx]! : -1,\n                md[mdIdx],\n                0,\n              )\n\n              mdIdx++\n              localOffset++\n              remaining--\n              mdMatchRemaining = 0\n              while (mdIdx < mdLength) {\n                const c = md[mdIdx]!\n                if (c >= 48 && c <= 57) {\n                  mdMatchRemaining = mdMatchRemaining * 10 + (c - 48)\n                  mdIdx++\n                } else {\n                  break\n                }\n              }\n            } else {\n              break\n            }\n          }\n        }\n      } else if (ref) {\n        for (let j = 0; j < len; j++) {\n          const seqIdx = soffset + j\n          const sb = numericSeq[seqIdx >> 1]!\n          const nibble = (sb >> ((1 - (seqIdx & 1)) << 2)) & 0xf\n          const seqBaseCode = SEQRET_NUMERIC_DECODER[nibble]!\n          const refCharCode = ref.charCodeAt(roffset + j)\n          // Compare case-insensitively (| 0x20 converts uppercase to lowercase)\n          if (seqBaseCode !== (refCharCode | 0x20)) {\n            callback(\n              MISMATCH_TYPE,\n              roffset + j,\n              1,\n              SEQRET[nibble]!,\n              hasQual ? qual[seqIdx]! : -1,\n              refCharCode,\n              0,\n            )\n          }\n        }\n      }\n      soffset += len\n      roffset += len\n    } else if (op === CIGAR_I) {\n      // Optimized insertion base extraction - avoid string concat for common cases\n      let insertedBases: string\n      if (len === 1) {\n        // Single base insertion - most common case\n        const sb = numericSeq[soffset >> 1]!\n        const nibble = (sb >> ((1 - (soffset & 1)) << 2)) & 0xf\n        insertedBases = SEQRET[nibble]!\n      } else if (len === 2) {\n        // Two base insertion - second most common\n        const seqIdx0 = soffset\n        const sb0 = numericSeq[seqIdx0 >> 1]!\n        const nibble0 = (sb0 >> ((1 - (seqIdx0 & 1)) << 2)) & 0xf\n        const seqIdx1 = soffset + 1\n        const sb1 = numericSeq[seqIdx1 >> 1]!\n        const nibble1 = (sb1 >> ((1 - (seqIdx1 & 1)) << 2)) & 0xf\n        insertedBases = SEQRET[nibble0]! + SEQRET[nibble1]!\n      } else {\n        const bases = new Array<string>(len)\n        for (let j = 0; j < len; j++) {\n          const seqIdx = soffset + j\n          const sb = numericSeq[seqIdx >> 1]!\n          const nibble = (sb >> ((1 - (seqIdx & 1)) << 2)) & 0xf\n          bases[j] = SEQRET[nibble]!\n        }\n        insertedBases = bases.join('')\n      }\n      callback(INSERTION_TYPE, roffset, 0, insertedBases, -1, 0, len)\n      soffset += len\n    } else if (op === CIGAR_D) {\n      callback(DELETION_TYPE, roffset, len, '*', -1, 0, 0)\n\n      // eslint-disable-next-line @typescript-eslint/no-confusing-non-null-assertion\n      if (hasMD && mdIdx < mdLength && md[mdIdx]! === 94) {\n        mdIdx++\n        while (mdIdx < mdLength && md[mdIdx]! >= 65) {\n          mdIdx++\n        }\n        mdMatchRemaining = 0\n        while (mdIdx < mdLength) {\n          const c = md[mdIdx]!\n          if (c >= 48 && c <= 57) {\n            mdMatchRemaining = mdMatchRemaining * 10 + (c - 48)\n            mdIdx++\n          } else {\n            break\n          }\n        }\n      }\n      roffset += len\n    } else if (op === CIGAR_N) {\n      callback(SKIP_TYPE, roffset, len, 'N', -1, 0, 0)\n      roffset += len\n    } else if (op === CIGAR_X) {\n      for (let j = 0; j < len; j++) {\n        const seqIdx = soffset + j\n        const sb = numericSeq[seqIdx >> 1]!\n        const nibble = (sb >> ((1 - (seqIdx & 1)) << 2)) & 0xf\n\n        let altbaseCode = 0\n        if (hasMD) {\n          if (mdMatchRemaining === 0 && mdIdx < mdLength && md[mdIdx]! >= 65) {\n            altbaseCode = md[mdIdx]!\n            mdIdx++\n            mdMatchRemaining = 0\n            while (mdIdx < mdLength) {\n              const c = md[mdIdx]!\n              if (c >= 48 && c <= 57) {\n                mdMatchRemaining = mdMatchRemaining * 10 + (c - 48)\n                mdIdx++\n              } else {\n                break\n              }\n            }\n          } else if (mdMatchRemaining > 0) {\n            mdMatchRemaining--\n          }\n        } else if (ref) {\n          // No MD tag - get reference base from ref string\n          altbaseCode = ref.charCodeAt(roffset + j)\n        }\n\n        callback(\n          MISMATCH_TYPE,\n          roffset + j,\n          1,\n          SEQRET[nibble]!,\n          hasQual ? qual[seqIdx]! : -1,\n          altbaseCode,\n          0,\n        )\n      }\n      soffset += len\n      roffset += len\n    } else if (op === CIGAR_S) {\n      callback(SOFTCLIP_TYPE, roffset, 1, `S${len}`, -1, 0, len)\n      soffset += len\n    } else if (op === CIGAR_H) {\n      callback(HARDCLIP_TYPE, roffset, 1, `H${len}`, -1, 0, len)\n    }\n  }\n}\n","import { parseCigar2 } from '../../MismatchParser/index.ts'\n\n// CIGAR operation indices (from BAM spec) - used in packed Uint32Array format\nexport const CIGAR_M = 0\nexport const CIGAR_I = 1\nexport const CIGAR_D = 2\nexport const CIGAR_N = 3\nexport const CIGAR_S = 4\nexport const CIGAR_H = 5\nexport const CIGAR_P = 6\nexport const CIGAR_EQ = 7\nexport const CIGAR_X = 8\n\n// Bitmasks for CIGAR operation categories (use with: (1 << op) & MASK)\n// Alignment match ops (M=0, ==7) - may contain mismatches, need MD tag\nexport const CIGAR_M_EQ_MASK = 0b10000001 // (1<<0)|(1<<7) = 129\n// Match/mismatch ops that consume both ref and seq (M=0, ==7, X=8)\nexport const CIGAR_MATCH_MASK = 0b110000001 // (1<<0)|(1<<7)|(1<<8) = 385\n// Seq-only ops (S=4, I=1)\nexport const CIGAR_SEQ_ONLY_MASK = 0b10010 // (1<<1)|(1<<4) = 18\n// Ref-skip ops (D=2, N=3)\nexport const CIGAR_REF_SKIP_MASK = 0b1100 // (1<<2)|(1<<3) = 12\n// Ref-consuming ops (M=0, D=2, ==7, X=8)\nexport const CIGAR_REF_CONSUMING_MASK = 0b110000101 // (1<<0)|(1<<2)|(1<<7)|(1<<8) = 389\n\n// BAM 4-bit encoded sequence lookup table\nexport const SEQRET = '=ACMGRSVTWYHKDBN'\n\n// Numeric decoder - returns char codes directly (lowercase for case-insensitive comparison)\n// '=' = 61, 'a' = 97, 'c' = 99, 'm' = 109, 'g' = 103, 'r' = 114, 's' = 115, 'v' = 118,\n// 't' = 116, 'w' = 119, 'y' = 121, 'h' = 104, 'k' = 107, 'd' = 100, 'b' = 98, 'n' = 110\nexport const SEQRET_NUMERIC_DECODER = new Uint8Array([\n  61, 97, 99, 109, 103, 114, 115, 118, 116, 119, 121, 104, 107, 100, 98, 110,\n])\n\n// Pre-computed char lookup for ASCII codes (avoids String.fromCharCode in hot loops)\nexport const CHAR_FROM_CODE: string[] = Array.from({ length: 128 }, (_, i) =>\n  String.fromCharCode(i),\n)\n\n// Helper to ensure we have Uint32Array (packed format)\nexport function getCigarOps(\n  cigar: Uint32Array | string | undefined,\n): ArrayLike<number> {\n  return typeof cigar === 'string' ? parseCigar2(cigar) : cigar || []\n}\n"],"names":["BamAdapter","BaseFeatureDataAdapter","configure","this","configureResult","bamLocation","getConf","location","csi","bam","BamFile","bamFilehandle","openLocation","pluginManager","csiFilehandle","undefined","baiFilehandle","recordClass","BamSlightlyLazyFeature","getSequenceAdapter","config","sequenceAdapterConfig","getSubAdapter","sequenceAdapterP","then","r","adapter","dataAdapter","catch","e","getHeader","_opts","getHeaderText","setup","opts","statusCallback","setupP","updateStatus","async","rawHeader","samHeader","parseSamHeader","getRefNames","idToName","getFeatures","region","refName","start","end","originalRefName","stopToken","filterBy","ObservableCreate","sequenceAdapter","checkStopToken","records","getRecordsForRange","readName","regionSeq","regionStart","Infinity","regionEnd","record","NUMERIC_MD","Math","min","max","getSequence","name","ref","slice","observer","next","complete","getMultiRegionFeatureDensityStats","regions","index","bytes","estimatedBytesForRegions","fetchSizeLimit","super","refIdToName","refId","SEQRET_DECODER","split","BamRecord","id","fileOffset","seq","numericSeq","seqLength","buf","Array","i","fullBytes","j","sb","join","decodeSeq","NUMERIC_SEQ","seq_length","mismatches","forEachMismatch","type","length","base","qual","altbase","cliplen","MISMATCH_TYPE","push","CHAR_FROM_CODE","INSERTION_TYPE","insertlen","insertedBases","SOFTCLIP_TYPE","HARDCLIP_TYPE","callback","cigar","md","roffset","l","packed","len","op","CIGAR_M_EQ_MASK","CIGAR_I","CIGAR_D","DELETION_TYPE","CIGAR_N","SKIP_TYPE","CIGAR_S","CIGAR_H","mdLength","hasQual","hasMD","soffset","mdIdx","mdMatchRemaining","c","remaining","localOffset","seqIdx","nibble","SEQRET","seqBaseCode","SEQRET_NUMERIC_DECODER","refCharCode","charCodeAt","seqIdx0","nibble0","seqIdx1","nibble1","bases","CIGAR_X","altbaseCode","forEachMismatchNumeric","NUMERIC_CIGAR","qualString","clipLengthAtStartOfRead","strand","ref_id","get","field","tags","CIGAR","flags","pair_orientation","next_ref","next_pos","template_length","fields","parent","children","_cachedFields","score","next_segment_position","uniqueId","isPaired","next_refid","toJSON","convertTagsToPlainArrays","CIGAR_M","CIGAR_EQ","CIGAR_REF_CONSUMING_MASK","Uint8Array","from","_","String","fromCharCode","getCigarOps","parseCigar2"],"sourceRoot":""}