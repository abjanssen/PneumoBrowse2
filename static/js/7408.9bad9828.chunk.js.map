{"version":3,"file":"static/js/7408.9bad9828.chunk.js","mappings":"2LAUO,SAASA,EAAiBC,GAC/B,MAAMC,GAAgBC,EAAAA,EAAAA,GAAwB,CAC5CF,OACAG,cAAe,8BACfC,aAAcA,IAAMJ,EAAKK,cACzBC,SAAUA,UAGZC,EAAAA,EAAAA,IACEP,EACAQ,WACOC,EAAAA,EAAAA,SAAQT,IAIbC,KAEF,CACES,MAAO,IACPC,KAAM,mBAIVC,EAAAA,EAAAA,GAA4BZ,EAC9B,C,oICoBO,SAASE,GAGd,KAAEF,EAAI,cAAEG,EAAa,aAAEC,EAAY,SAAEE,IACrC,OAAOE,UACL,MAAMK,GAAOC,EAAAA,EAAAA,mBAAkBd,GAE/B,IACGa,EAAKE,aACNf,EAAKgB,QACJhB,EAAKiB,6CAEN,OAGF,MAAM,QAAEC,GAAYL,EAEpB,IACE,MAAMM,GAAUC,EAAAA,EAAAA,YAAWpB,IACrB,WAAEqB,EAAU,gBAAEC,GAAoBH,EAClCI,EAAeV,EAAKW,cAAc,GACxC,IAAKD,EACH,OAGF,MAAME,EAAWH,EAAgBI,IAAIH,GAC/BI,EAAwBF,GAAUG,eAAeC,UAAUC,QAC3DC,EAAkBJ,GACpBK,EAAAA,EAAAA,aAAYL,QACZM,EAEEC,GAAgBC,EAAAA,EAAAA,WAAU,IAAMnC,EAAKoC,oBACvCF,IACFG,EAAAA,EAAAA,IAAcH,GAGhB,MAAMI,GAAYC,EAAAA,EAAAA,MAClBvC,EAAKwC,sBAAsBF,GAC3BtC,EAAKyC,YAAW,GAChBzC,EAAK0C,kBAAiB,GAEtB,MAAMC,EAAe,CACnBC,iBAAkBC,gBAAgBhC,EAAK+B,kBACvC1B,QAASL,EAAKK,QACd4B,SAAUjC,EAAKiC,SACfC,wBAAyBlC,EAAKkC,wBAC9BC,kBAAmBnC,EAAKmC,kBACxBC,MAAOpC,EAAKoC,OAGRC,GAAYC,EAAAA,EAAAA,iBAAgBnD,GAC5BoD,EAAgBpD,EAAKoD,cACrBC,GAASrB,EAAAA,EAAAA,aAAYhC,EAAK4B,eAC1B0B,QAAgBjC,EAAWkC,KAAKL,EAAW/C,EAAe,CAC9D+C,YACArC,KAAM8B,EACNS,gBACArB,kBACAsB,SACAG,eAAiBC,KACXhD,EAAAA,EAAAA,SAAQT,IACVA,EAAK0D,mBAAmBD,IAG5BnB,eACGlC,EAAa,CAAES,OAAMM,UAASY,kBAAiBO,gBAGhDgB,EAAOK,YACT3D,EAAK4D,sBAAsBN,EAAOK,gBACV1B,IAApBqB,EAAOR,UACT9C,EAAK6D,qBAAqBP,EAAOR,UAEnCxC,EAASgD,IAGXtD,EAAK8D,oBAAoB5C,EAC3B,CAAE,MAAOF,IACF+C,EAAAA,EAAAA,IAAiB/C,KACpBgD,QAAQhD,MAAMA,GACdhB,EAAKiE,SAASjD,GAElB,CAAE,QACAhB,EAAKwC,2BAAsBP,GAC3BjC,EAAKyC,YAAW,EAClB,EAEJ,CAEO,SAAS7B,EACdZ,IAEAO,EAAAA,EAAAA,IACEP,EACAQ,UACE,MAAM0D,GAAUC,EAAAA,EAAAA,IAAoBnE,EAAKoE,IAAKpE,EAAKqE,qBAC/C5D,EAAAA,EAAAA,SAAQT,IACVA,EAAK0C,iBAAiBwB,IAG1B,CACEvD,KAAM,uBAGZ,C","sources":["webpack://@jbrowse/web/../../plugins/alignments/src/LinearReadArcsDisplay/afterAttachRPC.tsx","webpack://@jbrowse/web/../../plugins/alignments/src/shared/createRPCRenderingSetup.ts"],"sourcesContent":["import { isAlive } from '@jbrowse/mobx-state-tree'\n\nimport {\n  createRPCRenderFunction,\n  setupCanvasRenderingAutorun,\n} from '../shared/createRPCRenderingSetup.ts'\nimport { createAutorun } from '../util.ts'\n\nimport type { LinearReadArcsDisplayModel } from './model.ts'\n\nexport function doAfterAttachRPC(self: LinearReadArcsDisplayModel) {\n  const performRender = createRPCRenderFunction({\n    self,\n    rpcMethodName: 'RenderLinearReadArcsDisplay',\n    getRPCParams: () => self.renderProps(),\n    onResult: () => {},\n  })\n\n  createAutorun(\n    self,\n    async () => {\n      if (!isAlive(self)) {\n        return\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      performRender()\n    },\n    {\n      delay: 1000,\n      name: 'PerformRender',\n    },\n  )\n\n  setupCanvasRenderingAutorun(self)\n}\n","import {\n  getContainingView,\n  getSession,\n  isAbortException,\n} from '@jbrowse/core/util'\nimport { createStopToken, stopStopToken } from '@jbrowse/core/util/stopToken'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\nimport { getSnapshot, isAlive } from '@jbrowse/mobx-state-tree'\nimport { drawCanvasImageData } from '@jbrowse/plugin-linear-genome-view'\nimport { untracked } from 'mobx'\n\nimport { createAutorun } from '../util.ts'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface RPCRenderableModel {\n  id: string\n  error: unknown\n  featureDensityStatsReadyAndRegionNotTooLarge: boolean\n  effectiveRpcDriverName: string\n  adapterConfig: unknown\n  configuration: AnyConfigurationModel\n  renderingStopToken?: StopToken\n  setRenderingStopToken: (token?: StopToken) => void\n  setLoading: (loading: boolean) => void\n  setError: (error: unknown) => void\n  setRenderingImageData: (imageData: ImageBitmap | undefined) => void\n  setLastDrawnOffsetPx: (offsetPx: number) => void\n  setLastDrawnBpPerPx: (bpPerPx: number) => void\n  ref: HTMLCanvasElement | null\n  renderingImageData?: ImageBitmap\n  setStatusMessage?: (msg: string) => void\n  setCanvasDrawn?: (drawn: boolean) => void\n}\n\nexport interface RPCRenderSetupParams<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n> {\n  self: T\n  rpcMethodName: string\n  getRPCParams: (params: {\n    view: LGV\n    session: ReturnType<typeof getSession>\n    sequenceAdapter: unknown\n    stopToken: StopToken\n  }) => Record<string, unknown>\n  onResult: (result: R) => void\n}\n\nexport function createRPCRenderFunction<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n>({ self, rpcMethodName, getRPCParams, onResult }: RPCRenderSetupParams<T, R>) {\n  return async () => {\n    const view = getContainingView(self) as LGV\n\n    if (\n      !view.initialized ||\n      self.error ||\n      !self.featureDensityStatsReadyAndRegionNotTooLarge\n    ) {\n      return\n    }\n\n    const { bpPerPx } = view\n\n    try {\n      const session = getSession(self)\n      const { rpcManager, assemblyManager } = session\n      const assemblyName = view.assemblyNames[0]\n      if (!assemblyName) {\n        return\n      }\n\n      const assembly = assemblyManager.get(assemblyName)\n      const sequenceAdapterConfig = assembly?.configuration?.sequence?.adapter\n      const sequenceAdapter = sequenceAdapterConfig\n        ? getSnapshot(sequenceAdapterConfig)\n        : undefined\n\n      const previousToken = untracked(() => self.renderingStopToken)\n      if (previousToken) {\n        stopStopToken(previousToken)\n      }\n\n      const stopToken = createStopToken()\n      self.setRenderingStopToken(stopToken)\n      self.setLoading(true)\n      self.setCanvasDrawn?.(false)\n\n      const viewSnapshot = {\n        displayedRegions: structuredClone(view.displayedRegions),\n        bpPerPx: view.bpPerPx,\n        offsetPx: view.offsetPx,\n        interRegionPaddingWidth: view.interRegionPaddingWidth,\n        minimumBlockWidth: view.minimumBlockWidth,\n        width: view.width,\n      }\n\n      const sessionId = getRpcSessionId(self)\n      const adapterConfig = self.adapterConfig\n      const config = getSnapshot(self.configuration)\n      const result = (await rpcManager.call(sessionId, rpcMethodName, {\n        sessionId,\n        view: viewSnapshot,\n        adapterConfig,\n        sequenceAdapter,\n        config,\n        statusCallback: (msg: string) => {\n          if (isAlive(self)) {\n            self.setStatusMessage?.(msg)\n          }\n        },\n        stopToken,\n        ...getRPCParams({ view, session, sequenceAdapter, stopToken }),\n      })) as R & { imageData?: ImageBitmap; offsetPx?: number }\n\n      if (result.imageData) {\n        self.setRenderingImageData(result.imageData)\n        if (result.offsetPx !== undefined) {\n          self.setLastDrawnOffsetPx(result.offsetPx)\n        }\n        onResult(result)\n      }\n\n      self.setLastDrawnBpPerPx(bpPerPx)\n    } catch (error) {\n      if (!isAbortException(error)) {\n        console.error(error)\n        self.setError(error)\n      }\n    } finally {\n      self.setRenderingStopToken(undefined)\n      self.setLoading(false)\n    }\n  }\n}\n\nexport function setupCanvasRenderingAutorun<T extends RPCRenderableModel>(\n  self: T,\n) {\n  createAutorun(\n    self,\n    async () => {\n      const success = drawCanvasImageData(self.ref, self.renderingImageData)\n      if (isAlive(self)) {\n        self.setCanvasDrawn?.(success)\n      }\n    },\n    {\n      name: 'CanvasRenderAutorun',\n    },\n  )\n}\n"],"names":["doAfterAttachRPC","self","performRender","createRPCRenderFunction","rpcMethodName","getRPCParams","renderProps","onResult","createAutorun","async","isAlive","delay","name","setupCanvasRenderingAutorun","view","getContainingView","initialized","error","featureDensityStatsReadyAndRegionNotTooLarge","bpPerPx","session","getSession","rpcManager","assemblyManager","assemblyName","assemblyNames","assembly","get","sequenceAdapterConfig","configuration","sequence","adapter","sequenceAdapter","getSnapshot","undefined","previousToken","untracked","renderingStopToken","stopStopToken","stopToken","createStopToken","setRenderingStopToken","setLoading","setCanvasDrawn","viewSnapshot","displayedRegions","structuredClone","offsetPx","interRegionPaddingWidth","minimumBlockWidth","width","sessionId","getRpcSessionId","adapterConfig","config","result","call","statusCallback","msg","setStatusMessage","imageData","setRenderingImageData","setLastDrawnOffsetPx","setLastDrawnBpPerPx","isAbortException","console","setError","success","drawCanvasImageData","ref","renderingImageData"],"sourceRoot":""}