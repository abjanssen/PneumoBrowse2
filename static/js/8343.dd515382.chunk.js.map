{"version":3,"file":"static/js/8343.dd515382.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region, Feature, updateStatus, isGzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport VCF from '@gmod/vcf'\nimport type { Buffer } from 'buffer'\n\n// local\nimport VcfFeature from '../VcfFeature'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  vcfFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.setup()\n    const parser = new VCF({ header })\n    return parser.getMetadata()\n  }\n\n  public async setupP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const buf = (await openLocation(\n      this.getConf('vcfLocation'),\n      this.pluginManager,\n    ).readFile(opts)) as Buffer\n    const buffer = isGzip(buf)\n      ? await updateStatus('Unzipping', statusCallback, () => unzip(buf))\n      : buf\n    const headerLines = []\n    const featureMap = {} as Record<string, string[]>\n    let blockStart = 0\n\n    const decoder =\n      typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined\n\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf('\\n', blockStart)\n      // could be a non-newline ended file, so slice to end of file if n===-1\n      const b =\n        n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n)\n      const line = (decoder?.decode(b) || b.toString()).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = []\n          }\n          featureMap[refName].push(line)\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${Math.floor(blockStart / 1_000_000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1_000_000).toLocaleString('en-US')} MB`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const header = headerLines.join('\\n')\n    const parser = new VCF({ header })\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing VCF data')\n            let idx = 0\n            const intervalTree = new IntervalTree()\n            for (const line of lines) {\n              const f = new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-${refName}-${idx++}`,\n              })\n              intervalTree.insert([f.get('start'), f.get('end')], f)\n            }\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header,\n      intervalTreeMap,\n    }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch((e: unknown) => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.setup()\n    return Object.keys(intervalTreeMap)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { intervalTreeMap } = await this.setup()\n        intervalTreeMap[refName]?.(opts.statusCallback)\n          .search([start, end])\n          .forEach(f => {\n            observer.next(f)\n          })\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","getHeader","header","this","setup","getMetadata","VCF","setupP","opts","statusCallback","buf","openLocation","getConf","pluginManager","readFile","buffer","isGzip","updateStatus","unzip","headerLines","featureMap","blockStart","decoder","TextDecoder","undefined","i","length","n","indexOf","b","subarray","line","decode","toString","trim","startsWith","push","ret","refName","slice","Math","floor","toLocaleString","join","parser","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","idx","intervalTree","IntervalTree","f","VcfFeature","variant","parseLine","id","insert","get","vcfFeatures","catch","e","getRefNames","_","keys","getFeatures","region","ObservableCreate","async","start","end","search","forEach","observer","next","complete","error","signal","freeResources"],"sourceRoot":""}