{"version":3,"file":"static/js/36.38534e8f.chunk.js","mappings":"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","sources":["../../../plugins/wiggle/src/BigWigAdapter/BigWigAdapter.ts"],"sourcesContent":["import { ArrayFeatureView, BigWig } from '@gmod/bbi'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  aggregateQuantitativeStats,\n  blankStats,\n} from '@jbrowse/core/data_adapters/BaseAdapter/stats'\nimport { updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { rectifyStats } from '@jbrowse/core/util/stats'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { UnrectifiedQuantitativeStats } from '@jbrowse/core/util/stats'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\ninterface WiggleOptions extends BaseOptions {\n  resolution?: number\n}\n\nfunction computeStatsFromView(\n  view: ArrayFeatureView,\n  targetStart: number,\n  targetEnd: number,\n) {\n  const len = view.length\n\n  if (len === 0) {\n    return {\n      scoreMin: 0,\n      scoreMax: 0,\n      scoreSum: 0,\n      scoreSumSquares: 0,\n      scoreMean: 0,\n      scoreStdDev: 0,\n      featureCount: 0,\n      basesCovered: targetEnd - targetStart,\n      featureDensity: 0,\n    }\n  }\n\n  let scoreMin = Number.MAX_VALUE\n  let scoreMax = Number.MIN_VALUE\n  let scoreSum = 0\n  let scoreSumSquares = 0\n  let featureCount = 0\n\n  for (let i = 0; i < len; i++) {\n    const featureStart = view.start(i)\n    const featureEnd = view.end(i)\n\n    // Skip features outside target range\n    if (featureEnd <= targetStart || featureStart >= targetEnd) {\n      continue\n    }\n\n    const score = view.score(i)\n    const min = view.minScore(i) ?? score\n    const max = view.maxScore(i) ?? score\n\n    scoreMin = Math.min(scoreMin, min)\n    scoreMax = Math.max(scoreMax, max)\n    scoreSum += score\n    scoreSumSquares += score * score\n    featureCount++\n  }\n\n  if (featureCount === 0) {\n    return {\n      scoreMin: 0,\n      scoreMax: 0,\n      scoreSum: 0,\n      scoreSumSquares: 0,\n      scoreMean: 0,\n      scoreStdDev: 0,\n      featureCount: 0,\n      basesCovered: targetEnd - targetStart,\n      featureDensity: 0,\n    }\n  }\n\n  const scoreMean = scoreSum / featureCount\n  const scoreStdDev = Math.sqrt(\n    scoreSumSquares / featureCount - scoreMean * scoreMean,\n  )\n\n  return {\n    scoreMin,\n    scoreMax,\n    scoreSum,\n    scoreSumSquares,\n    scoreMean,\n    scoreStdDev,\n    featureCount,\n    basesCovered: targetEnd - targetStart,\n    featureDensity: featureCount / (targetEnd - targetStart),\n  }\n}\n\nexport default class BigWigAdapter extends BaseFeatureDataAdapter {\n  private setupP?: Promise<{\n    bigwig: BigWig\n    header: Awaited<ReturnType<BigWig['getHeader']>>\n  }>\n\n  public static capabilities = [\n    'hasResolution',\n    'hasLocalStats',\n    'hasGlobalStats',\n  ]\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const pluginManager = this.pluginManager\n    const bigwig = new BigWig({\n      filehandle: openLocation(this.getConf('bigWigLocation'), pluginManager),\n    })\n    return {\n      bigwig,\n      header: await updateStatus(\n        'Downloading bigwig header',\n        statusCallback,\n        () => bigwig.getHeader(opts),\n      ),\n    }\n  }\n\n  async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  public async getRefNames(opts?: BaseOptions) {\n    const { header } = await this.setup(opts)\n    return Object.keys(header.refsByName)\n  }\n\n  public async refIdToName(refId: number) {\n    const { header } = await this.setup()\n    return header.refsByNumber[refId]?.name\n  }\n\n  public async getGlobalStats(opts?: BaseOptions) {\n    const { header } = await this.setup(opts)\n    return rectifyStats(header.totalSummary as UnrectifiedQuantitativeStats)\n  }\n\n  public getFeatures(region: Region, opts: WiggleOptions = {}) {\n    const { refName, start, end } = region\n    const {\n      bpPerPx = 0,\n      resolution = 1,\n      stopToken,\n      statusCallback = () => {},\n    } = opts\n    const source = this.getConf('source')\n    const resolutionMultiplier = this.getConf('resolutionMultiplier')\n\n    return ObservableCreate<Feature>(async observer => {\n      const { bigwig } = await this.setup(opts)\n\n      const arrays = await updateStatus(\n        'Downloading bigwig data',\n        statusCallback,\n        () =>\n          bigwig.getFeaturesAsArrays(refName, start, end, {\n            ...opts,\n            basesPerSpan: (bpPerPx / resolution) * resolutionMultiplier,\n          }),\n      )\n\n      const view = new ArrayFeatureView(arrays, source, refName)\n\n      for (let i = 0; i < view.length; i++) {\n        const uniqueId = view.id(i)\n        const idx = i\n        observer.next({\n          get: (str: string) => view.get(idx, str) as any,\n          id: () => uniqueId,\n          toJSON: () => ({\n            start: view.start(idx),\n            end: view.end(idx),\n            score: view.score(idx),\n            refName,\n            source,\n            uniqueId,\n            summary: view.isSummary,\n            minScore: view.minScore(idx),\n            maxScore: view.maxScore(idx),\n          }),\n        })\n      }\n      observer.complete()\n    }, stopToken)\n  }\n\n  private async getArrayFeatureView(\n    region: Region,\n    opts: WiggleOptions = {},\n  ): Promise<ArrayFeatureView> {\n    const { refName, start, end } = region\n    const { bpPerPx = 0, resolution = 1, statusCallback = () => {} } = opts\n    const resolutionMultiplier = this.getConf('resolutionMultiplier')\n    const source = this.getConf('source')\n\n    const { bigwig } = await this.setup(opts)\n\n    const arrays = await updateStatus(\n      'Downloading bigwig data',\n      statusCallback,\n      () =>\n        bigwig.getFeaturesAsArrays(refName, start, end, {\n          ...opts,\n          basesPerSpan: (bpPerPx / resolution) * resolutionMultiplier,\n        }),\n    )\n\n    return new ArrayFeatureView(arrays, source, refName)\n  }\n\n  public async getRegionQuantitativeStats(\n    region: Region,\n    opts?: WiggleOptions,\n  ) {\n    const { start, end } = region\n    const view = await this.getArrayFeatureView(region, {\n      ...opts,\n      bpPerPx: (end - start) / 1000,\n    })\n\n    return computeStatsFromView(view, start, end)\n  }\n\n  // always render bigwig instead of calculating a feature density for it\n  async getMultiRegionFeatureDensityStats(_regions: Region[]) {\n    return {\n      featureDensity: 0,\n    }\n  }\n\n  async getMultiRegionQuantitativeStats(\n    regions: Region[] = [],\n    opts: WiggleOptions = {},\n  ) {\n    if (!regions.length) {\n      return blankStats()\n    }\n    const stats = await Promise.all(\n      regions.map(region => this.getRegionQuantitativeStats(region, opts)),\n    )\n    return aggregateQuantitativeStats(stats)\n  }\n}\n"],"names":["BigWigAdapter","BaseFeatureDataAdapter","setupPre","opts","statusCallback","pluginManager","this","bigwig","BigWig","filehandle","openLocation","getConf","header","updateStatus","getHeader","setup","setupP","catch","e","undefined","getRefNames","Object","keys","refsByName","refIdToName","refId","refsByNumber","name","getGlobalStats","rectifyStats","totalSummary","getFeatures","region","refName","start","end","bpPerPx","resolution","stopToken","source","resolutionMultiplier","ObservableCreate","async","arrays","getFeaturesAsArrays","basesPerSpan","view","ArrayFeatureView","i","length","uniqueId","id","idx","observer","next","get","str","toJSON","score","summary","isSummary","minScore","maxScore","complete","getArrayFeatureView","getRegionQuantitativeStats","targetStart","targetEnd","len","scoreMin","scoreMax","scoreSum","scoreSumSquares","scoreMean","scoreStdDev","featureCount","basesCovered","featureDensity","Number","MAX_VALUE","MIN_VALUE","featureStart","min","max","Math","sqrt","computeStatsFromView","getMultiRegionFeatureDensityStats","_regions","getMultiRegionQuantitativeStats","regions","blankStats","stats","Promise","all","map","aggregateQuantitativeStats"],"ignoreList":[],"sourceRoot":""}