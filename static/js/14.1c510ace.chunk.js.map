{"version":3,"file":"static/js/14.1c510ace.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedpeAdapter/BedpeAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport {\n  Region,\n  Feature,\n  SimpleFeature,\n  fetchAndMaybeUnzip,\n} from '@jbrowse/core/util'\nimport IntervalTree from '@flatten-js/interval-tree'\n\nconst svTypes = new Set(['DUP', 'TRA', 'INV', 'CNV', 'DEL'])\n\nexport function featureData(\n  line: string,\n  uniqueId: string,\n  flip: boolean,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const ref1 = l[flip ? 3 : 0]!\n  const start1 = +l[flip ? 4 : 1]!\n  const end1 = +l[flip ? 5 : 2]!\n  const ref2 = l[!flip ? 3 : 0]!\n  const start2 = +l[!flip ? 4 : 1]!\n  const end2 = +l[!flip ? 5 : 2]!\n  const name = l[6]!\n  const score = +l[7]!\n  const strand1 = parseStrand(l[8]!)\n  const strand2 = parseStrand(l[9]!)\n  const extra = l.slice(10)\n  const rest = names\n    ? Object.fromEntries(names.slice(10).map((n, idx) => [n, extra[idx]]))\n    : extra\n  const ALT = svTypes.has(extra[0]!) ? `<${extra[0]}>` : undefined\n\n  return new SimpleFeature({\n    ...rest,\n    start: start1,\n    end: end1,\n    type: 'paired_feature',\n    refName: ref1,\n    strand: strand1,\n    name,\n    score,\n    uniqueId,\n    mate: {\n      refName: ref2,\n      start: start2,\n      end: end2,\n      strand: strand2,\n    },\n    ...(ALT ? { ALT: [ALT] } : {}), // ALT is an array in VCF\n  })\n}\n\nfunction parseStrand(strand: string) {\n  if (strand === '+') {\n    return 1\n  }\n  if (strand === '-') {\n    return -1\n  }\n  if (strand === '.') {\n    return 0\n  }\n  return undefined\n}\n\nexport default class BedpeAdapter extends BaseFeatureDataAdapter {\n  protected bedpeFeatures?: Promise<{\n    header: string\n    feats1: Record<string, string[]>\n    feats2: Record<string, string[]>\n    columnNames: string[]\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree | undefined> | undefined\n  > = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts?: BaseOptions) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedpeLocation')\n    const loc = openLocation(bedLoc, pm)\n    const buffer = await fetchAndMaybeUnzip(loc, opts)\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n    const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const headerLines = []\n    let i = 0\n    for (; i < lines.length && lines[i]!.startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n    const feats1 = {} as Record<string, string[]>\n    const feats2 = {} as Record<string, string[]>\n    for (; i < lines.length; i++) {\n      const line = lines[i]!\n      const cols = line.split('\\t')\n      const r1 = cols[0]!\n      const r2 = cols[3]!\n      if (!feats1[r1]) {\n        feats1[r1] = []\n      }\n      if (!feats2[r2]) {\n        feats2[r2] = []\n      }\n      feats1[r1].push(line)\n      feats2[r2].push(line)\n    }\n    const columnNames = this.getConf('columnNames')\n\n    return {\n      header,\n      feats1,\n      feats2,\n      columnNames,\n    }\n  }\n\n  private async loadData(opts: BaseOptions = {}) {\n    if (!this.bedpeFeatures) {\n      this.bedpeFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedpeFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedpeFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { feats1, feats2 } = await this.loadData(opts)\n    return [...new Set([...Object.keys(feats1), ...Object.keys(feats2)])]\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureTreeP(refName: string) {\n    const { feats1, feats2 } = await this.loadData()\n    const names = await this.getNames()\n    const intervalTree = new IntervalTree()\n    const ret1 =\n      feats1[refName]?.map((f, i) =>\n        featureData(f, `${this.id}-${refName}-${i}-r1`, false, names),\n      ) ?? []\n    const ret2 =\n      feats2[refName]?.map((f, i) =>\n        featureData(f, `${this.id}-${refName}-${i}-r2`, true, names),\n      ) ?? []\n\n    for (const obj of [...ret1, ...ret2]) {\n      intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n    }\n\n    return intervalTree\n  }\n\n  private async loadFeatureTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureTreeP(refName).catch(\n        (e: unknown) => {\n          this.intervalTrees[refName] = undefined\n          throw e\n        },\n      )\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureTree(refName)\n      intervalTree?.search([start, end]).forEach(f => {\n        observer.next(f)\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["svTypes","Set","featureData","line","uniqueId","flip","names","l","split","ref1","start1","end1","ref2","start2","end2","name","score","strand1","parseStrand","strand2","extra","slice","rest","Object","fromEntries","map","n","idx","ALT","has","undefined","SimpleFeature","start","end","type","refName","strand","mate","BedpeAdapter","BaseFeatureDataAdapter","intervalTrees","loadDataP","opts","pm","this","pluginManager","bedLoc","getConf","loc","openLocation","buffer","fetchAndMaybeUnzip","length","Error","lines","TextDecoder","fatal","decode","filter","f","headerLines","i","startsWith","push","header","join","feats1","feats2","cols","r1","r2","columnNames","loadData","bedpeFeatures","catch","e","getRefNames","keys","getHeader","getNames","defline","at","includes","field","trim","loadFeatureTreeP","intervalTree","IntervalTree","ret1","id","ret2","obj","insert","get","loadFeatureTree","getFeatures","query","ObservableCreate","async","search","forEach","observer","next","complete","signal","freeResources"],"sourceRoot":""}