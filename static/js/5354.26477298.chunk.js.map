{"version":3,"file":"static/js/5354.26477298.chunk.js","mappings":"sJAcO,SAASA,EACdC,EACAC,GAEA,IAAIC,EAAU,EACVC,EAAS,EACTC,EAAU,EACd,MAAMC,EAAM,GAEZ,IACE,IAAIC,EAAI,EAAGC,EAAIP,EAASQ,OAAQC,EAAKR,EAAUO,OAC/CF,EAAIC,GAAKH,EAAUK,EACnBH,IACA,CACA,MAAMI,EAASV,EAASM,GAClBK,EAAMD,GAAU,EAChBE,EAAc,GAATF,EACX,GAAIE,IAAOC,EAAAA,IAAWD,IAAOE,EAAAA,GAAS,CACpC,IAAK,IAAIC,EAAI,EAAGA,EAAIJ,GAAOP,EAAUK,EAAIM,IACnCd,EAAUG,KAAaF,EAAUa,GACnCX,IAGJF,GAAWS,CACb,MAAO,GAAIC,IAAOI,EAAAA,IAAWJ,IAAOK,EAAAA,GAClCd,GAAUQ,OACL,GAAIC,IAAOM,EAAAA,IAAWN,IAAOO,EAAAA,IAAWP,IAAOQ,EAAAA,GAAU,CAC9D,IAAK,IAAIL,EAAI,EAAGA,EAAIJ,GAAOP,EAAUK,EAAIM,IACnCd,EAAUG,KAAaF,EAAUa,IACnCV,EAAIgB,KAAK,CACPC,IAAKnB,EAASY,EACdQ,IAAKnB,IAEPA,KAGJF,GAAWS,EACXR,GAAUQ,CACZ,CACF,CAEA,OAAON,CACT,C,gFCjDO,SAASmB,EAAYC,EAAkBzB,GAC5C,MAAM0B,EAASD,EAAQE,IAAI,SACrBC,EAAOH,EAAQE,IAAI,OACnBE,EAAUJ,EAAQE,IAAI,UACtBG,EAAOF,EAAOF,EACdK,GAAMC,EAAAA,EAAAA,IAAUP,EAAS,KAAM,OAAgC,GAC/DQ,EAAW,GACXC,EAAkB,GAClBC,EAAY,GACZC,EAAmB,GACnBC,EAAMZ,EAAQE,IAAI,OACxB,GAAIU,EAAK,CACP,MAAMC,GAAgBC,EAAAA,EAAAA,GAAoBd,GACpCe,GAAgBC,EAAAA,EAAAA,GAAgBV,EAAIM,EAAKR,GAC/C,IAAIa,EAAY,EAEhB,IAAK,MAAM,KAAEC,EAAI,UAAE1C,KAAeuC,EAAe,CAC/C,IAAK,MAAM,IAAElB,EAAG,IAAEC,KAASxB,EAAAA,EAAAA,GAAcC,EAAUC,GAAY,CAE7D,GAAIqB,EAAM,GAAKA,GAAOQ,EACpB,SAIF,MACMc,EACJF,IAFmC,IAAbb,EAES5B,EAAUO,OAAS,EAAIe,EAAMA,GACxDsB,EAAOP,IAAgBM,IAAS,EAGzB,MAATD,GACFV,EAASX,GAAO,EAChBa,EAAUb,GAAOuB,GACC,MAATF,IACTT,EAAgBZ,GAAO,EACvBc,EAAiBd,GAAOuB,EAE5B,CACAH,GAAazC,EAAUO,MACzB,CACF,CACA,MAAO,CACLyB,WACAC,kBACAC,YACAC,mBAEJ,C,yDCzCO,SAASK,EAAgBV,EAAYe,EAAcjB,GACxD,MAAMQ,GAAmB,IAAbR,GAAiBkB,EAAAA,EAAAA,QAAOD,GAAQA,EACtCE,EAAYX,EAAI7B,OAChByC,EAAOlB,EAAGmB,MAAM,KAChBC,EAAS,GAEf,IAAK,MAAMC,KAAOH,EAAM,CAEtB,GAAY,KAARG,EACF,SAGF,MAAMF,EAAQE,EAAIF,MAAM,KAClBG,EAAUH,EAAM,GAChBI,EAAUC,EAAAA,EAAkBC,KAAKH,GACvC,IAAKC,EACH,MAAM,IAAIG,MAAM,2BAA2BL,MAE7C,MAAO,CAAEM,EAAMC,EAAQC,GAAWN,EAI5BO,EAAQD,EAASV,MAAM,WAO7B,IAAK,MAAMP,KAAQkB,EAAO,CACxB,GAAa,KAATlB,EACF,SAGF,MAAMmB,EAAcZ,EAAM1C,OAC1B,IAAIJ,EAAU,EAId,MAAMH,GAAyB,IAAb4B,EAAiB,IAAIkC,MAAMD,EAAc,GAAK,GAChE,IAAIE,GAA0B,IAAbnC,EAAiBiC,EAAc,EAAI,EAEpD,IAAK,IAAIxD,EAAI,EAAGA,EAAIwD,EAAaxD,IAAK,CACpC,IAAI2D,GAASf,EAAM5C,GACnB,GACe,MAAToD,GAAgBA,IAASrB,EAAIjC,IAC/B6D,IAEF7D,UACO6D,GAAS,GAAK7D,EAAU4C,GAGjC,IAAiB,IAAbnB,EAAgB,CAClB,MAAMqC,EAAMlB,EAAY5C,EACpB8D,GAAO,IAGTjE,EAAU+D,KAAgBE,EAM9B,MACEjE,EAAU+D,KAAgB5D,EAAU,CAExC,CAIA,MAAM+D,GACS,IAAbtC,EAAiB5B,EAAUmE,MAAMJ,EAAa,GAAK/D,EAErDkD,EAAO9B,KAAK,CACVsB,OACAe,KAAMA,EACNC,OAAQA,EACR1D,UAAWkE,GAEf,CACF,CAEA,OAAOhB,CACT,C,+CC5FO,SAASZ,EAAoBd,GASlC,MAAM4C,GAAKrC,EAAAA,EAAAA,IAAUP,EAAS,KAAM,OAA+B,GACnE,GAAI4C,EAAG,CACL,MAAMlB,EAAS,GACf,GAAiB,iBAANkB,EAAgB,CACzB,MAAMC,EAAQD,EAAEnB,MAAM,KACtB,IAAK,IAAI5C,EAAI,EAAGC,EAAI+D,EAAM9D,OAAQF,EAAIC,EAAGD,IACvC6C,EAAO9B,MAAMiD,EAAMhE,GAAM,IAE7B,MACE,IAAK,IAAIA,EAAI,EAAGC,EAAI8D,EAAE7D,OAAQF,EAAIC,EAAGD,IACnC6C,EAAO9B,KAAKgD,EAAE/D,GAAM,KAGxB,OAAO6C,CACT,CAAO,CACL,MAAMoB,GAAKvC,EAAAA,EAAAA,IAAUP,EAAS,KAAM,MACpC,GAAI8C,EAAI,CACN,MAAMpB,EAAS,GACf,IAAK,IAAI7C,EAAI,EAAGC,EAAIgE,EAAG/D,OAAQF,EAAIC,EAAGD,IAAK,CACzC,MAAMkE,EAAQD,EAAGE,WAAWnE,GAAK,GACjC6C,EAAO9B,KAAKqD,KAAKC,IAAI,EAAGH,EAAQ,IAClC,CACA,OAAOrB,CACT,CACA,MACF,CACF,C,mKCpCO,MAAMjC,EAAU,EACVJ,EAAU,EACVE,EAAU,EACVC,EAAU,EACVJ,EAAU,EACV+D,EAAU,EAEVxD,EAAW,EACXD,EAAU,EAIV0D,EAAkB,IAQlBC,EAA2B,IAG3BC,EAAS,mBAKTC,EAAyB,IAAIC,WAAW,CACnD,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,MAI5DC,EAA2BnB,MAAMoB,KAAK,CAAE3E,OAAQ,KAAO,CAAC4E,EAAG9E,IACtE+E,OAAOC,aAAahF,IAIf,SAASiF,EACdC,GAEA,MAAwB,iBAAVA,GAAqBC,EAAAA,EAAAA,IAAYD,GAASA,GAAS,EACnE,C,wJCtBA,MAEME,EAAe,IAAIC,WAAWC,SAC9BC,EAAoB,IAAIF,WAAWC,SACnCE,EAAqB,IAAIH,WAAWC,S,0BCyDnC,SAASG,EACdC,EACArC,EACAhB,EACAsD,EACAC,GAEA,MAAMC,EAASH,EAAIrD,GAAMsD,KA5DlB,CACLG,WAAY,EACZC,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,IACX,KAAM,EACN,EAAK,EACL,EAAK,GAmDPR,EAAMC,aACND,EAAME,kBAAoBH,EAC1BC,EAAMG,mBACNH,EAAMxC,IACR,C,wBCtFO,SAASiD,GAAqB,QACnCnF,EAAO,QACPoF,EAAO,OACPC,EAAM,KACNC,EAAI,eACJC,IAQA,MAAMtF,EAASD,EAAQE,IAAI,SACrBE,EAAUJ,EAAQE,IAAI,UACtBC,EAAOH,EAAQE,IAAI,OACnBsF,EAAWJ,GAASrE,eAAeyE,SACnCC,EAAuBL,GAASrE,eAAe0E,qBAC/C7E,EAAMZ,EAAQE,IAAI,OAElBwF,GADwBN,GAASrE,eAAe4E,WAAa,IACjB,IAElD,IAAK/E,EACH,OAGF,MAAMrC,EACJyB,EAAQE,IAAI,mBAAoB8D,EAAAA,EAAAA,IAAYhE,EAAQE,IAAI,UACpD0F,EAAcP,EAAOQ,MACrBC,EAAYT,EAAOU,KAKzBC,EAAAA,EAAAA,GAA4BhG,EAASzB,IAAW0H,QAC9C,EAAGC,WAAU9E,OAAMF,QAAQuB,KACzB,MAAM/D,EAAS+D,EAAMxC,EAGrB,GAAIvB,EAASkH,GAAelH,GAAUyB,EACpC,OAEF,MAAMgG,EAAOzH,EAASkH,EACtB,GAAIO,EAAO,GAAKA,GAAQL,EAAYF,EAClC,OAGF,GAAIH,GAAwBvE,IAASuE,EACnC,OAIF,GAAIrE,EAAOsE,EACT,OAGF,MAAMnB,EAAOe,EAAKa,KDpBf,CACLC,MAAO,EACPC,aAAc,EACdC,KAAM,CAAC,EACPzG,IAnBK,CACL8E,WAAY,EACZC,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,IACX,KAAM,EACN,EAAK,EACL,EAAK,GAUL1D,KAAM,CAAC,EACP+E,QAAS,CAAC,EACVC,SAAU,CAAC,EACXC,OAAQ,CAAC,GCaPlC,EAAImC,QAAUnB,EAAeY,GAE7B,MAAMQ,EAAI,GAAIC,EAAAA,EAAAA,KAAIV,GACdV,GAAYmB,GAAIE,EAAAA,EAAAA,KAAIX,GACtB5B,EAAqBC,EAAKnE,EAAS,UAAW,UAAUc,IAAQyF,GAEhErC,EAAqBC,EAAKnE,EAAS,OAAQ,OAAOc,IAAQE,IAIlE,C,eClEA,SAAS0F,EACPxB,EACAyB,EACA3G,EACA4G,EACA5F,EACA6F,GAEA,GAAID,EAAQ,CACV,MAAMzC,EAAOe,EAAKyB,KF0Bb,CACLX,MAAO,EACPC,aAAc,EACdC,KAAM,CAAC,EACPzG,IAnBK,CACL8E,WAAY,EACZC,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,IACX,KAAM,EACN,EAAK,EACL,EAAK,GAUL1D,KAAM,CAAC,EACP+E,QAAS,CAAC,EACVC,SAAU,CAAC,EACXC,OAAQ,CAAC,GEjCTnC,EAAqBC,EAAKnE,EAAS,OAAQ,WAAYgB,GACvDmD,EAAI1E,IAAI8E,aACRJ,EAAI1E,IAAIO,IACV,MACE,IAAK6G,EAAO,CACV,MAAM1C,EAAOe,EAAKyB,KFoBf,CACLX,MAAO,EACPC,aAAc,EACdC,KAAM,CAAC,EACPzG,IAnBK,CACL8E,WAAY,EACZC,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,IACX,KAAM,EACN,EAAK,EACL,EAAK,GAUL1D,KAAM,CAAC,EACP+E,QAAS,CAAC,EACVC,SAAU,CAAC,EACXC,OAAQ,CAAC,GE3BPnC,EAAqBC,EAAKnE,EAAS,UAAW,aAAc,EAAIgB,GAChEmD,EAAI1E,IAAI8E,aACRJ,EAAI1E,IAAIO,IACV,CAEJ,CAEO,SAAS8G,GAAqB,QACnClH,EAAO,OACPqF,EAAM,KACNC,EAAI,eACJC,IAOA,MAAMtF,EAASD,EAAQE,IAAI,SACrBC,EAAOH,EAAQE,IAAI,OACnBE,EAAUJ,EAAQE,IAAI,UACtBU,EAAMZ,EAAQE,IAAI,OAClBiH,EAAI5B,EAAe6B,cACzB,GAAIxG,EAAK,CACP,MAAMrC,EACJyB,EAAQE,IAAI,mBAAoB8D,EAAAA,EAAAA,IAAYhE,EAAQE,IAAI,WACpD,SAAEM,EAAQ,UAAEE,IAAcX,EAAAA,EAAAA,GAAYC,EAASzB,GAC/C8I,EAAY,IAAI/E,MAAM9B,EAASzB,QAAQuI,MAAK,GAClDtH,EAAQuH,gBAAgB,CAACrG,EAAM2E,EAAO9G,KACpC,GAAImC,IAASsG,EAAAA,GAAe,CAC1B,MAAMzB,EAAMF,EAAQ9G,EACpB,IAAK,IAAIF,EAAIgH,EAAOhH,EAAIkH,EAAKlH,IAC3BwI,EAAUxI,IAAK,CAEnB,IAEF,MAAM+G,EAAcP,EAAOQ,MACrBC,EAAYT,EAAOU,IAGnB0B,EAAWxE,KAAK4D,IAAI,EAAGjB,EAAc3F,GACrCyH,EAASzE,KAAKC,IAAI/C,EAAOF,EAAQ6F,EAAY7F,GAInD,IAAK,IAAIpB,EAAI4I,EAAU5I,EAAI6I,EAAQ7I,IAAK,CACtC,MAAMS,EAAIT,EAAIoB,EACR0H,EAAKR,EAAE7H,EAAIsG,EAAc,GACzB5G,EAAKmI,EAAE7H,EAAIsG,EAAc,GAC/B,GAAW,MAAP+B,GAAqB,MAAP3I,EAAY,CAC5B,MAAM4I,EAAOtI,EAAIsG,EACXiC,EAAOvI,EAAIsG,EAAc,EACzBkC,EAAKtH,EAAS3B,GACdkJ,EAAKvH,EAAS3B,EAAI,GAClBmJ,EAAKtH,EAAU7B,IAAM,EACrBoJ,EAAKvH,EAAU7B,EAAI,IAAM,EACzBmI,KAAac,GAAME,EAAK,IAASD,GAAME,EAAK,IAC5CC,EAASb,EAAUxI,GACnBsJ,EAASd,EAAUxI,EAAI,GAE7BiI,EAAWxB,EAAMsC,EAAMxH,EAAS4G,EAAQgB,IAAME,GAC9CpB,EAAWxB,EAAMuC,EAAMzH,EAAS4G,EAAQiB,IAAME,EAChD,CACF,CACF,CACF,C,eC7CO,SAASC,EAAgB7D,GAM9B,OALAA,EAAI+B,OAAS,CAAC,EACd/B,EAAI/C,OAAS,CAAC,EACd+C,EAAIgC,UAAY,CAAC,EACjBhC,EAAIiC,WAAa,CAAC,EAClBjC,EAAIkC,SAAW,CAAC,EACTlC,CACT,CAGA,MACM8D,EAAkB,IAAInE,WAAWC,SAevC,SAASmE,EAAiB5D,GACxB,MAAM,iBAAEE,EAAgB,iBAAEC,EAAgB,YAAEC,EAAW,YAAEC,GAAgBL,EASzE,GARIG,IACFH,EAAM6D,eAAiB3D,EAAmBC,GAExCE,IACFL,EAAM8D,UAAY1D,EAAcC,EAChCL,EAAM+D,UAAY/D,EAAMM,UACxBN,EAAMgE,UAAYhE,EAAMQ,WAEtBR,EAAMiE,gBAAgBC,KAAM,CAC9B,IACIC,EADAC,EAAW,EAEf,IAAK,MAAOlI,EAAKmI,KAAUrE,EAAMiE,eAC3BI,EAAQD,IACVA,EAAWC,EACXF,EAASjI,GAGb8D,EAAMsE,YAAcH,EACpBnE,EAAMiE,oBAAiBM,CACzB,CACF,CAUOC,eAAeC,GAA8B,cAClDC,EAAa,SACbC,EAAQ,OACRhE,EAAM,KACNiE,IAOA,MAAM,UAAEC,EAAS,QAAEnE,EAAO,oBAAEoE,GAAwBF,EAC9C1D,EAAcP,EAAOQ,MACrBC,EAAYT,EAAOU,IACnB0D,EAAa3D,EAAYF,GAG/B8D,EAAAA,EAAAA,IAAeH,GACf,MAAMI,EJrFD,SACLN,EACAhE,GAEA,MAAMO,EAAcP,EAAOQ,MACrBC,EAAYT,EAAOU,IACnB0D,EAAa3D,EAAYF,EAE/B,GAAI6D,EAvBkB,IAwBpB,MAAM,IAAIzH,MACR,eAAeyH,6BAKnBxF,EAAaqD,KAAK,EAAG,EAAGmC,EAAa,GACrCrF,EAAkBkD,KAAK,EAAG,EAAGmC,EAAa,GAC1CpF,EAAmBiD,KAAK,EAAG,EAAGmC,EAAa,GAG3C,IAAK,MAAMzJ,KAAWqJ,EAAU,CAC9B,MAAMpJ,EAASD,EAAQE,IAAI,SACrBC,EAAOH,EAAQE,IAAI,OACnBE,EAAUJ,EAAQE,IAAI,UAGtBuH,EAAWxE,KAAK4D,IAAI5G,EAAQ2F,GAAeA,EAC3C8B,EAASzE,KAAKC,IAAI/C,EAAM2F,GAAaF,EAEvC6B,EAAWC,IAEbzD,EAAawD,KACbxD,EAAayD,KAEG,IAAZtH,GACFgE,EAAkBqD,KAClBrD,EAAkBsD,OACI,IAAbtH,IACTiE,EAAmBoD,KACnBpD,EAAmBqD,MAGzB,CAGA,MAAMtB,EAAQ,IAAIlC,WAAWuF,GACvBG,EAAa,IAAI1F,WAAWuF,GAC5BI,EAAc,IAAI3F,WAAWuF,GAEnC,IAAIK,EAAI,EACJC,EAAK,EACLC,EAAK,EAET,IAAK,IAAInL,EAAI,EAAGA,EAAI4K,EAAY5K,IAC9BiL,GAAK7F,EAAapF,GAClBkL,GAAM3F,EAAkBvF,GACxBmL,GAAM3F,EAAmBxF,GAEzBuH,EAAMvH,GAAKiL,EACXF,EAAW/K,GAAKkL,EAChBF,EAAYhL,GAAKmL,EAGnB,MAAO,CACLpE,cACA6D,aACArD,QACAwD,aACAC,cAEJ,CIemBI,CAAsBZ,EAAUhE,GAMjD,GAAImE,EAAqB,CACvB,MAAMlE,EAAgC,GACtC,IAAK,IAAIzG,EAAI,EAAGA,EAAI4K,EAAY5K,IAAK,CACnC,MAAMuH,EAAQuD,EAASvD,MAAMvH,GACf,IAAVuH,IAGJd,EAAKzG,GAAK,CACRuH,QACAC,aAAcD,EACdvG,IAAK,CACH8E,WAAYyB,EACZ,KAAMuD,EAASE,YAAYhL,GAC3B,EAAK,EACL,EAAK8K,EAASC,WAAW/K,GACzB+F,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,MAGjB,CACA,MAAO,CAAEI,OAAMM,cAAasE,QAAS,CAAC,EACxC,EAGAR,EAAAA,EAAAA,IAAeH,GAEflB,EAAgBf,KAAK,EAAG,EAAGmC,EAAa,GAExC,MAAMU,EAAsD,GACtDC,EAA4D,GAC5DF,EAAmB,CAAC,EAE1B,IAAK,IAAIrL,EAAI,EAAGC,EAAIuK,EAAStK,OAAQF,EAAIC,EAAGD,IAC1CwL,EAAehF,EAAQgE,EAASxK,GAAKqL,EAASE,EAAcD,GAG9DG,EAAWtK,aAAUiJ,EAGrB,MAAMsB,EAAgB,IAAIrG,WAAWuF,GACrC,IAOIlE,EAPAiF,EAAK,EACT,IAAK,IAAI3L,EAAI,EAAGA,EAAI4K,EAAY5K,IAC9B2L,GAAMnC,EAAgBxJ,GACtB0L,EAAc1L,GAAK2L,EAKrB,MAAMC,EAAgC,GAChCC,EAASzH,KAAK4D,IAAI,EAAGjB,EAAc,GACnC+E,EAAO/E,EAAc8E,EAE3B,GAAsB,kBAAlBtF,GAASlE,MAA4BkI,EAAe,EACtDM,EAAAA,EAAAA,IAAeH,GACfhE,QACS6D,EAAc,IAChB/D,EACHQ,MAAO6E,EACP3E,IAAKD,EAAY,KACZ,GACT,MAAM8E,EAAiBrF,EAAe5C,MAAMgI,GAE5C,IAAK,MAAM3K,KAAWqJ,EACpBlE,EAAqB,CACnBnF,UACAoF,UACAE,KAAMmF,EACNpF,SACAE,eAAgBqF,GAGtB,MAAO,GAAsB,gBAAlBxF,GAASlE,MAA0BkI,EAAe,EAC3DM,EAAAA,EAAAA,IAAeH,GACfhE,UACS6D,EAAc,IAChB/D,EACHQ,MAAO6E,EACP3E,IAAKD,EAAY,KACZ,GAET,IAAK,MAAM9F,KAAWqJ,EACpBnC,EAAqB,CACnBlH,UACAsF,KAAMmF,EACNpF,SACAE,kBAGN,EAGAmE,EAAAA,EAAAA,IAAeH,GACf,MAAMjE,EAAgC,GAGtC,IAAK,IAAIzG,EAAI,EAAGA,EAAI4K,EAAY5K,IAAK,CACnC,MAAMuH,EAAQuD,EAASvD,MAAMvH,GACvBgM,EAAWN,EAAc1L,GAGjB,IAAVuH,GAA4B,IAAbyE,IAInBvF,EAAKzG,GAAK,CACRuH,MAAOA,EAAQyE,EACfxE,aAAcD,EACdvG,IAAK,CACH8E,WAAYyB,EACZ,KAAMuD,EAASE,YAAYhL,GAC3B,EAAK,EACL,EAAK8K,EAASC,WAAW/K,GACzB+F,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,KAEbsB,SACEqE,EAAW,EAAI,CAAEC,SAAUC,EAAoBF,SAAc5B,GAEnE,CAGA,IAAK,IAAIpK,EAAI,EAAGC,EAAIqL,EAAUpL,OAAQF,EAAIC,EAAGD,IAAK,CAChD,MAAMmM,EAAMb,EAAUtL,GAChB4D,EAAMuI,EAAIvI,IACViC,EAAQsG,EAAItG,MAElB,IAAIH,EAAMe,EAAK7C,GACV8B,IACHA,EAAM,CACJ6B,MAAO,EACPC,aAAc,EACdxG,IAAK,CACH8E,WAAY,EACZ,KAAM,EACN,EAAK,EACL,EAAK,EACLC,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,MAGfI,EAAK7C,GAAO8B,GAEd,MAAMtC,EAAOyC,EAAMzC,KACbC,EAASwC,EAAMxC,OACfoE,EAAQ/B,EAAI+B,OAAS,CAAC,EAC5B,IAAI2E,EAAW3E,EAAKrE,GACfgJ,IACHA,EAAW,CACTtG,WAAY,EACZ,KAAM,EACN,EAAK,EACL,EAAK,EACLC,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,KAEboB,EAAKrE,GAAQgJ,GAEfA,EAAStG,aACTsG,EAAS/I,KACTqC,EAAI1E,IAAI8E,aACRJ,EAAI1E,IAAIqC,KACJwC,EAAMwG,UACR3G,EAAImC,QAAUhC,EAAMwG,QAExB,CAGA,IAAK,IAAIrM,EAAI,EAAGC,EAAIsL,EAAarL,OAAQF,EAAIC,EAAGD,IAAK,CACnD,MAAMmM,EAAMZ,EAAavL,GACnB4D,EAAMuI,EAAIvI,IACViC,EAAQsG,EAAItG,MAElB,IAAIH,EAAMe,EAAK7C,GACV8B,IACHA,EAAM,CACJ6B,MAAO,EACPC,aAAc,EACdxG,IAAK,CACH8E,WAAY,EACZ,KAAM,EACN,EAAK,EACL,EAAK,EACLC,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,MAGfI,EAAK7C,GAAO8B,GAEd,MAAMrC,EAASwC,EAAMxC,OACfhB,EAAOwD,EAAMxD,KACbnC,EAAS2F,EAAM3F,OACf0H,EAAUlC,EAAIkC,SAAW,CAAC,EAChC,IAAI0E,EAAc1E,EAAOvF,GACpBiK,IACHA,EAAc,CACZxG,WAAY,EACZ,KAAM,EACN,EAAK,EACL,EAAK,EACLC,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,KAEbuB,EAAOvF,GAAQiK,GAEjBA,EAAYxG,aACZwG,EAAYjJ,KACZiJ,EAAYrG,aAAe/F,EAC3BoM,EAAYpG,cACZoG,EAAYnG,UAAY/B,KAAKC,IAAIiI,EAAYnG,UAAWjG,GACxDoM,EAAYjG,UAAYjC,KAAK4D,IAAIsE,EAAYjG,UAAWnG,GACxD,MAAM6B,EAAM8D,EAAM0G,cACNnC,IAARrI,IACFuK,EAAYxC,iBAAmB,IAAI0C,IACnCF,EAAYxC,eAAe2C,IACzB1K,GACCuK,EAAYxC,eAAezI,IAAIU,IAAQ,GAAK,GAGnD,CAKA,IAAK,IAAI/B,EAAI,EAAGC,EAAI2L,EAAQ1L,OAAQF,EAAIC,EAAGD,IAAK,CAC9C,MAAM0M,EAASd,EAAQ5L,GACvB,GAAI0M,EAAQ,CACV,MAAMhH,EAAMe,EAAKzG,GACb0F,IACEiH,OAAOC,KAAKF,EAAO/J,MAAMzC,OAAS,IACpCwF,EAAI/C,KAAOgK,OAAOE,OAAOnH,EAAI/C,MAAQ,CAAC,EAAG+J,EAAO/J,OAE9CgK,OAAOC,KAAKF,EAAOhF,SAASxH,OAAS,IACvCwF,EAAIgC,QAAUiF,OAAOE,OAAOnH,EAAIgC,SAAW,CAAC,EAAGgF,EAAOhF,eAEjC0C,IAAnBsC,EAAO7E,UACTnC,EAAImC,QAAU6E,EAAO7E,SAG3B,CACF,CAGA,IAAK,IAAI7H,EAAI,EAAGC,EAAIwG,EAAKvG,OAAQF,EAAIC,EAAGD,IAAK,CAC3C,MAAM0F,EAAMe,EAAKzG,GACjB,GAAI0F,EAAK,CACP,GAAIA,EAAI/C,KACN,IAAK,MAAMmK,KAAOpH,EAAI/C,KACpB8G,EAAiB/D,EAAI/C,KAAKmK,IAG9B,GAAIpH,EAAIgC,QACN,IAAK,MAAMoF,KAAOpH,EAAIgC,QACpB+B,EAAiB/D,EAAIgC,QAAQoF,IAGjC,GAAIpH,EAAIkC,OACN,IAAK,MAAMkF,KAAOpH,EAAIkC,OACpB6B,EAAiB/D,EAAIkC,OAAOkF,GAGlC,CACF,CAEA,MAAO,CAAErG,OAAMM,cAAasE,UAC9B,CAEA,SAASa,EAAoB3E,GAC3B,MAAO,CACLzB,WAAYyB,EACZ,KAAM,EACN,EAAK,EACL,EAAK,EACLxB,iBAAkB,EAClBC,iBAAkB,EAClBC,YAAa,EACbC,YAAa,EACbC,UAAWC,IACXC,WAAW,IAEf,CAGA,MAAMoF,EAAa,CACjBrK,OAAQ,EACRG,QAAS,EACTwF,YAAa,EACbE,UAAW,EACX2D,WAAY,EACZzJ,aAASiJ,EACTiB,aAASjB,EACTmB,kBAAcnB,EAGdkB,eAAWlB,GAGb,SAAS2C,EACP1K,EACA2E,EACAgG,EACA5J,EACA6J,EACAZ,EACAa,GAEA,MAAM,OACJ9L,EAAM,QACNG,EAAO,YACPwF,EAAW,UACXE,EAAS,WACT2D,EAAU,QACVzJ,EAAO,QACPkK,EAAO,aACPE,EAAY,UACZD,GACEG,EACE0B,EAAS/L,EAAS4F,EAClBoG,EHlcD,SAAqB/K,EAAcnC,GACxC,OAAS,GAAKmC,EAAQgL,EAAAA,GAAiC,EAATnN,CAChD,CGgceoN,CAAYjL,EAAM2K,GACzBO,EAAOJ,EAASC,EAEtB,GAAK,GAAK/K,EAAQmL,EAAAA,GAAc,CAC9B,MAAM5E,EAAWxE,KAAK4D,IAAImF,EAAQpG,GAAeA,EAC3C8B,EAASzE,KAAKC,IAAIkJ,EAAMtG,GAAaF,EAO3C,GALI6B,EAAWC,IACbW,EAAgBZ,KAChBY,EAAgBX,MAGdxG,IAASoL,EAAAA,EAAW,CACtB,MAAMC,EAAOvM,EAASE,IAAI,QACpBsM,EAAKD,GAAME,IAAMF,GAAMG,GACvBC,EAAKJ,GAAMI,GACXC,EACG,MAAPJ,EACI,EACO,MAAPA,GACG,GACO,MAAPG,EAAa,EAAW,MAAPA,GAAc,EAAI,GAAKvM,EAC3CyM,EAAO,GAAGb,KAAUI,KAAQQ,SACX3D,IAAnBiB,EAAS2C,KACX3C,EAAS2C,GAAQ,CACfhH,MAAOmG,EACPjG,IAAKqG,EACLlK,OAAQ9B,EACRwM,kBACAE,MAAO,IAGX5C,EAAS2C,GAAMC,OACjB,CACF,MAAO,GAAI5L,IAAS6L,EAAAA,GAAgB,CAClC,MAAM5G,EAAO6F,EAASpG,EAClBO,GAAQ,GAAKA,EAAOsD,GACtBW,EAAcxK,KAAK,CACjB6C,IAAK0D,EACLzB,MAAO,CACLxC,OAAQ9B,EACRc,KAAM,YACNnC,OAAQgN,EACRX,SAAUnJ,IAIlB,MAAO,GH3eF,SAAqBf,GAC1B,SAAS,GAAKA,EAAQgL,EAAAA,GACxB,CGyeac,CAAY9L,GAAO,CAC5B,MAAMiF,EAAO6F,EAASpG,EAClBO,GAAQ,GAAKA,EAAOsD,GACtBW,EAAcxK,KAAK,CACjB6C,IAAK0D,EACLzB,MAAO,CACLxC,OAAQ9B,EACRc,KAAM+L,EAAAA,GAAa/L,GACnBnC,OAAQgN,IAIhB,KAAO,CACL,MAAM5F,EAAO6F,EAASpG,EAClBO,GAAQ,GAAKA,EAAOsD,GACtBU,EAAWvK,KAAK,CACd6C,IAAK0D,EACLzB,MAAO,CACLzC,OACAC,OAAQ9B,EACR8K,QAASzH,EAAAA,GAAeyH,KAIhC,CACF,CAEA,SAASb,EACPhF,EACArF,EACAkK,EACAE,EACAD,GAYA,GAVAG,EAAWrK,OAASD,EAAQE,IAAI,SAChCoK,EAAWlK,QAAUJ,EAAQE,IAAI,UACjCoK,EAAW1E,YAAcP,EAAOQ,MAChCyE,EAAWxE,UAAYT,EAAOU,IAC9BuE,EAAWb,WAAapE,EAAOU,IAAMV,EAAOQ,MAC5CyE,EAAWtK,QAAUA,EACrBsK,EAAWJ,QAAUA,EACrBI,EAAWF,aAAeA,EAC1BE,EAAWH,UAAYA,EAEnB,oBAAqBnK,EACvBA,EAAQuH,gBAAgBqE,OACnB,CACL,MAAMsB,EAAalN,EAAQE,IAAI,cAC/B,GAAIgN,EACF,IAAK,MAAMtK,KAAKsK,EAAY,CAC1B,IAAIjL,EACAkL,EACW,aAAXvK,EAAE1B,KACJe,EAAOW,EAAEX,KACW,cAAXW,EAAE1B,MACXe,EAAOW,EAAEwK,eAAiB,GAC1BD,EAAUvK,EAAEyK,WACQ,aAAXzK,EAAE1B,MAAkC,aAAX0B,EAAE1B,MACpCe,EAAO,GACPkL,EAAUvK,EAAEuK,SAEZlL,EAAO,GAET2J,EACE0B,EAAAA,GAAiB1K,EAAE1B,MACnB0B,EAAEiD,MACFjD,EAAE7D,OACFkD,EACW,aAAXW,EAAE1B,MAAsB0B,EAAE2K,KACf,aAAX3K,EAAE1B,KAAsB0B,EAAEsI,SAASlI,WAAW,QAAKiG,EACnDkE,EAEJ,CAEJ,CACF,CCpiBA,SAASK,EAAoBnI,EAAgBiE,GAC3C,MAAO,GAAGjE,EAAOoI,WAAWpI,EAAOQ,SAASR,EAAOU,OAP5B2H,EAOmDpE,EAAKoE,SANxEA,EACH,GAAGA,EAASC,eAAeD,EAASE,eAAeF,EAASG,UAAY,MAAMH,EAASI,WAAWC,KAAO,MAAML,EAASI,WAAWE,OAAS,KAC5I,MAIwF1E,EAAK2E,iBAAmB,KAPtH,IAAyBP,CAQzB,CAiDe,MAAMQ,UAA2BC,EAAAA,EAOtCC,MAAQ,IAAIC,EAAAA,EAAqC,CACvDC,QAAS,GACTC,OAAQ,MAQVC,wBAAAA,CAAyBC,GACvBC,MAAMF,yBAAyBC,GAE3BE,KAAKC,eACPD,KAAKC,cAAcJ,yBAAyBC,EAEhD,CAEA,eAAgBI,GACd,MAAMC,EAAuBH,KAAKI,QAAQ,cAG1CJ,KAAKK,wBAA0BL,KAAKI,QAAQ,mBAG5C,MAAME,QAAoBN,KAAKO,gBAAgBJ,IAE/C,IAAKG,EACH,MAAM,IAAIjN,MAAM,4BAGlB,MAAMmN,EAAaF,EAAYA,YAQ/B,OAPAN,KAAKC,cAAgBO,EAGjBR,KAAKK,uBACPG,EAAWX,yBAAyBG,KAAKK,uBAGpC,CAAEG,aACX,CAEA,wBAAMC,GACJ,MAAMX,EAASE,KAAKK,uBAAyBL,KAAKI,QAAQ,mBAC1D,GAAKN,GAAWE,KAAKO,cAarB,OAVAP,KAAKU,mBAAqBV,KAAKO,cAAcT,GAC1Ca,KAAKnI,IACJ,MAAMoI,EAAUpI,EAAE8H,YAElB,MAAO,gBAAiBM,EAAUA,OAAUtG,IAE7CuG,MAAOC,IAEN,MADAd,KAAKU,sBAAmBpG,EAClBwG,IAEHd,KAAKU,gBACd,CAEAK,WAAAA,CAAYrK,EAAgBiE,EAAoB,CAAC,GAC/C,OAAOqG,EAAAA,EAAAA,kBAA0BzG,UAC/B,MAAM,KAAE5D,EAAI,YAAEM,EAAW,QAAEsE,SAAkByE,KAAKiB,gBAChDvK,EACAiE,IAGI,QAAEmE,GAAYpI,EACdwK,EAAYlB,KAAKmB,GAGvB,IAAK,IAAIjR,EAAI,EAAGC,EAAIwG,EAAKvG,OAAQF,EAAIC,EAAGD,IAAK,CAC3C,MAAM0F,EAAMe,EAAKzG,GACjB,GAAI0F,EAAK,CACP,MAAMsB,EAAQD,EAAc/G,EACtBkR,EAAU3H,EAAgB7D,GAC1BuI,EAAQvI,EAAI6B,MAClB4J,EAASC,KAAK,CACZ/P,IAAMsE,IACJ,OAAQA,GACN,IAAK,QACH,OAAOqB,EACT,IAAK,MACH,OAAOA,EAAQ,EACjB,IAAK,QACH,OAAOiH,EACT,IAAK,UACH,OAAOiD,EACT,IAAK,UACH,OAAOtC,EACT,QACE,SAGNqC,GAAIA,IAAM,GAAGD,KAAahK,IAC1BqK,OAAQA,KAAA,CACNC,SAAU,GAAGN,KAAahK,IAC1BA,QACAE,IAAKF,EAAQ,EACbiH,QACAiD,UACAtC,aAGN,CACF,CAGA,IAAK,MAAO9B,EAAKyE,KAAS5E,OAAO6E,QAAQnG,GACvC8F,EAASC,KACP,IAAIK,EAAAA,EAAc,CAChBR,GAAInE,EACJ4E,KAAM,CACJrP,KAAM,OACNuM,UACA5H,MAAOuK,EAAKvK,MACZE,IAAKqK,EAAKrK,IACV7D,OAAQkO,EAAKlO,OACb4K,MAAOsD,EAAKtD,MACZF,gBAAiBwD,EAAKxD,oBAM9BoD,EAASQ,YACRlH,EAAKC,UACV,CAEA,qBAAcqG,CACZvK,EACAiE,EAA2B,CAAC,GAE5B,MAAM,QAAEmH,EAAO,oBAAEjH,GAAwBF,EAgBzC,QAXcL,IAAZwH,QACqBxH,IAArB0F,KAAK+B,aACL/B,KAAK+B,cAAgBD,GAErB9B,KAAKP,MAAMuC,aAEG1H,IAAZwH,IACF9B,KAAK+B,YAAcD,GAIjBjH,EAAqB,CACvB,MAAMoH,EAAkBpD,EAAoBnI,EAAQiE,GAGpD,IAAK,MAAMqC,KAAOgD,KAAKP,MAAM3C,OAC3B,GAAIE,EAAIkF,WAAW,GAAGD,MAAqB,CACzC,MAAME,EAASnC,KAAKP,MAAMlO,IAAIyL,GAC9B,GAAImF,EAIF,OAAOA,CAEX,CAMF,MAAM,WAAE3B,SAAqBR,KAAKE,YAC5BxF,QAAiB0H,EAAAA,EAAAA,GACrB5B,EAAWO,YAAYrK,EAAQiE,GAAM0H,MAAKC,EAAAA,EAAAA,OAEtCvP,QAAeyH,EAA8B,CACjDE,SAAUA,EACVhE,SACAiE,SAGI4H,EAAW,GAAGN,KAKpB,OAJAjC,KAAKP,MAAM9C,IAAI4F,EAAUxP,GAIlBA,CACT,CAEA,MAAMyP,EAhPV,SAAsB9L,EAAgBiE,GACpC,MAAM,QAAElE,GAAYkE,EAEd8H,EAAahM,EACf,GAAGA,EAAQlE,QAAQkE,EAAQ2I,KAAO,MAAM3I,EAAQrE,eAAeyE,UAAY,MAAMJ,EAAQrE,eAAe0E,sBAAwB,MAAML,EAAQrE,eAAe4E,WAAa,KAC1K,GAEJ,MAAO,GAAG6H,EAAoBnI,EAAQiE,MAAS8H,GACjD,CAwOqBC,CAAahM,EAAQiE,GAChCwH,EAASnC,KAAKP,MAAMlO,IAAIiR,GAC9B,GAAIL,EAIF,OAAOA,EAMT,MAAM,WAAE3B,SAAqBR,KAAKE,YAC5ByC,QAAwB3C,KAAKS,qBAE7B/F,QAAiB0H,EAAAA,EAAAA,GACrB5B,EAAWO,YAAYrK,EAAQiE,GAAM0H,MAAKC,EAAAA,EAAAA,OAGtCvP,QAAeyH,EAA8B,CACjDE,SAAUA,EACVhE,SACAiE,OACAF,cAAekI,EACVjM,IAAmB+D,EAAAA,EAAAA,IAAc/D,EAAQiM,QAC1CrI,IAON,OAJA0F,KAAKP,MAAM9C,IAAI6F,EAAUzP,GAIlBA,CACT,CAEA,uCAAM6P,CACJC,EACAlI,GAEA,MAAM,WAAE6F,SAAqBR,KAAKE,YAClC,OAAOM,EAAWoC,kCAAkCC,EAASlI,EAC/D,CAEA,qCAAMmI,CACJD,EAAoB,GACpBlI,EAA2B,CAAC,GAE5B,IAAKkI,EAAQzS,OACX,OAAO2S,EAAAA,EAAAA,MAGT,MAAM,aAAEC,GAAiBrI,EAGzB,GAAIqI,GAAc5S,OAAQ,CAExB,MAAM6S,QAAwBC,QAAQC,IACpCH,EAAaI,IAAIC,GACfrD,KAAKiB,gBAAgBoC,EAAO,IACvB1I,EACHE,qBAAqB,IACpB8F,KAAKhK,IAAQ,CAAG0M,QAAO1M,YAKxB2M,EAAcT,EAAQO,IAAI1M,IAC9B,MAAM6M,EAAoBN,EAAgBO,OACxC,EAAGH,WACDA,EAAMvE,UAAYpI,EAAOoI,SACzBuE,EAAMnM,MAAQR,EAAOU,KACrBiM,EAAMjM,IAAMV,EAAOQ,OAGvB,GAAiC,IAA7BqM,EAAkBnT,OACpB,OAAOqT,EAAAA,EAAAA,IAAa,CAClBC,SAAU,EACVC,SAAU,EACVC,SAAU,EACVC,gBAAiB,EACjBC,aAAc,EACdC,aAAc,IAKlB,MAAMC,EAAaT,EAAkBH,IAAI,EAAGzM,WAC1C8M,EAAAA,EAAAA,IA7TV,SACE1Q,EACAkR,EACAC,GAEA,MAAM,KAAEvN,EAAI,YAAEM,GAAgBlE,EAC9B,IAAI2Q,EAAWS,OAAOC,UAClBT,EAAWQ,OAAOE,UAClBT,EAAW,EACXC,EAAkB,EAClBC,EAAe,EAEnB,IAAK,IAAI5T,EAAI,EAAGC,EAAIwG,EAAKvG,OAAQF,EAAIC,EAAGD,IAAK,CAC3C,MAAM0F,EAAMe,EAAKzG,GACjB,GAAI0F,EAAK,CACP,MAAM9B,EAAMmD,EAAc/G,EAC1B,GAAI4D,GAAOmQ,GAAenQ,EAAMoQ,EAAW,CACzC,MAAM/F,EAAQvI,EAAI6B,MAClBiM,EAAWpP,KAAKC,IAAImP,EAAUvF,GAC9BwF,EAAWrP,KAAK4D,IAAIyL,EAAUxF,GAC9ByF,GAAYzF,EACZ0F,GAAmB1F,EAAQA,EAC3B2F,GACF,CACF,CACF,CAEA,MAAO,CACLJ,SAAUI,EAAe,EAAIJ,EAAW,EACxCC,SAAUG,EAAe,EAAIH,EAAW,EACxCC,WACAC,kBACAC,eACAC,aAAcD,EAElB,CA0RuBQ,CAAqB3N,EAAMD,EAAOQ,MAAOR,EAAOU,OAG/D,OAAOmN,EAAAA,EAAAA,IAA2BP,KAGpC,OAAOO,EAAAA,EAAAA,IAA2BjB,EACpC,CAGA,MAAMkB,QAActB,QAAQC,IAC1BN,EAAQO,IAAI1M,GAAUsJ,KAAKyE,2BAA2B/N,EAAQiE,KAEhE,OAAO4J,EAAAA,EAAAA,IAA2BC,EACpC,CAEA,iBAAME,CAAY/J,EAAoB,CAAC,GACrC,MAAM,WAAE6F,SAAqBR,KAAKE,YAClC,OAAOM,EAAWkE,YAAY/J,EAChC,CAEAgK,aAAAA,CAAcjO,GACZ,MAAMkO,EAAS,GAAGlO,EAAOoI,WACzB,IAAK,MAAM9B,KAAOgD,KAAKP,MAAM3C,OACvBE,EAAIkF,WAAW0C,IACjB5E,KAAKP,MAAMoF,OAAO7H,EAGxB,E,gFCtYK,SAAS3F,EACdhG,EACAyT,GAEA,MAAMrT,EAAUJ,EAAQE,IAAI,UACtBU,EAAMZ,EAAQE,IAAI,OAClBI,GAAMC,EAAAA,EAAAA,IAAUP,EAAS,KAAM,OAAoB,GACzD,GAAIY,EAAK,CACP,MAAMG,GAAgBC,EAAAA,EAAAA,GAAgBV,EAAIM,EAAKR,GACzCS,GAAgBC,EAAAA,EAAAA,GAAoBd,GACpC0T,EAAwB,GAE9B,IAAIzS,EAAY,EAChB,IAAK,MAAM,KAAEC,EAAI,UAAE1C,KAAeuC,EAAe,CAC/C,IAAK,MAAM,IAAElB,EAAG,IAAEC,KAASxB,EAAAA,EAAAA,GAAcmV,EAAKjV,GAAY,CACxD,MAAM4C,EACJP,IACEI,IAA0B,IAAbb,EAAiB5B,EAAUO,OAAS,EAAIe,EAAMA,KACxD,EACP,GAAK4T,EAAsB7T,GAMpB,CACL,MAAM8T,EAAMD,EAAsB7T,GAClC6T,EAAsB7T,GAAO,CAC3BqG,SAAU,IAAIyN,EAAIzN,SAAU9E,GAC5BA,KAAM6B,KAAK4D,IAAI8M,EAAIvS,KAAMA,GACzBF,KAAMyS,EAAIvS,KAAOA,EAAOuS,EAAIzS,KAAOA,EAEvC,MAZEwS,EAAsB7T,GAAO,CAC3BqB,OACAE,OACA8E,SAAU,CAAC9E,GAUjB,CACAH,GAAazC,EAAUO,MACzB,CACA,OAAO2U,CACT,CAEF,C","sources":["webpack://@jbrowse/web/../../plugins/alignments/src/MismatchParser/getNextRefPos.ts","webpack://@jbrowse/web/../../plugins/alignments/src/ModificationParser/getMethBins.ts","webpack://@jbrowse/web/../../plugins/alignments/src/ModificationParser/getModPositions.ts","webpack://@jbrowse/web/../../plugins/alignments/src/ModificationParser/getModProbabilities.ts","webpack://@jbrowse/web/../../plugins/alignments/src/PileupRenderer/renderers/cigarUtil.ts","webpack://@jbrowse/web/../../plugins/alignments/src/SNPCoverageAdapter/processDepthPrefixSum.ts","webpack://@jbrowse/web/../../plugins/alignments/src/SNPCoverageAdapter/util.ts","webpack://@jbrowse/web/../../plugins/alignments/src/SNPCoverageAdapter/processModifications.ts","webpack://@jbrowse/web/../../plugins/alignments/src/SNPCoverageAdapter/processReferenceCpGs.ts","webpack://@jbrowse/web/../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBinsPrefixSum.ts","webpack://@jbrowse/web/../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts","webpack://@jbrowse/web/../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts"],"sourcesContent":["// get relative reference sequence positions for positions given relative to\n// the read sequence\n\nimport {\n  CIGAR_D,\n  CIGAR_EQ,\n  CIGAR_I,\n  CIGAR_M,\n  CIGAR_N,\n  CIGAR_S,\n  CIGAR_X,\n} from '../PileupRenderer/renderers/cigarUtil.ts'\n\n// Handles both packed Uint32Array and unpacked number[] formats\nexport function getNextRefPos(\n  cigarOps: ArrayLike<number>,\n  positions: number[],\n) {\n  let readPos = 0\n  let refPos = 0\n  let currPos = 0\n  const ret = []\n\n  for (\n    let i = 0, l = cigarOps.length, l2 = positions.length;\n    i < l && currPos < l2;\n    i++\n  ) {\n    const packed = cigarOps[i]!\n    const len = packed >> 4\n    const op = packed & 0xf\n    if (op === CIGAR_S || op === CIGAR_I) {\n      for (let j = 0; j < len && currPos < l2; j++) {\n        if (positions[currPos] === readPos + j) {\n          currPos++\n        }\n      }\n      readPos += len\n    } else if (op === CIGAR_D || op === CIGAR_N) {\n      refPos += len\n    } else if (op === CIGAR_M || op === CIGAR_X || op === CIGAR_EQ) {\n      for (let j = 0; j < len && currPos < l2; j++) {\n        if (positions[currPos] === readPos + j) {\n          ret.push({\n            ref: refPos + j,\n            idx: currPos,\n          })\n          currPos++\n        }\n      }\n      readPos += len\n      refPos += len\n    }\n  }\n\n  return ret\n}\n","import { getModPositions } from './getModPositions.ts'\nimport { getModProbabilities } from './getModProbabilities.ts'\nimport { getNextRefPos } from '../MismatchParser/index.ts'\nimport { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getMethBins(feature: Feature, cigarOps: ArrayLike<number>) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const flen = fend - fstart\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string | undefined) || ''\n  const methBins = []\n  const hydroxyMethBins = []\n  const methProbs = []\n  const hydroxyMethProbs = []\n  const seq = feature.get('seq') as string | undefined\n  if (seq) {\n    const probabilities = getModProbabilities(feature)\n    const modifications = getModPositions(mm, seq, fstrand)\n    let probIndex = 0\n\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n        // Skip positions outside the feature bounds\n        if (ref < 0 || ref >= flen) {\n          continue\n        }\n\n        // Calculate probability index based on strand\n        const isReverseStrand = fstrand === -1\n        const idx2 =\n          probIndex + (isReverseStrand ? positions.length - 1 - idx : idx)\n        const prob = probabilities?.[idx2] || 0\n\n        // Store modification data in appropriate bins\n        if (type === 'm') {\n          methBins[ref] = 1\n          methProbs[ref] = prob\n        } else if (type === 'h') {\n          hydroxyMethBins[ref] = 1\n          hydroxyMethProbs[ref] = prob\n        }\n      }\n      probIndex += positions.length\n    }\n  }\n  return {\n    methBins,\n    hydroxyMethBins,\n    methProbs,\n    hydroxyMethProbs,\n  }\n}\n","import { revcom } from '@jbrowse/core/util'\n\nimport { modificationRegex } from './consts.ts'\n\n/**\n * Parse MM tag to extract modification positions on the read sequence.\n *\n *\n * @param mm - MM tag string (e.g., \"C+m,2,2,1;A+a,0,3\")\n * @param fseq - Read sequence\n * @param fstrand - Read strand (-1, 0, or 1)\n * @returns Array of modification objects with positions\n */\nexport function getModPositions(mm: string, fseq: string, fstrand: number) {\n  const seq = fstrand === -1 ? revcom(fseq) : fseq\n  const seqLength = seq.length\n  const mods = mm.split(';')\n  const result = []\n\n  for (const mod of mods) {\n    // Empty string\n    if (mod === '') {\n      continue\n    }\n\n    const split = mod.split(',')\n    const basemod = split[0]!\n    const matches = modificationRegex.exec(basemod)\n    if (!matches) {\n      throw new Error(`bad format for MM tag: \"${mod}\"`)\n    }\n    const [, base, strand, typestr] = matches\n\n    // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so split,\n    // and they can also be chemical codes (ChEBI) e.g. C+16061\n    const types = typestr!.split(/(\\d+|.)/)\n\n    // Note: Negative strand modifications (e.g., T-a) are now supported\n    // They are processed the same way as positive strand modifications\n    // The strand information is preserved for simplex/duplex detection\n\n    // this logic based on parse_mm.pl from hts-specs\n    for (const type of types) {\n      if (type === '') {\n        continue\n      }\n\n      const splitLength = split.length\n      let currPos = 0\n\n      // For reverse strand, pre-allocate array and fill backwards to avoid reverse()\n      // This is worthwhile because we avoid an O(n) reverse() operation\n      const positions = fstrand === -1 ? new Array(splitLength - 1) : []\n      let writeIndex = fstrand === -1 ? splitLength - 2 : 0\n\n      for (let i = 1; i < splitLength; i++) {\n        let delta = +split[i]!\n        do {\n          if (base === 'N' || base === seq[currPos]) {\n            delta--\n          }\n          currPos++\n        } while (delta >= 0 && currPos < seqLength)\n\n        // Calculate and store position\n        if (fstrand === -1) {\n          const pos = seqLength - currPos\n          if (pos >= 0) {\n            // avoid negative-number-positions in array, seen in #4629 cause\n            // unknown, could warrant some further investigation\n            positions[writeIndex--] = pos\n          } else {\n            // Position is negative (edge case from #4629)\n            // Don't write anything, don't decrement writeIndex\n            // This leaves a gap at the beginning of the array that we'll slice off\n          }\n        } else {\n          positions[writeIndex++] = currPos - 1\n        }\n      }\n\n      // For reverse strand, slice off any unfilled slots at the beginning\n      // (happens when some positions were negative and skipped)\n      const validPositions =\n        fstrand === -1 ? positions.slice(writeIndex + 1) : positions\n\n      result.push({\n        type,\n        base: base!,\n        strand: strand!,\n        positions: validPositions,\n      })\n    }\n  }\n\n  return result\n}\n","import { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getModProbabilities(feature: Feature) {\n  // ML stores probabilities as array of numerics and MP is scaled phred scores\n  // https://github.com/samtools/hts-specs/pull/418/files#diff-e765c6479316309f56b636f88189cdde8c40b854c7bdcce9ee7fe87a4e76febcR596\n  //\n  // - if we have ML or Ml, it is an 8bit probability, divide by 255\n  //\n  // - if we have MP or Mp it is phred scaled ASCII, which can go up to 90 but\n  // has very high likelihood basecalls at that point, we really only care about\n  // low qual calls <20 approx\n  const m = (getTagAlt(feature, 'ML', 'Ml') as number[] | string) || []\n  if (m) {\n    const result = []\n    if (typeof m === 'string') {\n      const parts = m.split(',')\n      for (let i = 0, l = parts.length; i < l; i++) {\n        result.push(+parts[i]! / 255)\n      }\n    } else {\n      for (let i = 0, l = m.length; i < l; i++) {\n        result.push(m[i]! / 255)\n      }\n    }\n    return result\n  } else {\n    const mp = getTagAlt(feature, 'MP', 'Mp') as string | undefined\n    if (mp) {\n      const result = []\n      for (let i = 0, l = mp.length; i < l; i++) {\n        const phred = mp.charCodeAt(i) - 33\n        result.push(Math.min(1, phred / 50))\n      }\n      return result\n    }\n    return undefined\n  }\n}\n","import { parseCigar2 } from '../../MismatchParser/index.ts'\n\n// CIGAR operation indices (from BAM spec) - used in packed Uint32Array format\nexport const CIGAR_M = 0\nexport const CIGAR_I = 1\nexport const CIGAR_D = 2\nexport const CIGAR_N = 3\nexport const CIGAR_S = 4\nexport const CIGAR_H = 5\nexport const CIGAR_P = 6\nexport const CIGAR_EQ = 7\nexport const CIGAR_X = 8\n\n// Bitmasks for CIGAR operation categories (use with: (1 << op) & MASK)\n// Alignment match ops (M=0, ==7) - may contain mismatches, need MD tag\nexport const CIGAR_M_EQ_MASK = 0b10000001 // (1<<0)|(1<<7) = 129\n// Match/mismatch ops that consume both ref and seq (M=0, ==7, X=8)\nexport const CIGAR_MATCH_MASK = 0b110000001 // (1<<0)|(1<<7)|(1<<8) = 385\n// Seq-only ops (S=4, I=1)\nexport const CIGAR_SEQ_ONLY_MASK = 0b10010 // (1<<1)|(1<<4) = 18\n// Ref-skip ops (D=2, N=3)\nexport const CIGAR_REF_SKIP_MASK = 0b1100 // (1<<2)|(1<<3) = 12\n// Ref-consuming ops (M=0, D=2, ==7, X=8)\nexport const CIGAR_REF_CONSUMING_MASK = 0b110000101 // (1<<0)|(1<<2)|(1<<7)|(1<<8) = 389\n\n// BAM 4-bit encoded sequence lookup table\nexport const SEQRET = '=ACMGRSVTWYHKDBN'\n\n// Numeric decoder - returns char codes directly (lowercase for case-insensitive comparison)\n// '=' = 61, 'a' = 97, 'c' = 99, 'm' = 109, 'g' = 103, 'r' = 114, 's' = 115, 'v' = 118,\n// 't' = 116, 'w' = 119, 'y' = 121, 'h' = 104, 'k' = 107, 'd' = 100, 'b' = 98, 'n' = 110\nexport const SEQRET_NUMERIC_DECODER = new Uint8Array([\n  61, 97, 99, 109, 103, 114, 115, 118, 116, 119, 121, 104, 107, 100, 98, 110,\n])\n\n// Pre-computed char lookup for ASCII codes (avoids String.fromCharCode in hot loops)\nexport const CHAR_FROM_CODE: string[] = Array.from({ length: 128 }, (_, i) =>\n  String.fromCharCode(i),\n)\n\n// Helper to ensure we have Uint32Array (packed format)\nexport function getCigarOps(\n  cigar: Uint32Array | string | undefined,\n): ArrayLike<number> {\n  return typeof cigar === 'string' ? parseCigar2(cigar) : cigar || []\n}\n","import type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion } from '@jbrowse/core/util/types'\n\n/**\n * SoA (Structure of Arrays) output for coverage depth.\n * Much more memory efficient than object-per-position.\n *\n * For a 100kb region, this uses ~1.2MB (3 × 100k × 4 bytes)\n * vs ~40MB+ for 100k objects with nested properties.\n */\nexport interface CoverageDepthSoA {\n  regionStart: number\n  regionSize: number\n  /** Coverage depth at each position */\n  depth: Int32Array\n  /** Forward strand (+1) read count at each position */\n  strandPlus: Int32Array\n  /** Reverse strand (-1) read count at each position */\n  strandMinus: Int32Array\n}\n\n// Reusable buffers - avoids allocation on every call\n// Size for up to 1MB regions (should cover most use cases)\nconst MAX_REGION_SIZE = 1_000_000\n\nconst depthChanges = new Int32Array(MAX_REGION_SIZE + 1)\nconst strandPlusChanges = new Int32Array(MAX_REGION_SIZE + 1)\nconst strandMinusChanges = new Int32Array(MAX_REGION_SIZE + 1)\n\n/**\n * Process feature depth using prefix sums algorithm.\n *\n * Complexity: O(features + regionSize) instead of O(features × avgReadLength)\n *\n * For 300x coverage with 50kb long reads over 100kb region:\n * - Original: O(600 × 50000) = 30M iterations\n * - This: O(600 + 100000) = 100k iterations\n */\nexport function processDepthPrefixSum(\n  features: Feature[],\n  region: AugmentedRegion,\n): CoverageDepthSoA {\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionSize = regionEnd - regionStart\n\n  if (regionSize > MAX_REGION_SIZE) {\n    throw new Error(\n      `Region size ${regionSize} exceeds maximum ${MAX_REGION_SIZE}`,\n    )\n  }\n\n  // Clear only the portion we need (faster than creating new arrays)\n  depthChanges.fill(0, 0, regionSize + 1)\n  strandPlusChanges.fill(0, 0, regionSize + 1)\n  strandMinusChanges.fill(0, 0, regionSize + 1)\n\n  // Pass 1: Record depth changes at boundaries - O(features)\n  for (const feature of features) {\n    const fstart = feature.get('start')\n    const fend = feature.get('end')\n    const fstrand = feature.get('strand') as -1 | 0 | 1\n\n    // Clamp to visible region\n    const visStart = Math.max(fstart, regionStart) - regionStart\n    const visEnd = Math.min(fend, regionEnd) - regionStart\n\n    if (visStart < visEnd) {\n      // Increment at start, decrement at end\n      depthChanges[visStart]!++\n      depthChanges[visEnd]!--\n\n      if (fstrand === 1) {\n        strandPlusChanges[visStart]!++\n        strandPlusChanges[visEnd]!--\n      } else if (fstrand === -1) {\n        strandMinusChanges[visStart]!++\n        strandMinusChanges[visEnd]!--\n      }\n    }\n  }\n\n  // Pass 2: Compute prefix sums - O(regionSize)\n  const depth = new Int32Array(regionSize)\n  const strandPlus = new Int32Array(regionSize)\n  const strandMinus = new Int32Array(regionSize)\n\n  let d = 0\n  let sp = 0\n  let sm = 0\n\n  for (let i = 0; i < regionSize; i++) {\n    d += depthChanges[i]!\n    sp += strandPlusChanges[i]!\n    sm += strandMinusChanges[i]!\n\n    depth[i] = d\n    strandPlus[i] = sp\n    strandMinus[i] = sm\n  }\n\n  return {\n    regionStart,\n    regionSize,\n    depth,\n    strandPlus,\n    strandMinus,\n  }\n}\n","import { INTERBASE_MASK } from '../shared/forEachMismatchTypes.ts'\n\nimport type {\n  ColorBy,\n  PreBaseCoverageBin,\n  PreBaseCoverageBinSubtypes,\n  PreBinEntry,\n} from '../shared/types.ts'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\n\nexport interface Opts {\n  bpPerPx?: number\n  colorBy?: ColorBy\n  stopToken?: StopToken\n  /** When true, only compute depth (skip mismatch/modification processing) */\n  statsEstimationMode?: boolean\n}\n\n// Uses bitwise check: converts type to bit position, then ANDs with INTERBASE_MASK\n// INTERBASE_MASK = 0b110010 = (1<<1)|(1<<4)|(1<<5) for insertion, softclip, hardclip\nexport function mismatchLen(type: number, length: number) {\n  return ((1 << type) & INTERBASE_MASK) === 0 ? length : 1\n}\n\n// Uses bitwise check: converts type to bit position, then ANDs with INTERBASE_MASK\n// INTERBASE_MASK = 0b110010 = (1<<1)|(1<<4)|(1<<5) for insertion, softclip, hardclip\nexport function isInterbase(type: number) {\n  return ((1 << type) & INTERBASE_MASK) !== 0\n}\n\nexport function createPreBinEntry(): PreBinEntry {\n  return {\n    entryDepth: 0,\n    probabilityTotal: 0,\n    probabilityCount: 0,\n    lengthTotal: 0,\n    lengthCount: 0,\n    lengthMin: Infinity,\n    lengthMax: -Infinity,\n    '-1': 0,\n    '0': 0,\n    '1': 0,\n  }\n}\n\nexport function createEmptyBin(): PreBaseCoverageBin {\n  return {\n    depth: 0,\n    readsCounted: 0,\n    snps: {},\n    ref: createPreBinEntry(),\n    mods: {},\n    nonmods: {},\n    delskips: {},\n    noncov: {},\n  }\n}\n\nexport function inc(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  length?: number,\n  sequence?: string,\n) {\n  const entry = (bin[type][field] ??= createPreBinEntry())\n  entry.entryDepth++\n  entry[strand]++\n  if (length !== undefined) {\n    entry.lengthTotal += length\n    entry.lengthCount++\n    entry.lengthMin = Math.min(entry.lengthMin, length)\n    entry.lengthMax = Math.max(entry.lengthMax, length)\n  }\n  if (sequence !== undefined) {\n    entry.sequenceCounts ??= new Map()\n    entry.sequenceCounts.set(\n      sequence,\n      (entry.sequenceCounts.get(sequence) ?? 0) + 1,\n    )\n  }\n}\n\nexport function incWithProbabilities(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  probability: number,\n) {\n  const entry = (bin[type][field] ??= createPreBinEntry())\n  entry.entryDepth++\n  entry.probabilityTotal += probability\n  entry.probabilityCount++\n  entry[strand]++\n}\n","import { max, sum } from '@jbrowse/core/util'\n\nimport { createEmptyBin, incWithProbabilities } from './util.ts'\nimport { parseCigar2 } from '../MismatchParser/index.ts'\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition.ts'\n\nimport type { ColorBy, PreBaseCoverageBin } from '../shared/types.ts'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport function processModifications({\n  feature,\n  colorBy,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  colorBy?: ColorBy\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const fend = feature.get('end')\n  const twoColor = colorBy?.modifications?.twoColor\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  const seq = feature.get('seq') as string | undefined\n  const modificationThreshold = colorBy?.modifications?.threshold ?? 10\n  const thresholdFraction = modificationThreshold / 100\n\n  if (!seq) {\n    return\n  }\n\n  const cigarOps =\n    feature.get('NUMERIC_CIGAR') ?? parseCigar2(feature.get('CIGAR'))\n  const regionStart = region.start\n  const regionEnd = region.end\n\n  // Get only the maximum probability modification at each position\n  // this is a hole-y array, does not work with normal for loop\n  // eslint-disable-next-line unicorn/no-array-for-each\n  getMaxProbModAtEachPosition(feature, cigarOps)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      const refPos = pos + fstart\n\n      // Skip positions outside visible region (early check before other work)\n      if (refPos < regionStart || refPos >= fend) {\n        return\n      }\n      const epos = refPos - regionStart\n      if (epos < 0 || epos >= regionEnd - regionStart) {\n        return\n      }\n\n      if (isolatedModification && type !== isolatedModification) {\n        return\n      }\n\n      // Check if modification probability exceeds threshold\n      if (prob < thresholdFraction) {\n        return\n      }\n\n      const bin = (bins[epos] ??= createEmptyBin())\n      bin.refbase = regionSequence[epos]\n\n      const s = 1 - sum(allProbs)\n      if (twoColor && s > max(allProbs)) {\n        incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s)\n      } else {\n        incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob)\n      }\n    },\n  )\n}\n","import { createEmptyBin, incWithProbabilities } from './util.ts'\nimport { parseCigar2 } from '../MismatchParser/index.ts'\nimport { getMethBins } from '../ModificationParser/getMethBins.ts'\nimport { DELETION_TYPE } from '../shared/forEachMismatchTypes.ts'\n\nimport type {\n  FeatureWithMismatchIterator,\n  PreBaseCoverageBin,\n} from '../shared/types.ts'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nfunction processCpG(\n  bins: PreBaseCoverageBin[],\n  binIdx: number,\n  fstrand: -1 | 0 | 1,\n  isMeth: boolean,\n  prob: number,\n  isDel: boolean,\n) {\n  if (isMeth) {\n    const bin = (bins[binIdx] ??= createEmptyBin())\n    incWithProbabilities(bin, fstrand, 'mods', 'cpg_meth', prob)\n    bin.ref.entryDepth--\n    bin.ref[fstrand]--\n  } else {\n    if (!isDel) {\n      const bin = (bins[binIdx] ??= createEmptyBin())\n      incWithProbabilities(bin, fstrand, 'nonmods', 'cpg_unmeth', 1 - prob)\n      bin.ref.entryDepth--\n      bin.ref[fstrand]--\n    }\n  }\n}\n\nexport function processReferenceCpGs({\n  feature,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: FeatureWithMismatchIterator\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const r = regionSequence.toLowerCase()\n  if (seq) {\n    const cigarOps =\n      feature.get('NUMERIC_CIGAR') ?? parseCigar2(feature.get('CIGAR'))\n    const { methBins, methProbs } = getMethBins(feature, cigarOps)\n    const isDeleted = new Array(methBins.length).fill(false)\n    feature.forEachMismatch((type, start, length) => {\n      if (type === DELETION_TYPE) {\n        const end = start + length\n        for (let i = start; i < end; i++) {\n          isDeleted[i] = true\n        }\n      }\n    })\n    const regionStart = region.start\n    const regionEnd = region.end\n\n    // Calculate visible range within feature\n    const visStart = Math.max(0, regionStart - fstart)\n    const visEnd = Math.min(fend - fstart, regionEnd - fstart)\n\n    // methylation based coloring takes into account both reference sequence\n    // CpG detection and reads\n    for (let i = visStart; i < visEnd; i++) {\n      const j = i + fstart\n      const l1 = r[j - regionStart + 1]\n      const l2 = r[j - regionStart + 2]\n      if (l1 === 'c' && l2 === 'g') {\n        const idx0 = j - regionStart\n        const idx1 = j - regionStart + 1\n        const b0 = methBins[i]\n        const b1 = methBins[i + 1]\n        const p0 = methProbs[i] || 0\n        const p1 = methProbs[i + 1] || 0\n        const isMeth = !!((b0 && p0 > 0.5) || (b1 && p1 > 0.5))\n        const isDel0 = isDeleted[i]\n        const isDel1 = isDeleted[i + 1]\n\n        processCpG(bins, idx0, fstrand, isMeth, p0, !!isDel0)\n        processCpG(bins, idx1, fstrand, isMeth, p1, !!isDel1)\n      }\n    }\n  }\n}\n","import { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport { processDepthPrefixSum } from './processDepthPrefixSum.ts'\nimport { processModifications } from './processModifications.ts'\nimport { processReferenceCpGs } from './processReferenceCpGs.ts'\nimport { isInterbase, mismatchLen } from './util.ts'\nimport { CHAR_FROM_CODE } from '../PileupRenderer/renderers/cigarUtil.ts'\nimport {\n  DELSKIP_MASK,\n  INSERTION_TYPE,\n  MISMATCH_MAP,\n  MISMATCH_REV_MAP,\n  SKIP_TYPE,\n} from '../shared/forEachMismatchTypes.ts'\n\nimport type { Opts } from './util.ts'\nimport type {\n  FeatureWithMismatchIterator,\n  Mismatch,\n  PreBaseCoverageBin,\n  PreBinEntry,\n  SkipMap,\n} from '../shared/types.ts'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\n// Type with lazy sub-objects (undefined until needed)\nexport interface LazyBin {\n  refbase?: string\n  depth: number\n  readsCounted: number\n  ref: PreBinEntry\n  snps?: Record<string, PreBinEntry>\n  mods?: Record<string, PreBinEntry>\n  nonmods?: Record<string, PreBinEntry>\n  delskips?: Record<string, PreBinEntry>\n  noncov?: Record<string, PreBinEntry>\n}\n\n// Result format - sparse bins array with regionStart for computing positions\nexport interface CoverageBinsResult {\n  bins: (LazyBin | undefined)[]\n  regionStart: number\n  skipmap: SkipMap\n}\n\n// Finalize a lazy bin before returning to renderer\nexport function finalizeLazyBin(bin: LazyBin): PreBaseCoverageBin {\n  bin.snps ??= {}\n  bin.mods ??= {}\n  bin.nonmods ??= {}\n  bin.delskips ??= {}\n  bin.noncov ??= {}\n  return bin as PreBaseCoverageBin\n}\n\n// Reusable change arrays for deletion prefix sums\nconst MAX_REGION_SIZE = 1_000_000\nconst deletionChanges = new Int32Array(MAX_REGION_SIZE + 1)\n\ninterface SparseSnpEntry {\n  base: string\n  strand: -1 | 0 | 1\n  altbase?: string\n}\n\ninterface SparseNoncovEntry {\n  strand: -1 | 0 | 1\n  type: 'insertion' | 'softclip' | 'hardclip'\n  length: number\n  sequence?: string\n}\n\nfunction finalizeBinEntry(entry: PreBinEntry) {\n  const { probabilityTotal, probabilityCount, lengthTotal, lengthCount } = entry\n  if (probabilityCount) {\n    entry.avgProbability = probabilityTotal / probabilityCount\n  }\n  if (lengthCount) {\n    entry.avgLength = lengthTotal / lengthCount\n    entry.minLength = entry.lengthMin\n    entry.maxLength = entry.lengthMax\n  }\n  if (entry.sequenceCounts?.size) {\n    let maxCount = 0\n    let topSeq: string | undefined\n    for (const [seq, count] of entry.sequenceCounts) {\n      if (count > maxCount) {\n        maxCount = count\n        topSeq = seq\n      }\n    }\n    entry.topSequence = topSeq\n    entry.sequenceCounts = undefined\n  }\n}\n\n/**\n * Generate coverage bins using prefix sums algorithm.\n *\n * This is ~100-1000x faster than the original per-base iteration approach,\n * especially for high-coverage or long-read data.\n *\n * Returns structure-of-arrays format for efficient rendering.\n */\nexport async function generateCoverageBinsPrefixSum({\n  fetchSequence,\n  features,\n  region,\n  opts,\n}: {\n  features: FeatureWithMismatchIterator[]\n  region: Region\n  opts: Opts\n  fetchSequence?: (arg: Region) => Promise<string | undefined>\n}): Promise<CoverageBinsResult> {\n  const { stopToken, colorBy, statsEstimationMode } = opts\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionSize = regionEnd - regionStart\n\n  // Step 1: Compute depth using prefix sums - O(features + regionSize)\n  checkStopToken(stopToken)\n  const depthSoA = processDepthPrefixSum(features, region)\n\n  // In statsEstimationMode, skip all mismatch/modification processing. This is a\n  // performance optimization for when only the depth of coverage is needed, for\n  // example, for an overview of the data or when calculating statistics. Just\n  // return depth-only bins for fast coverage estimation\n  if (statsEstimationMode) {\n    const bins: (LazyBin | undefined)[] = []\n    for (let i = 0; i < regionSize; i++) {\n      const depth = depthSoA.depth[i]!\n      if (depth === 0) {\n        continue\n      }\n      bins[i] = {\n        depth,\n        readsCounted: depth,\n        ref: {\n          entryDepth: depth,\n          '-1': depthSoA.strandMinus[i]!,\n          '0': 0,\n          '1': depthSoA.strandPlus[i]!,\n          probabilityTotal: 0,\n          probabilityCount: 0,\n          lengthTotal: 0,\n          lengthCount: 0,\n          lengthMin: Infinity,\n          lengthMax: -Infinity,\n        },\n      }\n    }\n    return { bins, regionStart, skipmap: {} }\n  }\n\n  // Step 2: Process mismatches with prefix sums for deletions\n  checkStopToken(stopToken)\n  // Clear deletion changes buffer\n  deletionChanges.fill(0, 0, regionSize + 1)\n\n  const snpEvents: { pos: number; entry: SparseSnpEntry }[] = []\n  const noncovEvents: { pos: number; entry: SparseNoncovEntry }[] = []\n  const skipmap: SkipMap = {}\n\n  for (let i = 0, l = features.length; i < l; i++) {\n    processFeature(region, features[i]!, skipmap, noncovEvents, snpEvents)\n  }\n  // Clear feature reference to avoid retaining last feature in memory\n  featureCtx.feature = undefined\n\n  // Compute deletion depth prefix sums\n  const deletionDepth = new Int32Array(regionSize)\n  let dd = 0\n  for (let i = 0; i < regionSize; i++) {\n    dd += deletionChanges[i]!\n    deletionDepth[i] = dd\n  }\n\n  // Step 3: Handle modifications if needed (still per-feature, but modifications are rare)\n  let regionSequence: string | undefined\n  const modBins: PreBaseCoverageBin[] = []\n  const start2 = Math.max(0, regionStart - 1)\n  const diff = regionStart - start2\n\n  if (colorBy?.type === 'modifications' && fetchSequence) {\n    checkStopToken(stopToken)\n    regionSequence =\n      (await fetchSequence({\n        ...region,\n        start: start2,\n        end: regionEnd + 1,\n      })) || ''\n    const slicedSequence = regionSequence.slice(diff)\n\n    for (const feature of features) {\n      processModifications({\n        feature,\n        colorBy,\n        bins: modBins,\n        region,\n        regionSequence: slicedSequence,\n      })\n    }\n  } else if (colorBy?.type === 'methylation' && fetchSequence) {\n    checkStopToken(stopToken)\n    regionSequence ??=\n      (await fetchSequence({\n        ...region,\n        start: start2,\n        end: regionEnd + 1,\n      })) || ''\n\n    for (const feature of features) {\n      processReferenceCpGs({\n        feature,\n        bins: modBins,\n        region,\n        regionSequence,\n      })\n    }\n  }\n\n  // Step 4: Build final bins array - only create objects for positions with data\n  checkStopToken(stopToken)\n  const bins: (LazyBin | undefined)[] = []\n\n  // First pass: create bins only where we have depth > 0 or other data\n  for (let i = 0; i < regionSize; i++) {\n    const depth = depthSoA.depth[i]!\n    const delDepth = deletionDepth[i]!\n\n    // Skip empty positions (sparse optimization)\n    if (depth === 0 && delDepth === 0) {\n      continue\n    }\n\n    bins[i] = {\n      depth: depth - delDepth,\n      readsCounted: depth,\n      ref: {\n        entryDepth: depth,\n        '-1': depthSoA.strandMinus[i]!,\n        '0': 0,\n        '1': depthSoA.strandPlus[i]!,\n        probabilityTotal: 0,\n        probabilityCount: 0,\n        lengthTotal: 0,\n        lengthCount: 0,\n        lengthMin: Infinity,\n        lengthMax: -Infinity,\n      },\n      delskips:\n        delDepth > 0 ? { deletion: createDeletionEntry(delDepth) } : undefined,\n    }\n  }\n\n  // Apply SNP events\n  for (let i = 0, l = snpEvents.length; i < l; i++) {\n    const evt = snpEvents[i]!\n    const pos = evt.pos\n    const entry = evt.entry\n\n    let bin = bins[pos]\n    if (!bin) {\n      bin = {\n        depth: 0,\n        readsCounted: 0,\n        ref: {\n          entryDepth: 0,\n          '-1': 0,\n          '0': 0,\n          '1': 0,\n          probabilityTotal: 0,\n          probabilityCount: 0,\n          lengthTotal: 0,\n          lengthCount: 0,\n          lengthMin: Infinity,\n          lengthMax: -Infinity,\n        },\n      }\n      bins[pos] = bin\n    }\n    const base = entry.base\n    const strand = entry.strand\n    const snps = (bin.snps ??= {})\n    let snpEntry = snps[base]\n    if (!snpEntry) {\n      snpEntry = {\n        entryDepth: 0,\n        '-1': 0,\n        '0': 0,\n        '1': 0,\n        probabilityTotal: 0,\n        probabilityCount: 0,\n        lengthTotal: 0,\n        lengthCount: 0,\n        lengthMin: Infinity,\n        lengthMax: -Infinity,\n      }\n      snps[base] = snpEntry\n    }\n    snpEntry.entryDepth++\n    snpEntry[strand]++\n    bin.ref.entryDepth--\n    bin.ref[strand]--\n    if (entry.altbase) {\n      bin.refbase = entry.altbase\n    }\n  }\n\n  // Apply noncov events (insertions, clips)\n  for (let i = 0, l = noncovEvents.length; i < l; i++) {\n    const evt = noncovEvents[i]!\n    const pos = evt.pos\n    const entry = evt.entry\n\n    let bin = bins[pos]\n    if (!bin) {\n      bin = {\n        depth: 0,\n        readsCounted: 0,\n        ref: {\n          entryDepth: 0,\n          '-1': 0,\n          '0': 0,\n          '1': 0,\n          probabilityTotal: 0,\n          probabilityCount: 0,\n          lengthTotal: 0,\n          lengthCount: 0,\n          lengthMin: Infinity,\n          lengthMax: -Infinity,\n        },\n      }\n      bins[pos] = bin\n    }\n    const strand = entry.strand\n    const type = entry.type\n    const length = entry.length\n    const noncov = (bin.noncov ??= {})\n    let noncovEntry = noncov[type]\n    if (!noncovEntry) {\n      noncovEntry = {\n        entryDepth: 0,\n        '-1': 0,\n        '0': 0,\n        '1': 0,\n        probabilityTotal: 0,\n        probabilityCount: 0,\n        lengthTotal: 0,\n        lengthCount: 0,\n        lengthMin: Infinity,\n        lengthMax: -Infinity,\n      }\n      noncov[type] = noncovEntry\n    }\n    noncovEntry.entryDepth++\n    noncovEntry[strand]++\n    noncovEntry.lengthTotal += length\n    noncovEntry.lengthCount++\n    noncovEntry.lengthMin = Math.min(noncovEntry.lengthMin, length)\n    noncovEntry.lengthMax = Math.max(noncovEntry.lengthMax, length)\n    const seq = entry.sequence\n    if (seq !== undefined) {\n      noncovEntry.sequenceCounts ??= new Map()\n      noncovEntry.sequenceCounts.set(\n        seq,\n        (noncovEntry.sequenceCounts.get(seq) ?? 0) + 1,\n      )\n    }\n  }\n\n  // Merge modification bins - only into bins that already have depth data\n  // (matching original behavior where processModifications/processReferenceCpGs\n  // only added to existing bins)\n  for (let i = 0, l = modBins.length; i < l; i++) {\n    const modBin = modBins[i]\n    if (modBin) {\n      const bin = bins[i]\n      if (bin) {\n        if (Object.keys(modBin.mods).length > 0) {\n          bin.mods = Object.assign(bin.mods ?? {}, modBin.mods)\n        }\n        if (Object.keys(modBin.nonmods).length > 0) {\n          bin.nonmods = Object.assign(bin.nonmods ?? {}, modBin.nonmods)\n        }\n        if (modBin.refbase !== undefined) {\n          bin.refbase = modBin.refbase\n        }\n      }\n    }\n  }\n\n  // Finalize entries\n  for (let i = 0, l = bins.length; i < l; i++) {\n    const bin = bins[i]\n    if (bin) {\n      if (bin.mods) {\n        for (const key in bin.mods) {\n          finalizeBinEntry(bin.mods[key]!)\n        }\n      }\n      if (bin.nonmods) {\n        for (const key in bin.nonmods) {\n          finalizeBinEntry(bin.nonmods[key]!)\n        }\n      }\n      if (bin.noncov) {\n        for (const key in bin.noncov) {\n          finalizeBinEntry(bin.noncov[key]!)\n        }\n      }\n    }\n  }\n\n  return { bins, regionStart, skipmap }\n}\n\nfunction createDeletionEntry(depth: number): PreBinEntry {\n  return {\n    entryDepth: depth,\n    '-1': 0,\n    '0': 0,\n    '1': 0,\n    probabilityTotal: 0,\n    probabilityCount: 0,\n    lengthTotal: 0,\n    lengthCount: 0,\n    lengthMin: Infinity,\n    lengthMax: -Infinity,\n  }\n}\n\n// Shared context to avoid closure allocation per feature\nconst featureCtx = {\n  fstart: 0,\n  fstrand: 0 as -1 | 0 | 1,\n  regionStart: 0,\n  regionEnd: 0,\n  regionSize: 0,\n  feature: undefined as FeatureWithMismatchIterator | Feature | undefined,\n  skipmap: undefined as SkipMap | undefined,\n  noncovEvents: undefined as\n    | { pos: number; entry: SparseNoncovEntry }[]\n    | undefined,\n  snpEvents: undefined as { pos: number; entry: SparseSnpEntry }[] | undefined,\n}\n\nfunction mismatchHandler(\n  type: number,\n  start: number,\n  refLen: number,\n  base: string,\n  _qual: number | undefined,\n  altbase: number | undefined,\n  interbaseLen: number | undefined,\n) {\n  const {\n    fstart,\n    fstrand,\n    regionStart,\n    regionEnd,\n    regionSize,\n    feature,\n    skipmap,\n    noncovEvents,\n    snpEvents,\n  } = featureCtx\n  const mstart = fstart + start\n  const mlen = mismatchLen(type, refLen)\n  const mend = mstart + mlen\n\n  if ((1 << type) & DELSKIP_MASK) {\n    const visStart = Math.max(mstart, regionStart) - regionStart\n    const visEnd = Math.min(mend, regionEnd) - regionStart\n\n    if (visStart < visEnd) {\n      deletionChanges[visStart]!++\n      deletionChanges[visEnd]!--\n    }\n\n    if (type === SKIP_TYPE) {\n      const tags = feature!.get('tags') as Record<string, string> | undefined\n      const xs = tags?.XS || tags?.TS\n      const ts = tags?.ts\n      const effectiveStrand =\n        xs === '+'\n          ? 1\n          : xs === '-'\n            ? -1\n            : (ts === '+' ? 1 : ts === '-' ? -1 : 0) * fstrand\n      const hash = `${mstart}_${mend}_${effectiveStrand}`\n      if (skipmap![hash] === undefined) {\n        skipmap![hash] = {\n          start: mstart,\n          end: mend,\n          strand: fstrand,\n          effectiveStrand,\n          score: 0,\n        }\n      }\n      skipmap![hash].score++\n    }\n  } else if (type === INSERTION_TYPE) {\n    const epos = mstart - regionStart\n    if (epos >= 0 && epos < regionSize) {\n      noncovEvents!.push({\n        pos: epos,\n        entry: {\n          strand: fstrand,\n          type: 'insertion',\n          length: interbaseLen!,\n          sequence: base,\n        },\n      })\n    }\n  } else if (isInterbase(type)) {\n    const epos = mstart - regionStart\n    if (epos >= 0 && epos < regionSize) {\n      noncovEvents!.push({\n        pos: epos,\n        entry: {\n          strand: fstrand,\n          type: MISMATCH_MAP[type]! as 'hardclip' | 'softclip',\n          length: interbaseLen!,\n        },\n      })\n    }\n  } else {\n    const epos = mstart - regionStart\n    if (epos >= 0 && epos < regionSize) {\n      snpEvents!.push({\n        pos: epos,\n        entry: {\n          base,\n          strand: fstrand,\n          altbase: CHAR_FROM_CODE[altbase!],\n        },\n      })\n    }\n  }\n}\n\nfunction processFeature(\n  region: Region,\n  feature: FeatureWithMismatchIterator | Feature,\n  skipmap: SkipMap,\n  noncovEvents: { pos: number; entry: SparseNoncovEntry }[],\n  snpEvents: { pos: number; entry: SparseSnpEntry }[],\n) {\n  featureCtx.fstart = feature.get('start')\n  featureCtx.fstrand = feature.get('strand') as -1 | 0 | 1\n  featureCtx.regionStart = region.start\n  featureCtx.regionEnd = region.end\n  featureCtx.regionSize = region.end - region.start\n  featureCtx.feature = feature\n  featureCtx.skipmap = skipmap\n  featureCtx.noncovEvents = noncovEvents\n  featureCtx.snpEvents = snpEvents\n\n  if ('forEachMismatch' in feature) {\n    feature.forEachMismatch(mismatchHandler)\n  } else {\n    const mismatches = feature.get('mismatches') as Mismatch[] | undefined\n    if (mismatches) {\n      for (const m of mismatches) {\n        let base: string\n        let cliplen: number | undefined\n        if (m.type === 'mismatch') {\n          base = m.base\n        } else if (m.type === 'insertion') {\n          base = m.insertedBases ?? ''\n          cliplen = m.insertlen\n        } else if (m.type === 'softclip' || m.type === 'hardclip') {\n          base = ''\n          cliplen = m.cliplen\n        } else {\n          base = ''\n        }\n        mismatchHandler(\n          MISMATCH_REV_MAP[m.type],\n          m.start,\n          m.length,\n          base,\n          m.type === 'mismatch' ? m.qual : undefined,\n          m.type === 'mismatch' ? m.altbase?.charCodeAt(0) : undefined,\n          cliplen,\n        )\n      }\n    }\n  }\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  aggregateQuantitativeStats,\n  blankStats,\n} from '@jbrowse/core/data_adapters/BaseAdapter/stats'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { rectifyStats } from '@jbrowse/core/util/stats'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport { fetchSequence } from '../util.ts'\nimport {\n  finalizeLazyBin,\n  generateCoverageBinsPrefixSum,\n} from './generateCoverageBinsPrefixSum.ts'\n\nimport type { CoverageBinsResult } from './generateCoverageBinsPrefixSum.ts'\nimport type {\n  ColorBy,\n  FeatureWithMismatchIterator,\n  FilterBy,\n} from '../shared/types.ts'\nimport type {\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\ninterface SNPCoverageOptions extends BaseOptions {\n  filterBy?: FilterBy\n  colorBy?: ColorBy\n  staticBlocks?: Region[]\n  statsEstimationMode?: boolean\n}\n\nfunction makeFilterByKey(filterBy?: FilterBy) {\n  return filterBy\n    ? `${filterBy.flagExclude}|${filterBy.flagInclude}|${filterBy.readName ?? ''}|${filterBy.tagFilter?.tag ?? ''}|${filterBy.tagFilter?.value ?? ''}`\n    : ''\n}\n\nfunction makeRegionFilterKey(region: Region, opts: SNPCoverageOptions) {\n  return `${region.refName}:${region.start}-${region.end}|${makeFilterByKey(opts.filterBy)}|${opts.trackInstanceId || ''}`\n}\n\nfunction makeCacheKey(region: Region, opts: SNPCoverageOptions) {\n  const { colorBy } = opts\n\n  const colorByKey = colorBy\n    ? `${colorBy.type}|${colorBy.tag ?? ''}|${colorBy.modifications?.twoColor ?? ''}|${colorBy.modifications?.isolatedModification ?? ''}|${colorBy.modifications?.threshold ?? ''}`\n    : ''\n\n  return `${makeRegionFilterKey(region, opts)}|${colorByKey}`\n}\n\nfunction computeStatsFromBins(\n  result: CoverageBinsResult,\n  targetStart: number,\n  targetEnd: number,\n) {\n  const { bins, regionStart } = result\n  let scoreMin = Number.MAX_VALUE\n  let scoreMax = Number.MIN_VALUE\n  let scoreSum = 0\n  let scoreSumSquares = 0\n  let featureCount = 0\n\n  for (let i = 0, l = bins.length; i < l; i++) {\n    const bin = bins[i]\n    if (bin) {\n      const pos = regionStart + i\n      if (pos >= targetStart && pos < targetEnd) {\n        const score = bin.depth\n        scoreMin = Math.min(scoreMin, score)\n        scoreMax = Math.max(scoreMax, score)\n        scoreSum += score\n        scoreSumSquares += score * score\n        featureCount++\n      }\n    }\n  }\n\n  return {\n    scoreMin: featureCount > 0 ? scoreMin : 0,\n    scoreMax: featureCount > 0 ? scoreMax : 0,\n    scoreSum,\n    scoreSumSquares,\n    featureCount,\n    basesCovered: featureCount,\n  }\n}\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  private sequenceAdapterP?: Promise<BaseSequenceAdapter | undefined>\n\n  private subadapterRef?: BaseFeatureDataAdapter\n\n  // Cache for coverage results (keyed by region+filterBy+colorBy)\n  // Stats estimation uses empty colorBy key, full rendering includes colorBy\n  private cache = new QuickLRU<string, CoverageBinsResult>({\n    maxSize: 50,\n    maxAge: 5 * 60 * 1000, // 5 minute TTL\n  })\n\n  private lastBpPerPx?: number\n\n  /**\n   * Override to propagate sequenceAdapterConfig to the subadapter\n   */\n  setSequenceAdapterConfig(config: Record<string, unknown>) {\n    super.setSequenceAdapterConfig(config)\n    // Propagate to subadapter if it exists\n    if (this.subadapterRef) {\n      this.subadapterRef.setSequenceAdapterConfig(config)\n    }\n  }\n\n  protected async configure() {\n    const subadapterConfigBase = this.getConf('subadapter')\n\n    // Initialize from config if not set externally via setSequenceAdapterConfig\n    this.sequenceAdapterConfig ??= this.getConf('sequenceAdapter')\n\n    // Use the base subadapter config to ensure consistent cache keys\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfigBase)\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    const subadapter = dataAdapter.dataAdapter as BaseFeatureDataAdapter\n    this.subadapterRef = subadapter\n\n    // Propagate sequenceAdapterConfig to the subadapter\n    if (this.sequenceAdapterConfig) {\n      subadapter.setSequenceAdapterConfig(this.sequenceAdapterConfig)\n    }\n\n    return { subadapter }\n  }\n\n  async getSequenceAdapter() {\n    const config = this.sequenceAdapterConfig ?? this.getConf('sequenceAdapter')\n    if (!config || !this.getSubAdapter) {\n      return undefined\n    }\n    this.sequenceAdapterP ??= this.getSubAdapter(config)\n      .then(r => {\n        const adapter = r.dataAdapter as BaseSequenceAdapter\n        // verify adapter has getSequence method (e.g. ChromSizesAdapter doesn't)\n        return 'getSequence' in adapter ? adapter : undefined\n      })\n      .catch((e: unknown) => {\n        this.sequenceAdapterP = undefined\n        throw e\n      })\n    return this.sequenceAdapterP\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { bins, regionStart, skipmap } = await this.getCoverageBins(\n        region,\n        opts,\n      )\n\n      const { refName } = region\n      const adapterId = this.id\n\n      // Emit coverage features using lightweight inline feature objects\n      for (let i = 0, l = bins.length; i < l; i++) {\n        const bin = bins[i]\n        if (bin) {\n          const start = regionStart + i\n          const snpinfo = finalizeLazyBin(bin)\n          const score = bin.depth\n          observer.next({\n            get: (field: string): any => {\n              switch (field) {\n                case 'start':\n                  return start\n                case 'end':\n                  return start + 1\n                case 'score':\n                  return score\n                case 'snpinfo':\n                  return snpinfo\n                case 'refName':\n                  return refName\n                default:\n                  return undefined\n              }\n            },\n            id: () => `${adapterId}-${start}`,\n            toJSON: () => ({\n              uniqueId: `${adapterId}-${start}`,\n              start,\n              end: start + 1,\n              score,\n              snpinfo,\n              refName,\n            }),\n          })\n        }\n      }\n\n      // Emit skip features for arc rendering\n      for (const [key, skip] of Object.entries(skipmap)) {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              refName,\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              effectiveStrand: skip.effectiveStrand,\n            },\n          }),\n        )\n      }\n\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  private async getCoverageBins(\n    region: Region,\n    opts: SNPCoverageOptions = {},\n  ): Promise<CoverageBinsResult> {\n    const { bpPerPx, statsEstimationMode } = opts\n\n    // Clear cache when bpPerPx changes (zoom level changed)\n    // Only compare when both values are defined to avoid clearing on stats calls\n    if (\n      bpPerPx !== undefined &&\n      this.lastBpPerPx !== undefined &&\n      this.lastBpPerPx !== bpPerPx\n    ) {\n      this.cache.clear()\n    }\n    if (bpPerPx !== undefined) {\n      this.lastBpPerPx = bpPerPx\n    }\n\n    // For statsEstimationMode, check for any cached result with same region+filterBy\n    if (statsEstimationMode) {\n      const regionFilterKey = makeRegionFilterKey(region, opts)\n\n      // Check cache for any entry matching this region+filterBy (any colorBy)\n      for (const key of this.cache.keys()) {\n        if (key.startsWith(`${regionFilterKey}|`)) {\n          const cached = this.cache.get(key)\n          if (cached) {\n            // console.log(\n            //   `[SNPCoverageAdapter] cache HIT for statsEstimation ${region.refName}:${region.start}-${region.end}`,\n            // )\n            return cached\n          }\n        }\n      }\n\n      // console.log(\n      //   `[SNPCoverageAdapter] cache MISS for statsEstimation ${region.refName}:${region.start}-${region.end}`,\n      // )\n      const { subadapter } = await this.configure()\n      const features = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n      const result = await generateCoverageBinsPrefixSum({\n        features: features as FeatureWithMismatchIterator[],\n        region,\n        opts,\n      })\n      // Cache with empty colorBy key for stats-only results\n      const statsKey = `${regionFilterKey}|`\n      this.cache.set(statsKey, result)\n      // console.log(\n      //   `[SNPCoverageAdapter] cached statsEstimation result`,\n      // )\n      return result\n    }\n\n    const cacheKey = makeCacheKey(region, opts)\n    const cached = this.cache.get(cacheKey)\n    if (cached) {\n      // console.log(\n      //   `[SNPCoverageAdapter] cache HIT for ${region.refName}:${region.start}-${region.end}`,\n      // )\n      return cached\n    }\n    // console.log(\n    //   `[SNPCoverageAdapter] cache MISS for ${region.refName}:${region.start}-${region.end}`,\n    // )\n\n    const { subadapter } = await this.configure()\n    const sequenceAdapter = await this.getSequenceAdapter()\n\n    const features = await firstValueFrom(\n      subadapter.getFeatures(region, opts).pipe(toArray()),\n    )\n\n    const result = await generateCoverageBinsPrefixSum({\n      features: features as FeatureWithMismatchIterator[],\n      region,\n      opts,\n      fetchSequence: sequenceAdapter\n        ? (region: Region) => fetchSequence(region, sequenceAdapter)\n        : undefined,\n    })\n\n    this.cache.set(cacheKey, result)\n    // console.log(\n    //   `[SNPCoverageAdapter] cached full result: ${formatBytes(estimateBinsByteSize(result))} (total cache: ${formatBytes(this.estimateCacheBytes())})`,\n    // )\n    return result\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getMultiRegionQuantitativeStats(\n    regions: Region[] = [],\n    opts: SNPCoverageOptions = {},\n  ) {\n    if (!regions.length) {\n      return blankStats()\n    }\n\n    const { staticBlocks } = opts\n\n    // If staticBlocks provided, use them for caching and subselect for dynamic regions\n    if (staticBlocks?.length) {\n      // Fetch data for all static blocks (these will be cached)\n      const staticBlockData = await Promise.all(\n        staticBlocks.map(block =>\n          this.getCoverageBins(block, {\n            ...opts,\n            statsEstimationMode: true,\n          }).then(bins => ({ block, bins })),\n        ),\n      )\n\n      // For each dynamic region, find overlapping static blocks and compute stats\n      const regionStats = regions.map(region => {\n        const overlappingBlocks = staticBlockData.filter(\n          ({ block }) =>\n            block.refName === region.refName &&\n            block.start < region.end &&\n            block.end > region.start,\n        )\n\n        if (overlappingBlocks.length === 0) {\n          return rectifyStats({\n            scoreMin: 0,\n            scoreMax: 0,\n            scoreSum: 0,\n            scoreSumSquares: 0,\n            featureCount: 0,\n            basesCovered: 0,\n          })\n        }\n\n        // Compute stats from overlapping blocks, subselecting to region bounds\n        const blockStats = overlappingBlocks.map(({ bins }) =>\n          rectifyStats(computeStatsFromBins(bins, region.start, region.end)),\n        )\n\n        return aggregateQuantitativeStats(blockStats)\n      })\n\n      return aggregateQuantitativeStats(regionStats)\n    }\n\n    // Fallback: fetch directly for each dynamic region (original behavior)\n    const stats = await Promise.all(\n      regions.map(region => this.getRegionQuantitativeStats(region, opts)),\n    )\n    return aggregateQuantitativeStats(stats)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n\n  freeResources(region: Region) {\n    const prefix = `${region.refName}:`\n    for (const key of this.cache.keys()) {\n      if (key.startsWith(prefix)) {\n        this.cache.delete(key)\n      }\n    }\n  }\n}\n","import { getNextRefPos } from '../MismatchParser/index.ts'\nimport { getModPositions } from '../ModificationParser/getModPositions.ts'\nimport { getModProbabilities } from '../ModificationParser/getModProbabilities.ts'\nimport { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  ops: ArrayLike<number>,\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n"],"names":["getNextRefPos","cigarOps","positions","readPos","refPos","currPos","ret","i","l","length","l2","packed","len","op","CIGAR_S","CIGAR_I","j","CIGAR_D","CIGAR_N","CIGAR_M","CIGAR_X","CIGAR_EQ","push","ref","idx","getMethBins","feature","fstart","get","fend","fstrand","flen","mm","getTagAlt","methBins","hydroxyMethBins","methProbs","hydroxyMethProbs","seq","probabilities","getModProbabilities","modifications","getModPositions","probIndex","type","idx2","prob","fseq","revcom","seqLength","mods","split","result","mod","basemod","matches","modificationRegex","exec","Error","base","strand","typestr","types","splitLength","Array","writeIndex","delta","pos","validPositions","slice","m","parts","mp","phred","charCodeAt","Math","min","CIGAR_H","CIGAR_M_EQ_MASK","CIGAR_REF_CONSUMING_MASK","SEQRET","SEQRET_NUMERIC_DECODER","Uint8Array","CHAR_FROM_CODE","from","_","String","fromCharCode","getCigarOps","cigar","parseCigar2","depthChanges","Int32Array","MAX_REGION_SIZE","strandPlusChanges","strandMinusChanges","incWithProbabilities","bin","field","probability","entry","entryDepth","probabilityTotal","probabilityCount","lengthTotal","lengthCount","lengthMin","Infinity","lengthMax","processModifications","colorBy","region","bins","regionSequence","twoColor","isolatedModification","thresholdFraction","threshold","regionStart","start","regionEnd","end","getMaxProbModAtEachPosition","forEach","allProbs","epos","depth","readsCounted","snps","nonmods","delskips","noncov","refbase","s","sum","max","processCpG","binIdx","isMeth","isDel","processReferenceCpGs","r","toLowerCase","isDeleted","fill","forEachMismatch","DELETION_TYPE","visStart","visEnd","l1","idx0","idx1","b0","b1","p0","p1","isDel0","isDel1","finalizeLazyBin","deletionChanges","finalizeBinEntry","avgProbability","avgLength","minLength","maxLength","sequenceCounts","size","topSeq","maxCount","count","topSequence","undefined","async","generateCoverageBinsPrefixSum","fetchSequence","features","opts","stopToken","statsEstimationMode","regionSize","checkStopToken","depthSoA","strandPlus","strandMinus","d","sp","sm","processDepthPrefixSum","skipmap","snpEvents","noncovEvents","processFeature","featureCtx","deletionDepth","dd","modBins","start2","diff","slicedSequence","delDepth","deletion","createDeletionEntry","evt","snpEntry","altbase","noncovEntry","sequence","Map","set","modBin","Object","keys","assign","key","mismatchHandler","refLen","_qual","interbaseLen","mstart","mlen","INTERBASE_MASK","mismatchLen","mend","DELSKIP_MASK","SKIP_TYPE","tags","xs","XS","TS","ts","effectiveStrand","hash","score","INSERTION_TYPE","isInterbase","MISMATCH_MAP","mismatches","cliplen","insertedBases","insertlen","MISMATCH_REV_MAP","qual","makeRegionFilterKey","refName","filterBy","flagExclude","flagInclude","readName","tagFilter","tag","value","trackInstanceId","SNPCoverageAdapter","BaseFeatureDataAdapter","cache","QuickLRU","maxSize","maxAge","setSequenceAdapterConfig","config","super","this","subadapterRef","configure","subadapterConfigBase","getConf","sequenceAdapterConfig","dataAdapter","getSubAdapter","subadapter","getSequenceAdapter","sequenceAdapterP","then","adapter","catch","e","getFeatures","ObservableCreate","getCoverageBins","adapterId","id","snpinfo","observer","next","toJSON","uniqueId","skip","entries","SimpleFeature","data","complete","bpPerPx","lastBpPerPx","clear","regionFilterKey","startsWith","cached","firstValueFrom","pipe","toArray","statsKey","cacheKey","colorByKey","makeCacheKey","sequenceAdapter","getMultiRegionFeatureDensityStats","regions","getMultiRegionQuantitativeStats","blankStats","staticBlocks","staticBlockData","Promise","all","map","block","regionStats","overlappingBlocks","filter","rectifyStats","scoreMin","scoreMax","scoreSum","scoreSumSquares","featureCount","basesCovered","blockStats","targetStart","targetEnd","Number","MAX_VALUE","MIN_VALUE","computeStatsFromBins","aggregateQuantitativeStats","stats","getRegionQuantitativeStats","getRefNames","freeResources","prefix","delete","ops","maxProbModForPosition","old"],"sourceRoot":""}