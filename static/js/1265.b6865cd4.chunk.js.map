{"version":3,"file":"static/js/1265.b6865cd4.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/sequence/src/BgzipFastaAdapter/BgzipFastaAdapter.ts","webpack://@jbrowse/web/../../plugins/sequence/src/IndexedFastaAdapter/IndexedFastaAdapter.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+indexedfasta@5.0.2/node_modules/@gmod/indexedfasta/src/indexedFasta.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+indexedfasta@5.0.2/node_modules/@gmod/indexedfasta/src/bgzipIndexedFasta.ts"],"sourcesContent":["import { BgzipIndexedFasta } from '@gmod/indexedfasta'\nimport { openLocation } from '@jbrowse/core/util/io'\n\nimport IndexedFasta from '../IndexedFastaAdapter/IndexedFastaAdapter.ts'\n\nimport type { FileLocation } from '@jbrowse/core/util/types'\n\nexport default class BgzipFastaAdapter extends IndexedFasta {\n  public async setupPre() {\n    const fastaLocation = this.getConf('fastaLocation')\n    const faiLocation = this.getConf('faiLocation')\n    const gziLocation = this.getConf('gziLocation')\n    const fastaOpts = {\n      fasta: openLocation(fastaLocation as FileLocation, this.pluginManager),\n      fai: openLocation(faiLocation as FileLocation, this.pluginManager),\n      gzi: openLocation(gziLocation as FileLocation, this.pluginManager),\n    }\n\n    return { fasta: new BgzipIndexedFasta(fastaOpts) }\n  }\n}\n","import AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport { IndexedFasta } from '@gmod/indexedfasta'\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { SimpleFeature, updateStatus2 } from '@jbrowse/core/util'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { FileLocation, NoAssemblyRegion } from '@jbrowse/core/util/types'\n\ninterface T {\n  refName: string\n  start: number\n  end: number\n  fasta: IndexedFasta\n}\n\nexport default class IndexedFastaAdapter extends BaseSequenceAdapter {\n  protected setupP?: Promise<{ fasta: IndexedFasta }>\n\n  private seqCache = new AbortablePromiseCache<T, string | undefined>({\n    cache: new QuickLRU({ maxSize: 200 }),\n    fill: async (args: T) => {\n      const { refName, start, end, fasta } = args\n      return fasta.getSequence(refName, start, end)\n    },\n  })\n\n  public async getRefNames(_opts?: BaseOptions) {\n    const { fasta } = await this.setup()\n    return fasta.getSequenceNames()\n  }\n\n  public async getRegions(_opts?: BaseOptions) {\n    const { fasta } = await this.setup()\n    const seqSizes = await fasta.getSequenceSizes()\n    return Object.keys(seqSizes).map(refName => ({\n      refName,\n      start: 0,\n      end: seqSizes[refName]!,\n    }))\n  }\n\n  public async setupPre() {\n    const fastaLocation = this.getConf('fastaLocation') as FileLocation\n    const faiLocation = this.getConf('faiLocation') as FileLocation\n\n    return {\n      fasta: new IndexedFasta({\n        fasta: openLocation(fastaLocation, this.pluginManager),\n        fai: openLocation(faiLocation, this.pluginManager),\n      }),\n    }\n  }\n\n  public async getHeader() {\n    const loc = this.getConf('metadataLocation')\n    return loc.uri === '' || loc.uri === '/path/to/fa.metadata.yaml'\n      ? null\n      : openLocation(loc, this.pluginManager).readFile('utf8')\n  }\n\n  public async setup() {\n    if (!this.setupP) {\n      this.setupP = this.setupPre().catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  public getFeatures(region: NoAssemblyRegion, opts?: BaseOptions) {\n    const { statusCallback = () => {}, stopToken } = opts || {}\n    const { refName, start, end } = region\n    return ObservableCreate<Feature>(async observer => {\n      await updateStatus2(\n        'Downloading sequence',\n        statusCallback,\n        stopToken,\n        async () => {\n          const { fasta } = await this.setup()\n          const size = await fasta.getSequenceSize(refName)\n          const regionEnd = Math.min(size || 0, end)\n          const chunkSize = 128000\n\n          const s = start - (start % chunkSize)\n          const e = end + (chunkSize - (end % chunkSize))\n          const chunkPromises = []\n          for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {\n            const r = {\n              refName,\n              start: chunkStart,\n              end: chunkStart + chunkSize,\n            }\n            chunkPromises.push(\n              this.seqCache.get(`${refName}-${chunkStart}-${r.end}`, {\n                ...r,\n                fasta,\n              }),\n            )\n          }\n          checkStopToken(stopToken)\n          const chunks = await Promise.all(chunkPromises)\n          const len = end - start\n          const seq = chunks.join('').slice(start - s, start - s + len)\n          if (seq) {\n            observer.next(\n              new SimpleFeature({\n                id: `${refName}-${start}-${regionEnd}`,\n                data: {\n                  refName,\n                  start,\n                  end: regionEnd,\n                  seq,\n                },\n              }),\n            )\n          }\n        },\n      )\n      observer.complete()\n    })\n  }\n}\n","// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter<V> {\n  callbacks = new Set<(arg: V) => void>()\n  currentMessage?: V\n\n  addCallback(callback: (arg: V) => void = () => {}): void {\n    this.callbacks.add(callback)\n    if (this.currentMessage) {\n      callback(this.currentMessage)\n    }\n  }\n\n  callback(message: V) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController.ts'\nimport AggregateStatusReporter from './AggregateStatusReporter.ts'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U, V> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: (arg: V) => void,\n) => Promise<U>\n\ninterface Entry<U, V> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter<V>\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U, V = string> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U, V>>\n  private fillCallback: FillCallback<T, U, V>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U, V>\n    cache: Cache<Entry<U, V>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U, V>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter<V>()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U, V> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: V) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch((error: unknown) => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      (error: unknown) => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n","import { LocalFile } from 'generic-filehandle2'\n\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\ninterface BaseOpts {\n  signal?: AbortSignal\n}\n\ninterface ParsedIndex {\n  names: string[]\n  nameToIndex: Record<string, number>\n  offsets: number[]\n  lengths: number[]\n  lineLengths: number[]\n  lineBytes: number[]\n  sizesCache?: Record<string, number>\n}\n\nfunction _faiOffset(\n  offset: number,\n  lineBytes: number,\n  lineLength: number,\n  pos: number,\n) {\n  return offset + lineBytes * Math.floor(pos / lineLength) + (pos % lineLength)\n}\n\nasync function readFAI(\n  fai: GenericFilehandle,\n  opts: BaseOpts = {},\n): Promise<ParsedIndex> {\n  const decoder = new TextDecoder('utf8')\n  const text = decoder.decode(\n    (await fai.readFile(opts)) as unknown as Uint8Array,\n  )\n\n  const names: string[] = []\n  const offsets: number[] = []\n  const lengths: number[] = []\n  const lineLengths: number[] = []\n  const lineBytes: number[] = []\n  const nameToIndex: Record<string, number> = {}\n\n  let lineStart = 0\n  const len = text.length\n  let idx = 0\n  while (lineStart < len) {\n    let lineEnd = text.indexOf('\\n', lineStart)\n    if (lineEnd === -1) {\n      lineEnd = len\n    }\n    let line = text.slice(lineStart, lineEnd)\n    if (line.endsWith('\\r')) {\n      line = line.slice(0, -1)\n    }\n    line = line.trim()\n    lineStart = lineEnd + 1\n\n    if (line.length === 0) {\n      continue\n    }\n\n    const tab1 = line.indexOf('\\t')\n    const tab2 = line.indexOf('\\t', tab1 + 1)\n    const tab3 = line.indexOf('\\t', tab2 + 1)\n    const tab4 = line.indexOf('\\t', tab3 + 1)\n\n    const name = line.slice(0, tab1)\n    if (name.startsWith('>')) {\n      throw new Error(\n        'found > in sequence name, might have supplied FASTA file for the FASTA index',\n      )\n    }\n\n    names.push(name)\n    lengths.push(+line.slice(tab1 + 1, tab2))\n    offsets.push(+line.slice(tab2 + 1, tab3))\n    lineLengths.push(+line.slice(tab3 + 1, tab4))\n    lineBytes.push(+line.slice(tab4 + 1))\n    nameToIndex[name] = idx\n    idx++\n  }\n\n  return { names, nameToIndex, offsets, lengths, lineLengths, lineBytes }\n}\n\nexport default class IndexedFasta {\n  fasta: GenericFilehandle\n  fai: GenericFilehandle\n  indexes?: Promise<ParsedIndex>\n\n  constructor({\n    fasta,\n    fai,\n    path,\n    faiPath,\n  }: {\n    fasta?: GenericFilehandle\n    fai?: GenericFilehandle\n    path?: string\n    faiPath?: string\n  }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass filehandle for fasta or path to localfile')\n    }\n\n    if (fai) {\n      this.fai = fai\n    } else if (faiPath) {\n      this.fai = new LocalFile(faiPath)\n    } else if (path) {\n      this.fai = new LocalFile(`${path}.fai`)\n    } else {\n      throw new Error('Need to pass filehandle for  or path to localfile')\n    }\n  }\n\n  async _getIndexes(opts?: BaseOpts) {\n    if (!this.indexes) {\n      this.indexes = readFAI(this.fai, opts).catch((e: unknown) => {\n        this.indexes = undefined\n        throw e\n      })\n    }\n    return this.indexes\n  }\n\n  /**\n   * @returns array of string sequence names that are present in the index, in\n   * which the array index indicates the sequence ID, and the value is the\n   * sequence name\n   */\n  async getSequenceNames(opts?: BaseOpts) {\n    return (await this._getIndexes(opts)).names\n  }\n\n  /**\n   * @returns object mapping sequence names to their lengths\n   */\n  async getSequenceSizes(opts?: BaseOpts) {\n    const idx = await this._getIndexes(opts)\n    if (!idx.sizesCache) {\n      const sizes: Record<string, number> = {}\n      for (let i = 0; i < idx.names.length; i++) {\n        sizes[idx.names[i]!] = idx.lengths[i]!\n      }\n      idx.sizesCache = sizes\n    }\n    return idx.sizesCache\n  }\n\n  /**\n   * @returns the length of the given sequence, or undefined if not found\n   */\n  async getSequenceSize(seqName: string, opts?: BaseOpts) {\n    const idx = await this._getIndexes(opts)\n    const i = idx.nameToIndex[seqName]\n    return i !== undefined ? idx.lengths[i] : undefined\n  }\n\n  /**\n   * @param name\n   *\n   * @returns true if the file contains the given reference sequence name\n   */\n  async hasReferenceSequence(name: string, opts?: BaseOpts) {\n    return (await this._getIndexes(opts)).nameToIndex[name] !== undefined\n  }\n\n  /**\n   * @param seqName\n   * @param min\n   * @param max\n   */\n  async getResiduesByName(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const idx = await this._getIndexes(opts)\n    const i = idx.nameToIndex[seqName]\n    if (i === undefined) {\n      return undefined\n    }\n    return this._fetchFromIndex(\n      idx.offsets[i]!,\n      idx.lineBytes[i]!,\n      idx.lineLengths[i]!,\n      idx.lengths[i]!,\n      min,\n      max,\n      opts,\n    )\n  }\n\n  //alias for getResiduesByName\n  async getSequence(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    return this.getResiduesByName(seqName, min, max, opts)\n  }\n\n  async _fetchFromIndex(\n    offset: number,\n    lineBytes: number,\n    lineLength: number,\n    seqLength: number,\n    min = 0,\n    max?: number,\n    opts?: BaseOpts,\n  ) {\n    let end = max\n    if (min < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    if (end === undefined || end > seqLength) {\n      end = seqLength\n    }\n    if (min >= end) {\n      return ''\n    }\n\n    const position = _faiOffset(offset, lineBytes, lineLength, min)\n    const readlen = _faiOffset(offset, lineBytes, lineLength, end) - position\n\n    const decoder = new TextDecoder('utf8')\n    const seq = decoder\n      .decode(await this.fasta.read(readlen, position, opts))\n      .replace(/\\s+/g, '')\n\n    if (/[^\\x20-\\x7e]/.test(seq.slice(0, 1000))) {\n      throw new Error(\n        'Non-ASCII characters detected in sequence. The file may be gzip compressed. Use BgzipIndexedFasta for bgzip files, or decompress the file.',\n      )\n    }\n\n    return seq\n  }\n}\n","import { BgzfFilehandle } from '@gmod/bgzf-filehandle'\nimport { LocalFile } from 'generic-filehandle2'\n\nimport IndexedFasta from './indexedFasta.ts'\n\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport default class BgzipIndexedFasta extends IndexedFasta {\n  constructor({\n    fasta,\n    path,\n    fai,\n    faiPath,\n    gzi,\n    gziPath,\n  }: {\n    fasta?: GenericFilehandle\n    path?: string\n    fai?: GenericFilehandle\n    faiPath?: string\n    gzi?: GenericFilehandle\n    gziPath?: string\n  }) {\n    super({ fasta, path, fai, faiPath })\n    if (fasta && gzi) {\n      // @ts-expect-error\n      this.fasta = new BgzfFilehandle({\n        filehandle: fasta,\n        gziFilehandle: gzi,\n      })\n    } else if (path && gziPath) {\n      // @ts-expect-error\n      this.fasta = new BgzfFilehandle({\n        filehandle: new LocalFile(path),\n        gziFilehandle: new LocalFile(gziPath),\n      })\n    }\n  }\n}\n"],"names":["BgzipFastaAdapter","IndexedFasta","setupPre","fastaLocation","this","getConf","faiLocation","gziLocation","fastaOpts","fasta","openLocation","pluginManager","fai","gzi","BgzipIndexedFasta","IndexedFastaAdapter","BaseSequenceAdapter","seqCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","async","refName","start","end","args","getSequence","getRefNames","_opts","setup","getSequenceNames","getRegions","seqSizes","getSequenceSizes","Object","keys","map","getHeader","loc","uri","readFile","setupP","catch","e","undefined","getFeatures","region","opts","statusCallback","stopToken","ObservableCreate","updateStatus2","size","getSequenceSize","regionEnd","Math","min","chunkSize","s","chunkPromises","chunkStart","r","push","get","checkStopToken","chunks","Promise","all","len","seq","join","slice","observer","next","SimpleFeature","id","data","complete","NullSignal","AggregateAbortController","constructor","signals","Set","abortController","AbortController","addSignal","signal","aborted","Error","add","handleAborted","addEventListener","delete","abort","AggregateStatusReporter","callbacks","addCallback","callback","currentMessage","message","elt","TypeError","set","fillCallback","isAbortException","exception","name","code","evict","key","entry","aborter","statusReporter","newEntry","promise","settled","then","error","console","checkSinglePromise","checkForSingleAbort","assign","result","has","AbortSignal","cacheEntry","cachedEntry","clear","keyIter","deleteCount","done","value","_faiOffset","offset","lineBytes","lineLength","pos","floor","path","faiPath","LocalFile","_getIndexes","indexes","text","TextDecoder","decode","names","offsets","lengths","lineLengths","nameToIndex","lineStart","length","idx","lineEnd","indexOf","line","endsWith","trim","tab1","tab2","tab3","tab4","startsWith","readFAI","sizesCache","sizes","i","seqName","hasReferenceSequence","getResiduesByName","max","_fetchFromIndex","seqLength","position","readlen","read","replace","test","gziPath","super","BgzfFilehandle","filehandle","gziFilehandle"],"sourceRoot":""}