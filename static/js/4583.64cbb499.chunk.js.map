{"version":3,"file":"static/js/4583.64cbb499.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/VcfImport.ts","webpack://@jbrowse/web/../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/isNumber.ts","webpack://@jbrowse/web/../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/util.ts","webpack://@jbrowse/web/../../plugins/variants/src/VcfFeature/index.ts","webpack://@jbrowse/web/../../plugins/variants/src/VcfFeature/util.ts"],"sourcesContent":["import VCF from '@gmod/vcf'\nimport { VcfFeature } from '@jbrowse/plugin-variants'\n\nimport { isNumber } from './isNumber.ts'\nimport { bufferToLines } from './util.ts'\n\nexport function parseVcfBuffer(buffer: Uint8Array) {\n  const lines = bufferToLines(buffer)\n  const header = lines.filter(l => l.startsWith('#')).join('\\n')\n  const body = lines.filter(l => !l.startsWith('#'))\n  const vcfParser = new VCF({ header })\n  const keys = new Set<string>()\n  const rows = []\n  let i = 0\n  for (const line of body) {\n    const [CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, FORMAT, ...rest] =\n      line.split('\\t')\n    const ret = Object.fromEntries(\n      INFO?.split(';')\n        .map(f => f.trim())\n        .map(e => {\n          const [key, val = 'true'] = e.split('=')\n          const k = `INFO.${key!.trim()}`\n          keys.add(k)\n          const v = val.trim()\n          return [k, isNumber(v) ? +v : v]\n        }) || [],\n    )\n    rows.push({\n      // what is displayed\n      cellData: {\n        CHROM,\n        POS: +POS!,\n        ID,\n        REF,\n        ALT,\n        QUAL: isNumber(QUAL) ? +QUAL : QUAL,\n        FILTER,\n        FORMAT,\n        ...ret,\n        ...Object.fromEntries(\n          vcfParser.samples.map((s, idx) => [s, rest[idx]]),\n        ),\n      },\n      // a simplefeatureserializd\n      feature: new VcfFeature({\n        parser: vcfParser,\n        variant: vcfParser.parseLine(line),\n        id: `vcf-${i}`,\n      }).toJSON(),\n    })\n    i++\n  }\n  return {\n    columns: [\n      'CHROM',\n      'POS',\n      'ID',\n      'REF',\n      'ALT',\n      'QUAL',\n      'FILTER',\n      ...keys,\n      'FORMAT',\n      ...vcfParser.samples,\n    ].map(c => ({ name: c })),\n    rowSet: {\n      rows,\n    },\n  }\n}\n","/**\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport function isNumber(num: unknown): num is number {\n  if (typeof num === 'number') {\n    return num - num === 0\n  } else if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite(+num)\n  } else {\n    return false\n  }\n}\n","export function parseStrand(strand?: string) {\n  if (strand === '+') {\n    return 1\n  } else if (strand === '-') {\n    return -1\n  } else {\n    return undefined\n  }\n}\n\nexport function bufferToLines(buffer: Uint8Array) {\n  return new TextDecoder('utf8')\n    .decode(buffer)\n    .split(/\\n|\\r\\n|\\r/)\n    .map(f => f.trim())\n    .filter(f => !!f)\n}\n","import { type Feature, max } from '@jbrowse/core/util'\n\nimport { getSOTermAndDescription } from './util.ts'\n\nimport type VCFParser from '@gmod/vcf'\nimport type { GenotypeCallback, Variant } from '@gmod/vcf'\n\ntype FeatureData = ReturnType<typeof dataFromVariant>\n\nfunction dataFromVariant(variant: Variant, parser: VCFParser) {\n  const { REF = '', ALT, POS, CHROM, ID } = variant\n  const start = POS - 1\n  const [type, description] = getSOTermAndDescription(REF, ALT, parser)\n\n  return {\n    refName: CHROM,\n    start,\n    end: getEnd(variant),\n    description,\n    type,\n    name: ID?.join(','),\n  }\n}\nfunction getEnd(variant: Variant) {\n  const { POS, REF = '', ALT = [] } = variant\n  const start = POS - 1\n  let isTRA = false\n  let isSymbolic = false\n  for (const a of ALT) {\n    if (a.includes('<')) {\n      isSymbolic = true\n      if (a === '<TRA>') {\n        isTRA = true\n        break\n      }\n    }\n  }\n  if (isSymbolic) {\n    const info = variant.INFO\n    if (info.END && !isTRA) {\n      return +(info.END as string[])[0]!\n    }\n    const lens = []\n    if (info.SVLEN && !isTRA) {\n      const svlens = info.SVLEN as string[]\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let i = 0; i < svlens.length; i++) {\n        const svlen = svlens[i]!\n        if (ALT[i]?.startsWith('<INS')) {\n          lens.push(1)\n        } else {\n          lens.push(Math.abs(+svlen))\n        }\n      }\n      return start + max(lens)\n    }\n  }\n  return start + REF.length\n}\n\nexport default class VCFFeature implements Feature {\n  private variant: Variant\n\n  private parser: VCFParser\n\n  private data: FeatureData\n\n  private _id: string\n\n  constructor(args: { variant: Variant; parser: VCFParser; id: string }) {\n    this.variant = args.variant\n    this.parser = args.parser\n    this.data = dataFromVariant(this.variant, this.parser)\n    this._id = args.id\n  }\n\n  get(field: string): any {\n    return field === 'samples'\n      ? this.variant.SAMPLES()\n      : field === 'genotypes'\n        ? this.variant.GENOTYPES()\n        : (this.data[field as keyof typeof this.data] ??\n          this.variant[field as keyof typeof this.variant])\n  }\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  id() {\n    return this._id\n  }\n\n  processGenotypes(callback: GenotypeCallback) {\n    this.variant.processGenotypes(callback)\n  }\n\n  toJSON(): any {\n    return {\n      uniqueId: this._id,\n      ...this.variant.toJSON(),\n      ...this.data,\n      samples: this.variant.SAMPLES(),\n    }\n  }\n}\n","import { parseBreakend } from '@gmod/vcf'\nimport { getBpDisplayStr } from '@jbrowse/core/util'\n\nimport type VCF from '@gmod/vcf'\n\nconst genotypeDelimRegex = /[/|]/\n\nfunction isBreakend(alt: string) {\n  return (\n    alt.includes('[') ||\n    alt.includes(']') ||\n    alt.startsWith('.') ||\n    alt.endsWith('.')\n  )\n}\n\nfunction isSymbolic(alt: string) {\n  return alt.startsWith('<') || isBreakend(alt)\n}\n\nfunction isInversion(ref: string, alt: string) {\n  return ref.split('').reverse().join('') === alt\n}\n\nconst altTypeToSO: Record<string, string> = {\n  '<DEL>': 'deletion',\n  '<INS>': 'insertion',\n  '<DUP>': 'duplication',\n  '<INV>': 'inversion',\n  '<INVDUP>': 'inverted_duplication',\n  '<CNV>': 'copy_number_variation',\n  '<TRA>': 'translocation',\n  '<DUP:TANDEM>': 'tandem_duplication',\n  '<NON_REF>': 'sequence_variant',\n  '<*>': 'sequence_variant',\n}\n\nexport function getSOTermAndDescription(\n  ref: string,\n  alt: string[] | undefined,\n  parser: VCF,\n): string[] {\n  if (!alt || alt.length === 0) {\n    return ['remark', 'no alternative alleles']\n  }\n\n  const soTerms = alt.map(a => getSOTerm(a, ref, parser))\n  const uniqueSoTerms = [...new Set(soTerms)]\n  const description = formatGroupDescription(ref, alt)\n\n  return [uniqueSoTerms.join(','), description]\n}\n\nfunction getSOTerm(alt: string, ref: string, parser: VCF): string {\n  // Symbolic alleles\n  if (alt.startsWith('<')) {\n    return findSOTerm(alt, parser) ?? 'variant'\n  }\n\n  // Breakends\n  if (isBreakend(alt) && parseBreakend(alt)) {\n    return 'breakend'\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n\n  if (lenRef === 1 && lenAlt === 1) {\n    return 'SNV'\n  } else if (lenRef === lenAlt) {\n    return isInversion(ref, alt) ? 'inversion' : 'substitution'\n  } else {\n    return lenRef < lenAlt ? 'insertion' : 'deletion'\n  }\n}\n\nfunction formatGroupDescription(ref: string, alts: string[]): string {\n  if (alts.every(isSymbolic)) {\n    return alts.join(',')\n  }\n\n  const lenRef = ref.length\n\n  return `${ref.length > 10 ? getBpDisplayStr(lenRef) : ref} -> ${alts.map(a => (a.length > 10 ? getBpDisplayStr(a.length) : a)).join(',')}`\n}\n\nfunction findSOTerm(alt: string, parser: VCF): string | undefined {\n  if (altTypeToSO[alt]) {\n    return altTypeToSO[alt]\n  }\n  if (parser.getMetadata('ALT', alt)) {\n    return 'sequence_variant'\n  }\n  // Try parent term by stripping last component, e.g. '<INS:ME>' -> '<INS>'\n  const parts = alt.slice(1, -1).split(':')\n  return parts.length > 1\n    ? findSOTerm(`<${parts.slice(0, -1).join(':')}>`, parser)\n    : undefined\n}\n\nexport function getSOAndDescFromAltDefs(alt: string, parser: VCF): string[] {\n  if (!alt.startsWith('<')) {\n    return []\n  }\n\n  const soTerm = findSOTerm(alt, parser)\n  return [soTerm ?? 'variant', alt]\n}\n\nexport function getMinimalDesc(ref: string, alt: string) {\n  if (isSymbolic(alt) || (ref.length === 1 && alt.length === 1)) {\n    return alt\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n  const isLong = lenRef > 5 || lenAlt > 5\n\n  return isLong\n    ? `${getBpDisplayStr(lenRef)} -> ${getBpDisplayStr(lenAlt)}`\n    : `${ref} -> ${alt}`\n}\n\nexport function makeSimpleAltString(\n  genotype: string,\n  ref: string,\n  alt: string[],\n) {\n  return genotype\n    .split(genotypeDelimRegex)\n    .map(r =>\n      r === '.'\n        ? '.'\n        : +r === 0\n          ? `ref(${ref.length < 10 ? ref : getBpDisplayStr(ref.length)})`\n          : getMinimalDesc(ref, alt[+r - 1] || ''),\n    )\n    .join(genotype.includes('|') ? '|' : '/')\n}\n"],"names":["parseVcfBuffer","buffer","lines","bufferToLines","header","filter","l","startsWith","join","body","vcfParser","VCF","keys","Set","rows","i","line","CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO","FORMAT","rest","split","ret","Object","fromEntries","map","f","trim","e","key","val","k","add","v","isNumber","push","cellData","samples","s","idx","feature","VcfFeature","parser","variant","parseLine","id","toJSON","columns","c","name","rowSet","num","Number","isFinite","parseStrand","strand","TextDecoder","decode","getEnd","start","isTRA","isSymbolic","a","includes","info","END","lens","SVLEN","svlens","length","svlen","Math","abs","max","VCFFeature","constructor","args","this","data","type","description","getSOTermAndDescription","refName","end","dataFromVariant","_id","get","field","SAMPLES","GENOTYPES","parent","children","processGenotypes","callback","uniqueId","genotypeDelimRegex","isBreakend","alt","endsWith","altTypeToSO","ref","soTerms","findSOTerm","parseBreakend","lenRef","lenAlt","reverse","isInversion","getSOTerm","uniqueSoTerms","alts","every","getBpDisplayStr","formatGroupDescription","getMetadata","parts","slice","undefined","getMinimalDesc","makeSimpleAltString","genotype","r"],"sourceRoot":""}