{"version":3,"file":"static/js/8309.4e6f12de.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/bam/src/chunk.ts","../../../node_modules/@gmod/bam/src/indexFile.ts","../../../node_modules/@gmod/bam/src/long.ts","../../../node_modules/@gmod/bam/src/util.ts","../../../node_modules/@gmod/bam/src/virtualOffset.ts","../../../node_modules/@gmod/bam/src/bai.ts","../../../node_modules/@gmod/bam/src/csi.ts","../../../node_modules/@gmod/bam/src/nullFilehandle.ts","../../../node_modules/@gmod/bam/src/constants.ts","../../../node_modules/@gmod/bam/src/record.ts","../../../node_modules/@gmod/bam/src/sam.ts","../../../node_modules/@gmod/bam/src/bamFile.ts","../../../node_modules/@gmod/bam/src/htsget.ts","../../../node_modules/crc/mjs/calculators/crc32.js","../../../node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts"],"sourcesContent":["import { Offset } from './virtualOffset'\n\n// little class representing a chunk in the index\nexport default class Chunk {\n  public buffer?: Uint8Array\n\n  constructor(\n    public minv: Offset,\n    public maxv: Offset,\n    public bin: number,\n    public _fetchedSize?: number,\n  ) {}\n\n  toUniqueString() {\n    return `${this.minv.toString()}..${this.maxv.toString()} (bin ${\n      this.bin\n    }, fetchedSize ${this.fetchedSize()})`\n  }\n\n  toString() {\n    return this.toUniqueString()\n  }\n\n  compareTo(b: Chunk) {\n    return (\n      this.minv.compareTo(b.minv) ||\n      this.maxv.compareTo(b.maxv) ||\n      this.bin - b.bin\n    )\n  }\n\n  fetchedSize() {\n    if (this._fetchedSize !== undefined) {\n      return this._fetchedSize\n    }\n    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition\n  }\n}\n","import Chunk from './chunk'\nimport { BaseOpts } from './util'\n\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport default abstract class IndexFile {\n  public filehandle: GenericFilehandle\n  public renameRefSeq: (s: string) => string\n\n  /**\n   * @param {filehandle} filehandle\n   * @param {function} renameRefSeqs\n   */\n  constructor({\n    filehandle,\n    renameRefSeq = (n: string) => n,\n  }: {\n    filehandle: GenericFilehandle\n    renameRefSeq?: (a: string) => string\n  }) {\n    this.filehandle = filehandle\n    this.renameRefSeq = renameRefSeq\n  }\n  public abstract lineCount(refId: number): Promise<number>\n  public abstract indexCov(\n    refId: number,\n    start?: number,\n    end?: number,\n  ): Promise<{ start: number; end: number; score: number }[]>\n\n  public abstract blocksForRange(\n    chrId: number,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ): Promise<Chunk[]>\n}\n","export const TWO_PWR_16_DBL = 1 << 16\nexport const TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL\n\nexport function longFromBytesToUnsigned(source: Uint8Array, i = 0) {\n  const low =\n    source[i]! |\n    (source[i + 1]! << 8) |\n    (source[i + 2]! << 16) |\n    (source[i + 3]! << 24)\n  const high =\n    source[i + 4]! |\n    (source[i + 5]! << 8) |\n    (source[i + 6]! << 16) |\n    (source[i + 7]! << 24)\n  return (high >>> 0) * TWO_PWR_32_DBL + (low >>> 0)\n}\n","import Chunk from './chunk'\nimport { longFromBytesToUnsigned } from './long'\nimport { Offset, VirtualOffset } from './virtualOffset'\n\nexport function timeout(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n/**\n * Properly check if the given AbortSignal is aborted.\n *\n * Per the standard, if the signal reads as aborted, this function throws\n * either a DOMException AbortError, or a regular error with a `code` attribute\n * set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal?: AbortSignal) {\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    // console.log('bam aborted!')\n    if (typeof DOMException === 'undefined') {\n      const e = new Error('aborted')\n      // @ts-ignore\n      e.code = 'ERR_ABORTED'\n      throw e\n    } else {\n      throw new DOMException('aborted', 'AbortError')\n    }\n  }\n}\n\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal?: AbortSignal) {\n  await Promise.resolve()\n  checkAbortSignal(signal)\n}\n\nexport function canMergeBlocks(chunk1: Chunk, chunk2: Chunk) {\n  return (\n    chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n    chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000\n  )\n}\n\nexport interface BamOpts {\n  viewAsPairs?: boolean\n  pairAcrossChr?: boolean\n  maxInsertSize?: number\n  signal?: AbortSignal\n}\n\nexport interface BaseOpts {\n  signal?: AbortSignal\n}\n\nexport function makeOpts(obj: AbortSignal | BaseOpts = {}): BaseOpts {\n  return 'aborted' in obj ? ({ signal: obj } as BaseOpts) : obj\n}\n\nexport function optimizeChunks(chunks: Chunk[], lowest?: Offset) {\n  const mergedChunks: Chunk[] = []\n  let lastChunk: Chunk | undefined\n\n  if (chunks.length === 0) {\n    return chunks\n  }\n\n  chunks.sort((c0, c1) => {\n    const dif = c0.minv.blockPosition - c1.minv.blockPosition\n    return dif === 0 ? c0.minv.dataPosition - c1.minv.dataPosition : dif\n  })\n\n  for (const chunk of chunks) {\n    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n      if (lastChunk === undefined) {\n        mergedChunks.push(chunk)\n        lastChunk = chunk\n      } else {\n        if (canMergeBlocks(lastChunk, chunk)) {\n          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n            lastChunk.maxv = chunk.maxv\n          }\n        } else {\n          mergedChunks.push(chunk)\n          lastChunk = chunk\n        }\n      }\n    }\n  }\n\n  return mergedChunks\n}\n\nexport function parsePseudoBin(bytes: Uint8Array, offset: number) {\n  return {\n    lineCount: longFromBytesToUnsigned(bytes, offset),\n  }\n}\n\nexport function findFirstData(\n  firstDataLine: VirtualOffset | undefined,\n  virtualOffset: VirtualOffset,\n) {\n  return firstDataLine\n    ? firstDataLine.compareTo(virtualOffset) > 0\n      ? virtualOffset\n      : firstDataLine\n    : virtualOffset\n}\n\nexport function parseNameBytes(\n  namesBytes: Uint8Array,\n  renameRefSeq: (arg: string) => string = s => s,\n) {\n  let currRefId = 0\n  let currNameStart = 0\n  const refIdToName = []\n  const refNameToId: Record<string, number> = {}\n  for (let i = 0; i < namesBytes.length; i += 1) {\n    if (!namesBytes[i]) {\n      if (currNameStart < i) {\n        let refName = ''\n        for (let j = currNameStart; j < i; j++) {\n          refName += String.fromCharCode(namesBytes[j]!)\n        }\n        refName = renameRefSeq(refName)\n        refIdToName[currRefId] = refName\n        refNameToId[refName] = currRefId\n      }\n      currNameStart = i + 1\n      currRefId += 1\n    }\n  }\n  return { refNameToId, refIdToName }\n}\n\nexport function sum(array: Uint8Array[]) {\n  let sum = 0\n  for (const entry of array) {\n    sum += entry.length\n  }\n  return sum\n}\nexport function concatUint8Array(args: Uint8Array[]) {\n  const mergedArray = new Uint8Array(sum(args))\n  let offset = 0\n  for (const entry of args) {\n    mergedArray.set(entry, offset)\n    offset += entry.length\n  }\n  return mergedArray\n}\n\nexport async function gen2array<T>(gen: AsyncIterable<T[]>): Promise<T[]> {\n  let out: T[] = []\n  for await (const x of gen) {\n    out = out.concat(x)\n  }\n  return out\n}\n","export interface Offset {\n  blockPosition: number\n  dataPosition: number\n  toString(): string\n  compareTo(arg: Offset): number\n}\n\nexport class VirtualOffset {\n  public blockPosition: number\n  public dataPosition: number\n  constructor(blockPosition: number, dataPosition: number) {\n    this.blockPosition = blockPosition // < offset of the compressed data block\n    this.dataPosition = dataPosition // < offset into the uncompressed data\n  }\n\n  toString() {\n    return `${this.blockPosition}:${this.dataPosition}`\n  }\n\n  compareTo(b: VirtualOffset) {\n    return (\n      this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition\n    )\n  }\n}\nexport function fromBytes(bytes: Uint8Array, offset = 0, bigendian = false) {\n  if (bigendian) {\n    throw new Error('big-endian virtual file offsets not implemented')\n  }\n\n  return new VirtualOffset(\n    bytes[offset + 7]! * 0x10000000000 +\n      bytes[offset + 6]! * 0x100000000 +\n      bytes[offset + 5]! * 0x1000000 +\n      bytes[offset + 4]! * 0x10000 +\n      bytes[offset + 3]! * 0x100 +\n      bytes[offset + 2]!,\n    (bytes[offset + 1]! << 8) | bytes[offset]!,\n  )\n}\n","import QuickLRU from 'quick-lru'\n\nimport Chunk from './chunk'\nimport IndexFile from './indexFile'\nimport { BaseOpts, findFirstData, optimizeChunks, parsePseudoBin } from './util'\nimport { VirtualOffset, fromBytes } from './virtualOffset'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nfunction roundDown(n: number, multiple: number) {\n  return n - (n % multiple)\n}\nfunction roundUp(n: number, multiple: number) {\n  return n - (n % multiple) + multiple\n}\n\nexport interface IndexCovEntry {\n  start: number\n  end: number\n  score: number\n}\n\nfunction reg2bins(beg: number, end: number) {\n  end -= 1\n  return [\n    [0, 0],\n    [1 + (beg >> 26), 1 + (end >> 26)],\n    [9 + (beg >> 23), 9 + (end >> 23)],\n    [73 + (beg >> 20), 73 + (end >> 20)],\n    [585 + (beg >> 17), 585 + (end >> 17)],\n    [4681 + (beg >> 14), 4681 + (end >> 14)],\n  ] as const\n}\n\nexport default class BAI extends IndexFile {\n  public setupP?: ReturnType<BAI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices(refId)?.stats?.lineCount || 0\n  }\n\n  async _parse(_opts?: BaseOpts) {\n    const bytes = await this.filehandle.readFile()\n    const dataView = new DataView(bytes.buffer)\n\n    // check BAI magic numbers\n    if (dataView.getUint32(0, true) !== BAI_MAGIC) {\n      throw new Error('Not a BAI file')\n    }\n\n    const refCount = dataView.getInt32(4, true)\n    const depth = 5\n    const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7\n\n    // read the indexes for each reference sequence\n    let curr = 8\n    let firstDataLine: VirtualOffset | undefined\n\n    const offsets = [] as number[]\n    for (let i = 0; i < refCount; i++) {\n      offsets.push(curr)\n      const binCount = dataView.getInt32(curr, true)\n\n      curr += 4\n\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = dataView.getUint32(curr, true)\n        curr += 4\n        if (bin === binLimit + 1) {\n          curr += 4\n          curr += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = dataView.getInt32(curr, true)\n          curr += 4\n          for (let k = 0; k < chunkCount; k++) {\n            curr += 8\n            curr += 8\n          }\n        }\n      }\n\n      const linearCount = dataView.getInt32(curr, true)\n      curr += 4\n      // as we're going through the linear index, figure out the smallest\n      // virtual offset in the indexes, which tells us where the BAM header\n      // ends\n      const linearIndex = new Array<VirtualOffset>(linearCount)\n      for (let j = 0; j < linearCount; j++) {\n        const offset = fromBytes(bytes, curr)\n        curr += 8\n        firstDataLine = findFirstData(firstDataLine, offset)\n        linearIndex[j] = offset\n      }\n    }\n    const indicesCache = new QuickLRU<number, ReturnType<typeof getIndices>>({\n      maxSize: 5,\n    })\n\n    function getIndices(refId: number) {\n      let curr = offsets[refId]\n      if (curr === undefined) {\n        return undefined\n      }\n      const binCount = dataView.getInt32(curr, true)\n      let stats\n\n      curr += 4\n      const binIndex: Record<number, Chunk[]> = {}\n\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = dataView.getUint32(curr, true)\n        curr += 4\n        if (bin === binLimit + 1) {\n          curr += 4\n          stats = parsePseudoBin(bytes, curr + 16)\n          curr += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = dataView.getInt32(curr, true)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k++) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      const linearCount = dataView.getInt32(curr, true)\n      curr += 4\n      // as we're going through the linear index, figure out the smallest\n      // virtual offset in the indexes, which tells us where the BAM header\n      // ends\n      const linearIndex = new Array<VirtualOffset>(linearCount)\n      for (let j = 0; j < linearCount; j++) {\n        const offset = fromBytes(bytes, curr)\n        curr += 8\n        firstDataLine = findFirstData(firstDataLine, offset)\n        linearIndex[j] = offset\n      }\n\n      return {\n        binIndex,\n        linearIndex,\n        stats,\n      }\n    }\n\n    return {\n      bai: true,\n      firstDataLine,\n      maxBlockSize: 1 << 16,\n      indices: (refId: number) => {\n        if (!indicesCache.has(refId)) {\n          const result = getIndices(refId)\n          if (result) {\n            indicesCache.set(refId, result)\n          }\n          return result\n        }\n        return indicesCache.get(refId)\n      },\n      refCount,\n    }\n  }\n\n  async indexCov(\n    seqId: number,\n    start?: number,\n    end?: number,\n    opts?: BaseOpts,\n  ): Promise<IndexCovEntry[]> {\n    const v = 16384\n    const range = start !== undefined\n    const indexData = await this.parse(opts)\n    const seqIdx = indexData.indices(seqId)\n\n    if (!seqIdx) {\n      return []\n    }\n    const { linearIndex = [], stats } = seqIdx\n    if (linearIndex.length === 0) {\n      return []\n    }\n    const e = end === undefined ? (linearIndex.length - 1) * v : roundUp(end, v)\n    const s = start === undefined ? 0 : roundDown(start, v)\n    const depths = range\n      ? new Array((e - s) / v)\n      : new Array(linearIndex.length - 1)\n    const totalSize = linearIndex[linearIndex.length - 1]!.blockPosition\n    if (e > (linearIndex.length - 1) * v) {\n      throw new Error('query outside of range of linear index')\n    }\n    let currentPos = linearIndex[s / v]!.blockPosition\n    for (let i = s / v, j = 0; i < e / v; i++, j++) {\n      depths[j] = {\n        score: linearIndex[i + 1]!.blockPosition - currentPos,\n        start: i * v,\n        end: i * v + v,\n      }\n      currentPos = linearIndex[i + 1]!.blockPosition\n    }\n    return depths.map(d => ({\n      ...d,\n      score: (d.score * (stats?.lineCount || 0)) / totalSize,\n    }))\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices(refId)\n\n    if (!ba) {\n      return []\n    }\n\n    // List of bin #s that overlap min, max\n    const overlappingBins = reg2bins(min, max)\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]!\n          for (const binChunk of binChunks) {\n            chunks.push(new Chunk(binChunk.minv, binChunk.maxv, bin))\n          }\n        }\n      }\n    }\n\n    // Use the linear index to find minimum file position of chunks that could\n    // contain alignments in the region\n    const nintv = ba.linearIndex.length\n    let lowest: VirtualOffset | undefined\n    const minLin = Math.min(min >> 14, nintv - 1)\n    const maxLin = Math.min(max >> 14, nintv - 1)\n    for (let i = minLin; i <= maxLin; ++i) {\n      const vp = ba.linearIndex[i]\n\n      if (vp && (!lowest || vp.compareTo(lowest) < 0)) {\n        lowest = vp\n      }\n    }\n\n    return optimizeChunks(chunks, lowest)\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices(seqId)?.binIndex\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\nimport QuickLRU from 'quick-lru'\n\nimport Chunk from './chunk'\nimport IndexFile from './indexFile'\nimport {\n  BaseOpts,\n  findFirstData,\n  optimizeChunks,\n  parseNameBytes,\n  parsePseudoBin,\n} from './util'\nimport { VirtualOffset, fromBytes } from './virtualOffset'\n\nconst CSI1_MAGIC = 21582659 // CSI\\1\nconst CSI2_MAGIC = 38359875 // CSI\\2\n\nfunction lshift(num: number, bits: number) {\n  return num * 2 ** bits\n}\nfunction rshift(num: number, bits: number) {\n  return Math.floor(num / 2 ** bits)\n}\n\nexport default class CSI extends IndexFile {\n  private maxBinNumber = 0\n  private depth = 0\n  private minShift = 0\n\n  public setupP?: ReturnType<CSI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices(refId)?.stats?.lineCount || 0\n  }\n\n  async indexCov() {\n    return []\n  }\n\n  parseAuxData(bytes: Uint8Array, offset: number) {\n    const dataView = new DataView(bytes.buffer)\n    const formatFlags = dataView.getUint32(offset, true)\n    const coordinateType =\n      formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    const format = (\n      { 0: 'generic', 1: 'SAM', 2: 'VCF' } as Record<number, string>\n    )[formatFlags & 0xf]\n    if (!format) {\n      throw new Error(`invalid Tabix preset format flags ${formatFlags}`)\n    }\n    const columnNumbers = {\n      ref: dataView.getInt32(offset + 4, true),\n      start: dataView.getInt32(offset + 8, true),\n      end: dataView.getInt32(offset + 12, true),\n    }\n    const metaValue = dataView.getInt32(offset + 16, true)\n    const metaChar = metaValue ? String.fromCharCode(metaValue) : ''\n    const skipLines = dataView.getInt32(offset + 20, true)\n    const nameSectionLength = dataView.getInt32(offset + 24, true)\n\n    return {\n      columnNumbers,\n      coordinateType,\n      metaValue,\n      metaChar,\n      skipLines,\n      format,\n      formatFlags,\n      ...parseNameBytes(\n        bytes.subarray(offset + 28, offset + 28 + nameSectionLength),\n        this.renameRefSeq,\n      ),\n    }\n  }\n\n  // fetch and parse the index\n  async _parse(opts: { signal?: AbortSignal }) {\n    const buffer = await this.filehandle.readFile(opts)\n    const bytes = await unzip(buffer)\n\n    const dataView = new DataView(bytes.buffer)\n    let csiVersion\n    const magic = dataView.getUint32(0, true)\n\n    if (magic === CSI1_MAGIC) {\n      csiVersion = 1\n    } else if (magic === CSI2_MAGIC) {\n      csiVersion = 2\n    } else {\n      throw new Error(`Not a CSI file ${magic}`)\n      // TODO: do we need to support big-endian CSI files?\n    }\n\n    this.minShift = dataView.getInt32(4, true)\n    this.depth = dataView.getInt32(8, true)\n    this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7\n    const maxBinNumber = this.maxBinNumber\n    const auxLength = dataView.getInt32(12, true)\n    const aux = auxLength >= 30 ? this.parseAuxData(bytes, 16) : undefined\n    const refCount = dataView.getInt32(16 + auxLength, true)\n\n    // read the indexes for each reference sequence\n    let curr = 16 + auxLength + 4\n    let firstDataLine: VirtualOffset | undefined\n    const offsets = [] as number[]\n    for (let i = 0; i < refCount; i++) {\n      offsets.push(curr)\n      const binCount = dataView.getInt32(curr, true)\n      curr += 4\n      for (let j = 0; j < binCount; j++) {\n        const bin = dataView.getUint32(curr, true)\n        curr += 4\n        if (bin > this.maxBinNumber) {\n          curr += 28 + 16\n        } else {\n          curr += 8\n          const chunkCount = dataView.getInt32(curr, true)\n          curr += 4\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n          }\n        }\n      }\n    }\n\n    const indicesCache = new QuickLRU<number, ReturnType<typeof getIndices>>({\n      maxSize: 5,\n    })\n\n    function getIndices(refId: number) {\n      let curr = offsets[refId]\n      if (curr === undefined) {\n        return undefined\n      }\n      // the binning index\n      const binCount = dataView.getInt32(curr, true)\n      curr += 4\n      const binIndex: Record<string, Chunk[]> = {}\n      let pseudoBinStats\n      for (let j = 0; j < binCount; j++) {\n        const bin = dataView.getUint32(curr, true)\n        curr += 4\n        if (bin > maxBinNumber) {\n          pseudoBinStats = parsePseudoBin(bytes, curr + 28)\n          curr += 28 + 16\n        } else {\n          firstDataLine = findFirstData(firstDataLine, fromBytes(bytes, curr))\n          curr += 8\n          const chunkCount = dataView.getInt32(curr, true)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      return {\n        binIndex,\n        stats: pseudoBinStats,\n      }\n    }\n\n    return {\n      csiVersion,\n      firstDataLine,\n      indices: (refId: number) => {\n        if (!indicesCache.has(refId)) {\n          const result = getIndices(refId)\n          if (result) {\n            indicesCache.set(refId, result)\n          }\n          return result\n        }\n        return indicesCache.get(refId)\n      },\n      refCount,\n      csi: true,\n      maxBlockSize: 1 << 16,\n      ...aux,\n    }\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    const ba = indexData.indices(refId)\n\n    if (!ba) {\n      return []\n    }\n    const overlappingBins = this.reg2bins(min, max)\n\n    if (overlappingBins.length === 0) {\n      return []\n    }\n\n    const chunks = []\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]!\n          for (const c of binChunks) {\n            chunks.push(c)\n          }\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, new VirtualOffset(0, 0))\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end)\n   * (zero-based half-open)\n   */\n  reg2bins(beg: number, end: number) {\n    beg -= 1 // < convert to 1-based closed\n    if (beg < 1) {\n      beg = 1\n    }\n    if (end > 2 ** 50) {\n      end = 2 ** 34\n    } // 17 GiB ought to be enough for anybody\n    end -= 1\n    let l = 0\n    let t = 0\n    let s = this.minShift + this.depth * 3\n    const bins = []\n    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n      const b = t + rshift(beg, s)\n      const e = t + rshift(end, s)\n      if (e - b + bins.length > this.maxBinNumber) {\n        throw new Error(\n          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,\n        )\n      }\n      bins.push([b, e] as const)\n    }\n    return bins\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices(seqId)?.binIndex\n  }\n}\n","export default class NullFilehandle {\n  public read(): Promise<any> {\n    throw new Error('never called')\n  }\n  public stat(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public readFile(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public close(): Promise<any> {\n    throw new Error('never called')\n  }\n}\n","export default {\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n}\n","import Constants from './constants'\n\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('')\nconst CIGAR_DECODER = 'MIDNSHP=X???????'.split('')\n\ninterface Bytes {\n  start: number\n  end: number\n  byteArray: Uint8Array\n}\n\nexport default class BamRecord {\n  public fileOffset: number\n  private bytes: Bytes\n  #dataView: DataView\n\n  constructor(args: { bytes: Bytes; fileOffset: number }) {\n    this.bytes = args.bytes\n    this.fileOffset = args.fileOffset\n    this.#dataView = new DataView(this.bytes.byteArray.buffer)\n  }\n\n  get byteArray() {\n    return this.bytes.byteArray\n  }\n\n  get flags() {\n    return (\n      (this.#dataView.getInt32(this.bytes.start + 16, true) & 0xffff0000) >> 16\n    )\n  }\n  get ref_id() {\n    return this.#dataView.getInt32(this.bytes.start + 4, true)\n  }\n\n  get start() {\n    return this.#dataView.getInt32(this.bytes.start + 8, true)\n  }\n\n  get end() {\n    return this.start + this.length_on_ref\n  }\n\n  get id() {\n    return this.fileOffset\n  }\n\n  get mq() {\n    const mq = (this.bin_mq_nl & 0xff00) >> 8\n    return mq === 255 ? undefined : mq\n  }\n\n  get score() {\n    return this.mq\n  }\n\n  get qual() {\n    if (this.isSegmentUnmapped()) {\n      return\n    }\n\n    const p =\n      this.b0 +\n      this.read_name_length +\n      this.num_cigar_ops * 4 +\n      this.num_seq_bytes\n    return this.byteArray.subarray(p, p + this.seq_length)\n  }\n\n  get strand() {\n    return this.isReverseComplemented() ? -1 : 1\n  }\n\n  get b0() {\n    return this.bytes.start + 36\n  }\n  get name() {\n    let str = ''\n    for (let i = 0; i < this.read_name_length - 1; i++) {\n      str += String.fromCharCode(this.byteArray[this.b0 + i]!)\n    }\n    return str\n  }\n\n  get tags() {\n    let p =\n      this.b0 +\n      this.read_name_length +\n      this.num_cigar_ops * 4 +\n      this.num_seq_bytes +\n      this.seq_length\n\n    const blockEnd = this.bytes.end\n    const tags = {} as Record<string, unknown>\n    while (p < blockEnd) {\n      const tag = String.fromCharCode(\n        this.byteArray[p]!,\n        this.byteArray[p + 1]!,\n      )\n      const type = String.fromCharCode(this.byteArray[p + 2]!)\n      p += 3\n\n      if (type === 'A') {\n        tags[tag] = String.fromCharCode(this.byteArray[p]!)\n        p += 1\n      } else if (type === 'i') {\n        tags[tag] = this.#dataView.getInt32(p, true)\n        p += 4\n      } else if (type === 'I') {\n        tags[tag] = this.#dataView.getUint32(p, true)\n        p += 4\n      } else if (type === 'c') {\n        tags[tag] = this.#dataView.getInt8(p)\n        p += 1\n      } else if (type === 'C') {\n        tags[tag] = this.#dataView.getUint8(p)\n        p += 1\n      } else if (type === 's') {\n        tags[tag] = this.#dataView.getInt16(p, true)\n        p += 2\n      } else if (type === 'S') {\n        tags[tag] = this.#dataView.getUint16(p, true)\n        p += 2\n      } else if (type === 'f') {\n        tags[tag] = this.#dataView.getFloat32(p, true)\n        p += 4\n      } else if (type === 'Z' || type === 'H') {\n        const value = []\n        while (p <= blockEnd) {\n          const cc = this.byteArray[p++]!\n          if (cc !== 0) {\n            value.push(String.fromCharCode(cc))\n          } else {\n            break\n          }\n        }\n        tags[tag] = value.join('')\n      } else if (type === 'B') {\n        const cc = this.byteArray[p++]!\n        const Btype = String.fromCharCode(cc)\n        const limit = this.#dataView.getInt32(p, true)\n        p += 4\n        if (Btype === 'i') {\n          if (tag === 'CG') {\n            const value = []\n            for (let k = 0; k < limit; k++) {\n              const cigop = this.#dataView.getInt32(p, true)\n              const lop = cigop >> 4\n              const op = CIGAR_DECODER[cigop & 0xf]!\n              value.push(lop + op)\n              p += 4\n            }\n            tags[tag] = value.join('')\n          } else {\n            const value = []\n            for (let k = 0; k < limit; k++) {\n              value.push(this.#dataView.getInt32(p, true))\n              p += 4\n            }\n            tags[tag] = value\n          }\n        } else if (Btype === 'I') {\n          if (tag === 'CG') {\n            const value = []\n            for (let k = 0; k < limit; k++) {\n              const cigop = this.#dataView.getUint32(p, true)\n              const lop = cigop >> 4\n              const op = CIGAR_DECODER[cigop & 0xf]!\n              value.push(lop + op)\n              p += 4\n            }\n            tags[tag] = value.join('')\n          } else {\n            const value = []\n            for (let k = 0; k < limit; k++) {\n              value.push(this.#dataView.getUint32(p, true))\n              p += 4\n            }\n            tags[tag] = value\n          }\n        } else if (Btype === 's') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(this.#dataView.getInt16(p, true))\n            p += 2\n          }\n          tags[tag] = value\n        } else if (Btype === 'S') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(this.#dataView.getUint16(p, true))\n            p += 2\n          }\n          tags[tag] = value\n        } else if (Btype === 'c') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(this.#dataView.getInt8(p))\n            p += 1\n          }\n          tags[tag] = value\n        } else if (Btype === 'C') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(this.#dataView.getUint8(p))\n            p += 1\n          }\n          tags[tag] = value\n        } else if (Btype === 'f') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(this.#dataView.getFloat32(p, true))\n            p += 4\n          }\n          tags[tag] = value\n        }\n      } else {\n        console.error('Unknown BAM tag type', type)\n        break\n      }\n    }\n    return tags\n  }\n\n  /**\n   * @returns {boolean} true if the read is paired, regardless of whether both\n   * segments are mapped\n   */\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  /** @returns {boolean} true if the read is paired, and both segments are mapped */\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  /** @returns {boolean} true if the read is mapped to the reverse strand */\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  /** @returns {boolean} true if the mate is mapped to the reverse strand */\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  /** @returns {boolean} true if this is read number 1 in a pair */\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  /** @returns {boolean} true if this is read number 2 in a pair */\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  /** @returns {boolean} true if this is a secondary alignment */\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  /** @returns {boolean} true if this read has failed QC checks */\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  /** @returns {boolean} true if the read is an optical or PCR duplicate */\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  /** @returns {boolean} true if this is a supplementary alignment */\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  get cigarAndLength() {\n    if (this.isSegmentUnmapped()) {\n      return {\n        length_on_ref: 0,\n        CIGAR: '',\n      }\n    }\n\n    const numCigarOps = this.num_cigar_ops\n    let p = this.b0 + this.read_name_length\n    const CIGAR = []\n\n    // check for CG tag by inspecting whether the CIGAR field contains a clip\n    // that consumes entire seqLen\n    let cigop = this.#dataView.getInt32(p, true)\n    let lop = cigop >> 4\n    let op = CIGAR_DECODER[cigop & 0xf]\n    if (op === 'S' && lop === this.seq_length) {\n      // if there is a CG the second CIGAR field will be a N tag the represents\n      // the length on ref\n      p += 4\n      cigop = this.#dataView.getInt32(p, true)\n      lop = cigop >> 4\n      op = CIGAR_DECODER[cigop & 0xf]\n      if (op !== 'N') {\n        console.warn('CG tag with no N tag')\n      }\n      return {\n        CIGAR: this.tags.CG as string,\n        length_on_ref: lop,\n      }\n    } else {\n      let lref = 0\n      for (let c = 0; c < numCigarOps; ++c) {\n        cigop = this.#dataView.getInt32(p, true)\n        lop = cigop >> 4\n        op = CIGAR_DECODER[cigop & 0xf]!\n        CIGAR.push(lop + op)\n        // soft clip, hard clip, and insertion don't count toward the length on\n        // the reference\n        if (op !== 'H' && op !== 'S' && op !== 'I') {\n          lref += lop\n        }\n\n        p += 4\n      }\n\n      return {\n        CIGAR: CIGAR.join(''),\n        length_on_ref: lref,\n      }\n    }\n  }\n\n  get length_on_ref() {\n    return this.cigarAndLength.length_on_ref\n  }\n\n  get CIGAR() {\n    return this.cigarAndLength.CIGAR\n  }\n\n  get num_cigar_ops() {\n    return this.flag_nc & 0xffff\n  }\n\n  get read_name_length() {\n    return this.bin_mq_nl & 0xff\n  }\n\n  get num_seq_bytes() {\n    return (this.seq_length + 1) >> 1\n  }\n\n  get seq() {\n    const p = this.b0 + this.read_name_length + this.num_cigar_ops * 4\n    const seqBytes = this.num_seq_bytes\n    const len = this.seq_length\n    const buf = []\n    let i = 0\n    for (let j = 0; j < seqBytes; ++j) {\n      const sb = this.byteArray[p + j]!\n      buf.push(SEQRET_DECODER[(sb & 0xf0) >> 4])\n      i++\n      if (i < len) {\n        buf.push(SEQRET_DECODER[sb & 0x0f])\n        i++\n      }\n    }\n    return buf.join('')\n  }\n\n  // adapted from igv.js\n  get pair_orientation() {\n    if (\n      !this.isSegmentUnmapped() &&\n      !this.isMateUnmapped() &&\n      this.ref_id === this.next_refid\n    ) {\n      const s1 = this.isReverseComplemented() ? 'R' : 'F'\n      const s2 = this.isMateReverseComplemented() ? 'R' : 'F'\n      let o1 = ' '\n      let o2 = ' '\n      if (this.isRead1()) {\n        o1 = '1'\n        o2 = '2'\n      } else if (this.isRead2()) {\n        o1 = '2'\n        o2 = '1'\n      }\n\n      const tmp = []\n      const isize = this.template_length\n      if (isize > 0) {\n        tmp[0] = s1\n        tmp[1] = o1\n        tmp[2] = s2\n        tmp[3] = o2\n      } else {\n        tmp[2] = s1\n        tmp[3] = o1\n        tmp[0] = s2\n        tmp[1] = o2\n      }\n      return tmp.join('')\n    }\n    return undefined\n  }\n\n  get bin_mq_nl() {\n    return this.#dataView.getInt32(this.bytes.start + 12, true)\n  }\n\n  get flag_nc() {\n    return this.#dataView.getInt32(this.bytes.start + 16, true)\n  }\n\n  get seq_length() {\n    return this.#dataView.getInt32(this.bytes.start + 20, true)\n  }\n\n  get next_refid() {\n    return this.#dataView.getInt32(this.bytes.start + 24, true)\n  }\n\n  get next_pos() {\n    return this.#dataView.getInt32(this.bytes.start + 28, true)\n  }\n\n  get template_length() {\n    return this.#dataView.getInt32(this.bytes.start + 32, true)\n  }\n\n  toJSON() {\n    const data: Record<string, any> = {}\n    for (const k of Object.keys(this)) {\n      if (k.startsWith('_') || k === 'bytes') {\n        continue\n      }\n      // @ts-ignore\n      data[k] = this[k]\n    }\n\n    return data\n  }\n}\n\nfunction cacheGetter<T>(ctor: { prototype: T }, prop: keyof T): void {\n  const desc = Object.getOwnPropertyDescriptor(ctor.prototype, prop)\n  if (!desc) {\n    throw new Error('OH NO, NO PROPERTY DESCRIPTOR')\n  }\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  const getter = desc.get\n  if (!getter) {\n    throw new Error('OH NO, NOT A GETTER')\n  }\n  Object.defineProperty(ctor.prototype, prop, {\n    get() {\n      const ret = getter.call(this)\n      Object.defineProperty(this, prop, { value: ret })\n      return ret\n    },\n  })\n}\n\ncacheGetter(BamRecord, 'tags')\ncacheGetter(BamRecord, 'cigarAndLength')\ncacheGetter(BamRecord, 'seq')\ncacheGetter(BamRecord, 'qual')\n","export function parseHeaderText(text: string) {\n  const lines = text.split(/\\r?\\n/)\n  const data: { tag: string; data: { tag: string; value: string }[] }[] = []\n  for (const line of lines) {\n    const [tag, ...fields] = line.split(/\\t/)\n    if (tag) {\n      data.push({\n        tag: tag.slice(1),\n        data: fields.map(f => {\n          const r = f.indexOf(':')\n          const fieldTag = f.slice(0, r)\n          const value = f.slice(r + 1)\n          return { tag: fieldTag, value }\n        }),\n      })\n    }\n  }\n  return data\n}\n","import AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle'\nimport crc32 from 'crc/calculators/crc32'\nimport { LocalFile, RemoteFile } from 'generic-filehandle2'\nimport QuickLRU from 'quick-lru'\n\nimport BAI from './bai'\nimport Chunk from './chunk'\nimport CSI from './csi'\nimport NullFilehandle from './nullFilehandle'\nimport BAMFeature from './record'\nimport { parseHeaderText } from './sam'\nimport {\n  BamOpts,\n  BaseOpts,\n  checkAbortSignal,\n  gen2array,\n  makeOpts,\n  timeout,\n} from './util'\n\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport const BAM_MAGIC = 21840194\n\nconst blockLen = 1 << 16\ninterface Args {\n  chunk: Chunk\n  opts: BaseOpts\n}\n\nexport default class BamFile {\n  public renameRefSeq: (a: string) => string\n  public bam: GenericFilehandle\n  public header?: string\n  public chrToIndex?: Record<string, number>\n  public indexToChr?: { refName: string; length: number }[]\n  public yieldThreadTime: number\n  public index?: BAI | CSI\n  public htsget = false\n  public headerP?: ReturnType<BamFile['getHeaderPre']>\n\n  private featureCache = new AbortablePromiseCache<Args, BAMFeature[]>({\n    cache: new QuickLRU({\n      maxSize: 50,\n    }),\n    fill: async (args: Args, signal) => {\n      const { chunk, opts } = args\n      const { data, cpositions, dpositions } = await this._readChunk({\n        chunk,\n        opts: { ...opts, signal },\n      })\n      return this.readBamFeatures(data, cpositions, dpositions, chunk)\n    },\n  })\n\n  constructor({\n    bamFilehandle,\n    bamPath,\n    bamUrl,\n    baiPath,\n    baiFilehandle,\n    baiUrl,\n    csiPath,\n    csiFilehandle,\n    csiUrl,\n    htsget,\n    yieldThreadTime = 100,\n    renameRefSeqs = n => n,\n  }: {\n    bamFilehandle?: GenericFilehandle\n    bamPath?: string\n    bamUrl?: string\n    baiPath?: string\n    baiFilehandle?: GenericFilehandle\n    baiUrl?: string\n    csiPath?: string\n    csiFilehandle?: GenericFilehandle\n    csiUrl?: string\n    renameRefSeqs?: (a: string) => string\n    yieldThreadTime?: number\n    htsget?: boolean\n  }) {\n    this.renameRefSeq = renameRefSeqs\n\n    if (bamFilehandle) {\n      this.bam = bamFilehandle\n    } else if (bamPath) {\n      this.bam = new LocalFile(bamPath)\n    } else if (bamUrl) {\n      this.bam = new RemoteFile(bamUrl)\n    } else if (htsget) {\n      this.htsget = true\n      this.bam = new NullFilehandle()\n    } else {\n      throw new Error('unable to initialize bam')\n    }\n    if (csiFilehandle) {\n      this.index = new CSI({ filehandle: csiFilehandle })\n    } else if (csiPath) {\n      this.index = new CSI({ filehandle: new LocalFile(csiPath) })\n    } else if (csiUrl) {\n      this.index = new CSI({ filehandle: new RemoteFile(csiUrl) })\n    } else if (baiFilehandle) {\n      this.index = new BAI({ filehandle: baiFilehandle })\n    } else if (baiPath) {\n      this.index = new BAI({ filehandle: new LocalFile(baiPath) })\n    } else if (baiUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(baiUrl) })\n    } else if (bamPath) {\n      this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) })\n    } else if (bamUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) })\n    } else if (htsget) {\n      this.htsget = true\n    } else {\n      throw new Error('unable to infer index format')\n    }\n    this.yieldThreadTime = yieldThreadTime\n  }\n\n  async getHeaderPre(origOpts?: BaseOpts) {\n    const opts = makeOpts(origOpts)\n    if (!this.index) {\n      return\n    }\n    const indexData = await this.index.parse(opts)\n    const ret = indexData.firstDataLine\n      ? indexData.firstDataLine.blockPosition + 65535\n      : undefined\n    let buffer\n    if (ret) {\n      const s = ret + blockLen\n      buffer = await this.bam.read(s, 0)\n    } else {\n      buffer = await this.bam.readFile(opts)\n    }\n\n    const uncba = await unzip(buffer)\n    const dataView = new DataView(uncba.buffer)\n\n    if (dataView.getInt32(0, true) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = dataView.getInt32(4, true)\n\n    const decoder = new TextDecoder('utf8')\n    this.header = decoder.decode(uncba.subarray(8, 8 + headLen))\n    const { chrToIndex, indexToChr } = await this._readRefSeqs(\n      headLen + 8,\n      65535,\n      opts,\n    )\n    this.chrToIndex = chrToIndex\n    this.indexToChr = indexToChr\n\n    return parseHeaderText(this.header)\n  }\n\n  getHeader(opts?: BaseOpts) {\n    if (!this.headerP) {\n      this.headerP = this.getHeaderPre(opts).catch((e: unknown) => {\n        this.headerP = undefined\n        throw e\n      })\n    }\n    return this.headerP\n  }\n\n  async getHeaderText(opts: BaseOpts = {}) {\n    await this.getHeader(opts)\n    return this.header\n  }\n\n  // the full length of the refseq block is not given in advance so this grabs\n  // a chunk and doubles it if all refseqs haven't been processed\n  async _readRefSeqs(\n    start: number,\n    refSeqBytes: number,\n    opts?: BaseOpts,\n  ): Promise<{\n    chrToIndex: Record<string, number>\n    indexToChr: { refName: string; length: number }[]\n  }> {\n    if (start > refSeqBytes) {\n      return this._readRefSeqs(start, refSeqBytes * 2, opts)\n    }\n    // const size = refSeqBytes + blockLen <-- use this?\n    const buffer = await this.bam.read(refSeqBytes, 0, opts)\n    const uncba = await unzip(buffer)\n    const dataView = new DataView(uncba.buffer)\n    const nRef = dataView.getInt32(start, true)\n    let p = start + 4\n    const chrToIndex: Record<string, number> = {}\n    const indexToChr: { refName: string; length: number }[] = []\n    const decoder = new TextDecoder('utf8')\n    for (let i = 0; i < nRef; i += 1) {\n      const lName = dataView.getInt32(p, true)\n      const refName = this.renameRefSeq(\n        decoder.decode(uncba.subarray(p + 4, p + 4 + lName - 1)),\n      )\n      const lRef = dataView.getInt32(p + lName + 4, true)\n\n      chrToIndex[refName] = i\n      indexToChr.push({ refName, length: lRef })\n\n      p = p + 8 + lName\n      if (p > uncba.length) {\n        console.warn(\n          `BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`,\n        )\n        return this._readRefSeqs(start, refSeqBytes * 2, opts)\n      }\n    }\n    return { chrToIndex, indexToChr }\n  }\n\n  async getRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    return gen2array(this.streamRecordsForRange(chr, min, max, opts))\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    await this.getHeader(opts)\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined || !this.index) {\n      yield []\n    } else {\n      const chunks = await this.index.blocksForRange(chrId, min - 1, max, opts)\n      yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts)\n    }\n  }\n\n  async *_fetchChunkFeatures(\n    chunks: Chunk[],\n    chrId: number,\n    min: number,\n    max: number,\n    opts: BamOpts = {},\n  ) {\n    const { viewAsPairs } = opts\n    const feats = [] as BAMFeature[][]\n    let done = false\n\n    for (const chunk of chunks) {\n      const records = await this.featureCache.get(\n        chunk.toString(),\n        { chunk, opts },\n        opts.signal,\n      )\n\n      const recs = [] as BAMFeature[]\n      for (const feature of records) {\n        if (feature.ref_id === chrId) {\n          if (feature.start >= max) {\n            // past end of range, can stop iterating\n            done = true\n            break\n          } else if (feature.end >= min) {\n            // must be in range\n            recs.push(feature)\n          }\n        }\n      }\n      feats.push(recs)\n      yield recs\n      if (done) {\n        break\n      }\n    }\n\n    checkAbortSignal(opts.signal)\n    if (viewAsPairs) {\n      yield this.fetchPairs(chrId, feats, opts)\n    }\n  }\n\n  async fetchPairs(chrId: number, feats: BAMFeature[][], opts: BamOpts) {\n    const { pairAcrossChr, maxInsertSize = 200000 } = opts\n    const unmatedPairs: Record<string, boolean> = {}\n    const readIds: Record<string, number> = {}\n    feats.map(ret => {\n      const readNames: Record<string, number> = {}\n      for (const element of ret) {\n        const name = element.name\n        const id = element.id\n        if (!readNames[name]) {\n          readNames[name] = 0\n        }\n        readNames[name]++\n        readIds[id] = 1\n      }\n      for (const [k, v] of Object.entries(readNames)) {\n        if (v === 1) {\n          unmatedPairs[k] = true\n        }\n      }\n    })\n\n    const matePromises: Promise<Chunk[]>[] = []\n    feats.map(ret => {\n      for (const f of ret) {\n        const name = f.name\n        const start = f.start\n        const pnext = f.next_pos\n        const rnext = f.next_refid\n        if (\n          this.index &&\n          unmatedPairs[name] &&\n          (pairAcrossChr ||\n            (rnext === chrId && Math.abs(start - pnext) < maxInsertSize))\n        ) {\n          matePromises.push(\n            this.index.blocksForRange(rnext, pnext, pnext + 1, opts),\n          )\n        }\n      }\n    })\n\n    // filter out duplicate chunks (the blocks are lists of chunks, blocks are\n    // concatenated, then filter dup chunks)\n    const map = new Map<string, Chunk>()\n    const res = await Promise.all(matePromises)\n    for (const m of res.flat()) {\n      if (!map.has(m.toString())) {\n        map.set(m.toString(), m)\n      }\n    }\n\n    const mateFeatPromises = await Promise.all(\n      [...map.values()].map(async c => {\n        const { data, cpositions, dpositions, chunk } = await this._readChunk({\n          chunk: c,\n          opts,\n        })\n        const mateRecs = [] as BAMFeature[]\n        for (const feature of await this.readBamFeatures(\n          data,\n          cpositions,\n          dpositions,\n          chunk,\n        )) {\n          if (unmatedPairs[feature.name] && !readIds[feature.id]) {\n            mateRecs.push(feature)\n          }\n        }\n        return mateRecs\n      }),\n    )\n    return mateFeatPromises.flat()\n  }\n\n  async _readChunk({ chunk, opts }: { chunk: Chunk; opts: BaseOpts }) {\n    const buf = await this.bam.read(\n      chunk.fetchedSize(),\n      chunk.minv.blockPosition,\n      opts,\n    )\n\n    const {\n      buffer: data,\n      cpositions,\n      dpositions,\n    } = await unzipChunkSlice(buf, chunk)\n    return { data, cpositions, dpositions, chunk }\n  }\n\n  async readBamFeatures(\n    ba: Uint8Array,\n    cpositions: number[],\n    dpositions: number[],\n    chunk: Chunk,\n  ) {\n    let blockStart = 0\n    const sink = [] as BAMFeature[]\n    let pos = 0\n    let last = +Date.now()\n\n    const dataView = new DataView(ba.buffer)\n    while (blockStart + 4 < ba.length) {\n      const blockSize = dataView.getInt32(blockStart, true)\n      const blockEnd = blockStart + 4 + blockSize - 1\n\n      // increment position to the current decompressed status\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (dpositions) {\n        while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]!) {}\n        pos--\n      }\n\n      // only try to read the feature if we have all the bytes for it\n      if (blockEnd < ba.length) {\n        const feature = new BAMFeature({\n          bytes: {\n            byteArray: ba,\n            start: blockStart,\n            end: blockEnd,\n          },\n          // the below results in an automatically calculated file-offset based\n          // ID if the info for that is available, otherwise crc32 of the\n          // features\n          //\n          // cpositions[pos] refers to actual file offset of a bgzip block\n          // boundaries\n          //\n          // we multiply by (1 <<8) in order to make sure each block has a\n          // \"unique\" address space so that data in that block could never\n          // overlap\n          //\n          // then the blockStart-dpositions is an uncompressed file offset from\n          // that bgzip block boundary, and since the cpositions are multiplied\n          // by (1 << 8) these uncompressed offsets get a unique space\n          //\n          // this has an extra chunk.minv.dataPosition added on because it\n          // blockStart starts at 0 instead of chunk.minv.dataPosition\n          //\n          // the +1 is just to avoid any possible uniqueId 0 but this does not\n          // realistically happen\n          fileOffset:\n            cpositions.length > 0\n              ? cpositions[pos]! * (1 << 8) +\n                (blockStart - dpositions[pos]!) +\n                chunk.minv.dataPosition +\n                1\n              : // this shift >>> 0 is equivalent to crc32(b).unsigned but uses the\n                // internal calculator of crc32 to avoid accidentally importing buffer\n                // https://github.com/alexgorbatchev/crc/blob/31fc3853e417b5fb5ec83335428805842575f699/src/define_crc.ts#L5\n                crc32(ba.subarray(blockStart, blockEnd)) >>> 0,\n        })\n\n        sink.push(feature)\n        if (this.yieldThreadTime && +Date.now() - last > this.yieldThreadTime) {\n          await timeout(1)\n          last = +Date.now()\n        }\n      }\n\n      blockStart = blockEnd + 1\n    }\n    return sink\n  }\n\n  async hasRefSeq(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? false : this.index?.hasRefSeq(seqId)\n  }\n\n  async lineCount(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined || !this.index ? 0 : this.index.lineCount(seqId)\n  }\n\n  async indexCov(seqName: string, start?: number, end?: number) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? [] : this.index.indexCov(seqId, start, end)\n  }\n\n  async blocksForRange(\n    seqName: string,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined\n      ? []\n      : this.index.blocksForRange(seqId, start, end, opts)\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\n\nimport BamFile, { BAM_MAGIC } from './bamFile'\nimport Chunk from './chunk'\nimport { parseHeaderText } from './sam'\nimport { BamOpts, BaseOpts, concatUint8Array } from './util'\n\ninterface HtsgetChunk {\n  url: string\n  headers?: Record<string, string>\n}\nasync function concat(arr: HtsgetChunk[], opts?: Record<string, any>) {\n  const res = await Promise.all(\n    arr.map(async chunk => {\n      const { url, headers } = chunk\n      if (url.startsWith('data:')) {\n        // pass base64 data url to fetch to decode to buffer\n        // https://stackoverflow.com/a/54123275/2129219\n        const res = await fetch(url)\n        if (!res.ok) {\n          throw new Error('failed to decode base64')\n        }\n        const ret = await res.arrayBuffer()\n        return new Uint8Array(ret)\n      } else {\n        // remove referer header, it is not even allowed to be specified\n        // @ts-expect-error\n\n        const { referer, ...rest } = headers\n        const res = await fetch(url, {\n          ...opts,\n          headers: { ...opts?.headers, ...rest },\n        })\n        if (!res.ok) {\n          throw new Error(\n            `HTTP ${res.status} fetching ${url}: ${await res.text()}`,\n          )\n        }\n        return new Uint8Array(await res.arrayBuffer())\n      }\n    }),\n  )\n\n  return concatUint8Array(await Promise.all(res.map(elt => unzip(elt))))\n}\n\nexport default class HtsgetFile extends BamFile {\n  private baseUrl: string\n\n  private trackId: string\n\n  constructor(args: { trackId: string; baseUrl: string }) {\n    super({ htsget: true })\n    this.baseUrl = args.baseUrl\n    this.trackId = args.trackId\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    const base = `${this.baseUrl}/${this.trackId}`\n    const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined) {\n      yield []\n    } else {\n      const result = await fetch(url, { ...opts })\n      if (!result.ok) {\n        throw new Error(\n          `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n        )\n      }\n      const data = await result.json()\n      const uncba = await concat(data.htsget.urls.slice(1), opts)\n\n      yield* this._fetchChunkFeatures(\n        [\n          // fake stuff to pretend to be a Chunk\n          {\n            buffer: uncba,\n            _fetchedSize: undefined,\n            bin: 0,\n            compareTo() {\n              return 0\n            },\n            toUniqueString() {\n              return `${chr}_${min}_${max}`\n            },\n            fetchedSize() {\n              return 0\n            },\n            minv: {\n              dataPosition: 0,\n              blockPosition: 0,\n              compareTo: () => 0,\n            },\n            maxv: {\n              dataPosition: Number.MAX_SAFE_INTEGER,\n              blockPosition: 0,\n              compareTo: () => 0,\n            },\n            toString() {\n              return `${chr}_${min}_${max}`\n            },\n          },\n        ],\n        chrId,\n        min,\n        max,\n        opts,\n      )\n    }\n  }\n\n  // @ts-expect-error\n  async _readChunk({ chunk }: { chunk: Chunk; opts: BaseOpts }) {\n    if (!chunk.buffer) {\n      throw new Error('expected chunk.buffer in htsget')\n    }\n    return {\n      data: chunk.buffer,\n      cpositions: [],\n      dpositions: [],\n      chunk,\n    }\n  }\n\n  async getHeader(opts: BaseOpts = {}) {\n    const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`\n    const result = await fetch(url, opts)\n    if (!result.ok) {\n      throw new Error(\n        `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n      )\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls, opts)\n    const dataView = new DataView(uncba.buffer)\n\n    if (dataView.getInt32(0, true) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = dataView.getInt32(4, true)\n\n    const decoder = new TextDecoder('utf8')\n    const headerText = decoder.decode(uncba.subarray(8, 8 + headLen))\n    const samHeader = parseHeaderText(headerText)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ref ID numbers and names\n    const idToName: { refName: string; length: number }[] = []\n    const nameToId: Record<string, number> = {}\n    const sqLines = samHeader.filter(l => l.tag === 'SQ')\n    for (const [refId, sqLine] of sqLines.entries()) {\n      let refName = ''\n      let length = 0\n      for (const item of sqLine.data) {\n        if (item.tag === 'SN') {\n          refName = item.value\n        } else if (item.tag === 'LN') {\n          length = +item.value\n        }\n      }\n      nameToId[refName] = refId\n      idToName[refId] = { refName, length }\n    }\n    this.chrToIndex = nameToId\n    this.indexToChr = idToName\n    return samHeader\n  }\n}\n","// Generated by `./pycrc.py --algorithm=table-driven --model=crc-32 --generate=c`\nlet TABLE = [\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n];\nif (typeof Int32Array !== 'undefined') {\n    TABLE = new Int32Array(TABLE);\n}\nconst crc32 = (current, previous) => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    let crc = previous === 0 ? 0 : ~~previous ^ -1;\n    for (let index = 0; index < current.length; index++) {\n        crc = TABLE[(crc ^ current[index]) & 0xff] ^ (crc >>> 8);\n    }\n    return crc ^ -1;\n};\nexport default crc32;\n","class NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter {\n  callbacks = new Set<Function>()\n  currentMessage: unknown\n\n  addCallback(callback: Function = () => {}): void {\n    this.callbacks.add(callback)\n    callback(this.currentMessage)\n  }\n\n  callback(message: unknown) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController'\nimport AggregateStatusReporter from './AggregateStatusReporter'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: Function,\n) => Promise<U>\n\ninterface Entry<U> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U>>\n  private fillCallback: FillCallback<T, U>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U>\n    cache: Cache<Entry<U>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(key: string, data: T, signal?: AbortSignal, statusCallback?: Function) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: unknown) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch(error => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      error => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: Function,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n"],"names":["Chunk","minv","maxv","bin","_fetchedSize","buffer","constructor","toUniqueString","this","toString","fetchedSize","compareTo","b","undefined","blockPosition","IndexFile","filehandle","renameRefSeq","n","longFromBytesToUnsigned","source","i","low","TWO_PWR_16_DBL","timeout","ms","Promise","resolve","setTimeout","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","length","sort","c0","c1","dif","dataPosition","chunk","push","chunk1","chunk2","parsePseudoBin","bytes","offset","lineCount","findFirstData","firstDataLine","virtualOffset","parseNameBytes","namesBytes","s","currRefId","currNameStart","refIdToName","refNameToId","refName","j","String","fromCharCode","VirtualOffset","fromBytes","bigendian","Error","BAI","setupP","refId","opts","indexData","parse","indices","stats","_parse","_opts","readFile","dataView","DataView","getUint32","refCount","getInt32","curr","offsets","binCount","binLimit","chunkCount","k","linearCount","linearIndex","Array","indicesCache","maxSize","bai","maxBlockSize","has","result","binIndex","u","v","getIndices","set","get","indexCov","seqId","start","end","range","seqIdx","e","roundDown","depths","totalSize","currentPos","score","map","d","blocksForRange","min","max","ba","overlappingBins","beg","binChunks","binChunk","nintv","minLin","Math","maxLin","vp","catch","hasRefSeq","header","rshift","num","bits","floor","CSI","maxBinNumber","depth","minShift","parseAuxData","formatFlags","coordinateType","format","columnNumbers","ref","metaValue","metaChar","skipLines","nameSectionLength","subarray","csiVersion","magic","auxLength","aux","pseudoBinStats","csi","reg2bins","c","l","t","bins","NullFilehandle","read","stat","close","SEQRET_DECODER","split","CIGAR_DECODER","BamRecord","fileOffset","args","byteArray","flags","ref_id","length_on_ref","id","mq","bin_mq_nl","qual","isSegmentUnmapped","p","b0","read_name_length","num_cigar_ops","num_seq_bytes","seq_length","strand","isReverseComplemented","name","str","tags","blockEnd","tag","type","getInt8","getUint8","getInt16","getUint16","getFloat32","value","cc","join","console","error","Btype","limit","cigop","lop","op","isPaired","isProperlyPaired","isMateUnmapped","isMateReverseComplemented","isRead1","isRead2","isSecondary","isFailedQc","isDuplicate","isSupplementary","cigarAndLength","CIGAR","numCigarOps","warn","CG","lref","flag_nc","seq","seqBytes","len","buf","sb","pair_orientation","next_refid","s1","s2","o1","o2","tmp","template_length","next_pos","toJSON","data","Object","keys","startsWith","cacheGetter","ctor","prop","desc","getOwnPropertyDescriptor","prototype","getter","defineProperty","ret","call","parseHeaderText","text","lines","line","fields","slice","f","r","indexOf","BAM_MAGIC","BamFile","bam","chrToIndex","indexToChr","yieldThreadTime","index","htsget","headerP","featureCache","AbortablePromiseCache","A","cache","fill","async","signal","cpositions","dpositions","_readChunk","readBamFeatures","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","renameRefSeqs","getHeaderPre","origOpts","obj","makeOpts","uncba","headLen","decoder","TextDecoder","decode","_readRefSeqs","getHeader","getHeaderText","refSeqBytes","nRef","lName","lRef","getRecordsForRange","chr","gen","out","x","concat","gen2array","streamRecordsForRange","chrId","_fetchChunkFeatures","viewAsPairs","feats","done","records","recs","feature","aborted","DOMException","code","checkAbortSignal","fetchPairs","pairAcrossChr","maxInsertSize","unmatedPairs","readIds","readNames","element","entries","matePromises","pnext","rnext","abs","Map","res","all","m","flat","values","mateRecs","blockStart","sink","pos","last","Date","now","crc32","seqName","arr","url","headers","fetch","ok","arrayBuffer","Uint8Array","referer","rest","status","mergedArray","array","sum","entry","concatUint8Array","elt","HtsgetFile","baseUrl","trackId","super","json","urls","Number","MAX_SAFE_INTEGER","samHeader","idToName","nameToId","sqLines","filter","sqLine","item","TABLE","Int32Array","current","previous","crc","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","addSignal","add","handleAborted","addEventListener","delete","size","abort","AggregateStatusReporter","callbacks","addCallback","callback","currentMessage","message","TypeError","fillCallback","isAbortException","exception","evict","key","statusCallback","aborter","statusReporter","newEntry","promise","settled","then","checkSinglePromise","checkForSingleAbort","assign","AbortSignal","cacheEntry","cachedEntry","clear","keyIter","deleteCount","next"],"sourceRoot":""}