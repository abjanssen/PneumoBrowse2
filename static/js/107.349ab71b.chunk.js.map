{"version":3,"file":"static/js/107.349ab71b.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/CramAdapter/const.ts","../../../plugins/alignments/src/CramAdapter/readFeaturesToNumericCIGAR.ts","../../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","../../../plugins/alignments/src/CramAdapter/CramAdapter.ts","../../../plugins/alignments/src/PileupRenderer/renderers/cigarUtil.ts"],"sourcesContent":["// CRAM feature code char codes for faster comparison\nexport const CODE_X = 88 // 'X' - substitution\nexport const CODE_I = 73 // 'I' - insertion\nexport const CODE_N = 78 // 'N' - reference skip\nexport const CODE_S = 83 // 'S' - soft clip\nexport const CODE_P = 80 // 'P' - padding\nexport const CODE_H = 72 // 'H' - hard clip\nexport const CODE_D = 68 // 'D' - deletion\nexport const CODE_b = 98 // 'b' - stretch of bases\nexport const CODE_q = 113 // 'q' - stretch of qual scores\nexport const CODE_B = 66 // 'B' - a pair of [base, qual]\nexport const CODE_i = 105 // 'i' - single-base insertion\nexport const CODE_Q = 81 // 'Q' - single quality value\n","import {\n  CODE_B,\n  CODE_D,\n  CODE_H,\n  CODE_I,\n  CODE_N,\n  CODE_P,\n  CODE_S,\n  CODE_X,\n  CODE_b,\n  CODE_i,\n} from './const.ts'\n\nimport type { CramRecord } from '@gmod/cram'\n\ntype ReadFeatures = CramRecord['readFeatures']\n\n// CIGAR operation char codes to indices (from BAM spec)\nconst CIGAR_CODE_TO_INDEX: Record<number, number> = {\n  77: 0, // M\n  73: 1, // I\n  68: 2, // D\n  78: 3, // N\n  83: 4, // S\n  72: 5, // H\n  80: 6, // P\n  61: 7, // =\n  88: 8, // X\n}\n\n// Generates packed NUMERIC_CIGAR format: Uint32Array where each value is (length << 4) | opIndex\nexport function readFeaturesToNumericCIGAR(\n  readFeatures: ReadFeatures,\n  alignmentStart: number,\n  readLen: number,\n): ArrayLike<number> {\n  const cigarParts: number[] = []\n  let op = 77 // 'M'\n  let oplen = 0\n  let lastPos = alignmentStart\n  let insLen = 0\n  let seqLen = 0\n\n  if (readFeatures !== undefined) {\n    for (let i = 0, l = readFeatures.length; i < l; i++) {\n      const { code, refPos, data } = readFeatures[i]!\n      const sublen = refPos - lastPos\n      seqLen += sublen\n      lastPos = refPos\n\n      // Flush pending insertions if we have a match region\n      if (insLen && sublen) {\n        const opIndex = CIGAR_CODE_TO_INDEX[73]! // I\n        cigarParts.push((insLen << 4) | opIndex)\n        insLen = 0\n      }\n      // Flush previous non-match operation\n      if (oplen && op !== 77) {\n        const opIndex = CIGAR_CODE_TO_INDEX[op]!\n        cigarParts.push((oplen << 4) | opIndex)\n        oplen = 0\n      }\n      // Accumulate match length\n      if (sublen) {\n        op = 77 // 'M'\n        oplen += sublen\n      }\n\n      const codeChar = code.charCodeAt(0)\n\n      if (codeChar === CODE_b) {\n        // An array of bases stored verbatim\n        const addedLen = data.split(',').length\n        seqLen += addedLen\n        lastPos += addedLen\n        oplen += addedLen\n      } else if (codeChar === CODE_B || codeChar === CODE_X) {\n        // Single base (+ qual score) or Substitution - both increment by 1\n        seqLen++\n        lastPos++\n        oplen++\n      } else if (codeChar === CODE_D || codeChar === CODE_N) {\n        // Deletion or Ref Skip\n        lastPos += data\n        if (oplen) {\n          const opIndex = CIGAR_CODE_TO_INDEX[op]!\n          cigarParts.push((oplen << 4) | opIndex)\n          oplen = 0\n        }\n        const opIndex = CIGAR_CODE_TO_INDEX[codeChar]!\n        cigarParts.push((data << 4) | opIndex)\n      } else if (codeChar === CODE_I || codeChar === CODE_S) {\n        // Insertion or soft-clip\n        const dataLen = data.length\n        seqLen += dataLen\n        if (oplen) {\n          const opIndex = CIGAR_CODE_TO_INDEX[op]!\n          cigarParts.push((oplen << 4) | opIndex)\n          oplen = 0\n        }\n        const opIndex = CIGAR_CODE_TO_INDEX[codeChar]!\n        cigarParts.push((dataLen << 4) | opIndex)\n      } else if (codeChar === CODE_i) {\n        // Single base insertion\n        if (oplen) {\n          const opIndex = CIGAR_CODE_TO_INDEX[op]!\n          cigarParts.push((oplen << 4) | opIndex)\n          oplen = 0\n        }\n        insLen++\n        seqLen++\n      } else if (codeChar === CODE_P || codeChar === CODE_H) {\n        // Padding or Hard clip\n        if (oplen) {\n          const opIndex = CIGAR_CODE_TO_INDEX[op]!\n          cigarParts.push((oplen << 4) | opIndex)\n          oplen = 0\n        }\n        const opIndex = CIGAR_CODE_TO_INDEX[codeChar]!\n        cigarParts.push((data << 4) | opIndex)\n      } // else q or Q (no-op)\n    }\n  }\n\n  // Handle remaining sequence length\n  const remaining = readLen - seqLen\n  if (remaining) {\n    if (oplen && op !== 77) {\n      const opIndex = CIGAR_CODE_TO_INDEX[op]!\n      cigarParts.push((oplen << 4) | opIndex)\n      oplen = 0\n    }\n    op = 77 // 'M'\n    oplen += remaining\n  }\n\n  // Flush pending insertions\n  if (remaining && insLen) {\n    const opIndex = CIGAR_CODE_TO_INDEX[73]! // I\n    cigarParts.push((insLen << 4) | opIndex)\n  }\n  // Flush final operation\n  if (oplen) {\n    const opIndex = CIGAR_CODE_TO_INDEX[op]!\n    cigarParts.push((oplen << 4) | opIndex)\n  }\n\n  return cigarParts\n}\n","import {\n  CODE_D,\n  CODE_H,\n  CODE_I,\n  CODE_N,\n  CODE_S,\n  CODE_X,\n  CODE_i,\n} from './const.ts'\nimport { readFeaturesToNumericCIGAR } from './readFeaturesToNumericCIGAR.ts'\nimport { CHAR_FROM_CODE } from '../PileupRenderer/renderers/cigarUtil.ts'\nimport {\n  DELETION_TYPE,\n  HARDCLIP_TYPE,\n  INSERTION_TYPE,\n  MISMATCH_TYPE,\n  SKIP_TYPE,\n  SOFTCLIP_TYPE,\n} from '../shared/forEachMismatchTypes.ts'\nimport { cacheGetter, convertTagsToPlainArrays } from '../shared/util.ts'\n\nimport type CramAdapter from './CramAdapter.ts'\nimport type { MismatchCallback } from '../shared/forEachMismatchTypes.ts'\nimport type { Mismatch } from '../shared/types.ts'\nimport type { CramRecord } from '@gmod/cram'\nimport type { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\n\n// Module-level constant for CIGAR code conversion (avoids recreation on each call)\n// Maps packed CIGAR op codes to ASCII: M=77, I=73, D=68, N=78, S=83, H=72, P=80, ==61, X=88\nconst NUMERIC_CIGAR_CODES = new Uint8Array([\n  77, 73, 68, 78, 83, 72, 80, 61, 88, 63, 63, 63, 63, 63, 63, 63,\n])\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  private record: CramRecord\n  private _store: CramAdapter\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(record: CramRecord, _store: CramAdapter) {\n    this.record = record\n    this._store = _store\n  }\n\n  get name() {\n    return this.record.readName\n  }\n\n  get start() {\n    return this.record.alignmentStart - 1\n  }\n\n  get end() {\n    return this.start + (this.record.lengthOnRef ?? 1)\n  }\n\n  get score() {\n    return this.record.mappingQuality\n  }\n\n  get flags() {\n    return this.record.flags\n  }\n\n  get strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  get qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  get qualRaw() {\n    return this.record.qualityScores\n  }\n\n  get refName() {\n    return this._store.refIdToName(this.record.sequenceId)!\n  }\n\n  get pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  get template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  get next_ref() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  get next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  get is_paired() {\n    return !!this.record.mate\n  }\n\n  get next_pos() {\n    return this.record.mate?.alignmentStart\n  }\n\n  get tags() {\n    const RG = this._store.samHeader?.readGroups[this.record.readGroupId]\n    return RG !== undefined ? { ...this.record.tags, RG } : this.record.tags\n  }\n\n  get seq() {\n    // CRAM stores sequences as strings, not packed like BAM\n    // So we return the string directly without encoding/decoding\n    return this.record.getReadBases()\n  }\n\n  // generate packed NUMERIC_CIGAR as Uint32Array\n  get NUMERIC_CIGAR() {\n    return readFeaturesToNumericCIGAR(\n      this.record.readFeatures,\n      this.record.alignmentStart,\n      this.record.readLength,\n    )\n  }\n\n  // generate a CIGAR string from NUMERIC_CIGAR\n  get CIGAR() {\n    const numeric = this.NUMERIC_CIGAR\n    let result = ''\n    for (let i = 0, l = numeric.length; i < l; i++) {\n      const packed = numeric[i]!\n      const length = packed >> 4\n      const opCode = NUMERIC_CIGAR_CODES[packed & 0xf]!\n      result += length + CHAR_FROM_CODE[opCode]!\n    }\n    return result\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string): any {\n    switch (field) {\n      case 'mismatches':\n        return this.mismatches\n      case 'qual':\n        return this.qual\n      case 'CIGAR':\n        return this.CIGAR\n      case 'NUMERIC_CIGAR':\n        return this.NUMERIC_CIGAR\n      default:\n        return this.fields[field]\n    }\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  get mismatches() {\n    const mismatches: Mismatch[] = []\n    this.forEachMismatch(\n      (type, start, length, base, qual, altbase, cliplen) => {\n        if (type === MISMATCH_TYPE) {\n          mismatches.push({\n            type: 'mismatch',\n            start,\n            length,\n            base,\n            qual: qual !== undefined && qual >= 0 ? qual : undefined,\n            altbase:\n              altbase !== undefined && altbase > 0\n                ? CHAR_FROM_CODE[altbase]\n                : undefined,\n          })\n        } else if (type === INSERTION_TYPE) {\n          mismatches.push({\n            type: 'insertion',\n            start,\n            length,\n            insertlen: cliplen!,\n            insertedBases: base,\n          })\n        } else if (type === SOFTCLIP_TYPE) {\n          mismatches.push({\n            type: 'softclip',\n            start,\n            length,\n            cliplen: cliplen!,\n          })\n        } else if (type === HARDCLIP_TYPE) {\n          mismatches.push({\n            type: 'hardclip',\n            start,\n            length,\n            cliplen: cliplen!,\n          })\n        } else {\n          mismatches.push({\n            type: type === 2 ? 'deletion' : 'skip',\n            start,\n            length,\n          })\n        }\n      },\n    )\n    return mismatches\n  }\n\n  forEachMismatch(callback: MismatchCallback) {\n    const readFeatures = this.record.readFeatures\n    if (!readFeatures) {\n      return\n    }\n\n    const featStart = this.start\n    const qual = this.qualRaw\n    const hasQual = !!qual\n    const len = readFeatures.length\n\n    let refPos = 0\n    let lastPos = featStart\n    let insertedBases = ''\n    let insertedBasesLen = 0\n\n    for (let i = 0; i < len; i++) {\n      const rf = readFeatures[i]!\n      const sublen = refPos - lastPos\n      lastPos = refPos\n\n      // Flush accumulated single-base insertions\n      if (sublen && insertedBasesLen > 0) {\n        callback(\n          INSERTION_TYPE,\n          refPos,\n          0,\n          insertedBases,\n          -1,\n          0,\n          insertedBasesLen,\n        )\n        insertedBases = ''\n        insertedBasesLen = 0\n      }\n      refPos = rf.refPos - 1 - featStart\n\n      const codeChar = rf.code.charCodeAt(0)\n\n      if (codeChar === CODE_X) {\n        const refCharCode = rf.ref ? rf.ref.charCodeAt(0) & ~0x20 : 0\n        callback(\n          MISMATCH_TYPE,\n          refPos,\n          1,\n          rf.sub!,\n          hasQual ? qual[rf.pos - 1]! : -1,\n          refCharCode,\n          0,\n        )\n      } else if (codeChar === CODE_I) {\n        callback(INSERTION_TYPE, refPos, 0, rf.data, -1, 0, rf.data.length)\n      } else if (codeChar === CODE_N) {\n        callback(SKIP_TYPE, refPos, rf.data, 'N', -1, 0, 0)\n      } else if (codeChar === CODE_S) {\n        const dataLen = rf.data.length\n        callback(SOFTCLIP_TYPE, refPos, 1, `S${dataLen}`, -1, 0, dataLen)\n      } else if (codeChar === CODE_H) {\n        callback(HARDCLIP_TYPE, refPos, 1, `H${rf.data}`, -1, 0, rf.data)\n      } else if (codeChar === CODE_D) {\n        callback(DELETION_TYPE, refPos, rf.data, '*', -1, 0, 0)\n      } else if (codeChar === CODE_i) {\n        insertedBases += rf.data\n        insertedBasesLen++\n      }\n    }\n\n    // Flush any remaining accumulated insertions\n    if (insertedBasesLen > 0) {\n      callback(\n        INSERTION_TYPE,\n        refPos,\n        0,\n        insertedBases,\n        -1,\n        0,\n        insertedBasesLen,\n      )\n    }\n  }\n\n  get fields(): SimpleFeatureSerialized {\n    return {\n      start: this.start,\n      name: this.name,\n      end: this.end,\n      score: this.score,\n      strand: this.strand,\n      template_length: this.template_length,\n      flags: this.flags,\n      tags: convertTagsToPlainArrays(this.tags),\n      refName: this.refName,\n      seq: this.seq,\n      type: 'match',\n      pair_orientation: this.pair_orientation,\n      next_ref: this.next_ref,\n      next_pos: this.next_pos,\n      next_segment_position: this.next_segment_position,\n      uniqueId: this.id(),\n    }\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...this.fields,\n      // lazy\n      CIGAR: this.CIGAR,\n      // lazy\n      qual: this.qual,\n    }\n  }\n}\n\ncacheGetter(CramSlightlyLazyFeature, 'fields')\ncacheGetter(CramSlightlyLazyFeature, 'CIGAR')\ncacheGetter(CramSlightlyLazyFeature, 'NUMERIC_CIGAR')\ncacheGetter(CramSlightlyLazyFeature, 'mismatches')\n","import { CraiIndex, IndexedCramFile } from '@gmod/cram'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { sum, updateStatus } from '@jbrowse/core/util'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature.ts'\nimport {\n  filterReadFlag,\n  filterTagValue,\n  parseSamHeader,\n} from '../shared/util.ts'\n\nimport type { FilterBy } from '../shared/types.ts'\nimport type { ParsedSamHeader } from '../shared/util.ts'\nimport type {\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  public samHeader?: ParsedSamHeader\n\n  private setupP?: Promise<{\n    samHeader: ParsedSamHeader\n    cram: IndexedCramFile\n  }>\n\n  private configureResult?: { cram: IndexedCramFile }\n\n  private sequenceAdapterP?: Promise<BaseSequenceAdapter>\n\n  private ultraLongFeatureCache = new QuickLRU<number, Feature>({\n    maxSize: 500,\n  })\n\n  private seqIdToOriginalRefName: string[] = []\n\n  private configure() {\n    if (!this.configureResult) {\n      const cramLocation = this.getConf('cramLocation')\n      const craiLocation = this.getConf('craiLocation')\n\n      this.configureResult = {\n        cram: new IndexedCramFile({\n          cramFilehandle: openLocation(cramLocation, this.pluginManager),\n          index: new CraiIndex({\n            filehandle: openLocation(craiLocation, this.pluginManager),\n          }),\n          seqFetch: async (seqId: number, start: number, end: number) => {\n            const sequenceAdapter = await this.getSequenceAdapter()\n            if (!sequenceAdapter) {\n              throw new Error('no sequenceAdapter available')\n            }\n            const refName =\n              this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n            if (!refName) {\n              throw new Error('unknown refName')\n            }\n\n            return (\n              (await sequenceAdapter.getSequence({\n                refName,\n                start: start - 1,\n                end,\n              })) ?? ''\n            )\n          },\n          checkSequenceMD5: false,\n        }),\n      }\n    }\n    return this.configureResult\n  }\n\n  async getSequenceAdapter() {\n    const config = this.sequenceAdapterConfig\n    if (!config || !this.getSubAdapter) {\n      return undefined\n    }\n    this.sequenceAdapterP ??= this.getSubAdapter(config)\n      .then(r => r.dataAdapter as BaseSequenceAdapter)\n      .catch((e: unknown) => {\n        this.sequenceAdapterP = undefined\n        throw e\n      })\n    return this.sequenceAdapterP\n  }\n\n  async getHeader(_opts?: BaseOptions) {\n    const { cram } = this.configure()\n    return cram.cram.getHeaderText()\n  }\n\n  private async setup(_opts?: BaseOptions) {\n    this.setupP ??= (async () => {\n      const { cram } = this.configure()\n      const rawHeader = await cram.cram.getSamHeader()\n      const samHeader = parseSamHeader(rawHeader)\n      this.samHeader = samHeader\n      return { samHeader, cram }\n    })().catch((e: unknown) => {\n      this.setupP = undefined\n      this.configureResult = undefined\n      throw e\n    })\n\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { samHeader } = await this.setup(opts)\n    return samHeader.idToName\n  }\n\n  refNameToId(refName: string) {\n    return this.samHeader?.nameToId[refName]\n  }\n\n  refIdToName(refId: number) {\n    return this.samHeader?.idToName[refId]\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy?: FilterBy\n    },\n  ) {\n    const { stopToken, filterBy, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      const { cram, samHeader } = await this.setup(opts)\n\n      const refId = this.refNameToId(refName)\n      if (refId === undefined) {\n        console.warn('Unknown refName', refName)\n        observer.complete()\n        return\n      }\n\n      if (originalRefName) {\n        this.seqIdToOriginalRefName[refId] = originalRefName\n      }\n      let records\n      try {\n        records = await updateStatus(\n          'Downloading alignments',\n          statusCallback,\n          () => cram.getRecordsForRange(refId, start, end),\n        )\n      } catch (e) {\n        // Clear caches on error so reload works\n        this.setupP = undefined\n        this.configureResult = undefined\n        throw e\n      }\n      checkStopToken(stopToken)\n      await updateStatus('Processing alignments', statusCallback, () => {\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n        } = filterBy || {}\n\n        for (const record of records) {\n          if (filterReadFlag(record.flags, flagInclude, flagExclude)) {\n            continue\n          }\n          if (\n            tagFilter &&\n            filterTagValue(\n              tagFilter.tag === 'RG'\n                ? samHeader.readGroups[record.readGroupId]\n                : record.tags[tagFilter.tag],\n              tagFilter.value,\n            )\n          ) {\n            continue\n          }\n          if (readName && record.readName !== readName) {\n            continue\n          }\n\n          if (record.readLength > 5_000) {\n            const ret = this.ultraLongFeatureCache.get(record.uniqueId)\n            if (ret) {\n              observer.next(ret)\n            } else {\n              const elt = new CramSlightlyLazyFeature(record, this)\n              this.ultraLongFeatureCache.set(record.uniqueId, elt)\n              observer.next(elt)\n            }\n          } else {\n            observer.next(new CramSlightlyLazyFeature(record, this))\n          }\n        }\n\n        observer.complete()\n      })\n    }, stopToken)\n  }\n\n  /**\n   * we return the configured fetchSizeLimit, and the bytes for the region\n   */\n  async getMultiRegionFeatureDensityStats(regions: Region[]) {\n    const bytes = await this.bytesForRegions(regions)\n    const fetchSizeLimit = this.getConf('fetchSizeLimit')\n    return {\n      bytes,\n      fetchSizeLimit,\n    }\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   */\n  private async bytesForRegions(regions: Region[]) {\n    const { cram } = this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region => {\n        const { refName, start, end } = region\n        const chrId = this.refNameToId(refName)\n        return chrId !== undefined\n          ? cram.index.getEntriesForRange(chrId, start, end)\n          : Promise.resolve([{ sliceBytes: 0 }])\n      }),\n    )\n\n    return sum(blockResults.flat().map(a => a.sliceBytes))\n  }\n}\n","import { parseCigar2 } from '../../MismatchParser/index.ts'\n\n// CIGAR operation indices (from BAM spec) - used in packed Uint32Array format\nexport const CIGAR_M = 0\nexport const CIGAR_I = 1\nexport const CIGAR_D = 2\nexport const CIGAR_N = 3\nexport const CIGAR_S = 4\nexport const CIGAR_H = 5\nexport const CIGAR_P = 6\nexport const CIGAR_EQ = 7\nexport const CIGAR_X = 8\n\n// Bitmasks for CIGAR operation categories (use with: (1 << op) & MASK)\n// Alignment match ops (M=0, ==7) - may contain mismatches, need MD tag\nexport const CIGAR_M_EQ_MASK = 0b10000001 // (1<<0)|(1<<7) = 129\n// Match/mismatch ops that consume both ref and seq (M=0, ==7, X=8)\nexport const CIGAR_MATCH_MASK = 0b110000001 // (1<<0)|(1<<7)|(1<<8) = 385\n// Seq-only ops (S=4, I=1)\nexport const CIGAR_SEQ_ONLY_MASK = 0b10010 // (1<<1)|(1<<4) = 18\n// Ref-skip ops (D=2, N=3)\nexport const CIGAR_REF_SKIP_MASK = 0b1100 // (1<<2)|(1<<3) = 12\n// Ref-consuming ops (M=0, D=2, ==7, X=8)\nexport const CIGAR_REF_CONSUMING_MASK = 0b110000101 // (1<<0)|(1<<2)|(1<<7)|(1<<8) = 389\n\n// BAM 4-bit encoded sequence lookup table\nexport const SEQRET = '=ACMGRSVTWYHKDBN'\n\n// Numeric decoder - returns char codes directly (lowercase for case-insensitive comparison)\n// '=' = 61, 'a' = 97, 'c' = 99, 'm' = 109, 'g' = 103, 'r' = 114, 's' = 115, 'v' = 118,\n// 't' = 116, 'w' = 119, 'y' = 121, 'h' = 104, 'k' = 107, 'd' = 100, 'b' = 98, 'n' = 110\nexport const SEQRET_NUMERIC_DECODER = new Uint8Array([\n  61, 97, 99, 109, 103, 114, 115, 118, 116, 119, 121, 104, 107, 100, 98, 110,\n])\n\n// Pre-computed char lookup for ASCII codes (avoids String.fromCharCode in hot loops)\nexport const CHAR_FROM_CODE: string[] = Array.from({ length: 128 }, (_, i) =>\n  String.fromCharCode(i),\n)\n\n// Helper to ensure we have Uint32Array (packed format)\nexport function getCigarOps(\n  cigar: Uint32Array | string | undefined,\n): ArrayLike<number> {\n  return typeof cigar === 'string' ? parseCigar2(cigar) : cigar || []\n}\n"],"names":["CIGAR_CODE_TO_INDEX","NUMERIC_CIGAR_CODES","Uint8Array","CramSlightlyLazyFeature","constructor","record","_store","this","name","readName","start","alignmentStart","end","lengthOnRef","score","mappingQuality","flags","strand","isReverseComplemented","qual","qualityScores","join","qualRaw","refName","refIdToName","sequenceId","pair_orientation","isPaired","getPairOrientation","undefined","template_length","templateLength","templateSize","next_ref","mate","next_segment_position","is_paired","next_pos","tags","RG","samHeader","readGroups","readGroupId","seq","getReadBases","NUMERIC_CIGAR","readFeatures","readLen","cigarParts","op","oplen","lastPos","insLen","seqLen","i","l","length","code","refPos","data","sublen","opIndex","push","codeChar","charCodeAt","addedLen","split","dataLen","remaining","readFeaturesToNumericCIGAR","readLength","CIGAR","numeric","result","packed","opCode","CHAR_FROM_CODE","id","uniqueId","get","field","mismatches","fields","parent","children","forEachMismatch","type","base","altbase","cliplen","MISMATCH_TYPE","INSERTION_TYPE","insertlen","insertedBases","SOFTCLIP_TYPE","HARDCLIP_TYPE","callback","featStart","hasQual","len","insertedBasesLen","rf","refCharCode","ref","sub","pos","SKIP_TYPE","DELETION_TYPE","convertTagsToPlainArrays","toJSON","cacheGetter","CramAdapter","BaseFeatureDataAdapter","ultraLongFeatureCache","QuickLRU","maxSize","seqIdToOriginalRefName","configure","configureResult","cramLocation","getConf","craiLocation","cram","IndexedCramFile","cramFilehandle","openLocation","pluginManager","index","CraiIndex","filehandle","seqFetch","async","seqId","sequenceAdapter","getSequenceAdapter","Error","refIdToOriginalName","getSequence","checkSequenceMD5","config","sequenceAdapterConfig","getSubAdapter","sequenceAdapterP","then","r","dataAdapter","catch","e","getHeader","_opts","getHeaderText","setup","setupP","rawHeader","getSamHeader","parseSamHeader","getRefNames","opts","idToName","refNameToId","nameToId","refId","getFeatures","region","stopToken","filterBy","statusCallback","originalRefName","ObservableCreate","console","warn","observer","complete","records","updateStatus","getRecordsForRange","checkStopToken","flagInclude","flagExclude","tagFilter","filterReadFlag","filterTagValue","tag","value","ret","next","elt","set","getMultiRegionFeatureDensityStats","regions","bytes","bytesForRegions","fetchSizeLimit","blockResults","Promise","all","map","chrId","getEntriesForRange","resolve","sliceBytes","sum","flat","a","CIGAR_M","CIGAR_I","CIGAR_D","CIGAR_N","CIGAR_S","CIGAR_H","CIGAR_EQ","CIGAR_X","CIGAR_M_EQ_MASK","CIGAR_REF_CONSUMING_MASK","SEQRET","SEQRET_NUMERIC_DECODER","Array","from","_","String","fromCharCode","getCigarOps","cigar","parseCigar2"],"ignoreList":[],"sourceRoot":""}