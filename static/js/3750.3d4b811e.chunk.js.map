{"version":3,"file":"static/js/3750.3d4b811e.chunk.js","mappings":"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","sources":["../../../node_modules/.pnpm/@gmod+vcf@6.1.0/node_modules/@gmod/vcf/src/parseMetaString.ts","../../../node_modules/.pnpm/@gmod+vcf@6.1.0/node_modules/@gmod/vcf/src/vcfReserved.ts","../../../node_modules/.pnpm/@gmod+vcf@6.1.0/node_modules/@gmod/vcf/src/parse.ts","../../../node_modules/.pnpm/@gmod+vcf@6.1.0/node_modules/@gmod/vcf/src/parseGenotypesOnly.ts","../../../node_modules/.pnpm/@gmod+vcf@6.1.0/node_modules/@gmod/vcf/src/parseBreakend.ts"],"sourcesContent":["// constructed with the assistance of claude AI\n//\n// I first prompted it with a regex that splits a comma separated string with\n// awareness of quotation from this stackoverflow question\n// https://stackoverflow.com/a/18893443/2129219, and asked it to add support\n// for square brackets\n//\n// it undid the regex into serial logic and the result was this function\nfunction customSplit(str: string) {\n  const result = []\n  const chars = []\n  let inQuotes = false\n  let inBrackets = false\n  const strLen = str.length\n\n  for (let i = 0; i < strLen; i++) {\n    const char = str[i]!\n    if (char === '\"') {\n      inQuotes = !inQuotes\n      chars.push(char)\n    } else if (char === '[') {\n      inBrackets = true\n      chars.push(char)\n    } else if (char === ']') {\n      inBrackets = false\n      chars.push(char)\n    } else if (char === ',' && !inQuotes && !inBrackets) {\n      result.push(chars.join('').trim())\n      chars.length = 0\n    } else {\n      chars.push(char)\n    }\n  }\n\n  if (chars.length > 0) {\n    result.push(chars.join('').trim())\n  }\n\n  return result\n}\n\nfunction splitFirst(str: string, split: string) {\n  const index = str.indexOf(split)\n  return [str.slice(0, index), str.slice(index + 1)]\n}\n\nexport function parseMetaString(metaString: string) {\n  const inside = metaString.slice(1, -1)\n  const parts = customSplit(inside)\n  const entries: [string, any][] = []\n  for (let i = 0; i < parts.length; i++) {\n    const f = parts[i]!\n    const [key, val] = splitFirst(f, '=')\n    if (val && val.startsWith('[') && val.endsWith(']')) {\n      const items = val.slice(1, -1).split(',')\n      for (let j = 0; j < items.length; j++) {\n        items[j] = items[j]!.trim()\n      }\n      entries.push([key!, items])\n    } else if (val && val.startsWith('\"') && val.endsWith('\"')) {\n      entries.push([key!, val.slice(1, -1)])\n    } else {\n      entries.push([key!, val])\n    }\n  }\n  return Object.fromEntries(entries)\n}\n","export default {\n  // INFO fields\n  InfoFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AA: { Number: 1, Type: 'String', Description: 'Ancestral allele' },\n    AC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description:\n        'Allele count in genotypes, for each ALT allele, in the same order as listed',\n    },\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Total read depth for each allele',\n    },\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand',\n    },\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand',\n    },\n    AF: {\n      Number: 'A',\n      Type: 'Float',\n      Description:\n        'Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)',\n    },\n    AN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Total number of alleles in called genotypes',\n    },\n    BQ: {\n      Number: 1,\n      Type: 'Float',\n      Description: 'RMS base quality',\n    },\n    CIGAR: {\n      Number: 1,\n      Type: 'Float',\n      Description:\n        'Cigar string describing how to align an alternate allele to the reference allele',\n    },\n    DB: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'dbSNP membership',\n    },\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'combined depth across samples',\n    },\n    END: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'End position (for use with symbolic alleles)',\n    },\n    H2: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap2 membership',\n    },\n    H3: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap3 membership',\n    },\n    MQ: {\n      Number: 1,\n      Type: null,\n      Description: 'RMS mapping quality',\n    },\n    MQ0: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of MAPQ == 0 reads',\n    },\n    NS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of samples with data',\n    },\n    SB: {\n      Number: 4,\n      Type: 'Integer',\n      Description: 'Strand bias',\n    },\n    SOMATIC: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Somatic mutation (for cancer genomics)',\n    },\n    VALIDATED: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Validated by follow-up experiment',\n    },\n    '1000G': {\n      Number: 0,\n      Type: 'Flag',\n      Description: '1000 Genomes membership',\n    },\n    // specifically for structural variants\n    IMPRECISE: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Imprecise structural variation',\n    },\n    NOVEL: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Indicates a novel structural variation',\n    },\n    // For precise variants, END is POS + length of REF allele - 1,\n    // and the for imprecise variants the corresponding best estimate.\n    SVTYPE: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Type of structural variant',\n    },\n    // Value should be one of DEL, INS, DUP, INV, CNV, BND. This key can\n    // be derived from the REF/ALT fields but is useful for filtering.\n    SVLEN: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Difference in length between REF and ALT alleles',\n    },\n    // One value for each ALT allele. Longer ALT alleles (e.g. insertions)\n    // have positive values, shorter ALT alleles (e.g. deletions)\n    // have negative values.\n    CIPOS: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around POS for imprecise variants',\n    },\n    CIEND: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around END for imprecise variants',\n    },\n    HOMLEN: {\n      Type: 'Integer',\n      Description:\n        'Length of base pair identical micro-homology at event breakpoints',\n    },\n    HOMSEQ: {\n      Type: 'String',\n      Description:\n        'Sequence of base pair identical micro-homology at event breakpoints',\n    },\n    BKPTID: {\n      Type: 'String',\n      Description: 'ID of the assembled alternate allele in the assembly file',\n    },\n    // For precise variants, the consensus sequence the alternate allele assembly\n    // is derivable from the REF and ALT fields. However, the alternate allele\n    // assembly file may contain additional information about the characteristics\n    // of the alt allele contigs.\n    MEINFO: {\n      Number: 4,\n      Type: 'String',\n      Description: 'Mobile element info of the form NAME,START,END,POLARITY',\n    },\n    METRANS: {\n      Number: 4,\n      Type: 'String',\n      Description:\n        'Mobile element transduction info of the form CHR,START,END,POLARITY',\n    },\n    DGVID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in Database of Genomic Variation',\n    },\n    DBVARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBVAR',\n    },\n    DBRIPID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBRIP',\n    },\n    MATEID: {\n      Number: null,\n      Type: 'String',\n      Description: 'ID of mate breakends',\n    },\n    PARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of partner breakend',\n    },\n    EVENT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of event associated to breakend',\n    },\n    CILEN: {\n      Number: 2,\n      Type: 'Integer',\n      Description:\n        'Confidence interval around the inserted material between breakend',\n    },\n    DPADJ: { Type: 'Integer', Description: 'Read Depth of adjacency' },\n    CN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Copy number of segment containing breakend',\n    },\n    CNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Copy number of adjacency',\n    },\n    CICN: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the segment',\n    },\n    CICNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the adjacency',\n    },\n  },\n\n  // FORMAT fields\n  GenotypeFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele',\n    },\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand',\n    },\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand',\n    },\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Read depth',\n    },\n    EC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description: 'Expected alternate allele counts',\n    },\n    FT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Filter indicating if this genotype was \"called\"',\n    },\n    GL: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype likelihoods',\n    },\n    GP: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype posterior probabilities',\n    },\n    GQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Conditional genotype quality',\n    },\n    GT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Genotype',\n    },\n    HQ: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Haplotype quality',\n    },\n    MQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'RMS mapping quality',\n    },\n    PL: {\n      Number: 'G',\n      Type: 'Integer',\n      Description:\n        'Phred-scaled genotype likelihoods rounded to the closest integer',\n    },\n    PQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phasing quality',\n    },\n    PS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phase set',\n    },\n  },\n\n  // ALT fields\n  AltTypes: {\n    DEL: {\n      Description: 'Deletion relative to the reference',\n    },\n    INS: {\n      Description: 'Insertion of novel sequence relative to the reference',\n    },\n    DUP: {\n      Description: 'Region of elevated copy number relative to the reference',\n    },\n    INV: {\n      Description: 'Inversion of reference sequence',\n    },\n    CNV: {\n      Description:\n        'Copy number variable region (may be both deletion and duplication)',\n    },\n    'DUP:TANDEM': {\n      Description: 'Tandem duplication',\n    },\n    'DEL:ME': {\n      Description: 'Deletion of mobile element relative to the reference',\n    },\n    'INS:ME': {\n      Description: 'Insertion of a mobile element relative to the reference',\n    },\n    NON_REF: {\n      Description:\n        'Represents any possible alternative allele at this location',\n    },\n    '*': {\n      Description:\n        'Represents any possible alternative allele at this location',\n    },\n  },\n\n  // FILTER fields\n  FilterTypes: {\n    PASS: {\n      Description: 'Passed all filters',\n    },\n  },\n}\n","import { parseGenotypesOnly } from './parseGenotypesOnly.ts'\nimport { parseMetaString } from './parseMetaString.ts'\nimport vcfReserved from './vcfReserved.ts'\n\nfunction decodeURIComponentNoThrow(uri: string) {\n  try {\n    return decodeURIComponent(uri)\n  } catch (_e) {\n    // avoid throwing exception on a failure to decode URI component\n    return uri\n  }\n}\n\n/**\n * Class representing a VCF parser, instantiated with the VCF header.\n *\n * @param {object} args\n *\n * @param {string} args.header - The VCF header. Supports both LF and CRLF\n * newlines.\n *\n * @param {boolean} args.strict - Whether to parse in strict mode or not\n * (default true)\n */\nexport default class VCFParser {\n  private metadata: Record<string, unknown>\n  public strict: boolean\n  public samples: string[]\n\n  constructor({\n    header = '',\n    strict = true,\n  }: {\n    header: string\n    strict?: boolean\n  }) {\n    if (!header.length) {\n      throw new Error('empty header received')\n    }\n    const headerLines = header.split(/[\\r\\n]+/).filter(Boolean)\n    if (!headerLines.length) {\n      throw new Error('no non-empty header lines specified')\n    }\n\n    this.strict = strict\n    this.metadata = {\n      INFO: { ...vcfReserved.InfoFields },\n      FORMAT: { ...vcfReserved.GenotypeFields },\n      ALT: { ...vcfReserved.AltTypes },\n      FILTER: { ...vcfReserved.FilterTypes },\n    }\n\n    let lastLine: string | undefined\n    for (let i = 0; i < headerLines.length; i++) {\n      const line = headerLines[i]!\n      if (!line.startsWith('#')) {\n        throw new Error(`Bad line in header:\\n${line}`)\n      } else if (line.startsWith('##')) {\n        this.parseMetadata(line)\n      } else {\n        lastLine = line\n      }\n    }\n\n    if (!lastLine) {\n      throw new Error('No format line found in header')\n    }\n    const fields = lastLine.trim().split('\\t')\n    const thisHeader = fields.slice(0, 8)\n    const correctHeader = [\n      '#CHROM',\n      'POS',\n      'ID',\n      'REF',\n      'ALT',\n      'QUAL',\n      'FILTER',\n      'INFO',\n    ]\n    if (fields.length < 8) {\n      throw new Error(`VCF header missing columns:\\n${lastLine}`)\n    } else if (\n      thisHeader.length !== correctHeader.length ||\n      !thisHeader.every((value, index) => value === correctHeader[index])\n    ) {\n      throw new Error(`VCF column headers not correct:\\n${lastLine}`)\n    }\n    this.samples = fields.slice(9)\n  }\n\n  private parseInfo(infoStr: string) {\n    const result: Record<string, any> = {}\n    const hasDecode = infoStr.includes('%')\n    const infoPairs = infoStr.split(';')\n    const infoMeta = this.metadata.INFO as Record<string, any>\n    const pairsLen = infoPairs.length\n\n    for (let i = 0; i < pairsLen; i++) {\n      const pair = infoPairs[i]!\n      const eqIdx = pair.indexOf('=')\n      const key = eqIdx === -1 ? pair : pair.slice(0, eqIdx)\n      const val = eqIdx === -1 ? undefined : pair.slice(eqIdx + 1)\n      const itemType = infoMeta[key]?.Type\n\n      if (itemType === 'Flag') {\n        result[key] = true\n      } else if (!val) {\n        result[key] = true\n      } else {\n        const isNumber = itemType === 'Integer' || itemType === 'Float'\n        const rawItems = val.split(',')\n        const itemsLen = rawItems.length\n\n        if (hasDecode) {\n          const items: (string | number | undefined)[] = []\n          for (let j = 0; j < itemsLen; j++) {\n            const v = rawItems[j]!\n            if (v === '.') {\n              items.push(undefined)\n            } else {\n              const decoded = decodeURIComponentNoThrow(v)\n              items.push(isNumber ? Number(decoded) : decoded)\n            }\n          }\n          result[key] = items\n        } else {\n          const items: (string | number | undefined)[] = []\n          for (let j = 0; j < itemsLen; j++) {\n            const v = rawItems[j]!\n            if (v === '.') {\n              items.push(undefined)\n            } else {\n              items.push(isNumber ? Number(v) : v)\n            }\n          }\n          result[key] = items\n        }\n      }\n    }\n    return result\n  }\n\n  private parseSamples(format: string, prerest: string) {\n    const genotypes = {} as Record<\n      string,\n      Record<string, (string | number | undefined)[] | undefined>\n    >\n    if (format) {\n      const rest = prerest.split('\\t')\n      const formatKeys = format.split(':')\n      const formatMeta = this.metadata.FORMAT as Record<string, any>\n      const isNumberType: boolean[] = []\n      for (let i = 0; i < formatKeys.length; i++) {\n        const r = formatMeta[formatKeys[i]!]?.Type\n        isNumberType.push(r === 'Integer' || r === 'Float')\n      }\n      const numKeys = formatKeys.length\n      const samplesLen = this.samples.length\n      for (let i = 0; i < samplesLen; i++) {\n        const sample = this.samples[i]!\n        const sampleData: Record<\n          string,\n          (string | number | undefined)[] | undefined\n        > = {}\n        const sampleStr = rest[i]!\n        const sampleStrLen = sampleStr.length\n        let colStart = 0\n        let colIdx = 0\n\n        for (let j = 0; j <= sampleStrLen; j++) {\n          if (j === sampleStrLen || sampleStr[j] === ':') {\n            const val = sampleStr.slice(colStart, j)\n            if (val === '' || val === '.') {\n              sampleData[formatKeys[colIdx]!] = undefined\n            } else {\n              const items = val.split(',')\n              const result: (string | number | undefined)[] = []\n              if (isNumberType[colIdx]) {\n                for (let k = 0; k < items.length; k++) {\n                  const ent = items[k]!\n                  result.push(ent === '.' ? undefined : +ent)\n                }\n              } else {\n                for (let k = 0; k < items.length; k++) {\n                  const ent = items[k]!\n                  result.push(ent === '.' ? undefined : ent)\n                }\n              }\n              sampleData[formatKeys[colIdx]!] = result\n            }\n            colStart = j + 1\n            colIdx += 1\n            if (colIdx >= numKeys) {\n              break\n            }\n          }\n        }\n        genotypes[sample] = sampleData\n      }\n    }\n    return genotypes\n  }\n\n  /**\n   * Parse a VCF metadata line (i.e. a line that starts with \"##\") and add its\n   * properties to the object.\n   *\n   * @param {string} line - A line from the VCF. Supports both LF and CRLF\n   * newlines.\n   */\n  private parseMetadata(line: string) {\n    const match = /^##(.+?)=(.*)/.exec(line.trim())\n    if (!match) {\n      throw new Error(`Line is not a valid metadata line: ${line}`)\n    }\n    const [metaKey, metaVal] = match.slice(1, 3)\n\n    const r = metaKey!\n    if (metaVal?.startsWith('<')) {\n      if (!(r in this.metadata)) {\n        this.metadata[r] = {}\n      }\n      const [id, keyVals] = this.parseStructuredMetaVal(metaVal)\n      if (id) {\n        // if there is an ID field in the <> metadata\n        // e.g. ##INFO=<ID=AF_ESP,...>\n        ;(this.metadata[r] as Record<string, unknown>)[id] = keyVals\n      } else {\n        // if there is not an ID field in the <> metadata\n        // e.g. ##ID=<Description=\"ClinVar Variation ID\">\n        this.metadata[r] = keyVals\n      }\n    } else {\n      this.metadata[r] = metaVal\n    }\n  }\n\n  /**\n   * Parse a VCF header structured meta string (i.e. a meta value that starts\n   * with \"<ID=...\")\n   *\n   * @param {string} metaVal - The VCF metadata value\n   *\n   * @returns {Array} - Array with two entries, 1) a string of the metadata ID\n   * and 2) an object with the other key-value pairs in the metadata\n   */\n  private parseStructuredMetaVal(metaVal: string) {\n    const keyVals = parseMetaString(metaVal)\n    const id = keyVals.ID!\n    delete keyVals.ID\n    if ('Number' in keyVals) {\n      if (!Number.isNaN(Number(keyVals.Number))) {\n        keyVals.Number = Number(keyVals.Number)\n      }\n    }\n    return [id, keyVals] as const\n  }\n\n  /**\n   * Get metadata filtered by the elements in args. For example, can pass\n   * ('INFO', 'DP') to only get info on an metadata tag that was like\n   * \"##INFO=<ID=DP,...>\"\n   *\n   * @param  {...string} args - List of metadata filter strings.\n   *\n   * @returns {any} An object, string, or number, depending on the filtering\n   */\n  getMetadata(...args: string[]) {\n    let filteredMetadata: any = this.metadata\n    const argsLen = args.length\n    for (let i = 0; i < argsLen; i++) {\n      filteredMetadata = filteredMetadata[args[i]!]\n      if (!filteredMetadata) {\n        return filteredMetadata\n      }\n    }\n    return filteredMetadata\n  }\n\n  /**\n   * Parse a VCF line into an object like\n   *\n   * ```typescript\n   * {\n   *   CHROM: 'contigA',\n   *   POS: 3000,\n   *   ID: ['rs17883296'],\n   *   REF: 'G',\n   *   ALT: ['T', 'A'],\n   *   QUAL: 100,\n   *   FILTER: 'PASS',\n   *   INFO: {\n   *     NS: [3],\n   *     DP: [14],\n   *     AF: [0.5],\n   *     DB: true,\n   *     XYZ: ['5'],\n   *   },\n   *   SAMPLES: () => ({\n   *     HG00096: {\n   *       GT: ['0|0'],\n   *       AP: ['0.000', '0.000'],\n   *     }\n   *   }),\n   *   GENOTYPES: () => ({\n   *     HG00096: '0|0'\n   *   })\n   * }\n   * ```\n   *\n   * SAMPLES and GENOTYPES methods are functions instead of static data fields\n   * because it avoids parsing the potentially long list of samples from e.g.\n   * 1000 genotypes data unless requested.\n   *\n   * The SAMPLES function gives all info about the samples\n   *\n   * The GENOTYPES function only extracts the raw GT string if it exists, for\n   * potentially optimized parsing by programs that need it\n   *\n   * @param {string} line - A string of a line from a VCF\n   */\n  parseLine(line: string) {\n    let currChar = 0\n    let tabCount = 0\n    while (currChar < line.length && tabCount < 9) {\n      if (line[currChar] === '\\t') {\n        tabCount += 1\n      }\n      currChar += 1\n    }\n    const splitPos = tabCount === 9 ? currChar - 1 : currChar\n    const fields = line.slice(0, splitPos).split('\\t')\n    const rest = line.slice(splitPos + 1)\n    const [CHROM, POS, ID, REF, ALT, QUAL, FILTER] = fields\n    const chrom = CHROM\n    const pos = +POS!\n    const id = ID === '.' ? undefined : ID!.split(';')\n    const ref = REF\n    const alt = ALT === '.' ? undefined : ALT!.split(',')\n    const qual = QUAL === '.' ? undefined : +QUAL!\n    const filter = FILTER === '.' ? undefined : FILTER!.split(';')\n    const format = fields[8]\n\n    if (this.strict && !fields[7]) {\n      throw new Error(\n        \"no INFO field specified, must contain at least a '.' (turn off strict mode to allow)\",\n      )\n    }\n    const info =\n      fields[7] === undefined || fields[7] === '.'\n        ? {}\n        : this.parseInfo(fields[7])\n\n    return {\n      CHROM: chrom,\n      POS: pos,\n      ALT: alt,\n      INFO: info,\n      REF: ref,\n      FILTER: filter?.length === 1 && filter[0] === 'PASS' ? 'PASS' : filter,\n      ID: id,\n      QUAL: qual,\n      FORMAT: format,\n      SAMPLES: () => this.parseSamples(fields[8] ?? '', rest),\n      GENOTYPES: () => parseGenotypesOnly(fields[8] ?? '', rest, this.samples),\n    }\n  }\n}\n\nexport type Variant = ReturnType<VCFParser['parseLine']>\n","/**\n * Extracts genotype (GT) values from VCF sample data.\n */\nexport function parseGenotypesOnly(\n  format: string,\n  prerest: string,\n  samples: string[],\n) {\n  const genotypes = Object.create(null) as Record<string, string>\n\n  const samplesLen = samples.length\n  const prerestLen = prerest.length\n  const TAB = 9\n  const COLON = 58\n  let pos = 0\n\n  // Fast path: format is exactly \"GT\"\n  if (format === 'GT') {\n    for (let idx = 0; idx < samplesLen; idx++) {\n      const start = pos\n      while (pos < prerestLen && prerest.charCodeAt(pos) !== TAB) {\n        pos++\n      }\n      genotypes[samples[idx]!] = prerest.slice(start, pos)\n      pos++\n    }\n    return genotypes\n  }\n\n  // Check if GT field exists\n  const gtIdx = format.indexOf('GT')\n  if (gtIdx === -1) {\n    return genotypes\n  }\n\n  // GT is first field but not only field\n  if (gtIdx === 0) {\n    for (let idx = 0; idx < samplesLen; idx++) {\n      const start = pos\n      while (\n        pos < prerestLen &&\n        prerest.charCodeAt(pos) !== COLON &&\n        prerest.charCodeAt(pos) !== TAB\n      ) {\n        pos++\n      }\n      genotypes[samples[idx]!] = prerest.slice(start, pos)\n      while (pos < prerestLen && prerest.charCodeAt(pos) !== TAB) {\n        pos++\n      }\n      pos++\n    }\n    return genotypes\n  }\n\n  // GT is not first field\n  let colonCount = 0\n  for (let j = 0; j < gtIdx; j++) {\n    if (format.charCodeAt(j) === COLON) {\n      colonCount++\n    }\n  }\n  for (let idx = 0; idx < samplesLen; idx++) {\n    const sampleStart = pos\n    let tabIdx = pos\n    while (tabIdx < prerestLen && prerest.charCodeAt(tabIdx) !== TAB) {\n      tabIdx++\n    }\n\n    let colons = 0\n    let fieldStart = sampleStart\n    for (let j = sampleStart; j <= tabIdx; j++) {\n      if (j === tabIdx || prerest.charCodeAt(j) === COLON) {\n        if (colons === colonCount) {\n          genotypes[samples[idx]!] = prerest.slice(fieldStart, j)\n          break\n        }\n        colons++\n        fieldStart = j + 1\n      }\n    }\n    pos = tabIdx + 1\n  }\n\n  return genotypes\n}\n","export interface Breakend {\n  Join: string\n  Replacement: string\n  MatePosition?: string\n  MateDirection?: string\n  SingleBreakend?: boolean\n}\n\nconst ANGLE_BRACKET_START_REGEX = /<(.*)>(.*)/\nconst ANGLE_BRACKET_END_REGEX = /(.*)<(.*)>/\n\nexport function parseBreakend(breakendString: string): Breakend | undefined {\n  const firstChar = breakendString[0]\n  const lastChar = breakendString[breakendString.length - 1]\n\n  if (\n    firstChar === '[' ||\n    firstChar === ']' ||\n    lastChar === '[' ||\n    lastChar === ']'\n  ) {\n    const tokens = breakendString.split(/[[\\]]/)\n    const MateDirection = breakendString.includes('[') ? 'right' : 'left'\n    let Join\n    let Replacement\n    let MatePosition\n    const tokensLen = tokens.length\n    for (let i = 0; i < tokensLen; i++) {\n      const tok = tokens[i]!\n      if (tok) {\n        if (tok.includes(':')) {\n          MatePosition = tok\n          Join = Replacement ? 'right' : 'left'\n        } else {\n          Replacement = tok\n        }\n      }\n    }\n    if (!(MatePosition && Join && Replacement)) {\n      throw new Error(`Invalid breakend: ${breakendString}`)\n    }\n    return { MatePosition, Join, Replacement, MateDirection }\n  }\n\n  if (firstChar === '.') {\n    return {\n      Join: 'left',\n      SingleBreakend: true,\n      Replacement: breakendString.slice(1),\n    }\n  }\n\n  if (lastChar === '.') {\n    return {\n      Join: 'right',\n      SingleBreakend: true,\n      Replacement: breakendString.slice(0, -1),\n    }\n  }\n\n  if (firstChar === '<') {\n    const res = ANGLE_BRACKET_START_REGEX.exec(breakendString)\n    if (!res) {\n      throw new Error(`failed to parse ${breakendString}`)\n    }\n    const Replacement = res[2]\n    return Replacement\n      ? {\n          Join: 'left',\n          Replacement,\n          MateDirection: 'right',\n          MatePosition: `<${res[1]!}>:1`,\n        }\n      : undefined\n  }\n\n  if (breakendString.includes('<')) {\n    const res = ANGLE_BRACKET_END_REGEX.exec(breakendString)\n    if (!res) {\n      throw new Error(`failed to parse ${breakendString}`)\n    }\n    const Replacement = res[1]\n    return Replacement\n      ? {\n          Join: 'right',\n          Replacement,\n          MateDirection: 'right',\n          MatePosition: `<${res[2]!}>:1`,\n        }\n      : undefined\n  }\n\n  return undefined\n}\n"],"names":["splitFirst","str","split","index","indexOf","slice","AA","Number","Type","Description","AC","AD","ADF","ADR","AF","AN","BQ","CIGAR","DB","DP","END","H2","H3","MQ","MQ0","NS","SB","SOMATIC","VALIDATED","IMPRECISE","NOVEL","SVTYPE","SVLEN","CIPOS","CIEND","HOMLEN","HOMSEQ","BKPTID","MEINFO","METRANS","DGVID","DBVARID","DBRIPID","MATEID","PARID","EVENT","CILEN","DPADJ","CN","CNADJ","CICN","CICNADJ","EC","FT","GL","GP","GQ","GT","HQ","PL","PQ","PS","DEL","INS","DUP","INV","CNV","NON_REF","PASS","decodeURIComponentNoThrow","uri","decodeURIComponent","_e","VCFParser","constructor","header","strict","length","Error","headerLines","filter","Boolean","lastLine","this","metadata","INFO","vcfReserved","FORMAT","ALT","FILTER","i","line","startsWith","parseMetadata","fields","trim","thisHeader","correctHeader","every","value","samples","parseInfo","infoStr","result","hasDecode","includes","infoPairs","infoMeta","pairsLen","pair","eqIdx","key","val","undefined","itemType","isNumber","rawItems","itemsLen","items","j","v","push","decoded","parseSamples","format","prerest","genotypes","rest","formatKeys","formatMeta","isNumberType","r","numKeys","samplesLen","sample","sampleData","sampleStr","sampleStrLen","colStart","colIdx","k","ent","match","exec","metaKey","metaVal","id","keyVals","parseStructuredMetaVal","metaString","parts","chars","inQuotes","inBrackets","strLen","char","join","customSplit","entries","f","endsWith","Object","fromEntries","parseMetaString","ID","isNaN","getMetadata","args","filteredMetadata","argsLen","parseLine","currChar","tabCount","splitPos","CHROM","POS","REF","QUAL","chrom","pos","ref","alt","qual","SAMPLES","GENOTYPES","create","prerestLen","idx","start","charCodeAt","gtIdx","colonCount","sampleStart","tabIdx","colons","fieldStart","parseGenotypesOnly","ANGLE_BRACKET_START_REGEX","ANGLE_BRACKET_END_REGEX","parseBreakend","breakendString","firstChar","lastChar","tokens","MateDirection","Join","Replacement","MatePosition","tokensLen","tok","SingleBreakend","res"],"ignoreList":[],"sourceRoot":""}