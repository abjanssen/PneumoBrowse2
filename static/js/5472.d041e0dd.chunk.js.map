{"version":3,"file":"static/js/5472.d041e0dd.chunk.js","mappings":"sOAae,MAAMA,UAA6BC,EAAAA,uBAChD,kBAAcC,CAAaC,GACzB,MAAMC,EAAYC,KAAKC,QAAQ,aACzBC,EAAgBF,KAAKC,QAAQ,oBAAoBH,GACjDK,EAAgBH,KAAKC,QAAQ,oBAAoBH,IAAY,CACjEM,IAAK,GAAGF,EAAcE,OAAOL,EAAUM,iBAGnCC,GAAaC,EAAAA,EAAAA,cAAaL,EAAeF,KAAKQ,eAC9CC,EAAsB,QAAdV,EACRW,EAAM,IAAIC,EAAAA,GAAiB,CAC/BL,aACAM,cAAeH,GACXF,EAAAA,EAAAA,cAAaJ,EAAeH,KAAKQ,oBACjCK,EACJC,cAAgBL,OAEZI,GADAN,EAAAA,EAAAA,cAAaJ,EAAeH,KAAKQ,eAErCO,eAAgB,WAGlB,MAAO,CACLL,MACAM,OAAQ,IAAIC,EAAAA,EAAU,CACpBC,aAAcR,EAAIS,cAGxB,CAEA,eAAMC,CAAUtB,EAAiBuB,GAC/B,MAAM,eAAEC,EAAiBA,QAAaD,GAAQ,CAAC,EAC/C,OAAOE,EAAAA,EAAAA,cAAa,oBAAqBD,GAAgB,IACvDtB,KAAKH,aAAaC,IAEtB,CAEA,iBAAa0B,GACX,OAAOC,OAAOC,KAAK1B,KAAKC,QAAQ,oBAClC,CAEO0B,WAAAA,CAAYC,EAAyBP,EAAoB,CAAC,GAC/D,OAAOQ,EAAAA,EAAAA,mBAA0BC,UAC/B,MAAM,QAAEhC,EAAO,MAAEiC,EAAK,IAAEC,GAAQJ,GAC1B,eAAEN,EAAiBA,QAAaD,GAChC,IAAEX,EAAG,OAAEM,SAAiBhB,KAAKoB,UAAUQ,EAAM9B,QAASuB,SAEtDE,EAAAA,EAAAA,cAAa,uBAAwBD,GAAgB,IACzDZ,EAAIuB,SAASnC,EAASiC,EAAOC,EAAK,CAChCE,aAAcA,CAACC,EAAMC,KACnBC,EAASC,KACP,IAAIC,EAAAA,EAAW,CACbC,QAASxB,EAAOyB,UAAUN,GAC1BnB,SACA0B,GAAI,GAAG1C,KAAK0C,UAAUN,MAEzB,KAEAf,MAGPgB,EAASM,UAAU,GAClBtB,EAAKuB,UACV,CAEA,gBAAMC,GACJ,MAAMC,EAAO9C,KAAKC,QAAQ,sBACpB8C,EAAItB,OAAOC,KAAK1B,KAAKC,QAAQ,qBAAqB,GACxD,GAAiB,KAAb6C,EAAK1C,KAA2B,yBAAb0C,EAAK1C,IAAgC,CAC1D,MAAM,OAAEY,SAAiBhB,KAAKoB,UAAU2B,GACxC,OAAO/B,EAAOgC,QAAQC,KAAIC,IAAQ,CAChCA,UAEJ,CAAO,CACL,MAGMC,SAHYC,EAAAA,EAAAA,yBAChB7C,EAAAA,EAAAA,cAAauC,EAAM9C,KAAKQ,iBAER6C,MAAM,cAClBnC,EAASiC,EAAM,GAAIE,MAAM,OACzB,OAAErC,SAAiBhB,KAAKoB,UAAU2B,GAClCO,EAAI,IAAIC,IAAIvC,EAAOgC,SACzB,OAAOG,EACJK,MAAM,GACNP,KAAId,IACH,MAAMsB,EAAOtB,EAAKkB,MAAM,MACxB,MAAO,CACLH,KAAMO,EAAK,MACRhC,OAAOiC,YAERD,EAAKD,MAAM,GAAGP,KAAI,CAACU,EAAGC,IAAQ,CAAC1C,EAAO0C,EAAM,GAAKD,MAEpD,IAEFE,QAAOC,GAAKR,EAAES,IAAID,EAAEZ,OACzB,CACF,E","sources":["../../../plugins/variants/src/SplitVcfTabixAdapter/SplitVcfTabixAdapter.ts"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix'\nimport VcfParser from '@gmod/vcf'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { fetchAndMaybeUnzipText, updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport VcfFeature from '../VcfFeature'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { NoAssemblyRegion } from '@jbrowse/core/util/types'\n\nexport default class SplitVcfTabixAdapter extends BaseFeatureDataAdapter {\n  private async configurePre(refName: string) {\n    const indexType = this.getConf('indexType')\n    const vcfGzLocation = this.getConf('vcfGzLocationMap')[refName]\n    const indexLocation = this.getConf('indexLocationMap')[refName] || {\n      uri: `${vcfGzLocation.uri}.${indexType.toLowerCase()}`,\n    }\n\n    const filehandle = openLocation(vcfGzLocation, this.pluginManager)\n    const isCSI = indexType === 'CSI'\n    const vcf = new TabixIndexedFile({\n      filehandle,\n      csiFilehandle: isCSI\n        ? openLocation(indexLocation, this.pluginManager)\n        : undefined,\n      tbiFilehandle: !isCSI\n        ? openLocation(indexLocation, this.pluginManager)\n        : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n\n    return {\n      vcf,\n      parser: new VcfParser({\n        header: await vcf.getHeader(),\n      }),\n    }\n  }\n\n  async configure(refName: string, opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, () =>\n      this.configurePre(refName),\n    )\n  }\n\n  public async getRefNames() {\n    return Object.keys(this.getConf('vcfGzLocationMap'))\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { refName, start, end } = query\n      const { statusCallback = () => {} } = opts\n      const { vcf, parser } = await this.configure(query.refName, opts)\n\n      await updateStatus('Downloading variants', statusCallback, () =>\n        vcf.getLines(refName, start, end, {\n          lineCallback: (line, fileOffset) => {\n            observer.next(\n              new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-vcf-${fileOffset}`,\n              }),\n            )\n          },\n          ...opts,\n        }),\n      )\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  async getSources() {\n    const conf = this.getConf('samplesTsvLocation')\n    const r = Object.keys(this.getConf('vcfGzLocationMap'))[0]!\n    if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n      const { parser } = await this.configure(r)\n      return parser.samples.map(name => ({\n        name,\n      }))\n    } else {\n      const txt = await fetchAndMaybeUnzipText(\n        openLocation(conf, this.pluginManager),\n      )\n      const lines = txt.split(/\\n|\\r\\n|\\r/)\n      const header = lines[0]!.split('\\t')\n      const { parser } = await this.configure(r)\n      const s = new Set(parser.samples)\n      return lines\n        .slice(1)\n        .map(line => {\n          const cols = line.split('\\t')\n          return {\n            name: cols[0]!,\n            ...Object.fromEntries(\n              // force col 0 to be called name\n              cols.slice(1).map((c, idx) => [header[idx + 1]!, c] as const),\n            ),\n          }\n        })\n        .filter(f => s.has(f.name))\n    }\n  }\n}\n"],"names":["SplitVcfTabixAdapter","BaseFeatureDataAdapter","configurePre","refName","indexType","this","getConf","vcfGzLocation","indexLocation","uri","toLowerCase","filehandle","openLocation","pluginManager","isCSI","vcf","TabixIndexedFile","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","parser","VcfParser","header","getHeader","configure","opts","statusCallback","updateStatus","getRefNames","Object","keys","getFeatures","query","ObservableCreate","async","start","end","getLines","lineCallback","line","fileOffset","observer","next","VcfFeature","variant","parseLine","id","complete","stopToken","getSources","conf","r","samples","map","name","lines","fetchAndMaybeUnzipText","split","s","Set","slice","cols","fromEntries","c","idx","filter","f","has"],"sourceRoot":""}