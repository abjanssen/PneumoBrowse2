{"version":3,"file":"static/js/5547.5675f266.chunk.js","mappings":"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","sources":["../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/Extension.js","../../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/serializeError/index.ts","../../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/client.ts","../../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/server.ts","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/Storage.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/Redo.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/Publish.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.9_react@19.2.3__@emotion+s_873e60787661dc90ada907c57a275437/node_modules/@mui/material/esm/AppBar/appBarClasses.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.9_react@19.2.3__@emotion+s_873e60787661dc90ada907c57a275437/node_modules/@mui/material/esm/AppBar/AppBar.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.9_react@19.2.3__@emotion+s_873e60787661dc90ada907c57a275437/node_modules/@mui/material/esm/Fab/Fab.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/GetApp.js","../../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","../../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","../../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/Share.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/Settings.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/SpaceDashboard.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/FileCopy.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/Undo.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.9_react@19.2.3__@emotion+s_873e60787661dc90ada907c57a275437/node_modules/@mui/material/esm/Fab/fabClasses.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.9_react@19.2.3__@emotion+s_873e60787661dc90ada907c57a275437/node_modules/@mui/material/esm/CssBaseline/CssBaseline.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._4f45627fdfc0611a55124f5eb568ad63/node_modules/@mui/icons-material/esm/Launch.js","../../../node_modules/.pnpm/mobx-react-lite@4.1.1_mobx@6.15.0_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/mobx-react-lite/src/observer.ts","../../../node_modules/.pnpm/@jbrowse+mobx-state-tree@5.5.0_mobx@6.15.0/node_modules/@jbrowse/mobx-state-tree/dist/mobx-state-tree.module.js"],"sourcesContent":["\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7s2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11\"\n}), 'Extension');","import { errorConstructors, errorFactories } from './errorConstructors.ts'\nimport NonError from './nonError.ts'\n\nconst errorProperties = [\n  { property: 'name', enumerable: false },\n  { property: 'message', enumerable: false },\n  { property: 'stack', enumerable: false },\n  { property: 'code', enumerable: true },\n  { property: 'cause', enumerable: false },\n  { property: 'errors', enumerable: false },\n] as const\n\nconst toJsonWasCalled = new WeakSet()\n\nfunction toJSON(from: { toJSON: () => unknown }) {\n  toJsonWasCalled.add(from)\n  const json = from.toJSON()\n  toJsonWasCalled.delete(from)\n  return json\n}\n\nfunction newError(name: string) {\n  const factory = errorFactories.get(name)\n  if (factory) {\n    return factory()\n  }\n\n  const ErrorConstructor = errorConstructors.get(name) ?? Error\n  if (name === 'AggregateError') {\n    return new AggregateError([])\n  }\n  return new ErrorConstructor()\n}\n\nexport function isErrorLike(value: unknown): value is Error {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as Error).name === 'string' &&\n    typeof (value as Error).message === 'string' &&\n    typeof (value as Error).stack === 'string'\n  )\n}\n\nfunction isMinimumViableSerializedError(\n  value: unknown,\n): value is { name: string; message: string } {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as { message?: unknown }).message === 'string' &&\n    !Array.isArray(value)\n  )\n}\n\ninterface DestroyCircularOptions {\n  from: Record<string, unknown>\n  seen: unknown[]\n  to?: Record<string, unknown> | Error | unknown[]\n  forceEnumerable?: boolean\n  maxDepth: number\n  depth: number\n  useToJSON?: boolean\n  serialize: boolean\n}\n\nfunction destroyCircular({\n  from,\n  seen,\n  to,\n  forceEnumerable,\n  maxDepth,\n  depth,\n  useToJSON,\n  serialize,\n}: DestroyCircularOptions): Record<string, unknown> {\n  if (!to) {\n    if (Array.isArray(from)) {\n      to = []\n    } else if (!serialize && isErrorLike(from)) {\n      to = newError(from.name)\n    } else {\n      to = {}\n    }\n  }\n\n  seen.push(from)\n\n  if (depth >= maxDepth) {\n    return to as Record<string, unknown>\n  }\n\n  if (\n    useToJSON &&\n    typeof (from as { toJSON?: unknown }).toJSON === 'function' &&\n    !toJsonWasCalled.has(from)\n  ) {\n    return toJSON(from as { toJSON: () => unknown }) as Record<string, unknown>\n  }\n\n  const continueDestroyCircular = (value: Record<string, unknown>) =>\n    destroyCircular({\n      from: value,\n      seen: [...seen],\n      forceEnumerable,\n      maxDepth,\n      depth,\n      useToJSON,\n      serialize,\n    })\n\n  for (const [key, value] of Object.entries(from)) {\n    if (\n      value &&\n      value instanceof Uint8Array &&\n      value.constructor.name === 'Buffer'\n    ) {\n      ;(to as Record<string, unknown>)[key] = serialize\n        ? '[object Buffer]'\n        : value\n      continue\n    }\n\n    if (\n      value !== null &&\n      typeof value === 'object' &&\n      typeof (value as { pipe?: unknown }).pipe === 'function'\n    ) {\n      ;(to as Record<string, unknown>)[key] = serialize\n        ? '[object Stream]'\n        : value\n      continue\n    }\n\n    if (typeof value === 'function') {\n      if (!serialize) {\n        ;(to as Record<string, unknown>)[key] = value\n      }\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      try {\n        ;(to as Record<string, unknown>)[key] = value\n      } catch {}\n      continue\n    }\n\n    if (!seen.includes(from[key])) {\n      depth++\n      ;(to as Record<string, unknown>)[key] = continueDestroyCircular(\n        from[key] as Record<string, unknown>,\n      )\n      continue\n    }\n\n    ;(to as Record<string, unknown>)[key] = '[Circular]'\n  }\n\n  if (serialize || to instanceof Error) {\n    for (const { property, enumerable } of errorProperties) {\n      const val = from[property]\n      if (val !== undefined && val !== null) {\n        Object.defineProperty(to, property, {\n          value:\n            isErrorLike(val) || Array.isArray(val)\n              ? continueDestroyCircular(\n                  val as unknown as Record<string, unknown>,\n                )\n              : val,\n          enumerable: forceEnumerable ? true : enumerable,\n          configurable: true,\n          writable: true,\n        })\n      }\n    }\n  }\n\n  return to as Record<string, unknown>\n}\n\nexport interface ErrorObject {\n  name?: string\n  message: string\n  stack?: string\n  code?: string\n  cause?: unknown\n}\n\nexport function serializeError(\n  value: unknown,\n  options: { maxDepth?: number; useToJSON?: boolean } = {},\n) {\n  const { maxDepth = Number.POSITIVE_INFINITY, useToJSON = true } = options\n\n  if (typeof value === 'object' && value !== null) {\n    return destroyCircular({\n      from: value as Record<string, unknown>,\n      seen: [],\n      forceEnumerable: true,\n      maxDepth,\n      depth: 0,\n      useToJSON,\n      serialize: true,\n    }) as unknown as ErrorObject\n  }\n\n  let normalized: unknown = value\n  if (typeof value === 'function') {\n    normalized = '<Function>'\n  }\n\n  return destroyCircular({\n    from: new NonError(normalized) as unknown as Record<string, unknown>,\n    seen: [],\n    forceEnumerable: true,\n    maxDepth,\n    depth: 0,\n    useToJSON,\n    serialize: true,\n  }) as unknown as ErrorObject\n}\n\nexport function deserializeError(\n  value: unknown,\n  options: { maxDepth?: number } = {},\n) {\n  const { maxDepth = Number.POSITIVE_INFINITY } = options\n\n  if (value instanceof Error) {\n    return value\n  }\n\n  if (isMinimumViableSerializedError(value)) {\n    return destroyCircular({\n      from: value as unknown as Record<string, unknown>,\n      seen: [],\n      to: newError((value as { name?: string }).name ?? 'Error'),\n      maxDepth,\n      depth: 0,\n      serialize: false,\n    }) as unknown as Error\n  }\n\n  return new NonError(value)\n}\n","import EventEmitter from './ee.ts'\nimport { deserializeError } from './serializeError/index.ts'\n\ninterface RpcMessageData {\n  uid: string\n  libRpc?: true\n  error?: string\n  method?: string\n  eventName?: string\n  data: unknown\n}\n\nlet counter = 0\n\nexport default class RpcClient extends EventEmitter {\n  protected calls = new Map<string, (data: unknown) => void>()\n  protected errors = new Map<string, (error: Error) => void>()\n\n  constructor(public worker: Worker) {\n    super()\n    this.worker.addEventListener(\n      'message',\n      (e: MessageEvent<RpcMessageData>) => {\n        this.handler(e)\n      },\n    )\n    this.worker.addEventListener('error', (e: ErrorEvent) => {\n      this.catch(e)\n    })\n  }\n\n  protected handler(e: MessageEvent<RpcMessageData>) {\n    const { uid, error, method, eventName, data, libRpc } = e.data\n    if (!libRpc) {\n      return\n    }\n    if (error) {\n      this.reject(uid, error)\n    } else if (method) {\n      this.resolve(uid, data)\n    } else if (eventName) {\n      this.emit(eventName, data)\n    }\n  }\n\n  protected catch(e: ErrorEvent) {\n    this.emit('error', {\n      message: e.message,\n      lineno: e.lineno,\n      filename: e.filename,\n    })\n  }\n\n  protected reject(uid: string, error: string | Error) {\n    const errorFn = this.errors.get(uid)\n    if (errorFn) {\n      errorFn(deserializeError(error))\n      this.clear(uid)\n    }\n  }\n\n  protected resolve(uid: string, data: unknown) {\n    const callFn = this.calls.get(uid)\n    if (callFn) {\n      callFn(data)\n      this.clear(uid)\n    }\n  }\n\n  protected clear(uid: string) {\n    this.calls.delete(uid)\n    this.errors.delete(uid)\n  }\n\n  call(\n    method: string,\n    data: unknown,\n    { transferables = [] }: { transferables?: Transferable[] } = {},\n  ) {\n    const uid = String(++counter)\n    return new Promise((resolve, reject) => {\n      this.calls.set(uid, resolve)\n      this.errors.set(uid, reject)\n      this.worker.postMessage(\n        { method, uid, data, libRpc: true },\n        transferables,\n      )\n    })\n  }\n}\n","import { ErrorObject, serializeError } from './serializeError/index.ts'\n\nfunction isTransferable(object: unknown): object is Transferable {\n  try {\n    return (\n      object instanceof ArrayBuffer ||\n      object instanceof ImageBitmap ||\n      object instanceof OffscreenCanvas ||\n      object instanceof MessagePort\n    )\n  } catch {\n    return false\n  }\n}\n\nfunction isObject(data: unknown): data is Record<string, unknown> {\n  return Object(data) === data\n}\n\nfunction peekTransferables(data: unknown) {\n  const result: Transferable[] = []\n  if (isTransferable(data)) {\n    result.push(data)\n  } else if (isObject(data)) {\n    for (const key of Object.keys(data)) {\n      const val = data[key]\n      if (isTransferable(val)) {\n        result.push(val)\n      }\n    }\n  }\n  return result\n}\n\nexport interface RpcResult {\n  __rpcResult: true\n  value: unknown\n  transferables: Transferable[]\n}\n\nexport function rpcResult(\n  value: unknown,\n  transferables: Transferable[],\n): RpcResult {\n  return { __rpcResult: true, value, transferables }\n}\n\ntype Procedure = (data: unknown) => Promise<unknown>\n\ninterface RpcMessageData {\n  method: string\n  uid: string\n  libRpc?: true\n  data: unknown\n}\n\nfunction isRpcResult(value: unknown): value is RpcResult {\n  return typeof value === 'object' && value !== null && '__rpcResult' in value\n}\n\nexport default class RpcServer {\n  protected methods: Record<string, Procedure>\n\n  constructor(methods: Record<string, Procedure>) {\n    this.methods = methods\n    self.addEventListener('message', (e: MessageEvent<RpcMessageData>) => {\n      this.handler(e)\n    })\n  }\n\n  protected handler(e: MessageEvent<RpcMessageData>) {\n    const { libRpc, method, uid, data } = e.data\n    if (!libRpc) {\n      return\n    }\n    const methodFn = this.methods[method]\n    if (methodFn) {\n      Promise.resolve(data)\n        .then(methodFn)\n        .then(\n          response => {\n            this.reply(uid, method, response)\n          },\n          (error: unknown) => {\n            this.throw(uid, serializeError(error))\n          },\n        )\n    } else {\n      this.throw(uid, `Unknown RPC method \"${method}\"`)\n    }\n  }\n\n  protected reply(uid: string, method: string, response: unknown) {\n    try {\n      if (isRpcResult(response)) {\n        const { value, transferables } = response\n        self.postMessage(\n          { uid, method, data: value, libRpc: true },\n          transferables,\n        )\n      } else {\n        const transferables = peekTransferables(response)\n        self.postMessage(\n          { uid, method, data: response, libRpc: true },\n          transferables,\n        )\n      }\n    } catch (e) {\n      this.throw(uid, serializeError(e))\n    }\n  }\n\n  protected throw(uid: string, error: ErrorObject | string) {\n    self.postMessage({ uid, error, libRpc: true })\n  }\n\n  emit(eventName: string, data: unknown, transferables?: Transferable[]) {\n    const transfer = transferables ?? peekTransferables(data)\n    self.postMessage({ eventName, data, libRpc: true }, transfer)\n  }\n}\n","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M2 20h20v-4H2zm2-3h2v2H4zM2 4v4h20V4zm4 3H4V5h2zm-4 7h20v-4H2zm2-3h2v2H4z\"\n}), 'Storage');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z\"\n}), 'Redo');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M5 4v2h14V4zm0 10h4v6h6v-6h4l-7-7z\"\n}), 'Publish');","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getAppBarUtilityClass(slot) {\n  return generateUtilityClass('MuiAppBar', slot);\n}\nconst appBarClasses = generateUtilityClasses('MuiAppBar', ['root', 'positionFixed', 'positionAbsolute', 'positionSticky', 'positionStatic', 'positionRelative', 'colorDefault', 'colorPrimary', 'colorSecondary', 'colorInherit', 'colorTransparent', 'colorError', 'colorInfo', 'colorSuccess', 'colorWarning']);\nexport default appBarClasses;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { styled } from \"../zero-styled/index.js\";\nimport memoTheme from \"../utils/memoTheme.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\nimport capitalize from \"../utils/capitalize.js\";\nimport createSimplePaletteValueFilter from \"../utils/createSimplePaletteValueFilter.js\";\nimport Paper from \"../Paper/index.js\";\nimport { getAppBarUtilityClass } from \"./appBarClasses.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    color,\n    position,\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root', `color${capitalize(color)}`, `position${capitalize(position)}`]\n  };\n  return composeClasses(slots, getAppBarUtilityClass, classes);\n};\n\n// var2 is the fallback.\n// Ex. var1: 'var(--a)', var2: 'var(--b)'; return: 'var(--a, var(--b))'\nconst joinVars = (var1, var2) => var1 ? `${var1?.replace(')', '')}, ${var2})` : var2;\nconst AppBarRoot = styled(Paper, {\n  name: 'MuiAppBar',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[`position${capitalize(ownerState.position)}`], styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(memoTheme(({\n  theme\n}) => ({\n  display: 'flex',\n  flexDirection: 'column',\n  width: '100%',\n  boxSizing: 'border-box',\n  // Prevent padding issue with the Modal and fixed positioned AppBar.\n  flexShrink: 0,\n  variants: [{\n    props: {\n      position: 'fixed'\n    },\n    style: {\n      position: 'fixed',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0,\n      '@media print': {\n        // Prevent the app bar to be visible on each printed page.\n        position: 'absolute'\n      }\n    }\n  }, {\n    props: {\n      position: 'absolute'\n    },\n    style: {\n      position: 'absolute',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0\n    }\n  }, {\n    props: {\n      position: 'sticky'\n    },\n    style: {\n      position: 'sticky',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0\n    }\n  }, {\n    props: {\n      position: 'static'\n    },\n    style: {\n      position: 'static'\n    }\n  }, {\n    props: {\n      position: 'relative'\n    },\n    style: {\n      position: 'relative'\n    }\n  }, {\n    props: {\n      color: 'inherit'\n    },\n    style: {\n      '--AppBar-color': 'inherit',\n      color: 'var(--AppBar-color)'\n    }\n  }, {\n    props: {\n      color: 'default'\n    },\n    style: {\n      '--AppBar-background': theme.vars ? theme.vars.palette.AppBar.defaultBg : theme.palette.grey[100],\n      '--AppBar-color': theme.vars ? theme.vars.palette.text.primary : theme.palette.getContrastText(theme.palette.grey[100]),\n      ...theme.applyStyles('dark', {\n        '--AppBar-background': theme.vars ? theme.vars.palette.AppBar.defaultBg : theme.palette.grey[900],\n        '--AppBar-color': theme.vars ? theme.vars.palette.text.primary : theme.palette.getContrastText(theme.palette.grey[900])\n      })\n    }\n  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(['contrastText'])).map(([color]) => ({\n    props: {\n      color\n    },\n    style: {\n      '--AppBar-background': (theme.vars ?? theme).palette[color].main,\n      '--AppBar-color': (theme.vars ?? theme).palette[color].contrastText\n    }\n  })), {\n    props: props => props.enableColorOnDark === true && !['inherit', 'transparent'].includes(props.color),\n    style: {\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)'\n    }\n  }, {\n    props: props => props.enableColorOnDark === false && !['inherit', 'transparent'].includes(props.color),\n    style: {\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)',\n      ...theme.applyStyles('dark', {\n        backgroundColor: theme.vars ? joinVars(theme.vars.palette.AppBar.darkBg, 'var(--AppBar-background)') : null,\n        color: theme.vars ? joinVars(theme.vars.palette.AppBar.darkColor, 'var(--AppBar-color)') : null\n      })\n    }\n  }, {\n    props: {\n      color: 'transparent'\n    },\n    style: {\n      '--AppBar-background': 'transparent',\n      '--AppBar-color': 'inherit',\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)',\n      ...theme.applyStyles('dark', {\n        backgroundImage: 'none'\n      })\n    }\n  }]\n})));\nconst AppBar = /*#__PURE__*/React.forwardRef(function AppBar(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiAppBar'\n  });\n  const {\n    className,\n    color = 'primary',\n    enableColorOnDark = false,\n    position = 'fixed',\n    ...other\n  } = props;\n  const ownerState = {\n    ...props,\n    color,\n    position,\n    enableColorOnDark\n  };\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(AppBarRoot, {\n    square: true,\n    component: \"header\",\n    ownerState: ownerState,\n    elevation: 4,\n    className: clsx(classes.root, className, position === 'fixed' && 'mui-fixed'),\n    ref: ref,\n    ...other\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? AppBar.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'inherit', 'primary', 'secondary', 'transparent', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * Shadow depth, corresponds to `dp` in the spec.\n   * It accepts values between 0 and 24 inclusive.\n   * @default 4\n   */\n  elevation: PropTypes.number,\n  /**\n   * If true, the `color` prop is applied in dark mode.\n   * @default false\n   */\n  enableColorOnDark: PropTypes.bool,\n  /**\n   * The positioning type. The behavior of the different options is described\n   * [in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/position).\n   * Note: `sticky` is not universally supported and will fall back to `static` when unavailable.\n   * @default 'fixed'\n   */\n  position: PropTypes.oneOf(['absolute', 'fixed', 'relative', 'static', 'sticky']),\n  /**\n   * If `false`, rounded corners are enabled.\n   * @default true\n   */\n  square: PropTypes.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default AppBar;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport composeClasses from '@mui/utils/composeClasses';\nimport ButtonBase from \"../ButtonBase/index.js\";\nimport capitalize from \"../utils/capitalize.js\";\nimport fabClasses, { getFabUtilityClass } from \"./fabClasses.js\";\nimport rootShouldForwardProp from \"../styles/rootShouldForwardProp.js\";\nimport { styled } from \"../zero-styled/index.js\";\nimport memoTheme from \"../utils/memoTheme.js\";\nimport createSimplePaletteValueFilter from \"../utils/createSimplePaletteValueFilter.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    color,\n    variant,\n    classes,\n    size\n  } = ownerState;\n  const slots = {\n    root: ['root', variant, `size${capitalize(size)}`, color === 'inherit' ? 'colorInherit' : color]\n  };\n  const composedClasses = composeClasses(slots, getFabUtilityClass, classes);\n  return {\n    ...classes,\n    // forward the focused, disabled, etc. classes to the ButtonBase\n    ...composedClasses\n  };\n};\nconst FabRoot = styled(ButtonBase, {\n  name: 'MuiFab',\n  slot: 'Root',\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[ownerState.variant], styles[`size${capitalize(ownerState.size)}`], ownerState.color === 'inherit' && styles.colorInherit, styles[capitalize(ownerState.size)], styles[ownerState.color]];\n  }\n})(memoTheme(({\n  theme\n}) => ({\n  ...theme.typography.button,\n  minHeight: 36,\n  transition: theme.transitions.create(['background-color', 'box-shadow', 'border-color'], {\n    duration: theme.transitions.duration.short\n  }),\n  borderRadius: '50%',\n  padding: 0,\n  minWidth: 0,\n  width: 56,\n  height: 56,\n  zIndex: (theme.vars || theme).zIndex.fab,\n  boxShadow: (theme.vars || theme).shadows[6],\n  '&:active': {\n    boxShadow: (theme.vars || theme).shadows[12]\n  },\n  color: theme.vars ? theme.vars.palette.grey[900] : theme.palette.getContrastText?.(theme.palette.grey[300]),\n  backgroundColor: (theme.vars || theme).palette.grey[300],\n  '&:hover': {\n    backgroundColor: (theme.vars || theme).palette.grey.A100,\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: (theme.vars || theme).palette.grey[300]\n    },\n    textDecoration: 'none'\n  },\n  [`&.${fabClasses.focusVisible}`]: {\n    boxShadow: (theme.vars || theme).shadows[6]\n  },\n  variants: [{\n    props: {\n      size: 'small'\n    },\n    style: {\n      width: 40,\n      height: 40\n    }\n  }, {\n    props: {\n      size: 'medium'\n    },\n    style: {\n      width: 48,\n      height: 48\n    }\n  }, {\n    props: {\n      variant: 'extended'\n    },\n    style: {\n      borderRadius: 48 / 2,\n      padding: '0 16px',\n      width: 'auto',\n      minHeight: 'auto',\n      minWidth: 48,\n      height: 48\n    }\n  }, {\n    props: {\n      variant: 'extended',\n      size: 'small'\n    },\n    style: {\n      width: 'auto',\n      padding: '0 8px',\n      borderRadius: 34 / 2,\n      minWidth: 34,\n      height: 34\n    }\n  }, {\n    props: {\n      variant: 'extended',\n      size: 'medium'\n    },\n    style: {\n      width: 'auto',\n      padding: '0 16px',\n      borderRadius: 40 / 2,\n      minWidth: 40,\n      height: 40\n    }\n  }, {\n    props: {\n      color: 'inherit'\n    },\n    style: {\n      color: 'inherit'\n    }\n  }]\n})), memoTheme(({\n  theme\n}) => ({\n  variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(['dark', 'contrastText'])) // check all the used fields in the style below\n  .map(([color]) => ({\n    props: {\n      color\n    },\n    style: {\n      color: (theme.vars || theme).palette[color].contrastText,\n      backgroundColor: (theme.vars || theme).palette[color].main,\n      '&:hover': {\n        backgroundColor: (theme.vars || theme).palette[color].dark,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: (theme.vars || theme).palette[color].main\n        }\n      }\n    }\n  }))]\n})), memoTheme(({\n  theme\n}) => ({\n  [`&.${fabClasses.disabled}`]: {\n    color: (theme.vars || theme).palette.action.disabled,\n    boxShadow: (theme.vars || theme).shadows[0],\n    backgroundColor: (theme.vars || theme).palette.action.disabledBackground\n  }\n})));\nconst Fab = /*#__PURE__*/React.forwardRef(function Fab(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiFab'\n  });\n  const {\n    children,\n    className,\n    color = 'default',\n    component = 'button',\n    disabled = false,\n    disableFocusRipple = false,\n    focusVisibleClassName,\n    size = 'large',\n    variant = 'circular',\n    ...other\n  } = props;\n  const ownerState = {\n    ...props,\n    color,\n    component,\n    disabled,\n    disableFocusRipple,\n    size,\n    variant\n  };\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(FabRoot, {\n    className: clsx(classes.root, className),\n    component: component,\n    disabled: disabled,\n    focusRipple: !disableFocusRipple,\n    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),\n    ownerState: ownerState,\n    ref: ref,\n    ...other,\n    classes: classes,\n    children: children\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? Fab.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'default'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'error', 'info', 'inherit', 'primary', 'secondary', 'success', 'warning']), PropTypes.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the  keyboard focus ripple is disabled.\n   * @default false\n   */\n  disableFocusRipple: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  focusVisibleClassName: PropTypes.string,\n  /**\n   * The URL to link to when the button is clicked.\n   * If defined, an `a` element will be used as the root node.\n   */\n  href: PropTypes.string,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense button styling.\n   * @default 'large'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['small', 'medium', 'large']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The variant to use.\n   * @default 'circular'\n   */\n  variant: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['circular', 'extended']), PropTypes.string])\n} : void 0;\nexport default Fab;","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 9h-4V3H9v6H5l7 7zM5 18v2h14v-2z\"\n}), 'GetApp');","// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter<V> {\n  callbacks = new Set<(arg: V) => void>()\n  currentMessage?: V\n\n  addCallback(callback: (arg: V) => void = () => {}): void {\n    this.callbacks.add(callback)\n    if (this.currentMessage) {\n      callback(this.currentMessage)\n    }\n  }\n\n  callback(message: V) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController.ts'\nimport AggregateStatusReporter from './AggregateStatusReporter.ts'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U, V> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: (arg: V) => void,\n) => Promise<U>\n\ninterface Entry<U, V> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter<V>\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U, V = string> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U, V>>\n  private fillCallback: FillCallback<T, U, V>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U, V>\n    cache: Cache<Entry<U, V>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U, V>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter<V>()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U, V> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: V) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch((error: unknown) => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      (error: unknown) => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92\"\n}), 'Share');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6\"\n}), 'Settings');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M11 21H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h6zm2 0h6c1.1 0 2-.9 2-2v-7h-8zm8-11V5c0-1.1-.9-2-2-2h-6v7z\"\n}), 'SpaceDashboard');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm-1 4 6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2zm-1 7h5.5L14 6.5z\"\n}), 'FileCopy');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8\"\n}), 'Undo');","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getFabUtilityClass(slot) {\n  return generateUtilityClass('MuiFab', slot);\n}\nconst fabClasses = generateUtilityClasses('MuiFab', ['root', 'primary', 'secondary', 'extended', 'circular', 'focusVisible', 'disabled', 'colorInherit', 'sizeSmall', 'sizeMedium', 'sizeLarge', 'info', 'error', 'warning', 'success']);\nexport default fabClasses;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { globalCss } from \"../zero-styled/index.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\n\n// to determine if the global styles are static or dynamic\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst isDynamicSupport = typeof globalCss({}) === 'function';\nexport const html = (theme, enableColorScheme) => ({\n  WebkitFontSmoothing: 'antialiased',\n  // Antialiasing.\n  MozOsxFontSmoothing: 'grayscale',\n  // Antialiasing.\n  // Change from `box-sizing: content-box` so that `width`\n  // is not affected by `padding` or `border`.\n  boxSizing: 'border-box',\n  // Fix font resize problem in iOS\n  WebkitTextSizeAdjust: '100%',\n  // When used under CssVarsProvider, colorScheme should not be applied dynamically because it will generate the stylesheet twice for server-rendered applications.\n  ...(enableColorScheme && !theme.vars && {\n    colorScheme: theme.palette.mode\n  })\n});\nexport const body = theme => ({\n  color: (theme.vars || theme).palette.text.primary,\n  ...theme.typography.body1,\n  backgroundColor: (theme.vars || theme).palette.background.default,\n  '@media print': {\n    // Save printer ink.\n    backgroundColor: (theme.vars || theme).palette.common.white\n  }\n});\nexport const styles = (theme, enableColorScheme = false) => {\n  const colorSchemeStyles = {};\n  if (enableColorScheme && theme.colorSchemes && typeof theme.getColorSchemeSelector === 'function') {\n    Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {\n      const selector = theme.getColorSchemeSelector(key);\n      if (selector.startsWith('@')) {\n        // for @media (prefers-color-scheme), we need to target :root\n        colorSchemeStyles[selector] = {\n          ':root': {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      } else {\n        // else, it's likely that the selector already target an element with a class or data attribute\n        colorSchemeStyles[selector.replace(/\\s*&/, '')] = {\n          colorScheme: scheme.palette?.mode\n        };\n      }\n    });\n  }\n  let defaultStyles = {\n    html: html(theme, enableColorScheme),\n    '*, *::before, *::after': {\n      boxSizing: 'inherit'\n    },\n    'strong, b': {\n      fontWeight: theme.typography.fontWeightBold\n    },\n    body: {\n      margin: 0,\n      // Remove the margin in all browsers.\n      ...body(theme),\n      // Add support for document.body.requestFullScreen().\n      // Other elements, if background transparent, are not supported.\n      '&::backdrop': {\n        backgroundColor: (theme.vars || theme).palette.background.default\n      }\n    },\n    ...colorSchemeStyles\n  };\n  const themeOverrides = theme.components?.MuiCssBaseline?.styleOverrides;\n  if (themeOverrides) {\n    defaultStyles = [defaultStyles, themeOverrides];\n  }\n  return defaultStyles;\n};\n\n// `ecs` stands for enableColorScheme. This is internal logic to make it work with Pigment CSS, so shorter is better.\nconst SELECTOR = 'mui-ecs';\nconst staticStyles = theme => {\n  const result = styles(theme, false);\n  const baseStyles = Array.isArray(result) ? result[0] : result;\n  if (!theme.vars && baseStyles) {\n    baseStyles.html[`:root:has(${SELECTOR})`] = {\n      colorScheme: theme.palette.mode\n    };\n  }\n  if (theme.colorSchemes) {\n    Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {\n      const selector = theme.getColorSchemeSelector(key);\n      if (selector.startsWith('@')) {\n        // for @media (prefers-color-scheme), we need to target :root\n        baseStyles[selector] = {\n          [`:root:not(:has(.${SELECTOR}))`]: {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      } else {\n        // else, it's likely that the selector already target an element with a class or data attribute\n        baseStyles[selector.replace(/\\s*&/, '')] = {\n          [`&:not(:has(.${SELECTOR}))`]: {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      }\n    });\n  }\n  return result;\n};\nconst GlobalStyles = globalCss(isDynamicSupport ? ({\n  theme,\n  enableColorScheme\n}) => styles(theme, enableColorScheme) : ({\n  theme\n}) => staticStyles(theme));\n\n/**\n * Kickstart an elegant, consistent, and simple baseline to build upon.\n */\nfunction CssBaseline(inProps) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCssBaseline'\n  });\n  const {\n    children,\n    enableColorScheme = false\n  } = props;\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [isDynamicSupport && /*#__PURE__*/_jsx(GlobalStyles, {\n      enableColorScheme: enableColorScheme\n    }), !isDynamicSupport && !enableColorScheme && /*#__PURE__*/_jsx(\"span\", {\n      className: SELECTOR,\n      style: {\n        display: 'none'\n      }\n    }), children]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? CssBaseline.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * You can wrap a node.\n   */\n  children: PropTypes.node,\n  /**\n   * Enable `color-scheme` CSS property to use `theme.palette.mode`.\n   * For more details, check out https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/color-scheme\n   * For browser support, check out https://caniuse.com/?search=color-scheme\n   * @default false\n   */\n  enableColorScheme: PropTypes.bool\n} : void 0;\nexport default CssBaseline;","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z\"\n}), 'Launch');","import { forwardRef, memo } from \"react\"\n\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { useObserver } from \"./useObserver\"\n\nlet warnObserverOptionsDeprecated = true\nlet warnLegacyContextTypes = true\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\nconst isFunctionNameConfigurable =\n    Object.getOwnPropertyDescriptor(() => {}, \"name\")?.configurable ?? false\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof forwardRef === \"function\" && forwardRef((props: any) => null)[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof memo === \"function\" && memo((props: any) => null)[\"$$typeof\"]\n\n/**\n * @deprecated Observer options will be removed in the next major version of mobx-react-lite.\n * Look at the individual properties for alternatives.\n */\nexport interface IObserverOptions {\n    /**\n     * @deprecated Pass a `React.forwardRef` component to observer instead of using the options object\n     * e.g. `observer(React.forwardRef(fn))`\n     */\n    readonly forwardRef?: boolean\n}\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefRenderFunction<TRef, P>,\n    options: IObserverOptions & {\n        /**\n         * @deprecated Pass a `React.forwardRef` component to observer instead of using the options object\n         * e.g. `observer(React.forwardRef(fn))`\n         */\n        forwardRef: true\n    }\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\n\nexport function observer<P extends object>(\n    baseComponent: React.FunctionComponent<P>,\n    options?: IObserverOptions\n): React.FunctionComponent<P>\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefExoticComponent<\n        React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n    >\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\nexport function observer<\n    C extends React.FunctionComponent<any> | React.ForwardRefRenderFunction<any>,\n    Options extends IObserverOptions\n>(\n    baseComponent: C,\n    options?: Options\n): Options extends { forwardRef: true }\n    ? C extends React.ForwardRefRenderFunction<infer TRef, infer P>\n        ? C &\n              React.MemoExoticComponent<\n                  React.ForwardRefExoticComponent<\n                      React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n                  >\n              >\n        : never /* forwardRef set for a non forwarding component */\n    : C & { displayName: string }\n\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer<P extends object, TRef = {}>(\n    baseComponent:\n        | React.ForwardRefRenderFunction<TRef, P>\n        | React.FunctionComponent<P>\n        | React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>,\n    // TODO remove in next major\n    options?: IObserverOptions\n) {\n    if (process.env.NODE_ENV !== \"production\" && warnObserverOptionsDeprecated && options) {\n        warnObserverOptionsDeprecated = false\n        console.warn(\n            `[mobx-react-lite] \\`observer(fn, { forwardRef: true })\\` is deprecated, use \\`observer(React.forwardRef(fn))\\``\n        )\n    }\n\n    if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            `[mobx-react-lite] You are trying to use \\`observer\\` on a function component wrapped in either another \\`observer\\` or \\`React.memo\\`. The observer already applies 'React.memo' for you.`\n        )\n    }\n\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent\n    }\n\n    let useForwardRef = options?.forwardRef ?? false\n    let render = baseComponent\n\n    const baseComponentName = baseComponent.displayName || baseComponent.name\n\n    // If already wrapped with forwardRef, unwrap,\n    // so we can patch render and apply memo\n    if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n        useForwardRef = true\n        render = baseComponent[\"render\"]\n        if (typeof render !== \"function\") {\n            throw new Error(\n                `[mobx-react-lite] \\`render\\` property of ForwardRef was not a function`\n            )\n        }\n    }\n\n    let observerComponent = (props: any, ref: React.Ref<TRef>) => {\n        return useObserver(() => render(props, ref), baseComponentName)\n    }\n\n    // Inherit original name and displayName, see #3438\n    ;(observerComponent as React.FunctionComponent).displayName = baseComponent.displayName\n\n    if (isFunctionNameConfigurable) {\n        Object.defineProperty(observerComponent, \"name\", {\n            value: baseComponent.name,\n            writable: true,\n            configurable: true\n        })\n    }\n\n    // Support legacy context: `contextTypes` must be applied before `memo`\n    if ((baseComponent as any).contextTypes) {\n        ;(observerComponent as React.FunctionComponent).contextTypes = (\n            baseComponent as any\n        ).contextTypes\n\n        if (process.env.NODE_ENV !== \"production\" && warnLegacyContextTypes) {\n            warnLegacyContextTypes = false\n            console.warn(\n                `[mobx-react-lite] Support for Legacy Context in function components will be removed in the next major release.`\n            )\n        }\n    }\n\n    if (useForwardRef) {\n        // `forwardRef` must be applied prior `memo`\n        // `forwardRef(observer(cmp))` throws:\n        // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n        observerComponent = forwardRef(observerComponent)\n    }\n\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    observerComponent = memo(observerComponent)\n\n    copyStaticProperties(baseComponent, observerComponent)\n\n    if (\"production\" !== process.env.NODE_ENV) {\n        Object.defineProperty(observerComponent, \"contextTypes\", {\n            set() {\n                throw new Error(\n                    `[mobx-react-lite] \\`${\n                        this.displayName || this.type?.displayName || this.type?.name || \"Component\"\n                    }.contextTypes\\` must be set before applying \\`observer\\`.`\n                )\n            }\n        })\n    }\n\n    return observerComponent\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList: any = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n    // Don't redefine `displayName`,\n    // it's defined as getter-setter pair on `memo` (see #3192).\n    displayName: true\n}\n\nfunction copyStaticProperties(base: any, target: any) {\n    Object.keys(base).forEach(key => {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n","import { isComputedProp, isObservableProp, createAtom, action, computed, _allowStateChangesInsideComputed, reaction, runInAction, observable, values, entries, isObservableArray, _getGlobalState, isObservableObject, defineProperty as defineProperty$1, _interceptReads, intercept, observe, ObservableMap, _getAdministration, set, makeObservable, getAtom, when } from 'mobx';\n\nlet livelinessChecking = \"warn\";\n/**\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelinessChecking(mode) {\n    livelinessChecking = mode;\n}\n/**\n * Returns the current liveliness checking mode.\n *\n * @returns `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction getLivelinessChecking() {\n    return livelinessChecking;\n}\n/**\n * @deprecated use setLivelinessChecking instead\n * @hidden\n *\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelynessChecking(mode) {\n    setLivelinessChecking(mode);\n}\n\n/**\n * @hidden\n */\nvar Hook;\n(function (Hook) {\n    Hook[\"afterCreate\"] = \"afterCreate\";\n    Hook[\"afterAttach\"] = \"afterAttach\";\n    Hook[\"afterCreationFinalization\"] = \"afterCreationFinalization\";\n    Hook[\"beforeDetach\"] = \"beforeDetach\";\n    Hook[\"beforeDestroy\"] = \"beforeDestroy\";\n})(Hook || (Hook = {}));\n\n/**\n * Returns the _actual_ type of the given tree node. (Or throws)\n *\n * @param object\n * @returns\n */\nfunction getType(object) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).type;\n}\n/**\n * Returns the _declared_ type of the given sub property of an object, array or map.\n * In the case of arrays and maps the property name is optional and will be ignored.\n *\n * Example:\n * ```ts\n * const Box = types.model({ x: 0, y: 0 })\n * const box = Box.create()\n *\n * console.log(getChildType(box, \"x\").name) // 'number'\n * ```\n *\n * @param object\n * @param propertyName\n * @returns\n */\nfunction getChildType(object, propertyName) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).getChildType(propertyName);\n}\n/**\n * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.\n * Patches can be used to deeply observe a model tree.\n *\n * @param target the model instance from which to receive patches\n * @param callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch\n * @returns function to remove the listener\n */\nfunction onPatch(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onPatch(callback);\n}\n/**\n * Registers a function that is invoked whenever a new snapshot for the given model instance is available.\n * The listener will only be fire at the end of the current MobX (trans)action.\n * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.\n *\n * @param target\n * @param callback\n * @returns\n */\nfunction onSnapshot(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onSnapshot(callback);\n}\n/**\n * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.\n *\n * Can apply a single past, or an array of patches.\n *\n * @param target\n * @param patch\n * @returns\n */\nfunction applyPatch(target, patch) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(patch, p => typeof p === \"object\", \"object or array\", 2);\n    getStateTreeNode(target).applyPatches(asArray(patch));\n}\n/**\n * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.\n * Returns a recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IPatchRecorder {\n *      // the recorded patches\n *      patches: IJsonPatch[]\n *      // the inverse of the recorded patches\n *      inversePatches: IJsonPatch[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording patches\n *      stop(): void\n *      // resume recording patches\n *      resume(): void\n *      // apply all the recorded patches on the given target (the original subject if omitted)\n *      replay(target?: IAnyStateTreeNode): void\n *      // reverse apply the recorded patches on the given target  (the original subject if omitted)\n *      // stops the recorder if not already stopped\n *      undo(): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain patches.\n *\n * @param subject\n * @param filter\n * @returns\n */\nfunction recordPatches(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    const data = {\n        patches: [],\n        inversePatches: []\n    };\n    // we will generate the immutable copy of patches on demand for public consumption\n    const publicData = {};\n    let disposer;\n    const recorder = {\n        get recording() {\n            return !!disposer;\n        },\n        get patches() {\n            if (!publicData.patches) {\n                publicData.patches = data.patches.slice();\n            }\n            return publicData.patches;\n        },\n        get reversedInversePatches() {\n            if (!publicData.reversedInversePatches) {\n                publicData.reversedInversePatches = data.inversePatches\n                    .slice()\n                    .reverse();\n            }\n            return publicData.reversedInversePatches;\n        },\n        get inversePatches() {\n            if (!publicData.inversePatches) {\n                publicData.inversePatches = data.inversePatches.slice();\n            }\n            return publicData.inversePatches;\n        },\n        stop() {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume() {\n            if (disposer) {\n                return;\n            }\n            disposer = onPatch(subject, (patch, inversePatch) => {\n                // skip patches that are asked to be filtered if there's a filter in place\n                if (filter && !filter(patch, inversePatch, getRunningActionContext())) {\n                    return;\n                }\n                data.patches.push(patch);\n                data.inversePatches.push(inversePatch);\n                // mark immutable public patches as dirty\n                publicData.patches = undefined;\n                publicData.inversePatches = undefined;\n                publicData.reversedInversePatches = undefined;\n            });\n        },\n        replay(target) {\n            applyPatch(target || subject, data.patches);\n        },\n        undo(target) {\n            applyPatch(target || subject, data.inversePatches.slice().reverse());\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * The inverse of `unprotect`.\n *\n * @param target\n */\nfunction protect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (!node.isRoot) {\n        throw fail(\"`protect` can only be invoked on root nodes\");\n    }\n    node.isProtectionEnabled = true;\n}\n/**\n * By default it is not allowed to directly modify a model. Models can only be modified through actions.\n * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.\n * For example because you are building a PoC or don't have any middleware attached to your tree.\n *\n * In that case you can disable this protection by calling `unprotect` on the root of your tree.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *     done: false\n * }).actions(self => ({\n *     toggle() {\n *         self.done = !self.done\n *     }\n * }))\n *\n * const todo = Todo.create()\n * todo.done = true // throws!\n * todo.toggle() // OK\n * unprotect(todo)\n * todo.done = false // OK\n * ```\n */\nfunction unprotect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (!node.isRoot) {\n        throw fail(\"`unprotect` can only be invoked on root nodes\");\n    }\n    node.isProtectionEnabled = false;\n}\n/**\n * Returns true if the object is in protected mode, @see protect\n */\nfunction isProtected(target) {\n    return getStateTreeNode(target).isProtected;\n}\n/**\n * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.\n *\n * @param target\n * @param snapshot\n * @returns\n */\nfunction applySnapshot(target, snapshot) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).applySnapshot(snapshot);\n}\n/**\n * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use\n * structural sharing where possible. Doesn't require MobX transactions to be completed.\n *\n * @param target\n * @param applyPostProcess If true (the default) then postProcessSnapshot gets applied.\n * @returns\n */\nfunction getSnapshot(target, applyPostProcess = true) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (applyPostProcess) {\n        return node.snapshot;\n    }\n    return freeze(node.type.getSnapshot(node, false));\n}\n/**\n * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction hasParent(target, depth = 1) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--depth === 0) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the immediate parent of this object, or throws.\n *\n * Note that the immediate parent can be either an object, map or array, and\n * doesn't necessarily refer to the parent model.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction getParent(target, depth = 1) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    let d = depth;\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--d === 0) {\n            return parent.storedValue;\n        }\n        parent = parent.parent;\n    }\n    throw fail(`Failed to find the parent of ${getStateTreeNode(target)} at depth ${depth}`);\n}\n/**\n * Given a model instance, returns `true` if the object has a parent of given type, that is, is part of another object, map or array\n *\n * @param target\n * @param type\n * @returns\n */\nfunction hasParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue)) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the target's parent of a given type, or throws.\n *\n * @param target\n * @param type\n * @returns\n */\nfunction getParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue)) {\n            return parent.storedValue;\n        }\n        parent = parent.parent;\n    }\n    throw fail(`Failed to find the parent of ${getStateTreeNode(target)} of a given type`);\n}\n/**\n * Given an object in a model tree, returns the root object of that tree.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @returns\n */\nfunction getRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).root.storedValue;\n}\n/**\n * Returns the path of the given object in the model tree\n *\n * @param target\n * @returns\n */\nfunction getPath(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).path;\n}\n/**\n * Returns the path of the given object as unescaped string array.\n *\n * @param target\n * @returns\n */\nfunction getPathParts(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return splitJsonPath(getStateTreeNode(target).path);\n}\n/**\n * Returns true if the given object is the root of a model tree.\n *\n * @param target\n * @returns\n */\nfunction isRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).isRoot;\n}\n/**\n * Resolves a path relatively to a given object.\n * Returns undefined if no value can be found.\n *\n * @param target\n * @param path escaped json path\n * @returns\n */\nfunction resolvePath(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    const node = resolveNodeByPath(getStateTreeNode(target), path);\n    return node ? node.value : undefined;\n}\n/**\n * Resolves a model instance given a root target, the type and the identifier you are searching for.\n * Returns undefined if no value can be found.\n *\n * @param type\n * @param target\n * @param identifier\n * @returns\n */\nfunction resolveIdentifier(type, target, identifier) {\n    // check all arguments\n    assertIsType(type, 1);\n    assertIsStateTreeNode(target, 2);\n    assertIsValidIdentifier(identifier, 3);\n    const node = getStateTreeNode(target).root.identifierCache.resolve(type, normalizeIdentifier(identifier));\n    return node?.value;\n}\n/**\n * Returns the identifier of the target node.\n * This is the *string normalized* identifier, which might not match the type of the identifier attribute\n *\n * @param target\n * @returns\n */\nfunction getIdentifier(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).identifier;\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns such reference if the check passes,\n * else it returns undefined.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction tryReference(getter, checkIfAlive = true) {\n    try {\n        const node = getter();\n        if (node === undefined || node === null) {\n            return undefined;\n        }\n        else if (isStateTreeNode(node)) {\n            if (!checkIfAlive) {\n                return node;\n            }\n            else {\n                return isAlive(node) ? node : undefined;\n            }\n        }\n        else {\n            throw fail(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return undefined;\n        }\n        throw e;\n    }\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns if the check passes or not.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction isValidReference(getter, checkIfAlive = true) {\n    try {\n        const node = getter();\n        if (node === undefined || node === null) {\n            return false;\n        }\n        else if (isStateTreeNode(node)) {\n            return checkIfAlive ? isAlive(node) : true;\n        }\n        else {\n            throw fail(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return false;\n        }\n        throw e;\n    }\n}\n/**\n * Try to resolve a given path relative to a given node.\n *\n * @param target\n * @param path\n * @returns\n */\nfunction tryResolve(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    const node = resolveNodeByPath(getStateTreeNode(target), path, false);\n    if (node === undefined) {\n        return undefined;\n    }\n    try {\n        return node.value;\n    }\n    catch (e) {\n        // For what ever reason not resolvable (e.g. totally not existing path, or value that cannot be fetched)\n        // see test / issue: 'try resolve doesn't work #686'\n        return undefined;\n    }\n}\n/**\n * Given two state tree nodes that are part of the same tree,\n * returns the shortest jsonpath needed to navigate from the one to the other\n *\n * @param base\n * @param target\n * @returns\n */\nfunction getRelativePath(base, target) {\n    // check all arguments\n    assertIsStateTreeNode(base, 1);\n    assertIsStateTreeNode(target, 2);\n    return getRelativePathBetweenNodes(getStateTreeNode(base), getStateTreeNode(target));\n}\n/**\n * Returns a deep copy of the given state tree node as new tree.\n * Shorthand for `snapshot(x) = getType(x).create(getSnapshot(x))`\n *\n * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc. during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_\n *\n * @param source\n * @param keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.\n * @returns\n */\nfunction clone(source, keepEnvironment = true) {\n    // check all arguments\n    assertIsStateTreeNode(source, 1);\n    const node = getStateTreeNode(source);\n    return node.type.create(node.snapshot, keepEnvironment === true\n        ? node.root.environment\n        : keepEnvironment === false\n            ? undefined\n            : keepEnvironment); // it's an object or something else\n}\n/**\n * Removes a model element from the state tree, and let it live on as a new state tree\n */\nfunction detach(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    getStateTreeNode(target).detach();\n    return target;\n}\n/**\n * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore\n */\nfunction destroy(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (node.isRoot) {\n        node.die();\n    }\n    else {\n        node.parent.removeChild(node.subpath);\n    }\n}\n/**\n * Returns true if the given state tree node is not killed yet.\n * This means that the node is still a part of a tree, and that `destroy`\n * has not been called. If a node is not alive anymore, the only thing one can do with it\n * is requesting it's last path and snapshot\n *\n * @param target\n * @returns\n */\nfunction isAlive(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).observableIsAlive;\n}\n/**\n * Use this utility to register a function that should be called whenever the\n * targeted state tree node is destroyed. This is a useful alternative to managing\n * cleanup methods yourself using the `beforeDestroy` hook.\n *\n * This methods returns the same disposer that was passed as argument.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string\n * }).actions(self => ({\n *   afterCreate() {\n *     const autoSaveDisposer = reaction(\n *       () => getSnapshot(self),\n *       snapshot => sendSnapshotToServerSomehow(snapshot)\n *     )\n *     // stop sending updates to server if this\n *     // instance is destroyed\n *     addDisposer(self, autoSaveDisposer)\n *   }\n * }))\n * ```\n *\n * @param target\n * @param disposer\n * @returns The same disposer that was passed as argument\n */\nfunction addDisposer(target, disposer) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(disposer, 2);\n    const node = getStateTreeNode(target);\n    node.addDisposer(disposer);\n    return disposer;\n}\n/**\n * Returns the environment of the current state tree. For more info on environments,\n * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired\n *\n * Returns an empty environment if the tree wasn't initialized with an environment\n *\n * @param target\n * @returns\n */\nfunction getEnv(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    const env = node.root.environment;\n    if (!env) {\n        return EMPTY_OBJECT;\n    }\n    return env;\n}\n/**\n * Performs a depth first walk through a tree.\n */\nfunction walk(target, processor) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(processor, 2);\n    const node = getStateTreeNode(target);\n    // tslint:disable-next-line:no_unused-variable\n    node.getChildren().forEach(child => {\n        if (isStateTreeNode(child.storedValue)) {\n            walk(child.storedValue, processor);\n        }\n    });\n    processor(node.storedValue);\n}\n/**\n * Returns a reflection of the model type properties and name for either a model type or model node.\n *\n * @param typeOrNode\n * @returns\n */\nfunction getPropertyMembers(typeOrNode) {\n    let type;\n    if (isStateTreeNode(typeOrNode)) {\n        type = getType(typeOrNode);\n    }\n    else {\n        type = typeOrNode;\n    }\n    assertArg(type, t => isModelType(t), \"model type or model instance\", 1);\n    return {\n        name: type.name,\n        properties: { ...type.properties }\n    };\n}\n/**\n * Returns a reflection of the model node, including name, properties, views, volatile state,\n * and actions. `flowActions` is also provided as a separate array of names for any action that\n * came from a flow generator as well.\n *\n * In the case where a model has two actions: `doSomething` and `doSomethingWithFlow`, where\n * `doSomethingWithFlow` is a flow generator, the `actions` array will contain both actions,\n * i.e. [\"doSomething\", \"doSomethingWithFlow\"], and the `flowActions` array will contain only\n * the flow action, i.e. [\"doSomethingWithFlow\"].\n *\n * @param target\n * @returns\n */\nfunction getMembers(target) {\n    const type = getStateTreeNode(target).type;\n    const reflected = {\n        ...getPropertyMembers(type),\n        actions: [],\n        volatile: [],\n        views: [],\n        flowActions: []\n    };\n    const props = Object.getOwnPropertyNames(target);\n    props.forEach(key => {\n        if (key in reflected.properties) {\n            return;\n        }\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor.get) {\n            if (isComputedProp(target, key)) {\n                reflected.views.push(key);\n            }\n            else {\n                reflected.volatile.push(key);\n            }\n            return;\n        }\n        if (descriptor.value._isFlowAction === true) {\n            reflected.flowActions.push(key);\n        }\n        if (descriptor.value._isMSTAction === true) {\n            reflected.actions.push(key);\n        }\n        else if (isObservableProp(target, key)) {\n            reflected.volatile.push(key);\n        }\n        else {\n            reflected.views.push(key);\n        }\n    });\n    return reflected;\n}\n/**\n * Casts a node snapshot or instance type to an instance type so it can be assigned to a type instance.\n * Note that this is just a cast for the type system, this is, it won't actually convert a snapshot to an instance,\n * but just fool typescript into thinking so.\n * Either way, casting when outside an assignation operation won't compile.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * }).actions(self => ({\n *   someAction() {\n *     // this will allow the compiler to assign a snapshot to the property\n *     self.innerModel = cast({ a: 5 })\n *   }\n * }))\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object cast as an instance\n */\nfunction cast(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a snapshot type so it can be assigned to a type snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * })\n *\n * const a = ModelA.create({ n: 5 });\n * // this will allow the compiler to use a model as if it were a snapshot\n * const b = ModelB.create({ innerModel: castToSnapshot(a)})\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object cast as an input (creation) snapshot\n */\nfunction castToSnapshot(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a reference snapshot type so it can be assigned to a reference snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a reference snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   id: types.identifier,\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   refA: types.reference(ModelA)\n * })\n *\n * const a = ModelA.create({ id: 'someId', n: 5 });\n * // this will allow the compiler to use a model as if it were a reference snapshot\n * const b = ModelB.create({ refA: castToReferenceSnapshot(a)})\n * ```\n *\n * @param instance Instance\n * @returns The same object cast as a reference snapshot (string or number)\n */\nfunction castToReferenceSnapshot(instance) {\n    return instance;\n}\n/**\n * Returns the unique node id (not to be confused with the instance identifier) for a\n * given instance.\n * This id is a number that is unique for each instance.\n *\n * @export\n * @param target\n * @returns\n */\nfunction getNodeId(target) {\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).nodeId;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass BaseNode {\n    type;\n    environment;\n    _escapedSubpath;\n    _subpath;\n    get subpath() {\n        return this._subpath;\n    }\n    _subpathUponDeath;\n    get subpathUponDeath() {\n        return this._subpathUponDeath;\n    }\n    _pathUponDeath;\n    get pathUponDeath() {\n        return this._pathUponDeath;\n    }\n    storedValue; // usually the same type as the value, but not always (such as with references)\n    get value() {\n        return this.type.getValue(this);\n    }\n    aliveAtom;\n    _state = NodeLifeCycle.INITIALIZING;\n    get state() {\n        return this._state;\n    }\n    set state(val) {\n        const wasAlive = this.isAlive;\n        this._state = val;\n        const isAlive = this.isAlive;\n        if (this.aliveAtom && wasAlive !== isAlive) {\n            this.aliveAtom.reportChanged();\n        }\n    }\n    _hookSubscribers;\n    fireInternalHook(name) {\n        if (this._hookSubscribers) {\n            this._hookSubscribers.emit(name, this, name);\n        }\n    }\n    registerHook(hook, hookHandler) {\n        if (!this._hookSubscribers) {\n            this._hookSubscribers = new EventHandlers();\n        }\n        return this._hookSubscribers.register(hook, hookHandler);\n    }\n    _parent;\n    get parent() {\n        return this._parent;\n    }\n    constructor(type, parent, subpath, environment) {\n        this.type = type;\n        this.environment = environment;\n        this.environment = environment;\n        this.baseSetParent(parent, subpath);\n    }\n    getReconciliationType() {\n        return this.type;\n    }\n    pathAtom;\n    baseSetParent(parent, subpath) {\n        this._parent = parent;\n        this._subpath = subpath;\n        this._escapedSubpath = undefined; // regenerate when needed\n        if (this.pathAtom) {\n            this.pathAtom.reportChanged();\n        }\n    }\n    /*\n     * Returns (escaped) path representation as string\n     */\n    get path() {\n        return this.getEscapedPath(true);\n    }\n    getEscapedPath(reportObserved) {\n        if (reportObserved) {\n            if (!this.pathAtom) {\n                this.pathAtom = createAtom(`path`);\n            }\n            this.pathAtom.reportObserved();\n        }\n        if (!this.parent) {\n            return \"\";\n        }\n        // regenerate escaped subpath if needed\n        if (this._escapedSubpath === undefined) {\n            this._escapedSubpath = !this._subpath ? \"\" : escapeJsonPath(this._subpath);\n        }\n        return (this.parent.getEscapedPath(reportObserved) + \"/\" + this._escapedSubpath);\n    }\n    get isRoot() {\n        return this.parent === null;\n    }\n    get isAlive() {\n        return this.state !== NodeLifeCycle.DEAD;\n    }\n    get isDetaching() {\n        return this.state === NodeLifeCycle.DETACHING;\n    }\n    get observableIsAlive() {\n        if (!this.aliveAtom) {\n            this.aliveAtom = createAtom(`alive`);\n        }\n        this.aliveAtom.reportObserved();\n        return this.isAlive;\n    }\n    baseFinalizeCreation(whenFinalized) {\n        if (devMode()) {\n            if (!this.isAlive) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: cannot finalize the creation of a node that is already dead\");\n            }\n        }\n        // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already\n        if (this.state === NodeLifeCycle.CREATED) {\n            if (this.parent) {\n                if (this.parent.state !== NodeLifeCycle.FINALIZED) {\n                    // parent not ready yet, postpone\n                    return;\n                }\n                this.fireHook(Hook.afterAttach);\n            }\n            this.state = NodeLifeCycle.FINALIZED;\n            if (whenFinalized) {\n                whenFinalized();\n            }\n        }\n    }\n    baseFinalizeDeath() {\n        if (this._hookSubscribers) {\n            this._hookSubscribers.clearAll();\n        }\n        this._subpathUponDeath = this._subpath;\n        this._pathUponDeath = this.getEscapedPath(false);\n        this.baseSetParent(null, \"\");\n        this.state = NodeLifeCycle.DEAD;\n    }\n    baseAboutToDie() {\n        this.fireHook(Hook.beforeDestroy);\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nclass ScalarNode extends BaseNode {\n    constructor(simpleType, parent, subpath, environment, initialSnapshot) {\n        super(simpleType, parent, subpath, environment);\n        try {\n            this.storedValue = simpleType.createNewInstance(initialSnapshot);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        this.state = NodeLifeCycle.CREATED;\n        // for scalar nodes there's no point in firing this event since it would fire on the constructor, before\n        // anybody can actually register for/listen to it\n        // this.fireHook(Hook.AfterCreate)\n        this.finalizeCreation();\n    }\n    get root() {\n        // future optimization: store root ref in the node and maintain it\n        if (!this.parent) {\n            throw fail(`This scalar node is not part of a tree`);\n        }\n        return this.parent.root;\n    }\n    setParent(newParent, subpath) {\n        const parentChanged = this.parent !== newParent;\n        const subpathChanged = this.subpath !== subpath;\n        if (!parentChanged && !subpathChanged) {\n            return;\n        }\n        if (devMode()) {\n            if (!subpath) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: subpath expected\");\n            }\n            if (!newParent) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: parent expected\");\n            }\n            if (parentChanged) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: scalar nodes cannot change their parent\");\n            }\n        }\n        this.environment = undefined; // use parent's\n        this.baseSetParent(this.parent, subpath);\n    }\n    get snapshot() {\n        return freeze(this.getSnapshot());\n    }\n    getSnapshot() {\n        return this.type.getSnapshot(this);\n    }\n    toString() {\n        const path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n        return `${this.type.name}@${path}${this.isAlive ? \"\" : \" [dead]\"}`;\n    }\n    die() {\n        if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) {\n            return;\n        }\n        this.aboutToDie();\n        this.finalizeDeath();\n    }\n    finalizeCreation() {\n        this.baseFinalizeCreation();\n    }\n    aboutToDie() {\n        this.baseAboutToDie();\n    }\n    finalizeDeath() {\n        this.baseFinalizeDeath();\n    }\n    fireHook(name) {\n        this.fireInternalHook(name);\n    }\n}\nScalarNode.prototype.die = action(ScalarNode.prototype.die);\n\n// noinspection ES6UnusedImports\nlet nextNodeId = 1;\nconst snapshotReactionOptions = {\n    onError(e) {\n        throw e;\n    }\n};\n/**\n * @internal\n * @hidden\n */\nclass ObjectNode extends BaseNode {\n    nodeId = ++nextNodeId;\n    identifierAttribute;\n    identifier; // Identifier is always normalized to string, even if the identifier property isn't\n    unnormalizedIdentifier;\n    identifierCache;\n    isProtectionEnabled = true;\n    middlewares;\n    hasSnapshotPostProcessor = false;\n    _applyPatches;\n    applyPatches(patches) {\n        this.createObservableInstanceIfNeeded();\n        this._applyPatches(patches);\n    }\n    _applySnapshot;\n    applySnapshot(snapshot) {\n        this.createObservableInstanceIfNeeded();\n        this._applySnapshot(snapshot);\n    }\n    _autoUnbox = true; // unboxing is disabled when reading child nodes\n    _isRunningAction = false; // only relevant for root\n    _hasSnapshotReaction = false;\n    _observableInstanceState = 0 /* ObservableInstanceLifecycle.UNINITIALIZED */;\n    _childNodes;\n    _initialSnapshot;\n    _cachedInitialSnapshot;\n    _cachedInitialSnapshotCreated = false;\n    _snapshotComputed;\n    constructor(complexType, parent, subpath, environment, initialValue) {\n        super(complexType, parent, subpath, environment);\n        this._snapshotComputed = computed(() => freeze(this.getSnapshot()));\n        this.unbox = this.unbox.bind(this);\n        this._initialSnapshot = freeze(initialValue);\n        this.identifierAttribute = complexType.identifierAttribute;\n        if (!parent) {\n            this.identifierCache = new IdentifierCache();\n        }\n        this._childNodes = complexType.initializeChildNodes(this, this._initialSnapshot);\n        // identifier can not be changed during lifecycle of a node\n        // so we safely can read it from initial snapshot\n        this.identifier = null;\n        this.unnormalizedIdentifier = null;\n        if (this.identifierAttribute && this._initialSnapshot) {\n            let id = this._initialSnapshot[this.identifierAttribute];\n            if (id === undefined) {\n                // try with the actual node if not (for optional identifiers)\n                const childNode = this._childNodes[this.identifierAttribute];\n                if (childNode) {\n                    id = childNode.value;\n                }\n            }\n            if (typeof id !== \"string\" && typeof id !== \"number\") {\n                throw fail(`Instance identifier '${this.identifierAttribute}' for type '${this.type.name}' must be a string or a number`);\n            }\n            // normalize internal identifier to string\n            this.identifier = normalizeIdentifier(id);\n            this.unnormalizedIdentifier = id;\n        }\n        if (!parent) {\n            this.identifierCache.addNodeToCache(this);\n        }\n        else {\n            parent.root.identifierCache.addNodeToCache(this);\n        }\n    }\n    createObservableInstanceIfNeeded(fireHooks = true) {\n        if (this._observableInstanceState ===\n            0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            this.createObservableInstance(fireHooks);\n        }\n    }\n    createObservableInstance(fireHooks = true) {\n        if (devMode()) {\n            if (this.state !== NodeLifeCycle.INITIALIZING) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: the creation of the observable instance must be done on the initializing phase\");\n            }\n        }\n        this._observableInstanceState = 1 /* ObservableInstanceLifecycle.CREATING */;\n        // make sure the parent chain is created as well\n        // array with parent chain from parent to child\n        const parentChain = [];\n        let parent = this.parent;\n        // for performance reasons we never go back further than the most direct\n        // uninitialized parent\n        // this is done to avoid traversing the whole tree to the root when using\n        // the same reference again\n        while (parent &&\n            parent._observableInstanceState ===\n                0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            parentChain.unshift(parent);\n            parent = parent.parent;\n        }\n        // initialize the uninitialized parent chain from parent to child\n        for (const p of parentChain) {\n            // delay firing hooks until after all parents have been created\n            p.createObservableInstanceIfNeeded(false);\n        }\n        const type = this.type;\n        try {\n            // @ts-expect-error\n            this.storedValue = type.createNewInstance(this._childNodes);\n            this.preboot();\n            this._isRunningAction = true;\n            type.finalizeNewInstance(this, this.storedValue);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        finally {\n            this._isRunningAction = false;\n        }\n        this._observableInstanceState = 2 /* ObservableInstanceLifecycle.CREATED */;\n        this._snapshotComputed.trackAndCompute();\n        if (this.isRoot) {\n            this._addSnapshotReaction();\n        }\n        this._childNodes = EMPTY_OBJECT;\n        this.state = NodeLifeCycle.CREATED;\n        if (fireHooks) {\n            this.fireHook(Hook.afterCreate);\n            // Note that the parent might not be finalized at this point\n            // so afterAttach won't be called until later in that case\n            this.finalizeCreation();\n            // fire the hooks of the parents that we created\n            for (const p of parentChain.reverse()) {\n                p.fireHook(Hook.afterCreate);\n                // This will call afterAttach on the child if necessary\n                p.finalizeCreation();\n            }\n        }\n    }\n    get root() {\n        const parent = this.parent;\n        return parent ? parent.root : this;\n    }\n    clearParent() {\n        if (!this.parent) {\n            return;\n        }\n        // detach if attached\n        this.fireHook(Hook.beforeDetach);\n        const previousState = this.state;\n        this.state = NodeLifeCycle.DETACHING;\n        const root = this.root;\n        const newEnv = root.environment;\n        const newIdCache = root.identifierCache.splitCache(this);\n        try {\n            this.parent.removeChild(this.subpath);\n            this.baseSetParent(null, \"\");\n            this.environment = newEnv;\n            this.identifierCache = newIdCache;\n        }\n        finally {\n            this.state = previousState;\n        }\n    }\n    setParent(newParent, subpath) {\n        const parentChanged = newParent !== this.parent;\n        const subpathChanged = subpath !== this.subpath;\n        if (!parentChanged && !subpathChanged) {\n            return;\n        }\n        if (devMode()) {\n            if (!subpath) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: subpath expected\");\n            }\n            if (!newParent) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: new parent expected\");\n            }\n            if (this.parent && parentChanged) {\n                throw fail(`A node cannot exists twice in the state tree. Failed to add ${this} to path '${newParent.path}/${subpath}'.`);\n            }\n            if (!this.parent && newParent.root === this) {\n                throw fail(`A state tree is not allowed to contain itself. Cannot assign ${this} to path '${newParent.path}/${subpath}'`);\n            }\n            if (!this.parent &&\n                !!this.environment &&\n                this.environment !== newParent.root.environment) {\n                throw fail(`A state tree cannot be made part of another state tree as long as their environments are different.`);\n            }\n        }\n        if (parentChanged) {\n            // attach to new parent\n            this.environment = undefined; // will use root's\n            newParent.root.identifierCache.mergeCache(this);\n            this.baseSetParent(newParent, subpath);\n            this.fireHook(Hook.afterAttach);\n        }\n        else if (subpathChanged) {\n            // moving to a new subpath on the same parent\n            this.baseSetParent(this.parent, subpath);\n        }\n    }\n    fireHook(name) {\n        this.fireInternalHook(name);\n        const fn = this.storedValue &&\n            typeof this.storedValue === \"object\" &&\n            this.storedValue[name];\n        if (typeof fn === \"function\") {\n            // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)\n            if (_allowStateChangesInsideComputed) {\n                _allowStateChangesInsideComputed(() => {\n                    fn.apply(this.storedValue);\n                });\n            }\n            else {\n                fn.apply(this.storedValue);\n            }\n        }\n    }\n    _snapshotUponDeath;\n    // advantage of using computed for a snapshot is that nicely respects transactions etc.\n    get snapshot() {\n        if (this.hasSnapshotPostProcessor) {\n            this.createObservableInstanceIfNeeded();\n        }\n        return this._snapshotComputed.get();\n    }\n    // NOTE: we use this method to get snapshot without creating @computed overhead\n    getSnapshot() {\n        if (!this.isAlive) {\n            return this._snapshotUponDeath;\n        }\n        return this._observableInstanceState === 2 /* ObservableInstanceLifecycle.CREATED */\n            ? this._getActualSnapshot()\n            : this._getCachedInitialSnapshot();\n    }\n    _getActualSnapshot() {\n        return this.type.getSnapshot(this);\n    }\n    _getCachedInitialSnapshot() {\n        if (!this._cachedInitialSnapshotCreated) {\n            const type = this.type;\n            const childNodes = this._childNodes;\n            const snapshot = this._initialSnapshot;\n            this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);\n            this._cachedInitialSnapshotCreated = true;\n        }\n        return this._cachedInitialSnapshot;\n    }\n    isRunningAction() {\n        if (this._isRunningAction) {\n            return true;\n        }\n        if (this.isRoot) {\n            return false;\n        }\n        return this.parent.isRunningAction();\n    }\n    assertAlive(context) {\n        const livelinessChecking = getLivelinessChecking();\n        if (!this.isAlive && livelinessChecking !== \"ignore\") {\n            const error = this._getAssertAliveError(context);\n            switch (livelinessChecking) {\n                case \"error\":\n                    throw fail(error);\n                case \"warn\":\n                    warnError(error);\n            }\n        }\n    }\n    _getAssertAliveError(context) {\n        const escapedPath = this.getEscapedPath(false) || this.pathUponDeath || \"\";\n        const subpath = (context.subpath && escapeJsonPath(context.subpath)) || \"\";\n        let actionContext = context.actionContext || getCurrentActionContext();\n        // try to use a real action context if possible since it includes the action name\n        if (actionContext &&\n            actionContext.type !== \"action\" &&\n            actionContext.parentActionEvent) {\n            actionContext = actionContext.parentActionEvent;\n        }\n        let actionFullPath = \"\";\n        if (actionContext && actionContext.name != null) {\n            // try to use the context, and if it not available use the node one\n            const actionPath = (actionContext &&\n                actionContext.context &&\n                getPath(actionContext.context)) ||\n                escapedPath;\n            actionFullPath = `${actionPath}.${actionContext.name}()`;\n        }\n        return `You are trying to read or write to an object that is no longer part of a state tree. (Object type: '${this.type.name}', Path upon death: '${escapedPath}', Subpath: '${subpath}', Action: '${actionFullPath}'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.`;\n    }\n    getChildNode(subpath) {\n        this.assertAlive({\n            subpath\n        });\n        this._autoUnbox = false;\n        try {\n            return this._observableInstanceState ===\n                2 /* ObservableInstanceLifecycle.CREATED */\n                ? this.type.getChildNode(this, subpath)\n                : this._childNodes[subpath];\n        }\n        finally {\n            this._autoUnbox = true;\n        }\n    }\n    getChildren() {\n        this.assertAlive(EMPTY_OBJECT);\n        this._autoUnbox = false;\n        try {\n            return this._observableInstanceState ===\n                2 /* ObservableInstanceLifecycle.CREATED */\n                ? this.type.getChildren(this)\n                : convertChildNodesToArray(this._childNodes);\n        }\n        finally {\n            this._autoUnbox = true;\n        }\n    }\n    getChildType(propertyName) {\n        return this.type.getChildType(propertyName);\n    }\n    get isProtected() {\n        return this.root.isProtectionEnabled;\n    }\n    assertWritable(context) {\n        this.assertAlive(context);\n        if (!this.isRunningAction() && this.isProtected) {\n            throw fail(`Cannot modify '${this}', the object is protected and can only be modified by using an action.`);\n        }\n    }\n    removeChild(subpath) {\n        this.type.removeChild(this, subpath);\n    }\n    // bound on the constructor\n    unbox(childNode) {\n        if (!childNode) {\n            return childNode;\n        }\n        this.assertAlive({\n            subpath: childNode.subpath || childNode.subpathUponDeath\n        });\n        return this._autoUnbox ? childNode.value : childNode;\n    }\n    toString() {\n        const path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n        const identifier = this.identifier ? `(id: ${this.identifier})` : \"\";\n        return `${this.type.name}@${path}${identifier}${this.isAlive ? \"\" : \" [dead]\"}`;\n    }\n    finalizeCreation() {\n        this.baseFinalizeCreation(() => {\n            for (const child of this.getChildren()) {\n                child.finalizeCreation();\n            }\n            this.fireInternalHook(Hook.afterCreationFinalization);\n        });\n    }\n    detach() {\n        if (!this.isAlive) {\n            throw fail(`Error while detaching, node is not alive.`);\n        }\n        this.clearParent();\n    }\n    preboot() {\n        const self = this;\n        this._applyPatches = createActionInvoker(this.storedValue, \"@APPLY_PATCHES\", (patches) => {\n            patches.forEach(patch => {\n                if (!patch.path) {\n                    self.type.applySnapshot(self, patch.value);\n                    return;\n                }\n                const parts = splitJsonPath(patch.path);\n                const node = resolveNodeByPathParts(self, parts.slice(0, -1));\n                node.applyPatchLocally(parts[parts.length - 1], patch);\n            });\n        });\n        this._applySnapshot = createActionInvoker(this.storedValue, \"@APPLY_SNAPSHOT\", (snapshot) => {\n            // if the snapshot is the same as the current one, avoid performing a reconcile\n            if (snapshot === self.snapshot) {\n                return;\n            }\n            // else, apply it by calling the type logic\n            return self.type.applySnapshot(self, snapshot);\n        });\n        addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n        addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON);\n    }\n    die() {\n        if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) {\n            return;\n        }\n        this.aboutToDie();\n        this.finalizeDeath();\n    }\n    aboutToDie() {\n        if (this._observableInstanceState ===\n            0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            return;\n        }\n        this.getChildren().forEach(node => {\n            node.aboutToDie();\n        });\n        // beforeDestroy should run before the disposers since else we could end up in a situation where\n        // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released\n        this.baseAboutToDie();\n        this._internalEventsEmit(\"dispose\" /* InternalEvents.Dispose */);\n        this._internalEventsClear(\"dispose\" /* InternalEvents.Dispose */);\n    }\n    finalizeDeath() {\n        // invariant: not called directly but from \"die\"\n        this.getChildren().forEach(node => {\n            node.finalizeDeath();\n        });\n        this.root.identifierCache.notifyDied(this);\n        // \"kill\" the computed prop and just store the last snapshot\n        const snapshot = this.snapshot;\n        this._snapshotUponDeath = snapshot;\n        this._internalEventsClearAll();\n        this.baseFinalizeDeath();\n    }\n    onSnapshot(onChange) {\n        this._addSnapshotReaction();\n        return this._internalEventsRegister(\"snapshot\" /* InternalEvents.Snapshot */, onChange);\n    }\n    emitSnapshot(snapshot) {\n        this._internalEventsEmit(\"snapshot\" /* InternalEvents.Snapshot */, snapshot);\n    }\n    onPatch(handler) {\n        return this._internalEventsRegister(\"patch\" /* InternalEvents.Patch */, handler);\n    }\n    emitPatch(basePatch, source) {\n        if (this._internalEventsHasSubscribers(\"patch\" /* InternalEvents.Patch */)) {\n            const localizedPatch = extend({}, basePatch, {\n                path: source.path.substr(this.path.length) + \"/\" + basePatch.path // calculate the relative path of the patch\n            });\n            const [patch, reversePatch] = splitPatch(localizedPatch);\n            this._internalEventsEmit(\"patch\" /* InternalEvents.Patch */, patch, reversePatch);\n        }\n        if (this.parent) {\n            this.parent.emitPatch(basePatch, source);\n        }\n    }\n    hasDisposer(disposer) {\n        return this._internalEventsHas(\"dispose\" /* InternalEvents.Dispose */, disposer);\n    }\n    addDisposer(disposer) {\n        if (!this.hasDisposer(disposer)) {\n            this._internalEventsRegister(\"dispose\" /* InternalEvents.Dispose */, disposer, true);\n            return;\n        }\n        throw fail(\"cannot add a disposer when it is already registered for execution\");\n    }\n    removeDisposer(disposer) {\n        if (!this._internalEventsHas(\"dispose\" /* InternalEvents.Dispose */, disposer)) {\n            throw fail(\"cannot remove a disposer which was never registered for execution\");\n        }\n        this._internalEventsUnregister(\"dispose\" /* InternalEvents.Dispose */, disposer);\n    }\n    removeMiddleware(middleware) {\n        if (this.middlewares) {\n            const index = this.middlewares.indexOf(middleware);\n            if (index >= 0) {\n                this.middlewares.splice(index, 1);\n            }\n        }\n    }\n    addMiddleWare(handler, includeHooks = true) {\n        const middleware = { handler, includeHooks };\n        if (!this.middlewares) {\n            this.middlewares = [middleware];\n        }\n        else {\n            this.middlewares.push(middleware);\n        }\n        return () => {\n            this.removeMiddleware(middleware);\n        };\n    }\n    applyPatchLocally(subpath, patch) {\n        this.assertWritable({\n            subpath\n        });\n        this.createObservableInstanceIfNeeded();\n        this.type.applyPatchLocally(this, subpath, patch);\n    }\n    _addSnapshotReaction() {\n        if (!this._hasSnapshotReaction) {\n            const snapshotDisposer = reaction(() => this.snapshot, snapshot => this.emitSnapshot(snapshot), snapshotReactionOptions);\n            this.addDisposer(snapshotDisposer);\n            this._hasSnapshotReaction = true;\n        }\n    }\n    // #region internal event handling\n    _internalEvents;\n    // we proxy the methods to avoid creating an EventHandlers instance when it is not needed\n    _internalEventsHasSubscribers(event) {\n        return !!this._internalEvents && this._internalEvents.hasSubscribers(event);\n    }\n    _internalEventsRegister(event, eventHandler, atTheBeginning = false) {\n        if (!this._internalEvents) {\n            this._internalEvents = new EventHandlers();\n        }\n        return this._internalEvents.register(event, eventHandler, atTheBeginning);\n    }\n    _internalEventsHas(event, eventHandler) {\n        return (!!this._internalEvents && this._internalEvents.has(event, eventHandler));\n    }\n    _internalEventsUnregister(event, eventHandler) {\n        if (this._internalEvents) {\n            this._internalEvents.unregister(event, eventHandler);\n        }\n    }\n    _internalEventsEmit(event, ...args) {\n        if (this._internalEvents) {\n            this._internalEvents.emit(event, ...args);\n        }\n    }\n    _internalEventsClear(event) {\n        if (this._internalEvents) {\n            this._internalEvents.clear(event);\n        }\n    }\n    _internalEventsClearAll() {\n        if (this._internalEvents) {\n            this._internalEvents.clearAll();\n        }\n    }\n}\nObjectNode.prototype.createObservableInstance = action(ObjectNode.prototype.createObservableInstance);\nObjectNode.prototype.detach = action(ObjectNode.prototype.detach);\nObjectNode.prototype.die = action(ObjectNode.prototype.die);\n\n// Cache for validation results to avoid re-validating the same object against the same type\n// Uses WeakMap so cached objects can be garbage collected\nconst validationCache = new WeakMap();\n/**\n * @internal\n * @hidden\n */\nvar TypeFlags;\n(function (TypeFlags) {\n    TypeFlags[TypeFlags[\"String\"] = 1] = \"String\";\n    TypeFlags[TypeFlags[\"Number\"] = 2] = \"Number\";\n    TypeFlags[TypeFlags[\"Boolean\"] = 4] = \"Boolean\";\n    TypeFlags[TypeFlags[\"Date\"] = 8] = \"Date\";\n    TypeFlags[TypeFlags[\"Literal\"] = 16] = \"Literal\";\n    TypeFlags[TypeFlags[\"Array\"] = 32] = \"Array\";\n    TypeFlags[TypeFlags[\"Map\"] = 64] = \"Map\";\n    TypeFlags[TypeFlags[\"Object\"] = 128] = \"Object\";\n    TypeFlags[TypeFlags[\"Frozen\"] = 256] = \"Frozen\";\n    TypeFlags[TypeFlags[\"Optional\"] = 512] = \"Optional\";\n    TypeFlags[TypeFlags[\"Reference\"] = 1024] = \"Reference\";\n    TypeFlags[TypeFlags[\"Identifier\"] = 2048] = \"Identifier\";\n    TypeFlags[TypeFlags[\"Late\"] = 4096] = \"Late\";\n    TypeFlags[TypeFlags[\"Refinement\"] = 8192] = \"Refinement\";\n    TypeFlags[TypeFlags[\"Union\"] = 16384] = \"Union\";\n    TypeFlags[TypeFlags[\"Null\"] = 32768] = \"Null\";\n    TypeFlags[TypeFlags[\"Undefined\"] = 65536] = \"Undefined\";\n    TypeFlags[TypeFlags[\"Integer\"] = 131072] = \"Integer\";\n    TypeFlags[TypeFlags[\"Custom\"] = 262144] = \"Custom\";\n    TypeFlags[TypeFlags[\"SnapshotProcessor\"] = 524288] = \"SnapshotProcessor\";\n    TypeFlags[TypeFlags[\"Lazy\"] = 1048576] = \"Lazy\";\n    TypeFlags[TypeFlags[\"Finite\"] = 2097152] = \"Finite\";\n    TypeFlags[TypeFlags[\"Float\"] = 4194304] = \"Float\";\n})(TypeFlags || (TypeFlags = {}));\n/**\n * @internal\n * @hidden\n */\nconst cannotDetermineSubtype = \"cannotDetermine\";\n/** @hidden */\nconst $type = Symbol(\"$type\");\n/**\n * A base type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nclass BaseType {\n    [$type];\n    // these are just to make inner types avaialable to inherited classes\n    C;\n    S;\n    T;\n    N;\n    isType = true;\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n    create(snapshot, environment) {\n        typecheckInternal(this, snapshot);\n        return this.instantiate(null, \"\", environment, snapshot).value;\n    }\n    getSnapshot(node, applyPostProcess) {\n        // istanbul ignore next\n        throw fail(\"unimplemented method\");\n    }\n    isAssignableFrom(type) {\n        return type === this;\n    }\n    validate(value, context) {\n        const node = getStateTreeNodeSafe(value);\n        if (node) {\n            const valueType = getType(value);\n            return this.isAssignableFrom(valueType)\n                ? typeCheckSuccess()\n                : typeCheckFailure(context, value);\n            // it is tempting to compare snapshots, but in that case we should always clone on assignments...\n        }\n        // check cache for object values (only at root level to avoid context mismatches)\n        if (typeof value === \"object\" && value !== null && context.length === 1) {\n            const typeCache = validationCache.get(value);\n            if (typeCache) {\n                const cached = typeCache.get(this);\n                if (cached !== undefined) {\n                    return cached;\n                }\n            }\n        }\n        const result = this.isValidSnapshot(value, context);\n        // cache result for object values (only at root level)\n        if (typeof value === \"object\" && value !== null && context.length === 1) {\n            let typeCache = validationCache.get(value);\n            if (!typeCache) {\n                typeCache = new WeakMap();\n                validationCache.set(value, typeCache);\n            }\n            typeCache.set(this, result);\n        }\n        return result;\n    }\n    is(thing) {\n        return this.validate(thing, [{ path: \"\", type: this }]).length === 0;\n    }\n    get Type() {\n        // istanbul ignore next\n        throw fail(\"Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`\");\n    }\n    get TypeWithoutSTN() {\n        // istanbul ignore next\n        throw fail(\"Factory.TypeWithoutSTN should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.TypeWithoutSTN`\");\n    }\n    get SnapshotType() {\n        // istanbul ignore next\n        throw fail(\"Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`\");\n    }\n    get CreationType() {\n        // istanbul ignore next\n        throw fail(\"Factory.CreationType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.CreationType`\");\n    }\n}\nBaseType.prototype.create = action(BaseType.prototype.create);\n/**\n * A complex type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nclass ComplexType extends BaseType {\n    identifierAttribute;\n    constructor(name) {\n        super(name);\n    }\n    create(snapshot = this.getDefaultSnapshot(), environment) {\n        return super.create(snapshot, environment);\n    }\n    getValue(node) {\n        node.createObservableInstanceIfNeeded();\n        return node.storedValue;\n    }\n    isMatchingSnapshotId(current, snapshot) {\n        return (!current.identifierAttribute ||\n            current.identifier ===\n                normalizeIdentifier(snapshot[current.identifierAttribute]));\n    }\n    tryToReconcileNode(current, newValue) {\n        if (current.isDetaching) {\n            return false;\n        }\n        if (current.snapshot === newValue) {\n            // newValue is the current snapshot of the node, noop\n            return true;\n        }\n        if (isStateTreeNode(newValue) && getStateTreeNode(newValue) === current) {\n            // the current node is the same as the new one\n            return true;\n        }\n        if (current.type === this &&\n            isMutable(newValue) &&\n            !isStateTreeNode(newValue) &&\n            this.isMatchingSnapshotId(current, newValue)) {\n            // the newValue has no node, so can be treated like a snapshot\n            // we can reconcile\n            current.applySnapshot(newValue);\n            return true;\n        }\n        return false;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const nodeReconciled = this.tryToReconcileNode(current, newValue);\n        if (nodeReconciled) {\n            current.setParent(parent, subpath);\n            return current;\n        }\n        // current node cannot be recycled in any way\n        current.die(); // noop if detaching\n        // attempt to reuse the new one\n        if (isStateTreeNode(newValue) && this.isAssignableFrom(getType(newValue))) {\n            // newValue is a Node as well, move it here..\n            const newNode = getStateTreeNode(newValue);\n            newNode.setParent(parent, subpath);\n            return newNode;\n        }\n        // nothing to do, we have to create a new node\n        return this.instantiate(parent, subpath, undefined, newValue);\n    }\n    getSubTypes() {\n        return null;\n    }\n}\nComplexType.prototype.create = action(ComplexType.prototype.create);\n/**\n * @internal\n * @hidden\n */\nclass SimpleType extends BaseType {\n    createNewInstance(snapshot) {\n        return snapshot;\n    }\n    getValue(node) {\n        // if we ever find a case where scalar nodes can be accessed without iterating through its parent\n        // uncomment this to make sure the parent chain is created when this is accessed\n        // if (node.parent) {\n        //     node.parent.createObservableInstanceIfNeeded()\n        // }\n        return node.storedValue;\n    }\n    getSnapshot(node) {\n        return node.storedValue;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        // reconcile only if type and value are still the same, and only if the node is not detaching\n        if (!current.isDetaching &&\n            current.type === this &&\n            current.storedValue === newValue) {\n            return current;\n        }\n        const res = this.instantiate(parent, subpath, undefined, newValue);\n        current.die(); // noop if detaching\n        return res;\n    }\n    getSubTypes() {\n        return null;\n    }\n}\n/**\n * Returns if a given value represents a type.\n *\n * @param value Value to check.\n * @returns `true` if the value is a type.\n */\nfunction isType(value) {\n    return typeof value === \"object\" && value && value.isType === true;\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsType(type, argNumber) {\n    assertArg(type, isType, \"mobx-state-tree type\", argNumber);\n}\n\nconst runningActions = new Map();\n/**\n * Note: Consider migrating to `createActionTrackingMiddleware2`, it is easier to use.\n *\n * Convenience utility to create action based middleware that supports async processes more easily.\n * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called\n *\n * The create middleware tracks the process of an action (assuming it passes the `filter`).\n * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware(hooks) {\n    return function actionTrackingMiddleware(call, next, abort) {\n        switch (call.type) {\n            case \"action\": {\n                if (!hooks.filter || hooks.filter(call) === true) {\n                    const context = hooks.onStart(call);\n                    hooks.onResume(call, context);\n                    runningActions.set(call.id, {\n                        call,\n                        context,\n                        async: false\n                    });\n                    try {\n                        const res = next(call);\n                        hooks.onSuspend(call, context);\n                        if (runningActions.get(call.id).async === false) {\n                            runningActions.delete(call.id);\n                            hooks.onSuccess(call, context, res);\n                        }\n                        return res;\n                    }\n                    catch (e) {\n                        runningActions.delete(call.id);\n                        hooks.onFail(call, context, e);\n                        throw e;\n                    }\n                }\n                else {\n                    return next(call);\n                }\n            }\n            case \"flow_spawn\": {\n                const root = runningActions.get(call.rootId);\n                root.async = true;\n                return next(call);\n            }\n            case \"flow_resume\":\n            case \"flow_resume_error\": {\n                const root = runningActions.get(call.rootId);\n                hooks.onResume(call, root.context);\n                try {\n                    return next(call);\n                }\n                finally {\n                    hooks.onSuspend(call, root.context);\n                }\n            }\n            case \"flow_throw\": {\n                const root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onFail(call, root.context, call.args[0]);\n                return next(call);\n            }\n            case \"flow_return\": {\n                const root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onSuccess(call, root.context, call.args[0]);\n                return next(call);\n            }\n        }\n    };\n}\n\nclass RunningAction {\n    hooks;\n    call;\n    flowsPending = 0;\n    running = true;\n    constructor(hooks, call) {\n        this.hooks = hooks;\n        this.call = call;\n        if (hooks) {\n            hooks.onStart(call);\n        }\n    }\n    finish(error) {\n        if (this.running) {\n            this.running = false;\n            if (this.hooks) {\n                this.hooks.onFinish(this.call, error);\n            }\n        }\n    }\n    incFlowsPending() {\n        this.flowsPending++;\n    }\n    decFlowsPending() {\n        this.flowsPending--;\n    }\n    get hasFlowsPending() {\n        return this.flowsPending > 0;\n    }\n}\n/**\n * Convenience utility to create action based middleware that supports async processes more easily.\n * The flow is like this:\n * - for each action: if filter passes -> `onStart` -> (inner actions recursively) -> `onFinish`\n *\n * Example: if we had an action `a` that called inside an action `b1`, then `b2` the flow would be:\n * - `filter(a)`\n * - `onStart(a)`\n *   - `filter(b1)`\n *   - `onStart(b1)`\n *   - `onFinish(b1)`\n *   - `filter(b2)`\n *   - `onStart(b2)`\n *   - `onFinish(b2)`\n * - `onFinish(a)`\n *\n * The flow is the same no matter if the actions are sync or async.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware2(middlewareHooks) {\n    const runningActions = new Map();\n    return function actionTrackingMiddleware(call, next) {\n        // find parentRunningAction\n        const parentRunningAction = call.parentActionEvent\n            ? runningActions.get(call.parentActionEvent.id)\n            : undefined;\n        if (call.type === \"action\") {\n            const newCall = {\n                ...call,\n                // make a shallow copy of the parent action env\n                env: parentRunningAction && parentRunningAction.call.env,\n                parentCall: parentRunningAction && parentRunningAction.call\n            };\n            const passesFilter = !middlewareHooks.filter || middlewareHooks.filter(newCall);\n            const hooks = passesFilter ? middlewareHooks : undefined;\n            const runningAction = new RunningAction(hooks, newCall);\n            runningActions.set(call.id, runningAction);\n            let res;\n            try {\n                res = next(call);\n            }\n            catch (e) {\n                runningActions.delete(call.id);\n                runningAction.finish(e);\n                throw e;\n            }\n            // sync action finished\n            if (!runningAction.hasFlowsPending) {\n                runningActions.delete(call.id);\n                runningAction.finish();\n            }\n            return res;\n        }\n        else {\n            if (!parentRunningAction) {\n                return next(call);\n            }\n            switch (call.type) {\n                case \"flow_spawn\": {\n                    parentRunningAction.incFlowsPending();\n                    return next(call);\n                }\n                case \"flow_resume\":\n                case \"flow_resume_error\": {\n                    return next(call);\n                }\n                case \"flow_throw\": {\n                    const error = call.args[0];\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            runningActions.delete(call.parentActionEvent.id);\n                            parentRunningAction.finish(error);\n                        }\n                    }\n                }\n                case \"flow_return\": {\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            runningActions.delete(call.parentActionEvent.id);\n                            parentRunningAction.finish();\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\n\nfunction serializeArgument(node, actionName, index, arg) {\n    if (arg instanceof Date) {\n        return { $MST_DATE: arg.getTime() };\n    }\n    if (isPrimitive(arg)) {\n        return arg;\n    }\n    // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an\n    // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot\n    if (isStateTreeNode(arg)) {\n        return serializeTheUnserializable(`[MSTNode: ${getType(arg).name}]`);\n    }\n    if (typeof arg === \"function\") {\n        return serializeTheUnserializable(`[function]`);\n    }\n    if (typeof arg === \"object\" && !isPlainObject(arg) && !isArray(arg)) {\n        return serializeTheUnserializable(`[object ${(arg && arg.constructor && arg.constructor.name) ||\n            \"Complex Object\"}]`);\n    }\n    try {\n        // Check if serializable, cycle free etc...\n        // MWE: there must be a better way....\n        JSON.stringify(arg); // or throws\n        return arg;\n    }\n    catch (e) {\n        return serializeTheUnserializable(\"\" + e);\n    }\n}\nfunction deserializeArgument(adm, value) {\n    if (value && typeof value === \"object\" && \"$MST_DATE\" in value) {\n        return new Date(value[\"$MST_DATE\"]);\n    }\n    return value;\n}\nfunction serializeTheUnserializable(baseType) {\n    return {\n        $MST_UNSERIALIZABLE: true,\n        type: baseType\n    };\n}\n/**\n * Applies an action or a series of actions in a single MobX transaction.\n * Does not return any value\n * Takes an action description as produced by the `onAction` middleware.\n *\n * @param target\n * @param actions\n */\nfunction applyAction(target, actions) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(actions, a => typeof a === \"object\", \"object or array\", 2);\n    runInAction(() => {\n        asArray(actions).forEach(action => baseApplyAction(target, action));\n    });\n}\nfunction baseApplyAction(target, action) {\n    const resolvedTarget = tryResolve(target, action.path || \"\");\n    if (!resolvedTarget) {\n        throw fail(`Invalid action path: ${action.path || \"\"}`);\n    }\n    const node = getStateTreeNode(resolvedTarget);\n    // Reserved functions\n    if (action.name === \"@APPLY_PATCHES\") {\n        return applyPatch.call(null, resolvedTarget, action.args[0]);\n    }\n    if (action.name === \"@APPLY_SNAPSHOT\") {\n        return applySnapshot.call(null, resolvedTarget, action.args[0]);\n    }\n    if (!(typeof resolvedTarget[action.name] === \"function\")) {\n        throw fail(`Action '${action.name}' does not exist in '${node.path}'`);\n    }\n    return resolvedTarget[action.name].apply(resolvedTarget, action.args ? action.args.map(v => deserializeArgument(node, v)) : []);\n}\n/**\n * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IActionRecorder {\n *      // the recorded actions\n *      actions: ISerializedActionCall[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording actions\n *      stop(): void\n *      // resume recording actions\n *      resume(): void\n *      // apply all the recorded actions on the given object\n *      replay(target: IAnyStateTreeNode): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain actions.\n *\n * @param subject\n * @returns\n */\nfunction recordActions(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    const actions = [];\n    const listener = (call) => {\n        const recordThis = filter ? filter(call, getRunningActionContext()) : true;\n        if (recordThis) {\n            actions.push(call);\n        }\n    };\n    let disposer;\n    const recorder = {\n        actions,\n        get recording() {\n            return !!disposer;\n        },\n        stop() {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume() {\n            if (disposer) {\n                return;\n            }\n            disposer = onAction(subject, listener);\n        },\n        replay(target) {\n            applyAction(target, actions);\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.\n * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.\n * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.\n *\n * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: \"someType\" }` will be generated.\n * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).\n * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * }).actions(self => ({\n *   add(todo) {\n *     self.todos.push(todo);\n *   }\n * }))\n *\n * const s = TodoStore.create({ todos: [] })\n *\n * let disposer = onAction(s, (call) => {\n *   console.log(call);\n * })\n *\n * s.add({ task: \"Grab a coffee\" })\n * // Logs: { name: \"add\", path: \"\", args: [{ task: \"Grab a coffee\" }] }\n * ```\n *\n * @param target\n * @param listener\n * @param attachAfter (default false) fires the listener *after* the action has executed instead of before.\n * @returns\n */\nfunction onAction(target, listener, attachAfter = false) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    if (devMode()) {\n        if (!isRoot(target)) {\n            warnError(\"Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.\");\n        }\n        if (!isProtected(target)) {\n            warnError(\"Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.\");\n        }\n    }\n    return addMiddleware(target, function handler(rawCall, next) {\n        if (rawCall.type === \"action\" && rawCall.id === rawCall.rootId) {\n            const sourceNode = getStateTreeNode(rawCall.context);\n            const info = {\n                name: rawCall.name,\n                path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode),\n                args: rawCall.args.map((arg, index) => serializeArgument(sourceNode, rawCall.name, index, arg))\n            };\n            if (attachAfter) {\n                const res = next(rawCall);\n                listener(info);\n                return res;\n            }\n            else {\n                listener(info);\n                return next(rawCall);\n            }\n        }\n        else {\n            return next(rawCall);\n        }\n    });\n}\n\nlet nextActionId = 1;\nlet currentActionContext;\n/**\n * @internal\n * @hidden\n */\nfunction getCurrentActionContext() {\n    return currentActionContext;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getNextActionId() {\n    return nextActionId++;\n}\n// TODO: optimize away entire action context if there is no middleware in tree?\n/**\n * @internal\n * @hidden\n */\nfunction runWithActionContext(context, fn) {\n    const node = getStateTreeNode(context.context);\n    if (context.type === \"action\") {\n        node.assertAlive({\n            actionContext: context\n        });\n    }\n    const baseIsRunningAction = node._isRunningAction;\n    node._isRunningAction = true;\n    const previousContext = currentActionContext;\n    currentActionContext = context;\n    try {\n        return runMiddleWares(node, context, fn);\n    }\n    finally {\n        currentActionContext = previousContext;\n        node._isRunningAction = baseIsRunningAction;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction getParentActionContext(parentContext) {\n    if (!parentContext) {\n        return undefined;\n    }\n    if (parentContext.type === \"action\") {\n        return parentContext;\n    }\n    return parentContext.parentActionEvent;\n}\n/**\n * @internal\n * @hidden\n */\nfunction createActionInvoker(target, name, fn) {\n    const res = function () {\n        const id = getNextActionId();\n        const parentContext = currentActionContext;\n        const parentActionContext = getParentActionContext(parentContext);\n        return runWithActionContext({\n            type: \"action\",\n            name,\n            id,\n            args: argsToArray(arguments),\n            context: target,\n            tree: getRoot(target),\n            rootId: parentContext ? parentContext.rootId : id,\n            parentId: parentContext ? parentContext.id : 0,\n            allParentIds: parentContext\n                ? [...parentContext.allParentIds, parentContext.id]\n                : [],\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        }, fn);\n    };\n    res._isMSTAction = true;\n    res._isFlowAction = fn._isFlowAction;\n    return res;\n}\n/**\n * Middleware can be used to intercept any action is invoked on the subtree where it is attached.\n * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.\n *\n * For more details, see the [middleware docs](concepts/middleware.md)\n *\n * @param target Node to apply the middleware to.\n * @param middleware Middleware to apply.\n * @returns A callable function to dispose the middleware.\n */\nfunction addMiddleware(target, handler, includeHooks = true) {\n    const node = getStateTreeNode(target);\n    if (devMode()) {\n        if (!node.isProtectionEnabled) {\n            warnError(\"It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`\");\n        }\n    }\n    return node.addMiddleWare(handler, includeHooks);\n}\n/**\n * Binds middleware to a specific action.\n *\n * Example:\n * ```ts\n * type.actions(self => {\n *   function takeA____() {\n *       self.toilet.donate()\n *       self.wipe()\n *       self.wipe()\n *       self.toilet.flush()\n *   }\n *   return {\n *     takeA____: decorate(atomic, takeA____)\n *   }\n * })\n * ```\n *\n * @param handler\n * @param fn\n * @param includeHooks\n * @returns The original function\n */\nfunction decorate(handler, fn, includeHooks = true) {\n    const middleware = { handler, includeHooks };\n    fn.$mst_middleware = fn.$mst_middleware || [];\n    fn.$mst_middleware.push(middleware);\n    return fn;\n}\nclass CollectedMiddlewares {\n    arrayIndex = 0;\n    inArrayIndex = 0;\n    middlewares = [];\n    constructor(node, fn) {\n        // we just push middleware arrays into an array of arrays to avoid making copies\n        if (fn.$mst_middleware) {\n            this.middlewares.push(fn.$mst_middleware);\n        }\n        let n = node;\n        // Find all middlewares. Optimization: cache this?\n        while (n) {\n            if (n.middlewares) {\n                this.middlewares.push(n.middlewares);\n            }\n            n = n.parent;\n        }\n    }\n    get isEmpty() {\n        return this.middlewares.length <= 0;\n    }\n    getNextMiddleware() {\n        const array = this.middlewares[this.arrayIndex];\n        if (!array) {\n            return undefined;\n        }\n        const item = array[this.inArrayIndex++];\n        if (!item) {\n            this.arrayIndex++;\n            this.inArrayIndex = 0;\n            return this.getNextMiddleware();\n        }\n        return item;\n    }\n}\nfunction runMiddleWares(node, baseCall, originalFn) {\n    const middlewares = new CollectedMiddlewares(node, originalFn);\n    // Short circuit\n    if (middlewares.isEmpty) {\n        return action(originalFn).apply(null, baseCall.args);\n    }\n    let result = null;\n    function runNextMiddleware(call) {\n        const middleware = middlewares.getNextMiddleware();\n        const handler = middleware && middleware.handler;\n        if (!handler) {\n            return action(originalFn).apply(null, call.args);\n        }\n        // skip hooks if asked to\n        if (!middleware.includeHooks && Hook[call.name]) {\n            return runNextMiddleware(call);\n        }\n        let nextInvoked = false;\n        function next(call2, callback) {\n            nextInvoked = true;\n            // the result can contain\n            // - the non manipulated return value from an action\n            // - the non manipulated abort value\n            // - one of the above but manipulated through the callback function\n            result = runNextMiddleware(call2);\n            if (callback) {\n                result = callback(result);\n            }\n        }\n        let abortInvoked = false;\n        function abort(value) {\n            abortInvoked = true;\n            // overwrite the result\n            // can be manipulated through middlewares earlier in the queue using the callback fn\n            result = value;\n        }\n        handler(call, next, abort);\n        if (devMode()) {\n            if (!nextInvoked && !abortInvoked) {\n                const node2 = getStateTreeNode(call.tree);\n                throw fail(`Neither the next() nor the abort() callback within the middleware ${handler.name} for the action: \"${call.name}\" on the node: ${node2.type.name} was invoked.`);\n            }\n            else if (nextInvoked && abortInvoked) {\n                const node2 = getStateTreeNode(call.tree);\n                throw fail(`The next() and abort() callback within the middleware ${handler.name} for the action: \"${call.name}\" on the node: ${node2.type.name} were invoked.`);\n            }\n        }\n        return result;\n    }\n    return runNextMiddleware(baseCall);\n}\n\n/**\n * Returns the currently executing MST action context, or undefined if none.\n */\nfunction getRunningActionContext() {\n    let current = getCurrentActionContext();\n    while (current && current.type !== \"action\") {\n        current = current.parentActionEvent;\n    }\n    return current;\n}\nfunction _isActionContextThisOrChildOf(actionContext, sameOrParent, includeSame) {\n    const parentId = typeof sameOrParent === \"number\" ? sameOrParent : sameOrParent.id;\n    let current = includeSame\n        ? actionContext\n        : actionContext.parentActionEvent;\n    while (current) {\n        if (current.id === parentId) {\n            return true;\n        }\n        current = current.parentActionEvent;\n    }\n    return false;\n}\n/**\n * Returns if the given action context is a parent of this action context.\n */\nfunction isActionContextChildOf(actionContext, parent) {\n    return _isActionContextThisOrChildOf(actionContext, parent, false);\n}\n/**\n * Returns if the given action context is this or a parent of this action context.\n */\nfunction isActionContextThisOrChildOf(actionContext, parentOrThis) {\n    return _isActionContextThisOrChildOf(actionContext, parentOrThis, true);\n}\n\nfunction safeStringify(value) {\n    try {\n        return JSON.stringify(value);\n    }\n    catch (e) {\n        // istanbul ignore next\n        return `<Unserializable: ${e}>`;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction prettyPrintValue(value) {\n    return typeof value === \"function\"\n        ? `<function${value.name ? \" \" + value.name : \"\"}>`\n        : isStateTreeNode(value)\n            ? `<${value}>`\n            : `\\`${safeStringify(value)}\\``;\n}\nfunction shortenPrintValue(valueInString) {\n    return valueInString.length < 280\n        ? valueInString\n        : `${valueInString.substring(0, 272)}......${valueInString.substring(valueInString.length - 8)}`;\n}\nfunction toErrorString(error) {\n    const { value } = error;\n    const type = error.context[error.context.length - 1].type;\n    const fullPath = error.context\n        .map(({ path }) => path)\n        .filter(path => path.length > 0)\n        .join(\"/\");\n    const pathPrefix = fullPath.length > 0 ? `at path \"/${fullPath}\" ` : ``;\n    const currentTypename = isStateTreeNode(value)\n        ? `value of type ${getStateTreeNode(value).type.name}:`\n        : isPrimitive(value)\n            ? \"value\"\n            : \"snapshot\";\n    const isSnapshotCompatible = type && isStateTreeNode(value) && type.is(getStateTreeNode(value).snapshot);\n    return (`${pathPrefix}${currentTypename} ${prettyPrintValue(value)} is not assignable ${type ? `to type: \\`${type.name}\\`` : ``}` +\n        (error.message ? ` (${error.message})` : \"\") +\n        (type\n            ? isPrimitiveType(type) || isPrimitive(value)\n                ? `.`\n                : `, expected an instance of \\`${type.name}\\` or a snapshot like \\`${type.describe()}\\` instead.` +\n                    (isSnapshotCompatible\n                        ? \" (Note that a snapshot of the provided value is compatible with the targeted type)\"\n                        : \"\")\n            : `.`));\n}\n/**\n * @internal\n * @hidden\n * Pushes a new entry onto the context array (mutates in place for performance).\n * Returns the same context array for chaining.\n */\nfunction getContextForPath(context, path, type) {\n    context.push({ path, type });\n    return context;\n}\n/**\n * @internal\n * @hidden\n * Pops the last entry from the context array (mutates in place).\n * Must be called after validation to restore context state.\n */\nfunction popContext(context) {\n    context.pop();\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckSuccess() {\n    return EMPTY_ARRAY;\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckFailure(context, value, message) {\n    // Clone context since it may be mutated after this error is created\n    return [{ context: context.slice(), value, message }];\n}\n/**\n * @internal\n * @hidden\n */\nfunction flattenTypeErrors(errors) {\n    return errors.flat();\n}\n// TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change\n/**\n * @internal\n * @hidden\n */\nfunction typecheckInternal(type, value) {\n    // runs typeChecking if it is in dev-mode or through a process.env.ENABLE_TYPE_CHECK flag\n    if (isTypeCheckingEnabled()) {\n        typecheck(type, value);\n    }\n}\n/**\n * Run's the typechecker for the given type on the given value, which can be a snapshot or an instance.\n * Throws if the given value is not according the provided type specification.\n * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)\n *\n * @param type Type to check against.\n * @param value Value to be checked, either a snapshot or an instance.\n */\nfunction typecheck(type, value) {\n    const errors = type.validate(value, [{ path: \"\", type }]);\n    if (errors.length > 0) {\n        throw fail(validationErrorsToString(type, value, errors));\n    }\n}\nfunction validationErrorsToString(type, value, errors) {\n    if (errors.length === 0) {\n        return undefined;\n    }\n    return (`Error while converting ${shortenPrintValue(prettyPrintValue(value))} to \\`${type.name}\\`:\\n\\n    ` + errors.map(toErrorString).join(\"\\n    \"));\n}\n\nlet identifierCacheId = 0;\n/**\n * @internal\n * @hidden\n */\nclass IdentifierCache {\n    cacheId = identifierCacheId++;\n    // n.b. in cache all identifiers are normalized to strings\n    cache = observable.map();\n    // last time the cache (array) for a given time changed\n    // n.b. it is not really the time, but just an integer that gets increased after each modification to the array\n    lastCacheModificationPerId = observable.map();\n    constructor() { }\n    updateLastCacheModificationPerId(identifier) {\n        const lcm = this.lastCacheModificationPerId.get(identifier);\n        // we start at 1 since 0 means no update since cache creation\n        this.lastCacheModificationPerId.set(identifier, lcm === undefined ? 1 : lcm + 1);\n    }\n    getLastCacheModificationPerId(identifier) {\n        const modificationId = this.lastCacheModificationPerId.get(identifier) || 0;\n        return `${this.cacheId}-${modificationId}`;\n    }\n    addNodeToCache(node, lastCacheUpdate = true) {\n        if (node.identifierAttribute) {\n            const identifier = node.identifier;\n            if (!this.cache.has(identifier)) {\n                this.cache.set(identifier, observable.array([], mobxShallow));\n            }\n            const set = this.cache.get(identifier);\n            if (set.indexOf(node) !== -1) {\n                throw fail(`Already registered`);\n            }\n            set.push(node);\n            if (lastCacheUpdate) {\n                this.updateLastCacheModificationPerId(identifier);\n            }\n        }\n    }\n    mergeCache(node) {\n        values(node.identifierCache.cache).forEach(nodes => nodes.forEach(child => {\n            this.addNodeToCache(child);\n        }));\n    }\n    notifyDied(node) {\n        if (node.identifierAttribute) {\n            const id = node.identifier;\n            const set = this.cache.get(id);\n            if (set) {\n                set.remove(node);\n                // remove empty sets from cache\n                if (!set.length) {\n                    this.cache.delete(id);\n                }\n                this.updateLastCacheModificationPerId(node.identifier);\n            }\n        }\n    }\n    splitCache(splitNode) {\n        const newCache = new IdentifierCache();\n        // The slash is added here so we only match children of the splitNode. In version 5.1.8 and\n        // earlier there was no trailing slash, so non children that started with the same path string\n        // were being matched incorrectly.\n        const basePath = splitNode.path + \"/\";\n        entries(this.cache).forEach(([id, nodes]) => {\n            let modified = false;\n            for (let i = nodes.length - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (node === splitNode || node.path.indexOf(basePath) === 0) {\n                    newCache.addNodeToCache(node, false); // no need to update lastUpdated since it is a whole new cache\n                    nodes.splice(i, 1);\n                    // remove empty sets from cache\n                    if (!nodes.length) {\n                        this.cache.delete(id);\n                    }\n                    modified = true;\n                }\n            }\n            if (modified) {\n                this.updateLastCacheModificationPerId(id);\n            }\n        });\n        return newCache;\n    }\n    has(type, identifier) {\n        const set = this.cache.get(identifier);\n        if (!set) {\n            return false;\n        }\n        return set.some(candidate => type.isAssignableFrom(candidate.type));\n    }\n    resolve(type, identifier) {\n        const set = this.cache.get(identifier);\n        if (!set) {\n            return null;\n        }\n        const matches = set.filter(candidate => type.isAssignableFrom(candidate.type));\n        switch (matches.length) {\n            case 0:\n                return null;\n            case 1:\n                return matches[0];\n            default:\n                throw fail(`Cannot resolve a reference to type '${type.name}' with id: '${identifier}' unambigously, there are multiple candidates: ${matches\n                    .map(n => n.path)\n                    .join(\", \")}`);\n        }\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction createObjectNode(type, parent, subpath, environment, initialValue) {\n    const existingNode = getStateTreeNodeSafe(initialValue);\n    if (existingNode) {\n        if (existingNode.parent) {\n            // istanbul ignore next\n            throw fail(`Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '${parent ? parent.path : \"\"}/${subpath}', but it lives already at '${existingNode.path}'`);\n        }\n        if (parent) {\n            existingNode.setParent(parent, subpath);\n        }\n        // else it already has no parent since it is a pre-requisite\n        return existingNode;\n    }\n    // not a node, a snapshot\n    return new ObjectNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction createScalarNode(type, parent, subpath, environment, initialValue) {\n    return new ScalarNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction isNode(value) {\n    return value instanceof ScalarNode || value instanceof ObjectNode;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar NodeLifeCycle;\n(function (NodeLifeCycle) {\n    NodeLifeCycle[NodeLifeCycle[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n    NodeLifeCycle[NodeLifeCycle[\"CREATED\"] = 1] = \"CREATED\";\n    NodeLifeCycle[NodeLifeCycle[\"FINALIZED\"] = 2] = \"FINALIZED\";\n    NodeLifeCycle[NodeLifeCycle[\"DETACHING\"] = 3] = \"DETACHING\";\n    NodeLifeCycle[NodeLifeCycle[\"DEAD\"] = 4] = \"DEAD\"; // no coming back from this one\n})(NodeLifeCycle || (NodeLifeCycle = {}));\n/**\n * Returns true if the given value is a node in a state tree.\n * More precisely, that is, if the value is an instance of a\n * `types.model`, `types.array` or `types.map`.\n *\n * @param value\n * @returns true if the value is a state tree node.\n */\nfunction isStateTreeNode(value) {\n    return !!(value && value.$treenode);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsStateTreeNode(value, argNumber) {\n    assertArg(value, isStateTreeNode, \"mobx-state-tree node\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNode(value) {\n    if (!isStateTreeNode(value)) {\n        // istanbul ignore next\n        throw fail(`Value ${value} is no MST Node`);\n    }\n    return value.$treenode;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNodeSafe(value) {\n    return (value && value.$treenode) || null;\n}\n/**\n * @internal\n * @hidden\n */\nfunction toJSON() {\n    return getStateTreeNode(this).snapshot;\n}\nconst doubleDot = (_) => \"..\";\n/**\n * @internal\n * @hidden\n */\nfunction getRelativePathBetweenNodes(base, target) {\n    // PRE condition target is (a child of) base!\n    if (base.root !== target.root) {\n        throw fail(`Cannot calculate relative path: objects '${base}' and '${target}' are not part of the same object tree`);\n    }\n    const baseParts = splitJsonPath(base.path);\n    const targetParts = splitJsonPath(target.path);\n    let common = 0;\n    for (; common < baseParts.length; common++) {\n        if (baseParts[common] !== targetParts[common]) {\n            break;\n        }\n    }\n    // TODO: assert that no targetParts paths are \"..\", \".\" or \"\"!\n    return (baseParts.slice(common).map(doubleDot).join(\"/\") +\n        joinJsonPath(targetParts.slice(common)));\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPath(base, path, failIfResolveFails = true) {\n    return resolveNodeByPathParts(base, splitJsonPath(path), failIfResolveFails);\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPathParts(base, pathParts, failIfResolveFails = true) {\n    let current = base;\n    try {\n        for (let i = 0; i < pathParts.length; i++) {\n            const part = pathParts[i];\n            if (part === \"..\") {\n                current = current.parent;\n                if (current) {\n                    continue;\n                } // not everything has a parent\n            }\n            else if (part === \".\") {\n                continue;\n            }\n            else if (current) {\n                if (current instanceof ScalarNode) {\n                    // check if the value of a scalar resolves to a state tree node (e.g. references)\n                    // then we can continue resolving...\n                    const value = current.value;\n                    if (isStateTreeNode(value)) {\n                        current = getStateTreeNode(value);\n                        // fall through\n                    }\n                }\n                if (current instanceof ObjectNode) {\n                    const subType = current.getChildType(part);\n                    if (subType) {\n                        current = current.getChildNode(part);\n                        if (current) {\n                            continue;\n                        }\n                    }\n                }\n            }\n            throw fail(`Could not resolve '${part}' in path '${joinJsonPath(pathParts.slice(0, i)) || \"/\"}' while resolving '${joinJsonPath(pathParts)}'`);\n        }\n    }\n    catch (e) {\n        if (!failIfResolveFails) {\n            return undefined;\n        }\n        throw e;\n    }\n    return current;\n}\n/**\n * @internal\n * @hidden\n */\nfunction convertChildNodesToArray(childNodes) {\n    if (!childNodes) {\n        return EMPTY_ARRAY;\n    }\n    const keys = Object.keys(childNodes);\n    if (!keys.length) {\n        return EMPTY_ARRAY;\n    }\n    const result = new Array(keys.length);\n    keys.forEach((key, index) => {\n        result[index] = childNodes[key];\n    });\n    return result;\n}\n\n// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n/*\n    All contents of this file are deprecated.\n\n    The term `process` has been replaced with `flow` to avoid conflicts with the\n    global `process` object.\n\n    Refer to `flow.ts` for any further changes to this implementation.\n*/\nconst DEPRECATION_MESSAGE = \"See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. \" +\n    \"Note that the middleware event types starting with `process` now start with `flow`.\";\n/**\n * @hidden\n *\n * @deprecated has been renamed to `flow()`.\n * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.\n * Note that the middleware event types starting with `process` now start with `flow`.\n *\n * @returns {Promise}\n */\nfunction process$1(asyncAction) {\n    deprecated(\"process\", \"`process()` has been renamed to `flow()`. \" + DEPRECATION_MESSAGE);\n    return flow(asyncAction);\n}\n\nconst plainObjectString = Object.toString();\n/**\n * @internal\n * @hidden\n */\nconst EMPTY_ARRAY = Object.freeze([]);\n/**\n * @internal\n * @hidden\n */\nconst EMPTY_OBJECT = Object.freeze({});\n/**\n * @internal\n * @hidden\n */\nconst mobxShallow = _getGlobalState().useProxies\n    ? { deep: false }\n    : { deep: false, proxy: false };\nObject.freeze(mobxShallow);\n/**\n * @internal\n * @hidden\n */\nfunction fail(message = \"Illegal state\") {\n    return new Error(\"[mobx-state-tree] \" + message);\n}\n/**\n * @internal\n * @hidden\n */\nfunction identity(_) {\n    return _;\n}\n/**\n * @internal\n * @hidden\n */\nconst isInteger = Number.isInteger;\n/**\n * @internal\n * @hidden\n */\nfunction isFloat(val) {\n    return Number(val) === val && val % 1 !== 0;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isFinite(val) {\n    return Number.isFinite(val);\n}\n/**\n * @internal\n * @hidden\n */\nfunction isArray(val) {\n    return Array.isArray(val) || isObservableArray(val);\n}\n/**\n * @internal\n * @hidden\n */\nfunction asArray(val) {\n    if (!val) {\n        return EMPTY_ARRAY;\n    }\n    if (isArray(val)) {\n        return val;\n    }\n    return [val];\n}\n/**\n * @internal\n * @hidden\n */\nfunction extend(a, ...b) {\n    for (let i = 0; i < b.length; i++) {\n        const current = b[i];\n        for (const key in current) {\n            a[key] = current[key];\n        }\n    }\n    return a;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPlainObject(value) {\n    if (value === null || typeof value !== \"object\") {\n        return false;\n    }\n    const proto = Object.getPrototypeOf(value);\n    if (proto == null) {\n        return true;\n    }\n    return proto.constructor?.toString() === plainObjectString;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isMutable(value) {\n    return (value !== null &&\n        typeof value === \"object\" &&\n        !(value instanceof Date) &&\n        !(value instanceof RegExp));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPrimitive(value, includeDate = true) {\n    return (value === null ||\n        value === undefined ||\n        typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\" ||\n        (includeDate && value instanceof Date));\n}\n/**\n * @internal\n * @hidden\n * Freeze a value and return it (if not in production)\n */\nfunction freeze(value) {\n    if (!devMode()) {\n        return value;\n    }\n    return isPrimitive(value) || isObservableArray(value)\n        ? value\n        : Object.freeze(value);\n}\n/**\n * @internal\n * @hidden\n * Recursively freeze a value (if not in production)\n */\nfunction deepFreeze(value) {\n    if (!devMode()) {\n        return value;\n    }\n    freeze(value);\n    if (isPlainObject(value)) {\n        Object.keys(value).forEach(propKey => {\n            if (!isPrimitive(value[propKey]) &&\n                !Object.isFrozen(value[propKey])) {\n                deepFreeze(value[propKey]);\n            }\n        });\n    }\n    return value;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isSerializable(value) {\n    return typeof value !== \"function\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction defineProperty(object, key, descriptor) {\n    isObservableObject(object)\n        ? defineProperty$1(object, key, descriptor)\n        : Object.defineProperty(object, key, descriptor);\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenFinalProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenWritableProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nclass EventHandler {\n    handlers = [];\n    emitting = false;\n    pendingUnregisters = null;\n    get hasSubscribers() {\n        return this.handlers.length > 0;\n    }\n    register(fn, atTheBeginning = false) {\n        if (atTheBeginning) {\n            this.handlers.unshift(fn);\n        }\n        else {\n            this.handlers.push(fn);\n        }\n        return () => {\n            this.unregister(fn);\n        };\n    }\n    has(fn) {\n        return this.handlers.indexOf(fn) >= 0;\n    }\n    unregister(fn) {\n        if (this.emitting) {\n            // defer unregistration until emit is done\n            if (!this.pendingUnregisters) {\n                this.pendingUnregisters = [];\n            }\n            this.pendingUnregisters.push(fn);\n            return;\n        }\n        const index = this.handlers.indexOf(fn);\n        if (index >= 0) {\n            this.handlers.splice(index, 1);\n        }\n    }\n    clear() {\n        this.handlers.length = 0;\n    }\n    emit(...args) {\n        // use emitting flag to defer unregistrations instead of copying array\n        this.emitting = true;\n        try {\n            for (const f of this.handlers) {\n                f(...args);\n            }\n        }\n        finally {\n            this.emitting = false;\n            // process any deferred unregistrations\n            if (this.pendingUnregisters) {\n                for (const fn of this.pendingUnregisters) {\n                    const index = this.handlers.indexOf(fn);\n                    if (index >= 0) {\n                        this.handlers.splice(index, 1);\n                    }\n                }\n                this.pendingUnregisters = null;\n            }\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass EventHandlers {\n    eventHandlers;\n    hasSubscribers(event) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        return !!handler && handler.hasSubscribers;\n    }\n    register(event, fn, atTheBeginning = false) {\n        if (!this.eventHandlers) {\n            this.eventHandlers = {};\n        }\n        let handler = this.eventHandlers[event];\n        if (!handler) {\n            handler = this.eventHandlers[event] = new EventHandler();\n        }\n        return handler.register(fn, atTheBeginning);\n    }\n    has(event, fn) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        return !!handler && handler.has(fn);\n    }\n    unregister(event, fn) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        if (handler) {\n            handler.unregister(fn);\n        }\n    }\n    clear(event) {\n        if (this.eventHandlers) {\n            delete this.eventHandlers[event];\n        }\n    }\n    clearAll() {\n        this.eventHandlers = undefined;\n    }\n    emit(event, ...args) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        if (handler) {\n            handler.emit(...args);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction argsToArray(args) {\n    const res = new Array(args.length);\n    for (let i = 0; i < args.length; i++) {\n        res[i] = args[i];\n    }\n    return res;\n}\n/**\n * @internal\n * @hidden\n */\nfunction stringStartsWith(str, beginning) {\n    return str.indexOf(beginning) === 0;\n}\n/**\n * @internal\n * @hidden\n */\nconst deprecated = function (id, message) {\n    // skip if running production\n    if (!devMode()) {\n        return;\n    }\n    // warn if hasn't been warned before\n    if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {\n        warnError(\"Deprecation warning: \" + message);\n    }\n    // mark as warned to avoid duplicate warn message\n    if (deprecated.ids) {\n        deprecated.ids[id] = true;\n    }\n};\ndeprecated.ids = {};\n/**\n * @internal\n * @hidden\n */\nfunction warnError(msg) {\n    console.warn(new Error(`[mobx-state-tree] ${msg}`));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isTypeCheckingEnabled() {\n    return (devMode() ||\n        (typeof process !== \"undefined\" &&\n            process.env &&\n            process.env.ENABLE_TYPE_CHECK === \"true\"));\n}\nlet _devMode = process.env.NODE_ENV !== \"production\";\n/**\n * @internal\n * @hidden\n */\nfunction devMode() {\n    return _devMode;\n}\n/**\n * @internal\n * @hidden\n */\nfunction setDevMode(value) {\n    _devMode = value;\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertArg(value, fn, typeName, argNumber) {\n    if (devMode()) {\n        if (!fn(value)) {\n            // istanbul ignore next\n            throw fail(`expected ${typeName} as argument ${asArray(argNumber).join(\" or \")}, got ${value} instead`);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsFunction(value, argNumber) {\n    assertArg(value, fn => typeof fn === \"function\", \"function\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsNumber(value, argNumber, min, max) {\n    assertArg(value, n => typeof n === \"number\", \"number\", argNumber);\n    {\n        assertArg(value, n => n >= min, `number greater than ${min}`, argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsString(value, argNumber, canBeEmpty = true) {\n    assertArg(value, s => typeof s === \"string\", \"string\", argNumber);\n    if (!canBeEmpty) {\n        assertArg(value, s => s !== \"\", \"not empty string\", argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction setImmediateWithFallback(fn) {\n    if (typeof queueMicrotask === \"function\") {\n        queueMicrotask(fn);\n    }\n    else if (typeof setImmediate === \"function\") {\n        setImmediate(fn);\n    }\n    else {\n        setTimeout(fn, 1);\n    }\n}\n\n/**\n * See [asynchronous actions](concepts/async-actions.md).\n *\n * @returns The flow as a promise.\n */\nfunction flow(generator) {\n    return createFlowSpawner(generator.name, generator);\n}\n/**\n * @deprecated Not needed since TS3.6.\n * Used for TypeScript to make flows that return a promise return the actual promise result.\n *\n * @param val\n * @returns\n */\nfunction castFlowReturn(val) {\n    return val;\n}\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise-returning function to a generator-returning one.\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n * const getDataGen = toGeneratorFunction(getDataAsync);\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* getDataGen(\"input value\");\n *     ...\n *   })\n * }))\n * ```\n */\nfunction toGeneratorFunction(p) {\n    return function* (...args) {\n        return (yield p(...args));\n    };\n}\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise to a generator yielding that promise\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* toGenerator(getDataAsync(\"input value\"));\n *     ...\n *   })\n * }))\n * ```\n */\nfunction* toGenerator(p) {\n    return (yield p);\n}\n/**\n * @internal\n * @hidden\n */\nfunction createFlowSpawner(name, generator) {\n    const spawner = function flowSpawner() {\n        // Implementation based on https://github.com/tj/co/blob/master/index.js\n        const runId = getNextActionId();\n        const parentContext = getCurrentActionContext();\n        if (!parentContext) {\n            throw fail(\"a mst flow must always have a parent context\");\n        }\n        const parentActionContext = getParentActionContext(parentContext);\n        if (!parentActionContext) {\n            throw fail(\"a mst flow must always have a parent action context\");\n        }\n        const contextBase = {\n            name,\n            id: runId,\n            tree: parentContext.tree,\n            context: parentContext.context,\n            parentId: parentContext.id,\n            allParentIds: [...parentContext.allParentIds, parentContext.id],\n            rootId: parentContext.rootId,\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        };\n        const args = arguments;\n        function wrap(fn, type, arg) {\n            fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow\n            return runWithActionContext({\n                ...contextBase,\n                type,\n                args: [arg]\n            }, fn);\n        }\n        return new Promise(function (resolve, reject) {\n            let gen;\n            const init = function asyncActionInit() {\n                gen = generator.apply(null, arguments);\n                onFulfilled(undefined); // kick off the flow\n            };\n            init.$mst_middleware = spawner.$mst_middleware;\n            runWithActionContext({\n                ...contextBase,\n                type: \"flow_spawn\",\n                args: argsToArray(args)\n            }, init);\n            function onFulfilled(res) {\n                let ret;\n                try {\n                    // prettier-ignore\n                    const cancelError = wrap((r) => { ret = gen.next(r); }, \"flow_resume\", res);\n                    if (cancelError instanceof Error) {\n                        ret = gen.throw(cancelError);\n                    }\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n                return;\n            }\n            function onRejected(err) {\n                let ret;\n                try {\n                    // prettier-ignore\n                    wrap((r) => { ret = gen.throw(r); }, \"flow_resume_error\", err); // or yieldError?\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (ret.done) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { resolve(r); }, \"flow_return\", ret.value);\n                    });\n                    return;\n                }\n                // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100\n                if (!ret.value || typeof ret.value.then !== \"function\") {\n                    // istanbul ignore next\n                    throw fail(\"Only promises can be yielded to `async`, got: \" + ret);\n                }\n                return ret.value.then(onFulfilled, onRejected);\n            }\n        });\n    };\n    spawner._isFlowAction = true;\n    return spawner;\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction splitPatch(patch) {\n    if (!(\"oldValue\" in patch)) {\n        throw fail(`Patches without \\`oldValue\\` field cannot be inversed`);\n    }\n    return [stripPatch(patch), invertPatch(patch)];\n}\n/**\n * @internal\n * @hidden\n */\nfunction stripPatch(patch) {\n    // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec\n    // this removes the ability to undo the patch\n    switch (patch.op) {\n        case \"add\":\n            return { op: \"add\", path: patch.path, value: patch.value };\n        case \"remove\":\n            return { op: \"remove\", path: patch.path };\n        case \"replace\":\n            return { op: \"replace\", path: patch.path, value: patch.value };\n    }\n}\nfunction invertPatch(patch) {\n    switch (patch.op) {\n        case \"add\":\n            return {\n                op: \"remove\",\n                path: patch.path\n            };\n        case \"remove\":\n            return {\n                op: \"add\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n        case \"replace\":\n            return {\n                op: \"replace\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n    }\n}\n/**\n * Simple simple check to check it is a number.\n */\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\n/**\n * Escape slashes and backslashes.\n *\n * http://tools.ietf.org/html/rfc6901\n */\nfunction escapeJsonPath(path) {\n    if (isNumber(path) === true) {\n        return \"\" + path;\n    }\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1) {\n        return path;\n    }\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescape slashes and backslashes.\n */\nfunction unescapeJsonPath(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n/**\n * Generates a json-path compliant json path from path parts.\n *\n * @param path\n * @returns\n */\nfunction joinJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    if (path.length === 0) {\n        return \"\";\n    }\n    const getPathStr = (p) => p.map(escapeJsonPath).join(\"/\");\n    if (path[0] === \".\" || path[0] === \"..\") {\n        // relative\n        return getPathStr(path);\n    }\n    else {\n        // absolute\n        return \"/\" + getPathStr(path);\n    }\n}\n/**\n * Splits and decodes a json path into several parts.\n *\n * @param path\n * @returns\n */\nfunction splitJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    const parts = path.split(\"/\").map(unescapeJsonPath);\n    const valid = path === \"\" ||\n        path === \".\" ||\n        path === \"..\" ||\n        stringStartsWith(path, \"/\") ||\n        stringStartsWith(path, \"./\") ||\n        stringStartsWith(path, \"../\");\n    if (!valid) {\n        throw fail(`a json path must be either rooted, empty or relative, but got '${path}'`);\n    }\n    // '/a/b/c' -> [\"a\", \"b\", \"c\"]\n    // '../../b/c' -> [\"..\", \"..\", \"b\", \"c\"]\n    // '' -> []\n    // '/' -> ['']\n    // './a' -> [\".\", \"a\"]\n    // /./a' -> [\".\", \"a\"] equivalent to './a'\n    if (parts[0] === \"\") {\n        parts.shift();\n    }\n    return parts;\n}\n\n/** @hidden */\nconst $preProcessorFailed = Symbol(\"$preProcessorFailed\");\nclass SnapshotProcessor extends BaseType {\n    _subtype;\n    _processors;\n    get flags() {\n        return this._subtype.flags | TypeFlags.SnapshotProcessor;\n    }\n    constructor(_subtype, _processors, name) {\n        super(name || _subtype.name);\n        this._subtype = _subtype;\n        this._processors = _processors;\n    }\n    describe() {\n        return `snapshotProcessor(${this._subtype.describe()})`;\n    }\n    preProcessSnapshot(sn) {\n        if (this._processors.preProcessor) {\n            return this._processors.preProcessor.call(null, sn);\n        }\n        return sn;\n    }\n    preProcessSnapshotSafe(sn) {\n        try {\n            return this.preProcessSnapshot(sn);\n        }\n        catch (e) {\n            return $preProcessorFailed;\n        }\n    }\n    postProcessSnapshot(sn, node) {\n        if (this._processors.postProcessor) {\n            return this._processors.postProcessor.call(null, sn, node.storedValue);\n        }\n        return sn;\n    }\n    _fixNode(node) {\n        // the node has to use these methods rather than the original type ones\n        proxyNodeTypeMethods(node.type, this, \"create\");\n        if (node instanceof ObjectNode) {\n            node.hasSnapshotPostProcessor = !!this._processors.postProcessor;\n        }\n        const oldGetSnapshot = node.getSnapshot;\n        node.getSnapshot = () => this.postProcessSnapshot(oldGetSnapshot.call(node), node);\n        if (!isUnionType(this._subtype)) {\n            node.getReconciliationType = () => {\n                return this;\n            };\n        }\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const processedInitialValue = isStateTreeNode(initialValue)\n            ? initialValue\n            : this.preProcessSnapshot(initialValue);\n        const node = this._subtype.instantiate(parent, subpath, environment, processedInitialValue);\n        this._fixNode(node);\n        return node;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const node = this._subtype.reconcile(current, isStateTreeNode(newValue) ? newValue : this.preProcessSnapshot(newValue), parent, subpath);\n        if (node !== current) {\n            this._fixNode(node);\n        }\n        return node;\n    }\n    getSnapshot(node, applyPostProcess = true) {\n        const sn = this._subtype.getSnapshot(node);\n        return applyPostProcess ? this.postProcessSnapshot(sn, node) : sn;\n    }\n    isValidSnapshot(value, context) {\n        const processedSn = this.preProcessSnapshotSafe(value);\n        if (processedSn === $preProcessorFailed) {\n            return typeCheckFailure(context, value, \"Failed to preprocess value\");\n        }\n        return this._subtype.validate(processedSn, context);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n    is(thing) {\n        const value = isType(thing)\n            ? this._subtype\n            : isStateTreeNode(thing)\n                ? getSnapshot(thing, false)\n                : this.preProcessSnapshotSafe(thing);\n        if (value === $preProcessorFailed) {\n            return false;\n        }\n        return (this._subtype.validate(value, [{ path: \"\", type: this._subtype }])\n            .length === 0);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    isMatchingSnapshotId(current, snapshot) {\n        if (!(this._subtype instanceof ComplexType)) {\n            return false;\n        }\n        const processedSn = this.preProcessSnapshot(snapshot);\n        return this._subtype.isMatchingSnapshotId(current, processedSn);\n    }\n}\nfunction proxyNodeTypeMethods(nodeType, snapshotProcessorType, ...methods) {\n    for (const method of methods) {\n        nodeType[method] = snapshotProcessorType[method].bind(snapshotProcessorType);\n    }\n}\n/**\n * `types.snapshotProcessor` - Runs a pre/post snapshot processor before/after serializing a given type.\n *\n * Example:\n * ```ts\n * const Todo1 = types.model({ text: types.string })\n * // in the backend the text type must be null when empty\n * interface BackendTodo {\n *     text: string | null\n * }\n *\n * const Todo2 = types.snapshotProcessor(Todo1, {\n *     // from snapshot to instance\n *     preProcessor(snapshot: BackendTodo) {\n *         return {\n *             text: sn.text || \"\";\n *         }\n *     },\n *\n *     // from instance to snapshot\n *     postProcessor(snapshot, node): BackendTodo {\n *         return {\n *             text: !sn.text ? null : sn.text\n *         }\n *     }\n * })\n * ```\n *\n * @param type Type to run the processors over.\n * @param processors Processors to run.\n * @param name Type name, or undefined to inherit the inner type one.\n * @returns\n */\nfunction snapshotProcessor(type, processors, name) {\n    assertIsType(type, 1);\n    if (devMode()) {\n        if (processors.postProcessor &&\n            typeof processors.postProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"postSnapshotProcessor must be a function\");\n        }\n        if (processors.preProcessor &&\n            typeof processors.preProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"preSnapshotProcessor must be a function\");\n        }\n    }\n    return new SnapshotProcessor(type, processors, name);\n}\n\nconst needsIdentifierError = `Map.put can only be used to store complex values that have an identifier type attribute`;\nfunction tryCollectModelTypes(type, modelTypes) {\n    const subtypes = type.getSubTypes();\n    if (subtypes === cannotDetermineSubtype) {\n        return false;\n    }\n    if (subtypes) {\n        const subtypesArray = asArray(subtypes);\n        for (const subtype of subtypesArray) {\n            if (!tryCollectModelTypes(subtype, modelTypes)) {\n                return false;\n            }\n        }\n    }\n    if (type instanceof ModelType) {\n        modelTypes.push(type);\n    }\n    return true;\n}\n/**\n * @internal\n * @hidden\n */\nvar MapIdentifierMode;\n(function (MapIdentifierMode) {\n    MapIdentifierMode[MapIdentifierMode[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MapIdentifierMode[MapIdentifierMode[\"YES\"] = 1] = \"YES\";\n    MapIdentifierMode[MapIdentifierMode[\"NO\"] = 2] = \"NO\";\n})(MapIdentifierMode || (MapIdentifierMode = {}));\nclass MSTMap extends ObservableMap {\n    constructor(initialData, name) {\n        super(initialData, observable.ref.enhancer, name);\n    }\n    get(key) {\n        // maybe this is over-enthousiastic? normalize numeric keys to strings\n        return super.get(\"\" + key);\n    }\n    has(key) {\n        return super.has(\"\" + key);\n    }\n    delete(key) {\n        return super.delete(\"\" + key);\n    }\n    set(key, value) {\n        return super.set(\"\" + key, value);\n    }\n    put(value) {\n        if (!value) {\n            throw fail(`Map.put cannot be used to set empty values`);\n        }\n        if (isStateTreeNode(value)) {\n            const node = getStateTreeNode(value);\n            if (devMode()) {\n                if (!node.identifierAttribute) {\n                    throw fail(needsIdentifierError);\n                }\n            }\n            if (node.identifier === null) {\n                throw fail(needsIdentifierError);\n            }\n            this.set(node.identifier, value);\n            return value;\n        }\n        else if (!isMutable(value)) {\n            throw fail(`Map.put can only be used to store complex values`);\n        }\n        else {\n            const mapNode = getStateTreeNode(this);\n            const mapType = mapNode.type;\n            if (mapType.identifierMode !== MapIdentifierMode.YES) {\n                throw fail(needsIdentifierError);\n            }\n            const idAttr = mapType.mapIdentifierAttribute;\n            const id = value[idAttr];\n            if (!isValidIdentifier(id)) {\n                // try again but this time after creating a node for the value\n                // since it might be an optional identifier\n                const newNode = this.put(mapType.getChildType().create(value, mapNode.environment));\n                return this.put(getSnapshot(newNode));\n            }\n            const key = normalizeIdentifier(id);\n            this.set(key, value);\n            return this.get(key);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass MapType extends ComplexType {\n    _subType;\n    identifierMode = MapIdentifierMode.UNKNOWN;\n    mapIdentifierAttribute = undefined;\n    flags = TypeFlags.Map;\n    hookInitializers = [];\n    constructor(name, _subType, hookInitializers = []) {\n        super(name);\n        this._subType = _subType;\n        this._determineIdentifierMode();\n        this.hookInitializers = hookInitializers;\n    }\n    hooks(hooks) {\n        const hookInitializers = this.hookInitializers.length > 0\n            ? this.hookInitializers.concat(hooks)\n            : [hooks];\n        return new MapType(this.name, this._subType, hookInitializers);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        this._determineIdentifierMode();\n        return createObjectNode(this, parent, subpath, environment, initialValue);\n    }\n    _determineIdentifierMode() {\n        if (this.identifierMode !== MapIdentifierMode.UNKNOWN) {\n            return;\n        }\n        const modelTypes = [];\n        if (tryCollectModelTypes(this._subType, modelTypes)) {\n            const identifierAttribute = modelTypes.reduce((current, type) => {\n                if (!type.identifierAttribute) {\n                    return current;\n                }\n                if (current && current !== type.identifierAttribute) {\n                    throw fail(`The objects in a map should all have the same identifier attribute, expected '${current}', but child of type '${type.name}' declared attribute '${type.identifierAttribute}' as identifier`);\n                }\n                return type.identifierAttribute;\n            }, undefined);\n            if (identifierAttribute) {\n                this.identifierMode = MapIdentifierMode.YES;\n                this.mapIdentifierAttribute = identifierAttribute;\n            }\n            else {\n                this.identifierMode = MapIdentifierMode.NO;\n            }\n        }\n    }\n    initializeChildNodes(objNode, initialSnapshot = {}) {\n        const subType = objNode.type._subType;\n        const result = {};\n        Object.keys(initialSnapshot).forEach(name => {\n            result[name] = subType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        return new MSTMap(childNodes, this.name);\n    }\n    finalizeNewInstance(node, instance) {\n        _interceptReads(instance, node.unbox);\n        const type = node.type;\n        type.hookInitializers.forEach(initializer => {\n            const hooks = initializer(instance);\n            Object.keys(hooks).forEach(name => {\n                const hook = hooks[name];\n                const actionInvoker = createActionInvoker(instance, name, hook);\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n            });\n        });\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    describe() {\n        return this.name;\n    }\n    getChildren(node) {\n        // return (node.storedValue as ObservableMap<any>).values()\n        return values(node.storedValue);\n    }\n    getChildNode(node, key) {\n        const childNode = node.storedValue.get(\"\" + key);\n        if (!childNode) {\n            throw fail(\"Not a child \" + key);\n        }\n        return childNode;\n    }\n    willChange(change) {\n        const node = getStateTreeNode(change.object);\n        const key = change.name;\n        node.assertWritable({ subpath: key });\n        const mapType = node.type;\n        const subType = mapType._subType;\n        switch (change.type) {\n            case \"update\":\n                {\n                    const { newValue } = change;\n                    const oldValue = change.object.get(key);\n                    if (newValue === oldValue) {\n                        return null;\n                    }\n                    typecheckInternal(subType, newValue);\n                    change.newValue = subType.reconcile(node.getChildNode(key), change.newValue, node, key);\n                    mapType.processIdentifier(key, change.newValue);\n                }\n                break;\n            case \"add\":\n                {\n                    typecheckInternal(subType, change.newValue);\n                    change.newValue = subType.instantiate(node, key, undefined, change.newValue);\n                    mapType.processIdentifier(key, change.newValue);\n                }\n                break;\n        }\n        return change;\n    }\n    processIdentifier(expected, node) {\n        if (this.identifierMode === MapIdentifierMode.YES &&\n            node instanceof ObjectNode) {\n            const identifier = node.identifier;\n            if (identifier !== expected) {\n                throw fail(`A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '${identifier}', but expected: '${expected}'`);\n            }\n        }\n    }\n    getSnapshot(node) {\n        const res = {};\n        node.getChildren().forEach(childNode => {\n            res[childNode.subpath] = childNode.snapshot;\n        });\n        return res;\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = {};\n        Object.keys(childNodes).forEach(key => {\n            processed[key] = childNodes[key].getSnapshot();\n        });\n        return processed;\n    }\n    didChange(change) {\n        const node = getStateTreeNode(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: escapeJsonPath(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"add\":\n                return void node.emitPatch({\n                    op: \"add\",\n                    path: escapeJsonPath(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: undefined\n                }, node);\n            case \"delete\":\n                // a node got deleted, get the old snapshot and make the node die\n                const oldSnapshot = change.oldValue.snapshot;\n                change.oldValue.die();\n                // emit the patch\n                return void node.emitPatch({\n                    op: \"remove\",\n                    path: escapeJsonPath(change.name),\n                    oldValue: oldSnapshot\n                }, node);\n        }\n    }\n    applyPatchLocally(node, subpath, patch) {\n        const target = node.storedValue;\n        switch (patch.op) {\n            case \"add\":\n            case \"replace\":\n                target.set(subpath, patch.value);\n                break;\n            case \"remove\":\n                target.delete(subpath);\n                break;\n        }\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const target = node.storedValue;\n        const currentKeys = {};\n        Array.from(target.keys()).forEach(key => {\n            currentKeys[key] = false;\n        });\n        if (snapshot) {\n            // Don't use target.replace, as it will throw away all existing items first\n            for (const key in snapshot) {\n                target.set(key, snapshot[key]);\n                currentKeys[\"\" + key] = true;\n            }\n        }\n        Object.keys(currentKeys).forEach(key => {\n            if (currentKeys[key] === false) {\n                target.delete(key);\n            }\n        });\n    }\n    getChildType() {\n        return this._subType;\n    }\n    isValidSnapshot(value, context) {\n        if (!isPlainObject(value)) {\n            return typeCheckFailure(context, value, \"Value is not a plain object\");\n        }\n        for (const key of Object.keys(value)) {\n            getContextForPath(context, key, this._subType);\n            const errors = this._subType.validate(value[key], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    getDefaultSnapshot() {\n        return EMPTY_OBJECT;\n    }\n    removeChild(node, subpath) {\n        node.storedValue.delete(subpath);\n    }\n}\nMapType.prototype.applySnapshot = action(MapType.prototype.applySnapshot);\n/**\n * `types.map` - Creates a key based collection type who's children are all of a uniform declared type.\n * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.\n *\n * This type will always produce [observable maps](https://mobx.js.org/api.html#observablemap)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   id: types.identifier,\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.map(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: {} })\n * unprotect(s)\n * s.todos.set(17, { task: \"Grab coffee\", id: 17 })\n * s.todos.put({ task: \"Grab cookie\", id: 18 }) // put will infer key from the identifier\n * console.log(s.todos.get(17).task) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction map(subtype) {\n    return new MapType(`Map<string, ${subtype.name}>`, subtype);\n}\n/**\n * Returns if a given value represents a map type.\n *\n * @param type\n * @returns `true` if it is a map type.\n */\nfunction isMapType(type) {\n    return isType(type) && (type.flags & TypeFlags.Map) > 0;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass ArrayType extends ComplexType {\n    _subType;\n    flags = TypeFlags.Array;\n    hookInitializers = [];\n    constructor(name, _subType, hookInitializers = []) {\n        super(name);\n        this._subType = _subType;\n        this.hookInitializers = hookInitializers;\n    }\n    hooks(hooks) {\n        const hookInitializers = this.hookInitializers.length > 0\n            ? this.hookInitializers.concat(hooks)\n            : [hooks];\n        return new ArrayType(this.name, this._subType, hookInitializers);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createObjectNode(this, parent, subpath, environment, initialValue);\n    }\n    initializeChildNodes(objNode, snapshot = []) {\n        const subType = objNode.type._subType;\n        const result = {};\n        snapshot.forEach((item, index) => {\n            const subpath = \"\" + index;\n            result[subpath] = subType.instantiate(objNode, subpath, undefined, item);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        const options = { ...mobxShallow, name: this.name };\n        return observable.array(convertChildNodesToArray(childNodes), options);\n    }\n    finalizeNewInstance(node, instance) {\n        _getAdministration(instance).dehancer = node.unbox;\n        const type = node.type;\n        type.hookInitializers.forEach(initializer => {\n            const hooks = initializer(instance);\n            Object.keys(hooks).forEach(name => {\n                const hook = hooks[name];\n                const actionInvoker = createActionInvoker(instance, name, hook);\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n            });\n        });\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    describe() {\n        return this.name;\n    }\n    getChildren(node) {\n        return node.storedValue.slice();\n    }\n    getChildNode(node, key) {\n        const index = Number(key);\n        if (index < node.storedValue.length) {\n            return node.storedValue[index];\n        }\n        throw fail(\"Not a child: \" + key);\n    }\n    willChange(change) {\n        const node = getStateTreeNode(change.object);\n        node.assertWritable({ subpath: \"\" + change.index });\n        const subType = node.type._subType;\n        const childNodes = node.getChildren();\n        switch (change.type) {\n            case \"update\":\n                {\n                    if (change.newValue === change.object[change.index]) {\n                        return null;\n                    }\n                    const updatedNodes = reconcileArrayChildren(node, subType, [childNodes[change.index]], [change.newValue], [change.index]);\n                    if (!updatedNodes) {\n                        return null;\n                    }\n                    change.newValue = updatedNodes[0];\n                }\n                break;\n            case \"splice\":\n                {\n                    const { index, removedCount, added } = change;\n                    const addedNodes = reconcileArrayChildren(node, subType, childNodes.slice(index, index + removedCount), added, added.map((_, i) => index + i));\n                    if (!addedNodes) {\n                        return null;\n                    }\n                    change.added = addedNodes;\n                    // update paths of remaining items\n                    for (let i = index + removedCount; i < childNodes.length; i++) {\n                        childNodes[i].setParent(node, \"\" + (i + added.length - removedCount));\n                    }\n                }\n                break;\n        }\n        return change;\n    }\n    getSnapshot(node) {\n        return node.getChildren().map(childNode => childNode.snapshot);\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = [];\n        Object.keys(childNodes).forEach(key => {\n            processed.push(childNodes[key].getSnapshot());\n        });\n        return processed;\n    }\n    didChange(change) {\n        const node = getStateTreeNode(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: \"\" + change.index,\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"splice\":\n                for (let i = change.removedCount - 1; i >= 0; i--) {\n                    node.emitPatch({\n                        op: \"remove\",\n                        path: \"\" + (change.index + i),\n                        oldValue: change.removed[i].snapshot\n                    }, node);\n                }\n                for (let i = 0; i < change.addedCount; i++) {\n                    node.emitPatch({\n                        op: \"add\",\n                        path: \"\" + (change.index + i),\n                        value: node.getChildNode(\"\" + (change.index + i)).snapshot,\n                        oldValue: undefined\n                    }, node);\n                }\n                return;\n        }\n    }\n    applyPatchLocally(node, subpath, patch) {\n        const target = node.storedValue;\n        const index = subpath === \"-\" ? target.length : Number(subpath);\n        switch (patch.op) {\n            case \"replace\":\n                target[index] = patch.value;\n                break;\n            case \"add\":\n                target.splice(index, 0, patch.value);\n                break;\n            case \"remove\":\n                target.splice(index, 1);\n                break;\n        }\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const target = node.storedValue;\n        target.replace(snapshot);\n    }\n    getChildType() {\n        return this._subType;\n    }\n    isValidSnapshot(value, context) {\n        if (!isArray(value)) {\n            return typeCheckFailure(context, value, \"Value is not an array\");\n        }\n        for (let i = 0; i < value.length; i++) {\n            getContextForPath(context, \"\" + i, this._subType);\n            const errors = this._subType.validate(value[i], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    getDefaultSnapshot() {\n        return EMPTY_ARRAY;\n    }\n    removeChild(node, subpath) {\n        node.storedValue.splice(Number(subpath), 1);\n    }\n}\nArrayType.prototype.applySnapshot = action(ArrayType.prototype.applySnapshot);\n/**\n * `types.array` - Creates an index based collection type who's children are all of a uniform declared type.\n *\n * This type will always produce [observable arrays](https://mobx.js.org/api.html#observablearray)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: [] })\n * unprotect(s) // needed to allow modifying outside of an action\n * s.todos.push({ task: \"Grab coffee\" })\n * console.log(s.todos[0]) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction array(subtype) {\n    assertIsType(subtype, 1);\n    return new ArrayType(`${subtype.name}[]`, subtype);\n}\nfunction reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {\n    let nothingChanged = true;\n    for (let i = 0;; i++) {\n        const hasNewNode = i <= newValues.length - 1;\n        const oldNode = oldNodes[i];\n        let newValue = hasNewNode ? newValues[i] : undefined;\n        const newPath = \"\" + newPaths[i];\n        // for some reason, instead of newValue we got a node, fallback to the storedValue\n        // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681\n        if (isNode(newValue)) {\n            newValue = newValue.storedValue;\n        }\n        if (!oldNode && !hasNewNode) {\n            // both are empty, end\n            break;\n        }\n        else if (!hasNewNode) {\n            // new one does not exists\n            nothingChanged = false;\n            oldNodes.splice(i, 1);\n            if (oldNode instanceof ObjectNode) {\n                // since it is going to be returned by pop/splice/shift better create it before killing it\n                // so it doesn't end up in an undead state\n                oldNode.createObservableInstanceIfNeeded();\n            }\n            oldNode.die();\n            i--;\n        }\n        else if (!oldNode) {\n            // there is no old node, create it\n            // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.\n            if (isStateTreeNode(newValue) &&\n                getStateTreeNode(newValue).parent === parent) {\n                // this node is owned by this parent, but not in the reconcilable set, so it must be double\n                throw fail(`Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '${parent.path}/${newPath}', but it lives already at '${getStateTreeNode(newValue).path}'`);\n            }\n            nothingChanged = false;\n            const newNode = valueAsNode(childType, parent, newPath, newValue);\n            oldNodes.splice(i, 0, newNode);\n        }\n        else if (areSame(oldNode, newValue)) {\n            // both are the same, reconcile\n            oldNodes[i] = valueAsNode(childType, parent, newPath, newValue, oldNode);\n        }\n        else {\n            // nothing to do, try to reorder\n            let oldMatch = undefined;\n            // find a possible candidate to reuse\n            for (let j = i; j < oldNodes.length; j++) {\n                if (areSame(oldNodes[j], newValue)) {\n                    oldMatch = oldNodes.splice(j, 1)[0];\n                    break;\n                }\n            }\n            nothingChanged = false;\n            const newNode = valueAsNode(childType, parent, newPath, newValue, oldMatch);\n            oldNodes.splice(i, 0, newNode);\n        }\n    }\n    return nothingChanged ? null : oldNodes;\n}\n/**\n * Convert a value to a node at given parent and subpath. Attempts to reuse old node if possible and given.\n */\nfunction valueAsNode(childType, parent, subpath, newValue, oldNode) {\n    // ensure the value is valid-ish\n    typecheckInternal(childType, newValue);\n    function getNewNode() {\n        // the new value has a MST node\n        if (isStateTreeNode(newValue)) {\n            const childNode = getStateTreeNode(newValue);\n            childNode.assertAlive(EMPTY_OBJECT);\n            // the node lives here\n            if (childNode.parent !== null && childNode.parent === parent) {\n                childNode.setParent(parent, subpath);\n                return childNode;\n            }\n        }\n        // there is old node and new one is a value/snapshot\n        if (oldNode) {\n            return childType.reconcile(oldNode, newValue, parent, subpath);\n        }\n        // nothing to do, create from scratch\n        return childType.instantiate(parent, subpath, undefined, newValue);\n    }\n    const newNode = getNewNode();\n    if (oldNode && oldNode !== newNode) {\n        if (oldNode instanceof ObjectNode) {\n            // since it is going to be returned by pop/splice/shift better create it before killing it\n            // so it doesn't end up in an undead state\n            oldNode.createObservableInstanceIfNeeded();\n        }\n        oldNode.die();\n    }\n    return newNode;\n}\n/**\n * Check if a node holds a value.\n */\nfunction areSame(oldNode, newValue) {\n    // never consider dead old nodes for reconciliation\n    if (!oldNode.isAlive) {\n        return false;\n    }\n    // the new value has the same node\n    if (isStateTreeNode(newValue)) {\n        const newNode = getStateTreeNode(newValue);\n        return newNode.isAlive && newNode === oldNode;\n    }\n    // the provided value is the snapshot of the old node\n    if (oldNode.snapshot === newValue) {\n        return true;\n    }\n    // Non object nodes don't get reconciled\n    if (!(oldNode instanceof ObjectNode)) {\n        return false;\n    }\n    const oldNodeType = oldNode.getReconciliationType();\n    // new value is a snapshot with the correct identifier\n    return (oldNode.identifier !== null &&\n        oldNode.identifierAttribute &&\n        isPlainObject(newValue) &&\n        oldNodeType.is(newValue) &&\n        oldNodeType.isMatchingSnapshotId(oldNode, newValue));\n}\n/**\n * Returns if a given value represents an array type.\n *\n * @param type\n * @returns `true` if the type is an array type.\n */\nfunction isArrayType(type) {\n    return isType(type) && (type.flags & TypeFlags.Array) > 0;\n}\n\nconst PRE_PROCESS_SNAPSHOT = \"preProcessSnapshot\";\nconst POST_PROCESS_SNAPSHOT = \"postProcessSnapshot\";\nfunction objectTypeToString() {\n    return getStateTreeNode(this).toString();\n}\nconst defaultObjectOptions = {\n    name: \"AnonymousModel\",\n    properties: {},\n    initializers: EMPTY_ARRAY\n};\nfunction toPropertiesObject(declaredProps) {\n    const keysList = Object.keys(declaredProps);\n    const alreadySeenKeys = new Set();\n    keysList.forEach(key => {\n        if (alreadySeenKeys.has(key)) {\n            throw fail(`${key} is declared twice in the model. Model should not contain the same keys`);\n        }\n        alreadySeenKeys.add(key);\n    });\n    // loop through properties and ensures that all items are types\n    return keysList.reduce((props, key) => {\n        // warn if user intended a HOOK\n        if (key in Hook) {\n            throw fail(`Hook '${key}' was defined as property. Hooks should be defined as part of the actions`);\n        }\n        // the user intended to use a view\n        const descriptor = Object.getOwnPropertyDescriptor(declaredProps, key);\n        if (\"get\" in descriptor) {\n            throw fail(\"Getters are not supported as properties. Please use views instead\");\n        }\n        // undefined and null are not valid\n        const value = descriptor.value;\n        if (value === null || value === undefined) {\n            throw fail(\"The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?\");\n        }\n        // its a primitive, convert to its type\n        else if (isPrimitive(value)) {\n            props[key] = optional(getPrimitiveFactoryFromValue(value), value);\n        }\n        // map defaults to empty object automatically for models\n        else if (value instanceof MapType) {\n            props[key] = optional(value, {});\n        }\n        else if (value instanceof ArrayType) {\n            props[key] = optional(value, []);\n        }\n        // its already a type\n        else if (isType(value)) ;\n        // its a function, maybe the user wanted a view?\n        else if (devMode() && typeof value === \"function\") {\n            throw fail(`Invalid type definition for property '${key}', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?`);\n        }\n        // no other complex values\n        else if (devMode() && typeof value === \"object\") {\n            throw fail(`Invalid type definition for property '${key}', it looks like you passed an object. Try passing another model type or a types.frozen.`);\n        }\n        else {\n            throw fail(`Invalid type definition for property '${key}', cannot infer a type from a value like '${value}' (${typeof value})`);\n        }\n        return props;\n    }, { ...declaredProps });\n}\n/**\n * @internal\n * @hidden\n */\nclass ModelType extends ComplexType {\n    flags = TypeFlags.Object;\n    /*\n     * The original object definition\n     */\n    initializers;\n    properties;\n    preProcessor;\n    postProcessor;\n    propertyNames;\n    constructor(opts) {\n        super(opts.name || defaultObjectOptions.name);\n        Object.assign(this, defaultObjectOptions, opts);\n        // ensures that any default value gets converted to its related type\n        this.properties = toPropertiesObject(this.properties);\n        freeze(this.properties); // make sure nobody messes with it\n        this.propertyNames = Object.keys(this.properties);\n        this.identifierAttribute = this._getIdentifierAttribute();\n    }\n    _getIdentifierAttribute() {\n        let identifierAttribute = undefined;\n        this.forAllProps((propName, propType) => {\n            if (propType.flags & TypeFlags.Identifier) {\n                if (identifierAttribute) {\n                    throw fail(`Cannot define property '${propName}' as object identifier, property '${identifierAttribute}' is already defined as identifier property`);\n                }\n                identifierAttribute = propName;\n            }\n        });\n        return identifierAttribute;\n    }\n    cloneAndEnhance(opts) {\n        return new ModelType({\n            name: opts.name || this.name,\n            properties: Object.assign({}, this.properties, opts.properties),\n            initializers: this.initializers.concat(opts.initializers || []),\n            preProcessor: opts.preProcessor || this.preProcessor,\n            postProcessor: opts.postProcessor || this.postProcessor\n        });\n    }\n    actions(fn) {\n        const actionInitializer = (self) => {\n            this.instantiateActions(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [actionInitializer] });\n    }\n    instantiateActions(self, actions) {\n        // check if return is correct\n        if (!isPlainObject(actions)) {\n            throw fail(`actions initializer should return a plain object containing actions`);\n        }\n        // bind actions to the object created\n        Object.keys(actions).forEach(name => {\n            // warn if preprocessor was given\n            if (name === PRE_PROCESS_SNAPSHOT) {\n                throw fail(`Cannot define action '${PRE_PROCESS_SNAPSHOT}', it should be defined using 'type.preProcessSnapshot(fn)' instead`);\n            }\n            // warn if postprocessor was given\n            if (name === POST_PROCESS_SNAPSHOT) {\n                throw fail(`Cannot define action '${POST_PROCESS_SNAPSHOT}', it should be defined using 'type.postProcessSnapshot(fn)' instead`);\n            }\n            let action2 = actions[name];\n            // apply hook composition\n            const baseAction = self[name];\n            if (name in Hook && baseAction) {\n                const specializedAction = action2;\n                action2 = function () {\n                    baseAction.apply(null, arguments);\n                    specializedAction.apply(null, arguments);\n                };\n            }\n            // the goal of this is to make sure actions using \"this\" can call themselves,\n            // while still allowing the middlewares to register them\n            const middlewares = action2.$mst_middleware; // make sure middlewares are not lost\n            const boundAction = action2.bind(actions);\n            boundAction._isFlowAction =\n                action2._isFlowAction || false;\n            boundAction.$mst_middleware = middlewares;\n            const actionInvoker = createActionInvoker(self, name, boundAction);\n            actions[name] = actionInvoker;\n            (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, name, actionInvoker);\n        });\n    }\n    named = name => {\n        return this.cloneAndEnhance({ name });\n    };\n    props = properties => {\n        return this.cloneAndEnhance({ properties });\n    };\n    volatile(fn) {\n        if (typeof fn !== \"function\") {\n            throw fail(`You passed an ${typeof fn} to volatile state as an argument, when function is expected`);\n        }\n        const stateInitializer = (self) => {\n            this.instantiateVolatileState(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [stateInitializer] });\n    }\n    instantiateVolatileState(self, state) {\n        // check views return\n        if (!isPlainObject(state)) {\n            throw fail(`volatile state initializer should return a plain object containing state`);\n        }\n        set(self, state);\n    }\n    extend(fn) {\n        const initializer = (self) => {\n            const { actions, views, state, ...rest } = fn(self);\n            for (const key in rest) {\n                throw fail(`The \\`extend\\` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '${key}'`);\n            }\n            if (state) {\n                this.instantiateVolatileState(self, state);\n            }\n            if (views) {\n                this.instantiateViews(self, views);\n            }\n            if (actions) {\n                this.instantiateActions(self, actions);\n            }\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [initializer] });\n    }\n    views(fn) {\n        const viewInitializer = (self) => {\n            this.instantiateViews(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [viewInitializer] });\n    }\n    instantiateViews(self, views) {\n        // check views return\n        if (!isPlainObject(views)) {\n            throw fail(`views initializer should return a plain object containing views`);\n        }\n        Object.getOwnPropertyNames(views).forEach(key => {\n            // is this a computed property?\n            const descriptor = Object.getOwnPropertyDescriptor(views, key);\n            if (\"get\" in descriptor) {\n                defineProperty$1(self, key, descriptor);\n                makeObservable(self, { [key]: computed });\n            }\n            else if (typeof descriptor.value === \"function\") {\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, key, descriptor.value);\n            }\n            else {\n                throw fail(`A view member should either be a function or getter based property`);\n            }\n        });\n    }\n    preProcessSnapshot = preProcessor => {\n        const currentPreprocessor = this.preProcessor;\n        if (!currentPreprocessor) {\n            return this.cloneAndEnhance({ preProcessor });\n        }\n        else {\n            return this.cloneAndEnhance({\n                preProcessor: snapshot => currentPreprocessor(preProcessor(snapshot))\n            });\n        }\n    };\n    postProcessSnapshot = postProcessor => {\n        const currentPostprocessor = this.postProcessor;\n        if (!currentPostprocessor) {\n            return this.cloneAndEnhance({ postProcessor });\n        }\n        else {\n            return this.cloneAndEnhance({\n                postProcessor: snapshot => postProcessor(currentPostprocessor(snapshot))\n            });\n        }\n    };\n    instantiate(parent, subpath, environment, initialValue) {\n        const value = isStateTreeNode(initialValue)\n            ? initialValue\n            : this.applySnapshotPreProcessor(initialValue);\n        return createObjectNode(this, parent, subpath, environment, value);\n        // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class\n        // that pre-reserves all these fields for fast object-member lookups\n    }\n    initializeChildNodes(objNode, initialSnapshot = {}) {\n        const type = objNode.type;\n        const result = {};\n        type.forAllProps((name, childType) => {\n            result[name] = childType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        const options = { ...mobxShallow, name: this.name };\n        return observable.object(childNodes, EMPTY_OBJECT, options);\n    }\n    finalizeNewInstance(node, instance) {\n        addHiddenFinalProp(instance, \"toString\", objectTypeToString);\n        this.forAllProps(name => {\n            _interceptReads(instance, name, node.unbox);\n        });\n        this.initializers.reduce((self, fn) => fn(self), instance);\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    willChange(chg) {\n        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n        const change = chg;\n        const node = getStateTreeNode(change.object);\n        const subpath = change.name;\n        node.assertWritable({ subpath });\n        const childType = node.type.properties[subpath];\n        // only properties are typed, state are stored as-is references\n        if (childType) {\n            typecheckInternal(childType, change.newValue);\n            change.newValue = childType.reconcile(node.getChildNode(subpath), change.newValue, node, subpath);\n        }\n        return change;\n    }\n    didChange(chg) {\n        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n        const change = chg;\n        const childNode = getStateTreeNode(change.object);\n        const childType = childNode.type.properties[change.name];\n        if (!childType) {\n            // don't emit patches for volatile state\n            return;\n        }\n        const oldChildValue = change.oldValue ? change.oldValue.snapshot : undefined;\n        childNode.emitPatch({\n            op: \"replace\",\n            path: escapeJsonPath(change.name),\n            value: change.newValue.snapshot,\n            oldValue: oldChildValue\n        }, childNode);\n    }\n    getChildren(node) {\n        const res = [];\n        this.forAllProps(name => {\n            res.push(this.getChildNode(node, name));\n        });\n        return res;\n    }\n    getChildNode(node, key) {\n        if (!(key in this.properties)) {\n            throw fail(\"Not a value property: \" + key);\n        }\n        const adm = _getAdministration(node.storedValue, key);\n        const childNode = adm.raw?.();\n        if (!childNode) {\n            throw fail(\"Node not available for property \" + key);\n        }\n        return childNode;\n    }\n    getSnapshot(node, applyPostProcess = true) {\n        const res = {};\n        this.forAllProps((name, type) => {\n            try {\n                // TODO: FIXME, make sure the observable ref is used!\n                const atom = getAtom(node.storedValue, name);\n                atom.reportObserved();\n            }\n            catch (e) {\n                throw fail(`${name} property is declared twice`);\n            }\n            res[name] = this.getChildNode(node, name).snapshot;\n        });\n        if (applyPostProcess) {\n            return this.applySnapshotPostProcessor(res);\n        }\n        return res;\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = {};\n        Object.keys(childNodes).forEach(key => {\n            processed[key] = childNodes[key].getSnapshot();\n        });\n        return this.applySnapshotPostProcessor(processed);\n    }\n    applyPatchLocally(node, subpath, patch) {\n        if (!(patch.op === \"replace\" || patch.op === \"add\")) {\n            throw fail(`object does not support operation ${patch.op}`);\n        }\n        node.storedValue[subpath] = patch.value;\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const preProcessedSnapshot = this.applySnapshotPreProcessor(snapshot);\n        this.forAllProps(name => {\n            node.storedValue[name] = preProcessedSnapshot[name];\n        });\n    }\n    applySnapshotPreProcessor(snapshot) {\n        const processor = this.preProcessor;\n        return processor ? processor.call(null, snapshot) : snapshot;\n    }\n    applySnapshotPostProcessor(snapshot) {\n        const postProcessor = this.postProcessor;\n        if (postProcessor) {\n            return postProcessor.call(null, snapshot);\n        }\n        return snapshot;\n    }\n    getChildType(propertyName) {\n        assertIsString(propertyName, 1);\n        return this.properties[propertyName];\n    }\n    isValidSnapshot(value, context) {\n        const snapshot = this.applySnapshotPreProcessor(value);\n        if (!isPlainObject(snapshot)) {\n            return typeCheckFailure(context, snapshot, \"Value is not a plain object\");\n        }\n        for (const key of this.propertyNames) {\n            const propType = this.properties[key];\n            getContextForPath(context, key, propType);\n            const errors = propType.validate(snapshot[key], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    forAllProps(fn) {\n        this.propertyNames.forEach(key => fn(key, this.properties[key]));\n    }\n    describe() {\n        // optimization: cache\n        return (\"{ \" +\n            this.propertyNames\n                .map(key => key + \": \" + this.properties[key].describe())\n                .join(\"; \") +\n            \" }\");\n    }\n    getDefaultSnapshot() {\n        return EMPTY_OBJECT;\n    }\n    removeChild(node, subpath) {\n        node.storedValue[subpath] = undefined;\n    }\n}\nModelType.prototype.applySnapshot = action(ModelType.prototype.applySnapshot);\n/**\n * `types.model` - Creates a new model type by providing a name, properties, volatile state and actions.\n *\n * See the [model type](/concepts/trees#creating-models) description or the [getting started](intro/getting-started.md#getting-started-1) tutorial.\n */\nfunction model(...args) {\n    if (devMode() && typeof args[0] !== \"string\" && args[1]) {\n        throw fail(\"Model creation failed. First argument must be a string when two arguments are provided\");\n    }\n    const name = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n    const properties = args.shift() || {};\n    return new ModelType({ name, properties });\n}\n/**\n * `types.compose` - Composes a new model from one or more existing model types.\n * This method can be invoked in two forms:\n * Given 2 or more model types, the types are composed into a new Type.\n * Given first parameter as a string and 2 or more model types,\n * the types are composed into a new Type with the given name\n */\nfunction compose(...args) {\n    // TODO: just join the base type names if no name is provided\n    const hasTypename = typeof args[0] === \"string\";\n    const typeName = hasTypename ? args[0] : \"AnonymousModel\";\n    if (hasTypename) {\n        args.shift();\n    }\n    // check all parameters\n    if (devMode()) {\n        args.forEach((type, i) => {\n            assertArg(type, isModelType, \"mobx-state-tree model type\", hasTypename ? i + 2 : i + 1);\n        });\n    }\n    return args\n        .reduce((prev, cur) => prev.cloneAndEnhance({\n        name: prev.name + \"_\" + cur.name,\n        properties: cur.properties,\n        initializers: cur.initializers,\n        preProcessor: (snapshot) => cur.applySnapshotPreProcessor(prev.applySnapshotPreProcessor(snapshot)),\n        postProcessor: (snapshot) => cur.applySnapshotPostProcessor(prev.applySnapshotPostProcessor(snapshot))\n    }))\n        .named(typeName);\n}\n/**\n * Returns if a given value represents a model type.\n *\n * @param type\n * @returns\n */\nfunction isModelType(type) {\n    return isType(type) && (type.flags & TypeFlags.Object) > 0;\n}\n\n// TODO: implement CoreType using types.custom ?\n/**\n * @internal\n * @hidden\n */\nclass CoreType extends SimpleType {\n    flags;\n    checker;\n    initializer;\n    constructor(name, flags, checker, initializer = identity) {\n        super(name);\n        this.flags = flags;\n        this.checker = checker;\n        this.initializer = initializer;\n        this.flags = flags;\n    }\n    describe() {\n        return this.name;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    createNewInstance(snapshot) {\n        return this.initializer(snapshot);\n    }\n    isValidSnapshot(value, context) {\n        if (isPrimitive(value) && this.checker(value)) {\n            return typeCheckSuccess();\n        }\n        const typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name;\n        return typeCheckFailure(context, value, `Value is not a ${typeName}`);\n    }\n}\n/**\n * `types.string` - Creates a type that can only contain a string value.\n * This type is used for string values by default\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *   firstName: types.string,\n *   lastName: \"Doe\"\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst string = new CoreType(\"string\", TypeFlags.String, v => typeof v === \"string\");\n/**\n * `types.number` - Creates a type that can only contain a numeric value.\n * This type is used for numeric values by default\n *\n * Example:\n * ```ts\n * const Vector = types.model({\n *   x: types.number,\n *   y: 1.5\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst number = new CoreType(\"number\", TypeFlags.Number, v => typeof v === \"number\");\n/**\n * `types.integer` - Creates a type that can only contain an integer value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.integer,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst integer = new CoreType(\"integer\", TypeFlags.Integer, v => isInteger(v));\n/**\n * `types.float` - Creates a type that can only contain an float value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.float,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst float = new CoreType(\"float\", TypeFlags.Float, v => isFloat(v));\n/**\n * `types.finite` - Creates a type that can only contain an finite value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.finite,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst finite = new CoreType(\"finite\", TypeFlags.Finite, v => isFinite(v));\n/**\n * `types.boolean` - Creates a type that can only contain a boolean value.\n * This type is used for boolean values by default\n *\n * Example:\n * ```ts\n * const Thing = types.model({\n *   isCool: types.boolean,\n *   isAwesome: false\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst boolean = new CoreType(\"boolean\", TypeFlags.Boolean, v => typeof v === \"boolean\");\n/**\n * `types.null` - The type of the value `null`\n */\nconst nullType = new CoreType(\"null\", TypeFlags.Null, v => v === null);\n/**\n * `types.undefined` - The type of the value `undefined`\n */\nconst undefinedType = new CoreType(\"undefined\", TypeFlags.Undefined, v => v === undefined);\nconst _DatePrimitive = new CoreType(\"Date\", TypeFlags.Date, v => typeof v === \"number\" || v instanceof Date, v => (v instanceof Date ? v : new Date(v)));\n_DatePrimitive.getSnapshot = function (node) {\n    return node.storedValue.getTime();\n};\n/**\n * `types.Date` - Creates a type that can only contain a javascript Date value.\n *\n * Example:\n * ```ts\n * const LogLine = types.model({\n *   timestamp: types.Date,\n * })\n *\n * LogLine.create({ timestamp: new Date() })\n * ```\n */\nconst DatePrimitive = _DatePrimitive;\n/**\n * @internal\n * @hidden\n */\nfunction getPrimitiveFactoryFromValue(value) {\n    switch (typeof value) {\n        case \"string\":\n            return string;\n        case \"number\":\n            return number; // In the future, isInteger(value) ? integer : number would be interesting, but would be too breaking for now\n        case \"boolean\":\n            return boolean;\n        case \"object\":\n            if (value instanceof Date) {\n                return DatePrimitive;\n            }\n    }\n    throw fail(\"Cannot determine primitive type from value \" + value);\n}\n/**\n * Returns if a given value represents a primitive type.\n *\n * @param type\n * @returns\n */\nfunction isPrimitiveType(type) {\n    return (isType(type) &&\n        (type.flags &\n            (TypeFlags.String |\n                TypeFlags.Number |\n                TypeFlags.Integer |\n                TypeFlags.Boolean |\n                TypeFlags.Date)) >\n            0);\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Literal extends SimpleType {\n    value;\n    flags = TypeFlags.Literal;\n    constructor(value) {\n        super(JSON.stringify(value));\n        this.value = value;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    describe() {\n        return JSON.stringify(this.value);\n    }\n    isValidSnapshot(value, context) {\n        if (isPrimitive(value) && value === this.value) {\n            return typeCheckSuccess();\n        }\n        return typeCheckFailure(context, value, `Value is not a literal ${JSON.stringify(this.value)}`);\n    }\n}\n/**\n * `types.literal` - The literal type will return a type that will match only the exact given type.\n * The given value must be a primitive, in order to be serialized to a snapshot correctly.\n * You can use literal to match exact strings for example the exact male or female string.\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *     name: types.string,\n *     gender: types.union(types.literal('male'), types.literal('female'))\n * })\n * ```\n *\n * @param value The value to use in the strict equal check\n * @returns\n */\nfunction literal(value) {\n    // check that the given value is a primitive\n    assertArg(value, isPrimitive, \"primitive\", 1);\n    return new Literal(value);\n}\n/**\n * Returns if a given value represents a literal type.\n *\n * @param type\n * @returns\n */\nfunction isLiteralType(type) {\n    return isType(type) && (type.flags & TypeFlags.Literal) > 0;\n}\n\nclass Refinement extends BaseType {\n    _subtype;\n    _predicate;\n    _message;\n    get flags() {\n        return this._subtype.flags | TypeFlags.Refinement;\n    }\n    constructor(name, _subtype, _predicate, _message) {\n        super(name);\n        this._subtype = _subtype;\n        this._predicate = _predicate;\n        this._message = _message;\n    }\n    describe() {\n        return this.name;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        // create the child type\n        return this._subtype.instantiate(parent, subpath, environment, initialValue);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    isValidSnapshot(value, context) {\n        const subtypeErrors = this._subtype.validate(value, context);\n        if (subtypeErrors.length > 0) {\n            return subtypeErrors;\n        }\n        const snapshot = isStateTreeNode(value)\n            ? getStateTreeNode(value).snapshot\n            : value;\n        if (!this._predicate(snapshot)) {\n            return typeCheckFailure(context, value, this._message(value));\n        }\n        return typeCheckSuccess();\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this._subtype.reconcile(current, newValue, parent, subpath);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n}\n/**\n * `types.refinement` - Creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n *\n * @param name\n * @param type\n * @param predicate\n * @returns\n */\nfunction refinement(...args) {\n    const name = typeof args[0] === \"string\"\n        ? args.shift()\n        : isType(args[0])\n            ? args[0].name\n            : null;\n    const type = args[0];\n    const predicate = args[1];\n    const message = args[2]\n        ? args[2]\n        : (v) => \"Value does not respect the refinement predicate\";\n    // ensures all parameters are correct\n    assertIsType(type, [1, 2]);\n    assertIsString(name, 1);\n    assertIsFunction(predicate, [2, 3]);\n    assertIsFunction(message, [3, 4]);\n    return new Refinement(name, type, predicate, message);\n}\n/**\n * Returns if a given value is a refinement type.\n *\n * @param type\n * @returns\n */\nfunction isRefinementType(type) {\n    return (type.flags & TypeFlags.Refinement) > 0;\n}\n\n/**\n * `types.enumeration` - Can be used to create an string based enumeration.\n * (note: this methods is just sugar for a union of string literals)\n *\n * Example:\n * ```ts\n * const TrafficLight = types.model({\n *   color: types.enumeration(\"Color\", [\"Red\", \"Orange\", \"Green\"])\n * })\n * ```\n *\n * @param name descriptive name of the enumeration (optional)\n * @param options possible values this enumeration can have\n * @returns\n */\nfunction enumeration(name, options) {\n    const realOptions = typeof name === \"string\" ? options : name;\n    // check all options\n    if (devMode()) {\n        realOptions.forEach((option, i) => {\n            assertIsString(option, i + 1);\n        });\n    }\n    const type = union(...realOptions.map(option => literal(\"\" + option)));\n    if (typeof name === \"string\") {\n        type.name = name;\n    }\n    return type;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Union extends BaseType {\n    _types;\n    _dispatcher;\n    _eager = true;\n    get flags() {\n        let result = TypeFlags.Union;\n        this._types.forEach(type => {\n            result |= type.flags;\n        });\n        return result;\n    }\n    constructor(name, _types, options) {\n        super(name);\n        this._types = _types;\n        options = {\n            eager: true,\n            dispatcher: undefined,\n            ...options\n        };\n        this._dispatcher = options.dispatcher;\n        if (!options.eager) {\n            this._eager = false;\n        }\n    }\n    isAssignableFrom(type) {\n        return this._types.some(subType => subType.isAssignableFrom(type));\n    }\n    describe() {\n        return (\"(\" + this._types.map(factory => factory.describe()).join(\" | \") + \")\");\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const type = this.determineType(initialValue, undefined);\n        if (!type) {\n            throw fail(\"No matching type for union \" + this.describe());\n        } // can happen in prod builds\n        return type.instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const type = this.determineType(newValue, current.getReconciliationType());\n        if (!type) {\n            throw fail(\"No matching type for union \" + this.describe());\n        } // can happen in prod builds\n        return type.reconcile(current, newValue, parent, subpath);\n    }\n    determineType(value, reconcileCurrentType) {\n        // try the dispatcher, if defined\n        if (this._dispatcher) {\n            return this._dispatcher(value);\n        }\n        // fast path: when type checking is disabled, try quick structural matching first\n        if (!isTypeCheckingEnabled()) {\n            const quickMatch = this.tryQuickMatch(value, reconcileCurrentType);\n            if (quickMatch) {\n                return quickMatch;\n            }\n            // for plain object snapshots that didn't match via quick path, try all types\n            // with quick matching before falling back to full validation\n            // (state tree nodes must go through full validation for type identity checks)\n            if (isPlainObject(value) && !isStateTreeNode(value)) {\n                for (const type of this._types) {\n                    if (this.snapshotLooksLikeType(value, type)) {\n                        return type;\n                    }\n                }\n            }\n        }\n        // find the most accomodating type\n        // if we are using reconciliation try the current node type first (fix for #1045)\n        if (reconcileCurrentType) {\n            if (reconcileCurrentType.is(value)) {\n                return reconcileCurrentType;\n            }\n            return this._types\n                .filter(t => t !== reconcileCurrentType)\n                .find(type => type.is(value));\n        }\n        else {\n            return this._types.find(type => type.is(value));\n        }\n    }\n    tryQuickMatch(value, reconcileCurrentType) {\n        // state tree nodes need full type compatibility checking\n        // (e.g., A.is(B.create()) must return false even if snapshots are compatible)\n        if (isStateTreeNode(value)) {\n            return undefined;\n        }\n        // for non-object values, try primitive matching\n        if (!isPlainObject(value)) {\n            return this.tryMatchPrimitive(value);\n        }\n        // for objects, try structural matching against model types\n        const typesToCheck = reconcileCurrentType\n            ? [\n                reconcileCurrentType,\n                ...this._types.filter(t => t !== reconcileCurrentType)\n            ]\n            : this._types;\n        for (const type of typesToCheck) {\n            if (this.snapshotLooksLikeType(value, type)) {\n                return type;\n            }\n        }\n        return undefined;\n    }\n    tryMatchPrimitive(value) {\n        const valueType = typeof value;\n        for (const type of this._types) {\n            const flags = type.flags;\n            if ((valueType === \"string\" && flags & TypeFlags.String) ||\n                (valueType === \"number\" &&\n                    flags &\n                        (TypeFlags.Number |\n                            TypeFlags.Integer |\n                            TypeFlags.Float |\n                            TypeFlags.Finite)) ||\n                (valueType === \"boolean\" && flags & TypeFlags.Boolean) ||\n                (value === null && flags & TypeFlags.Null) ||\n                (value === undefined && flags & TypeFlags.Undefined)) {\n                return type;\n            }\n            // for literals, check exact value match\n            if (flags & TypeFlags.Literal) {\n                if (type.is(value)) {\n                    return type;\n                }\n            }\n        }\n        return undefined;\n    }\n    snapshotLooksLikeType(value, type) {\n        // for model types, check if snapshot has all the required property keys\n        // and that any literal-typed properties match exactly\n        if (type instanceof ModelType) {\n            const props = type.properties;\n            // use cached propertyNames from ModelType instead of Object.keys()\n            for (const key of type.propertyNames) {\n                const propType = props[key];\n                const isOptional = propType.flags & TypeFlags.Optional;\n                const propValue = value[key];\n                // check required properties exist and are not undefined\n                // (unless the type accepts undefined, which Optional types do)\n                if (!isOptional) {\n                    if (!(key in value) || propValue === undefined) {\n                        return false;\n                    }\n                }\n                // for literal types, verify the value matches exactly\n                // this is critical for discriminated unions\n                if (propType.flags & TypeFlags.Literal) {\n                    if (!propType.is(propValue)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    isValidSnapshot(value, context) {\n        if (this._dispatcher) {\n            return this._dispatcher(value).validate(value, context);\n        }\n        const allErrors = [];\n        let applicableTypes = 0;\n        for (let i = 0; i < this._types.length; i++) {\n            const type = this._types[i];\n            const errors = type.validate(value, context);\n            if (errors.length === 0) {\n                if (this._eager) {\n                    return typeCheckSuccess();\n                }\n                else {\n                    applicableTypes++;\n                }\n            }\n            else {\n                allErrors.push(errors);\n            }\n        }\n        if (applicableTypes === 1) {\n            return typeCheckSuccess();\n        }\n        return typeCheckFailure(context, value, \"No type is applicable for the union\").concat(flattenTypeErrors(allErrors));\n    }\n    getSubTypes() {\n        return this._types;\n    }\n}\n/**\n * `types.union` - Create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form `(snapshot) => Type`.\n *\n * @param optionsOrType\n * @param otherTypes\n * @returns\n */\nfunction union(optionsOrType, ...otherTypes) {\n    const options = isType(optionsOrType) ? undefined : optionsOrType;\n    const types = isType(optionsOrType)\n        ? [optionsOrType, ...otherTypes]\n        : otherTypes;\n    const name = \"(\" + types.map(type => type.name).join(\" | \") + \")\";\n    // check all options\n    if (devMode()) {\n        if (options) {\n            assertArg(options, o => isPlainObject(o), \"object { eager?: boolean, dispatcher?: Function }\", 1);\n        }\n        types.forEach((type, i) => {\n            assertIsType(type, options ? i + 2 : i + 1);\n        });\n    }\n    return new Union(name, types, options);\n}\n/**\n * Returns if a given value represents a union type.\n *\n * @param type\n * @returns\n */\nfunction isUnionType(type) {\n    return (type.flags & TypeFlags.Union) > 0;\n}\n\n/**\n * @hidden\n * @internal\n */\nclass OptionalValue extends BaseType {\n    _subtype;\n    _defaultValue;\n    optionalValues;\n    get flags() {\n        return this._subtype.flags | TypeFlags.Optional;\n    }\n    constructor(_subtype, _defaultValue, optionalValues) {\n        super(_subtype.name);\n        this._subtype = _subtype;\n        this._defaultValue = _defaultValue;\n        this.optionalValues = optionalValues;\n    }\n    describe() {\n        return this._subtype.describe() + \"?\";\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        if (this.optionalValues.indexOf(initialValue) >= 0) {\n            const defaultInstanceOrSnapshot = this.getDefaultInstanceOrSnapshot();\n            return this._subtype.instantiate(parent, subpath, environment, defaultInstanceOrSnapshot);\n        }\n        return this._subtype.instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this._subtype.reconcile(current, this.optionalValues.indexOf(newValue) < 0 && this._subtype.is(newValue)\n            ? newValue\n            : this.getDefaultInstanceOrSnapshot(), parent, subpath);\n    }\n    getDefaultInstanceOrSnapshot() {\n        const defaultInstanceOrSnapshot = typeof this._defaultValue === \"function\"\n            ? this._defaultValue()\n            : this._defaultValue;\n        // while static values are already snapshots and checked on types.optional\n        // generator functions must always be rechecked just in case\n        if (typeof this._defaultValue === \"function\") {\n            typecheckInternal(this, defaultInstanceOrSnapshot);\n        }\n        return defaultInstanceOrSnapshot;\n    }\n    isValidSnapshot(value, context) {\n        // defaulted values can be skipped\n        if (this.optionalValues.indexOf(value) >= 0) {\n            return typeCheckSuccess();\n        }\n        // bounce validation to the sub-type\n        return this._subtype.validate(value, context);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n}\nfunction checkOptionalPreconditions(type, defaultValueOrFunction) {\n    // make sure we never pass direct instances\n    if (typeof defaultValueOrFunction !== \"function\" &&\n        isStateTreeNode(defaultValueOrFunction)) {\n        throw fail(\"default value cannot be an instance, pass a snapshot or a function that creates an instance/snapshot instead\");\n    }\n    assertIsType(type, 1);\n    if (devMode()) {\n        // we only check default values if they are passed directly\n        // if they are generator functions they will be checked once they are generated\n        // we don't check generator function results here to avoid generating a node just for type-checking purposes\n        // which might generate side-effects\n        if (typeof defaultValueOrFunction !== \"function\") {\n            typecheckInternal(type, defaultValueOrFunction);\n        }\n    }\n}\n/**\n * `types.optional` - Can be used to create a property with a default value.\n *\n * Depending on the third argument (`optionalValues`) there are two ways of operation:\n * - If the argument is not provided, then if a value is not provided in the snapshot (`undefined` or missing),\n *   it will default to the provided `defaultValue`\n * - If the argument is provided, then if the value in the snapshot matches one of the optional values inside the array then it will\n *   default to the provided `defaultValue`. Additionally, if one of the optional values inside the array is `undefined` then a missing\n *   property is also valid.\n *\n *   Note that it is also possible to include values of the same type as the intended subtype as optional values,\n *   in this case the optional value will be transformed into the `defaultValue` (e.g. `types.optional(types.string, \"unnamed\", [undefined, \"\"])`\n *   will transform the snapshot values `undefined` (and therefore missing) and empty strings into the string `\"unnamed\"` when it gets\n *   instantiated).\n *\n * If `defaultValue` is a function, the function will be invoked for every new instance.\n * Applying a snapshot in which the optional value is one of the optional values (or `undefined`/_not_ present if none are provided) causes the\n * value to be reset.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string,\n *   subtitle1: types.optional(types.string, \"\", [null]),\n *   subtitle2: types.optional(types.string, \"\", [null, undefined]),\n *   done: types.optional(types.boolean, false),\n *   created: types.optional(types.Date, () => new Date()),\n * })\n *\n * // if done is missing / undefined it will become false\n * // if created is missing / undefined it will get a freshly generated timestamp\n * // if subtitle1 is null it will default to \"\", but it cannot be missing or undefined\n * // if subtitle2 is null or undefined it will default to \"\"; since it can be undefined it can also be missing\n * const todo = Todo.create({ title: \"Get coffee\", subtitle1: null })\n * ```\n *\n * @param type\n * @param defaultValueOrFunction\n * @param optionalValues an optional array with zero or more primitive values (string, number, boolean, null or undefined)\n *                       that will be converted into the default. `[ undefined ]` is assumed when none is provided\n * @returns\n */\nfunction optional(type, defaultValueOrFunction, optionalValues) {\n    checkOptionalPreconditions(type, defaultValueOrFunction);\n    return new OptionalValue(type, defaultValueOrFunction, optionalValues ? optionalValues : undefinedAsOptionalValues);\n}\nconst undefinedAsOptionalValues = [undefined];\n/**\n * Returns if a value represents an optional type.\n *\n * @template IT\n * @param type\n * @returns\n */\nfunction isOptionalType(type) {\n    return isType(type) && (type.flags & TypeFlags.Optional) > 0;\n}\n\nconst optionalUndefinedType = optional(undefinedType, undefined);\nconst optionalNullType = optional(nullType, null);\n/**\n * `types.maybe` - Maybe will make a type nullable, and also optional.\n * The value `undefined` will be used to represent nullability.\n *\n * @param type\n * @returns\n */\nfunction maybe(type) {\n    assertIsType(type, 1);\n    return union(type, optionalUndefinedType);\n}\n/**\n * `types.maybeNull` - Maybe will make a type nullable, and also optional.\n * The value `null` will be used to represent no value.\n *\n * @param type\n * @returns\n */\nfunction maybeNull(type) {\n    assertIsType(type, 1);\n    return union(type, optionalNullType);\n}\n\nclass Late extends BaseType {\n    _definition;\n    _subType;\n    get flags() {\n        return (this._subType ? this._subType.flags : 0) | TypeFlags.Late;\n    }\n    getSubType(mustSucceed) {\n        if (!this._subType) {\n            let t = undefined;\n            try {\n                t = this._definition();\n            }\n            catch (e) {\n                if (e instanceof ReferenceError) // can happen in strict ES5 code when a definition is self refering\n                 {\n                    t = undefined;\n                }\n                else {\n                    throw e;\n                }\n            }\n            if (mustSucceed && t === undefined) {\n                throw fail(\"Late type seems to be used too early, the definition (still) returns undefined\");\n            }\n            if (t) {\n                if (devMode() && !isType(t)) {\n                    throw fail(\"Failed to determine subtype, make sure types.late returns a type definition.\");\n                }\n                this._subType = t;\n            }\n        }\n        return this._subType;\n    }\n    constructor(name, _definition) {\n        super(name);\n        this._definition = _definition;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return this.getSubType(true).instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this.getSubType(true).reconcile(current, newValue, parent, subpath);\n    }\n    describe() {\n        const t = this.getSubType(false);\n        return t ? t.name : \"<uknown late type>\";\n    }\n    isValidSnapshot(value, context) {\n        const t = this.getSubType(false);\n        if (!t) {\n            // See #916; the variable the definition closure is pointing to wasn't defined yet, so can't be evaluted yet here\n            return typeCheckSuccess();\n        }\n        return t.validate(value, context);\n    }\n    isAssignableFrom(type) {\n        const t = this.getSubType(false);\n        return t ? t.isAssignableFrom(type) : false;\n    }\n    getSubTypes() {\n        const subtype = this.getSubType(false);\n        return subtype ? subtype : cannotDetermineSubtype;\n    }\n}\n/**\n * `types.late` - Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.\n * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.\n *\n * Example:\n * ```ts\n *   // TypeScript isn't smart enough to infer self referencing types.\n *  const Node = types.model({\n *       children: types.array(types.late((): IAnyModelType => Node)) // then typecast each array element to Instance<typeof Node>\n *  })\n * ```\n *\n * @param name The name to use for the type that will be returned.\n * @param type A function that returns the type that will be defined.\n * @returns\n */\nfunction late(nameOrType, maybeType) {\n    const name = typeof nameOrType === \"string\"\n        ? nameOrType\n        : `late(${nameOrType.toString()})`;\n    const type = typeof nameOrType === \"string\" ? maybeType : nameOrType;\n    // checks that the type is actually a late type\n    if (devMode()) {\n        if (!(typeof type === \"function\" && type.length === 0)) {\n            throw fail(\"Invalid late type, expected a function with zero arguments that returns a type, got: \" +\n                type);\n        }\n    }\n    return new Late(name, type);\n}\n/**\n * Returns if a given value represents a late type.\n *\n * @param type\n * @returns\n */\nfunction isLateType(type) {\n    return isType(type) && (type.flags & TypeFlags.Late) > 0;\n}\n\nfunction lazy(name, options) {\n    // TODO: fix this unknown casting to be stricter\n    return new Lazy(name, options);\n}\n/**\n * @internal\n * @hidden\n */\nclass Lazy extends SimpleType {\n    options;\n    flags = TypeFlags.Lazy;\n    loadedType = null;\n    pendingNodeList = observable.array();\n    constructor(name, options) {\n        super(name);\n        this.options = options;\n        when(() => this.pendingNodeList.length > 0 &&\n            this.pendingNodeList.some(node => node.isAlive &&\n                this.options.shouldLoadPredicate(node.parent ? node.parent.value : null)), () => {\n            this.options.loadType().then(action((type) => {\n                this.loadedType = type;\n                this.pendingNodeList.forEach(node => {\n                    if (!node.parent) {\n                        return;\n                    }\n                    if (!this.loadedType) {\n                        return;\n                    }\n                    node.parent.applyPatches([\n                        {\n                            op: \"replace\",\n                            path: `/${node.subpath}`,\n                            value: node.snapshot\n                        }\n                    ]);\n                });\n            }));\n        });\n    }\n    describe() {\n        return `<lazy ${this.name}>`;\n    }\n    instantiate(parent, subpath, environment, value) {\n        if (this.loadedType) {\n            return this.loadedType.instantiate(parent, subpath, environment, value);\n        }\n        const node = createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n        this.pendingNodeList.push(node);\n        when(() => !node.isAlive, () => this.pendingNodeList.splice(this.pendingNodeList.indexOf(node), 1));\n        return node;\n    }\n    isValidSnapshot(value, context) {\n        if (this.loadedType) {\n            return this.loadedType.validate(value, context);\n        }\n        if (!isSerializable(value)) {\n            return typeCheckFailure(context, value, \"Value is not serializable and cannot be lazy\");\n        }\n        return typeCheckSuccess();\n    }\n    reconcile(current, value, parent, subpath) {\n        if (this.loadedType) {\n            current.die();\n            return this.loadedType.instantiate(parent, subpath, parent.environment, value);\n        }\n        return super.reconcile(current, value, parent, subpath);\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Frozen extends SimpleType {\n    subType;\n    flags = TypeFlags.Frozen;\n    constructor(subType) {\n        super(subType ? `frozen(${subType.name})` : \"frozen\");\n        this.subType = subType;\n    }\n    describe() {\n        return \"<any immutable value>\";\n    }\n    instantiate(parent, subpath, environment, value) {\n        // create the node\n        return createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n    }\n    isValidSnapshot(value, context) {\n        if (!isSerializable(value)) {\n            return typeCheckFailure(context, value, \"Value is not serializable and cannot be frozen\");\n        }\n        if (this.subType) {\n            return this.subType.validate(value, context);\n        }\n        return typeCheckSuccess();\n    }\n}\nconst untypedFrozenInstance = new Frozen();\n/**\n * `types.frozen` - Frozen can be used to store any value that is serializable in itself (that is valid JSON).\n * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.\n * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.\n *\n * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.\n *\n * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.\n *\n * Frozen properties can be defined in three different ways\n * 1. `types.frozen(SubType)` - provide a valid MST type and frozen will check if the provided data conforms the snapshot for that type\n * 2. `types.frozen({ someDefaultValue: true})` - provide a primitive value, object or array, and MST will infer the type from that object, and also make it the default value for the field\n * 3. `types.frozen<TypeScriptType>()` - provide a typescript type, to help in strongly typing the field (design time only)\n *\n * Example:\n * ```ts\n * const GameCharacter = types.model({\n *   name: string,\n *   location: types.frozen({ x: 0, y: 0})\n * })\n *\n * const hero = GameCharacter.create({\n *   name: \"Mario\",\n *   location: { x: 7, y: 4 }\n * })\n *\n * hero.location = { x: 10, y: 2 } // OK\n * hero.location.x = 7 // Not ok!\n * ```\n *\n * ```ts\n * type Point = { x: number, y: number }\n *    const Mouse = types.model({\n *         loc: types.frozen<Point>()\n *    })\n * ```\n *\n * @param defaultValueOrType\n * @returns\n */\nfunction frozen(arg) {\n    if (arguments.length === 0) {\n        return untypedFrozenInstance;\n    }\n    else if (isType(arg)) {\n        return new Frozen(arg);\n    }\n    else {\n        return optional(untypedFrozenInstance, arg);\n    }\n}\n/**\n * Returns if a given value represents a frozen type.\n *\n * @param type\n * @returns\n */\nfunction isFrozenType(type) {\n    return isType(type) && (type.flags & TypeFlags.Frozen) > 0;\n}\n\nfunction getInvalidationCause(hook) {\n    switch (hook) {\n        case Hook.beforeDestroy:\n            return \"destroy\";\n        case Hook.beforeDetach:\n            return \"detach\";\n        default:\n            return undefined;\n    }\n}\nclass StoredReference {\n    targetType;\n    identifier;\n    node;\n    resolvedReference;\n    constructor(value, targetType) {\n        this.targetType = targetType;\n        if (isValidIdentifier(value)) {\n            this.identifier = value;\n        }\n        else if (isStateTreeNode(value)) {\n            const targetNode = getStateTreeNode(value);\n            if (!targetNode.identifierAttribute) {\n                throw fail(`Can only store references with a defined identifier attribute.`);\n            }\n            const id = targetNode.unnormalizedIdentifier;\n            if (id === null || id === undefined) {\n                throw fail(`Can only store references to tree nodes with a defined identifier.`);\n            }\n            this.identifier = id;\n        }\n        else {\n            throw fail(`Can only store references to tree nodes or identifiers, got: '${value}'`);\n        }\n    }\n    updateResolvedReference(node) {\n        const normalizedId = normalizeIdentifier(this.identifier);\n        const root = node.root;\n        const lastCacheModification = root.identifierCache.getLastCacheModificationPerId(normalizedId);\n        if (!this.resolvedReference ||\n            this.resolvedReference.lastCacheModification !== lastCacheModification) {\n            const { targetType } = this;\n            // reference was initialized with the identifier of the target\n            const target = root.identifierCache.resolve(targetType, normalizedId);\n            if (!target) {\n                throw new InvalidReferenceError(`[mobx-state-tree] Failed to resolve reference '${this.identifier}' to type '${this.targetType.name}' (from node: ${node.path})`);\n            }\n            this.resolvedReference = {\n                node: target,\n                lastCacheModification: lastCacheModification\n            };\n        }\n    }\n    get resolvedValue() {\n        this.updateResolvedReference(this.node);\n        return this.resolvedReference.node.value;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass InvalidReferenceError extends Error {\n    constructor(m) {\n        super(m);\n        Object.setPrototypeOf(this, InvalidReferenceError.prototype);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass BaseReferenceType extends SimpleType {\n    targetType;\n    onInvalidated;\n    flags = TypeFlags.Reference;\n    constructor(targetType, onInvalidated) {\n        super(`reference(${targetType.name})`);\n        this.targetType = targetType;\n        this.onInvalidated = onInvalidated;\n    }\n    describe() {\n        return this.name;\n    }\n    isAssignableFrom(type) {\n        return this.targetType.isAssignableFrom(type);\n    }\n    isValidSnapshot(value, context) {\n        return isValidIdentifier(value)\n            ? typeCheckSuccess()\n            : typeCheckFailure(context, value, \"Value is not a valid identifier, which is a string or a number\");\n    }\n    fireInvalidated(cause, storedRefNode, referenceId, refTargetNode) {\n        // to actually invalidate a reference we need an alive parent,\n        // since it is a scalar value (immutable-ish) and we need to change it\n        // from the parent\n        const storedRefParentNode = storedRefNode.parent;\n        if (!storedRefParentNode || !storedRefParentNode.isAlive) {\n            return;\n        }\n        const storedRefParentValue = storedRefParentNode.storedValue;\n        if (!storedRefParentValue) {\n            return;\n        }\n        this.onInvalidated({\n            cause,\n            parent: storedRefParentValue,\n            invalidTarget: refTargetNode ? refTargetNode.storedValue : undefined,\n            invalidId: referenceId,\n            replaceRef(newRef) {\n                applyPatch(storedRefNode.root.storedValue, {\n                    op: \"replace\",\n                    value: newRef,\n                    path: storedRefNode.path\n                });\n            },\n            removeRef() {\n                if (isModelType(storedRefParentNode.type)) {\n                    this.replaceRef(undefined);\n                }\n                else {\n                    applyPatch(storedRefNode.root.storedValue, {\n                        op: \"remove\",\n                        path: storedRefNode.path\n                    });\n                }\n            }\n        });\n    }\n    addTargetNodeWatcher(storedRefNode, referenceId) {\n        // this will make sure the target node becomes created\n        const refTargetValue = this.getValue(storedRefNode);\n        if (!refTargetValue) {\n            return undefined;\n        }\n        const refTargetNode = getStateTreeNode(refTargetValue);\n        const hookHandler = (_, refTargetNodeHook) => {\n            const cause = getInvalidationCause(refTargetNodeHook);\n            if (!cause) {\n                return;\n            }\n            this.fireInvalidated(cause, storedRefNode, referenceId, refTargetNode);\n        };\n        const refTargetDetachHookDisposer = refTargetNode.registerHook(Hook.beforeDetach, hookHandler);\n        const refTargetDestroyHookDisposer = refTargetNode.registerHook(Hook.beforeDestroy, hookHandler);\n        return () => {\n            refTargetDetachHookDisposer();\n            refTargetDestroyHookDisposer();\n        };\n    }\n    watchTargetNodeForInvalidations(storedRefNode, identifier, customGetSet) {\n        if (!this.onInvalidated) {\n            return;\n        }\n        let onRefTargetDestroyedHookDisposer;\n        // get rid of the watcher hook when the stored ref node is destroyed\n        // detached is ignored since scalar nodes (where the reference resides) cannot be detached\n        storedRefNode.registerHook(Hook.beforeDestroy, () => {\n            if (onRefTargetDestroyedHookDisposer) {\n                onRefTargetDestroyedHookDisposer();\n            }\n        });\n        const startWatching = (sync) => {\n            // re-create hook in case the stored ref gets reattached\n            if (onRefTargetDestroyedHookDisposer) {\n                onRefTargetDestroyedHookDisposer();\n            }\n            // make sure the target node is actually there and initialized\n            const storedRefParentNode = storedRefNode.parent;\n            const storedRefParentValue = storedRefParentNode && storedRefParentNode.storedValue;\n            if (storedRefParentNode &&\n                storedRefParentNode.isAlive &&\n                storedRefParentValue) {\n                let refTargetNodeExists;\n                if (customGetSet) {\n                    refTargetNodeExists = !!customGetSet.get(identifier, storedRefParentValue);\n                }\n                else {\n                    refTargetNodeExists = storedRefNode.root.identifierCache.has(this.targetType, normalizeIdentifier(identifier));\n                }\n                if (!refTargetNodeExists) {\n                    // we cannot change the reference in sync mode\n                    // since we are in the middle of a reconciliation/instantiation and the change would be overwritten\n                    // for those cases just let the wrong reference be assigned and fail upon usage\n                    // (like current references do)\n                    // this means that effectively this code will only run when it is created from a snapshot\n                    if (!sync) {\n                        this.fireInvalidated(\"invalidSnapshotReference\", storedRefNode, identifier, null);\n                    }\n                }\n                else {\n                    onRefTargetDestroyedHookDisposer = this.addTargetNodeWatcher(storedRefNode, identifier);\n                }\n            }\n        };\n        if (storedRefNode.state === NodeLifeCycle.FINALIZED) {\n            // already attached, so the whole tree is ready\n            startWatching(true);\n        }\n        else {\n            if (!storedRefNode.isRoot) {\n                // start watching once the whole tree is ready\n                storedRefNode.root.registerHook(Hook.afterCreationFinalization, () => {\n                    // make sure to attach it so it can start listening\n                    if (storedRefNode.parent) {\n                        storedRefNode.parent.createObservableInstanceIfNeeded();\n                    }\n                });\n            }\n            // start watching once the node is attached somewhere / parent changes\n            storedRefNode.registerHook(Hook.afterAttach, () => {\n                startWatching(false);\n            });\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierReferenceType extends BaseReferenceType {\n    constructor(targetType, onInvalidated) {\n        super(targetType, onInvalidated);\n    }\n    getValue(storedRefNode) {\n        if (!storedRefNode.isAlive) {\n            return undefined;\n        }\n        const storedRef = storedRefNode.storedValue;\n        return storedRef.resolvedValue;\n    }\n    getSnapshot(storedRefNode) {\n        const ref = storedRefNode.storedValue;\n        return ref.identifier;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const identifier = isStateTreeNode(initialValue)\n            ? getIdentifier(initialValue)\n            : initialValue;\n        const storedRef = new StoredReference(initialValue, this.targetType);\n        const storedRefNode = createScalarNode(this, parent, subpath, environment, storedRef);\n        storedRef.node = storedRefNode;\n        this.watchTargetNodeForInvalidations(storedRefNode, identifier, undefined);\n        return storedRefNode;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        if (!current.isDetaching && current.type === this) {\n            const compareByValue = isStateTreeNode(newValue);\n            const ref = current.storedValue;\n            if ((!compareByValue && ref.identifier === newValue) ||\n                (compareByValue && ref.resolvedValue === newValue)) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n        }\n        const newNode = this.instantiate(parent, subpath, undefined, newValue);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass CustomReferenceType extends BaseReferenceType {\n    options;\n    constructor(targetType, options, onInvalidated) {\n        super(targetType, onInvalidated);\n        this.options = options;\n    }\n    getValue(storedRefNode) {\n        if (!storedRefNode.isAlive) {\n            return undefined;\n        }\n        const referencedNode = this.options.get(storedRefNode.storedValue, storedRefNode.parent ? storedRefNode.parent.storedValue : null);\n        return referencedNode;\n    }\n    getSnapshot(storedRefNode) {\n        return storedRefNode.storedValue;\n    }\n    instantiate(parent, subpath, environment, newValue) {\n        const identifier = isStateTreeNode(newValue)\n            ? this.options.set(newValue, parent ? parent.storedValue : null)\n            : newValue;\n        const storedRefNode = createScalarNode(this, parent, subpath, environment, identifier);\n        this.watchTargetNodeForInvalidations(storedRefNode, identifier, this.options);\n        return storedRefNode;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const newIdentifier = isStateTreeNode(newValue)\n            ? this.options.set(newValue, current ? current.storedValue : null)\n            : newValue;\n        if (!current.isDetaching &&\n            current.type === this &&\n            current.storedValue === newIdentifier) {\n            current.setParent(parent, subpath);\n            return current;\n        }\n        const newNode = this.instantiate(parent, subpath, undefined, newIdentifier);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n/**\n * `types.reference` - Creates a reference to another type, which should have defined an identifier.\n * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.\n */\nfunction reference(subType, options) {\n    assertIsType(subType, 1);\n    if (devMode()) {\n        if (arguments.length === 2 && typeof arguments[1] === \"string\") {\n            // istanbul ignore next\n            throw fail(\"References with base path are no longer supported. Please remove the base path.\");\n        }\n    }\n    const getSetOptions = options\n        ? options\n        : undefined;\n    const onInvalidated = options\n        ? options.onInvalidated\n        : undefined;\n    if (getSetOptions && (getSetOptions.get || getSetOptions.set)) {\n        if (devMode()) {\n            if (!getSetOptions.get || !getSetOptions.set) {\n                throw fail(\"reference options must either contain both a 'get' and a 'set' method or none of them\");\n            }\n        }\n        return new CustomReferenceType(subType, {\n            get: getSetOptions.get,\n            set: getSetOptions.set\n        }, onInvalidated);\n    }\n    else {\n        return new IdentifierReferenceType(subType, onInvalidated);\n    }\n}\n/**\n * Returns if a given value represents a reference type.\n *\n * @param type\n * @returns\n */\nfunction isReferenceType(type) {\n    return (type.flags & TypeFlags.Reference) > 0;\n}\n/**\n * `types.safeReference` - A safe reference is like a standard reference, except that it accepts the undefined value by default\n * and automatically sets itself to undefined (when the parent is a model) / removes itself from arrays and maps\n * when the reference it is pointing to gets detached/destroyed.\n *\n * The optional options parameter object accepts a parameter named `acceptsUndefined`, which is set to true by default, so it is suitable\n * for model properties.\n * When used inside collections (arrays/maps), it is recommended to set this option to false so it can't take undefined as value,\n * which is usually the desired in those cases.\n * Additionally, the optional options parameter object accepts a parameter named `onInvalidated`, which will be called when the reference target node that the reference is pointing to is about to be detached/destroyed\n *\n * Strictly speaking it is a `types.maybe(types.reference(X))` (when `acceptsUndefined` is set to true, the default) and\n * `types.reference(X)` (when `acceptsUndefined` is set to false), both of them with a customized `onInvalidated` option.\n *\n * @param subType\n * @param options\n * @returns\n */\nfunction safeReference(subType, options) {\n    const refType = reference(subType, {\n        ...options,\n        onInvalidated(ev) {\n            if (options && options.onInvalidated) {\n                options.onInvalidated(ev);\n            }\n            ev.removeRef();\n        }\n    });\n    if (options && options.acceptsUndefined === false) {\n        return refType;\n    }\n    else {\n        return maybe(refType);\n    }\n}\n\nclass BaseIdentifierType extends SimpleType {\n    validType;\n    flags = TypeFlags.Identifier;\n    constructor(name, validType) {\n        super(name);\n        this.validType = validType;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        if (!parent || !(parent.type instanceof ModelType)) {\n            throw fail(`Identifier types can only be instantiated as direct child of a model type`);\n        }\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        // we don't consider detaching here since identifier are scalar nodes, and scalar nodes cannot be detached\n        if (current.storedValue !== newValue) {\n            throw fail(`Tried to change identifier from '${current.storedValue}' to '${newValue}'. Changing identifiers is not allowed.`);\n        }\n        current.setParent(parent, subpath);\n        return current;\n    }\n    isValidSnapshot(value, context) {\n        if (typeof value !== this.validType) {\n            return typeCheckFailure(context, value, `Value is not a valid ${this.describe()}, expected a ${this.validType}`);\n        }\n        return typeCheckSuccess();\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierType extends BaseIdentifierType {\n    flags = TypeFlags.Identifier;\n    constructor() {\n        super(`identifier`, \"string\");\n    }\n    describe() {\n        return `identifier`;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierNumberType extends BaseIdentifierType {\n    constructor() {\n        super(\"identifierNumber\", \"number\");\n    }\n    getSnapshot(node) {\n        return node.storedValue;\n    }\n    describe() {\n        return `identifierNumber`;\n    }\n}\n/**\n * `types.identifier` - Identifiers are used to make references, lifecycle events and reconciling works.\n * Inside a state tree, for each type can exist only one instance for each given identifier.\n * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.\n * Identifier can be used only as type property of a model.\n * This type accepts as parameter the value type of the identifier field that can be either string or number.\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifier,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nconst identifier = new IdentifierType();\n/**\n * `types.identifierNumber` - Similar to `types.identifier`. This one will serialize from / to a number when applying snapshots\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifierNumber,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nconst identifierNumber = new IdentifierNumberType();\n/**\n * Returns if a given value represents an identifier type.\n *\n * @param type\n * @returns\n */\nfunction isIdentifierType(type) {\n    return isType(type) && (type.flags & TypeFlags.Identifier) > 0;\n}\n/**\n * @internal\n * @hidden\n */\nfunction normalizeIdentifier(id) {\n    return \"\" + id;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isValidIdentifier(id) {\n    return typeof id === \"string\" || typeof id === \"number\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsValidIdentifier(id, argNumber) {\n    assertArg(id, isValidIdentifier, \"string or number (identifier)\", argNumber);\n}\n\n/**\n * `types.custom` - Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.\n *\n * The signature of the options is:\n * ```ts\n * export interface CustomTypeOptions<S, T> {\n *     // Friendly name\n *     name: string\n *     // given a serialized value and environment, how to turn it into the target type\n *     fromSnapshot(snapshot: S, env: any): T\n *     // return the serialization of the current value\n *     toSnapshot(value: T): S\n *     // if true, this is a converted value, if false, it's a snapshot\n *     isTargetType(value: T | S): value is T\n *     // a non empty string is assumed to be a validation error\n *     getValidationMessage?(snapshot: S): string\n * }\n * ```\n *\n * Example:\n * ```ts\n * const DecimalPrimitive = types.custom<string, Decimal>({\n *     name: \"Decimal\",\n *     fromSnapshot(value: string) {\n *         return new Decimal(value)\n *     },\n *     toSnapshot(value: Decimal) {\n *         return value.toString()\n *     },\n *     isTargetType(value: string | Decimal): boolean {\n *         return value instanceof Decimal\n *     },\n *     getValidationMessage(value: string): string {\n *         if (/^-?\\d+\\.\\d+$/.test(value)) return \"\" // OK\n *         return `'${value}' doesn't look like a valid decimal number`\n *     }\n * })\n *\n * const Wallet = types.model({\n *     balance: DecimalPrimitive\n * })\n * ```\n *\n * @param options\n * @returns\n */\nfunction custom(options) {\n    return new CustomType(options);\n}\n/**\n * @internal\n * @hidden\n */\nclass CustomType extends SimpleType {\n    options;\n    flags = TypeFlags.Custom;\n    constructor(options) {\n        super(options.name);\n        this.options = options;\n    }\n    describe() {\n        return this.name;\n    }\n    isValidSnapshot(value, context) {\n        if (this.options.isTargetType(value)) {\n            return typeCheckSuccess();\n        }\n        const typeError = this.options.getValidationMessage(value);\n        if (typeError) {\n            return typeCheckFailure(context, value, `Invalid value for type '${this.name}': ${typeError}`);\n        }\n        return typeCheckSuccess();\n    }\n    getSnapshot(node) {\n        return this.options.toSnapshot(node.storedValue);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const valueToStore = this.options.isTargetType(initialValue)\n            ? initialValue\n            : this.options.fromSnapshot(initialValue, parent && parent.root.environment);\n        return createScalarNode(this, parent, subpath, environment, valueToStore);\n    }\n    reconcile(current, value, parent, subpath) {\n        const isSnapshot = !this.options.isTargetType(value);\n        // in theory customs use scalar nodes which cannot be detached, but still...\n        if (!current.isDetaching) {\n            const unchanged = current.type === this &&\n                (isSnapshot\n                    ? value === current.snapshot\n                    : value === current.storedValue);\n            if (unchanged) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n        }\n        const valueToStore = isSnapshot\n            ? this.options.fromSnapshot(value, parent.root.environment)\n            : value;\n        const newNode = this.instantiate(parent, subpath, undefined, valueToStore);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n\n// we import the types to re-export them inside types.\nconst types = {\n    enumeration,\n    model,\n    compose,\n    custom,\n    reference,\n    safeReference,\n    union,\n    optional,\n    literal,\n    maybe,\n    maybeNull,\n    refinement,\n    string,\n    boolean,\n    number,\n    integer,\n    float,\n    finite,\n    Date: DatePrimitive,\n    map,\n    array,\n    frozen,\n    identifier,\n    identifierNumber,\n    late,\n    lazy,\n    undefined: undefinedType,\n    null: nullType,\n    snapshotProcessor\n};\n\nexport { addDisposer, addMiddleware, applyAction, applyPatch, applySnapshot, cast, castFlowReturn, castToReferenceSnapshot, castToSnapshot, clone, createActionTrackingMiddleware, createActionTrackingMiddleware2, decorate, destroy, detach, escapeJsonPath, flow, getChildType, getEnv, getIdentifier, getLivelinessChecking, getMembers, getNodeId, getParent, getParentOfType, getPath, getPathParts, getPropertyMembers, getRelativePath, getRoot, getRunningActionContext, getSnapshot, getType, hasParent, hasParentOfType, isActionContextChildOf, isActionContextThisOrChildOf, isAlive, isArrayType, isFrozenType, isIdentifierType, isLateType, isLiteralType, isMapType, isModelType, isOptionalType, isPrimitiveType, isProtected, isReferenceType, isRefinementType, isRoot, isStateTreeNode, isType, isUnionType, isValidReference, joinJsonPath, onAction, onPatch, onSnapshot, process$1 as process, protect, recordActions, recordPatches, resolveIdentifier, resolvePath, setDevMode, setLivelinessChecking, setLivelynessChecking, splitJsonPath, types as t, toGenerator, toGeneratorFunction, tryReference, tryResolve, typecheck, types, unescapeJsonPath, unprotect, walk };\n"],"names":["createSvgIcon","_jsx","d","errorProperties","property","enumerable","toJsonWasCalled","WeakSet","newError","name","factory","errorFactories","get","ErrorConstructor","errorConstructors","Error","AggregateError","isErrorLike","value","message","stack","destroyCircular","from","seen","to","forceEnumerable","maxDepth","depth","useToJSON","serialize","Array","isArray","push","toJSON","has","add","json","delete","continueDestroyCircular","key","Object","entries","Uint8Array","constructor","pipe","includes","val","defineProperty","configurable","writable","deserializeError","options","Number","POSITIVE_INFINITY","isMinimumViableSerializedError","NonError","counter","RpcClient","EventEmitter","worker","super","calls","Map","errors","this","addEventListener","e","handler","catch","uid","error","method","eventName","data","libRpc","reject","resolve","emit","lineno","filename","errorFn","clear","callFn","call","transferables","String","Promise","set","postMessage","rpcResult","__rpcResult","getAppBarUtilityClass","slot","generateUtilityClass","generateUtilityClasses","joinVars","var1","var2","replace","AppBarRoot","styled","Paper","overridesResolver","props","styles","ownerState","root","capitalize","position","color","memoTheme","theme","display","flexDirection","width","boxSizing","flexShrink","variants","style","zIndex","vars","appBar","top","left","right","palette","AppBar","defaultBg","grey","text","primary","getContrastText","applyStyles","filter","createSimplePaletteValueFilter","map","main","contrastText","enableColorOnDark","backgroundColor","darkBg","darkColor","backgroundImage","React","inProps","ref","useDefaultProps","className","other","classes","slots","composeClasses","useUtilityClasses","square","component","elevation","clsx","FabRoot","ButtonBase","shouldForwardProp","prop","rootShouldForwardProp","variant","size","colorInherit","typography","button","minHeight","transition","transitions","create","duration","short","borderRadius","padding","minWidth","height","fab","boxShadow","shadows","A100","textDecoration","fabClasses","focusVisible","dark","disabled","action","disabledBackground","children","disableFocusRipple","focusVisibleClassName","composedClasses","getFabUtilityClass","focusRipple","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","addSignal","signal","aborted","handleAborted","abort","AggregateStatusReporter","callbacks","addCallback","callback","currentMessage","elt","AbortablePromiseCache","fill","cache","TypeError","fillCallback","isAbortException","exception","code","evict","entry","statusCallback","aborter","statusReporter","newEntry","promise","settled","then","console","checkSinglePromise","checkForSingleAbort","assign","result","AbortSignal","cacheEntry","cachedEntry","keyIter","keys","deleteCount","next","done","isDynamicSupport","globalCss","html","enableColorScheme","WebkitFontSmoothing","MozOsxFontSmoothing","WebkitTextSizeAdjust","colorScheme","mode","body","body1","background","default","common","white","colorSchemeStyles","colorSchemes","getColorSchemeSelector","forEach","scheme","selector","startsWith","defaultStyles","fontWeight","fontWeightBold","margin","themeOverrides","components","MuiCssBaseline","styleOverrides","SELECTOR","GlobalStyles","baseStyles","staticStyles","_jsxs","hasSymbol","Symbol","for","isFunctionNameConfigurable","_b","_a","getOwnPropertyDescriptor","ReactForwardRefSymbol","forwardRef","ReactMemoSymbol","memo","observer","baseComponent","isUsingStaticRendering","useForwardRef","render","baseComponentName","displayName","base","target","observerComponent","useObserver","contextTypes","hoistBlackList","$$typeof","compare","type","livelinessChecking","setLivelinessChecking","getLivelinessChecking","setLivelynessChecking","Hook","getType","object","assertIsStateTreeNode","getStateTreeNode","getChildType","propertyName","onPatch","assertIsFunction","onSnapshot","applyPatch","patch","assertArg","p","applyPatches","asArray","recordPatches","subject","patches","inversePatches","publicData","disposer","recorder","recording","slice","reversedInversePatches","reverse","stop","undefined","resume","inversePatch","getRunningActionContext","replay","undo","protect","node","isRoot","fail","isProtectionEnabled","unprotect","isProtected","applySnapshot","snapshot","getSnapshot","applyPostProcess","freeze","hasParent","assertIsNumber","parent","getParent","storedValue","hasParentOfType","assertIsType","is","getParentOfType","getRoot","getPath","path","getPathParts","splitJsonPath","resolvePath","assertIsString","resolveNodeByPath","resolveIdentifier","identifier","isValidIdentifier","identifierCache","normalizeIdentifier","getIdentifier","tryReference","getter","checkIfAlive","isStateTreeNode","isAlive","InvalidReferenceError","isValidReference","tryResolve","getRelativePath","getRelativePathBetweenNodes","clone","source","keepEnvironment","environment","detach","destroy","die","removeChild","subpath","observableIsAlive","addDisposer","getEnv","EMPTY_OBJECT","walk","processor","getChildren","child","getPropertyMembers","typeOrNode","t","isModelType","properties","getMembers","reflected","actions","volatile","views","flowActions","getOwnPropertyNames","descriptor","isComputedProp","_isFlowAction","_isMSTAction","isObservableProp","cast","snapshotOrInstance","castToSnapshot","castToReferenceSnapshot","instance","getNodeId","nodeId","BaseNode","_escapedSubpath","_subpath","_subpathUponDeath","subpathUponDeath","_pathUponDeath","pathUponDeath","getValue","aliveAtom","_state","NodeLifeCycle","INITIALIZING","state","wasAlive","reportChanged","_hookSubscribers","fireInternalHook","registerHook","hook","hookHandler","EventHandlers","register","_parent","baseSetParent","getReconciliationType","pathAtom","getEscapedPath","reportObserved","createAtom","escapeJsonPath","DEAD","isDetaching","DETACHING","baseFinalizeCreation","whenFinalized","devMode","CREATED","FINALIZED","fireHook","afterAttach","baseFinalizeDeath","clearAll","baseAboutToDie","beforeDestroy","ScalarNode","simpleType","initialSnapshot","createNewInstance","finalizeCreation","setParent","newParent","parentChanged","subpathChanged","toString","aboutToDie","finalizeDeath","prototype","nextNodeId","snapshotReactionOptions","onError","ObjectNode","identifierAttribute","unnormalizedIdentifier","middlewares","hasSnapshotPostProcessor","_applyPatches","createObservableInstanceIfNeeded","_applySnapshot","_autoUnbox","_isRunningAction","_hasSnapshotReaction","_observableInstanceState","_childNodes","_initialSnapshot","_cachedInitialSnapshot","_cachedInitialSnapshotCreated","_snapshotComputed","complexType","initialValue","computed","unbox","bind","IdentifierCache","initializeChildNodes","id","childNode","addNodeToCache","fireHooks","createObservableInstance","parentChain","unshift","preboot","finalizeNewInstance","trackAndCompute","_addSnapshotReaction","afterCreate","clearParent","beforeDetach","previousState","newEnv","newIdCache","splitCache","mergeCache","fn","_allowStateChangesInsideComputed","apply","_snapshotUponDeath","_getActualSnapshot","_getCachedInitialSnapshot","childNodes","processInitialSnapshot","isRunningAction","assertAlive","context","_getAssertAliveError","warnError","escapedPath","actionContext","getCurrentActionContext","parentActionEvent","actionFullPath","getChildNode","convertChildNodesToArray","assertWritable","afterCreationFinalization","self","createActionInvoker","parts","resolveNodeByPathParts","applyPatchLocally","length","addHiddenFinalProp","_internalEventsEmit","_internalEventsClear","notifyDied","_internalEventsClearAll","onChange","_internalEventsRegister","emitSnapshot","emitPatch","basePatch","_internalEventsHasSubscribers","localizedPatch","a","b","i","current","extend","substr","reversePatch","stripPatch","invertPatch","splitPatch","hasDisposer","_internalEventsHas","removeDisposer","_internalEventsUnregister","removeMiddleware","middleware","index","indexOf","splice","addMiddleWare","includeHooks","snapshotDisposer","reaction","_internalEvents","event","hasSubscribers","eventHandler","atTheBeginning","unregister","args","validationCache","WeakMap","TypeFlags","cannotDetermineSubtype","$type","BaseType","C","S","T","N","isType","typecheckInternal","instantiate","isAssignableFrom","validate","getStateTreeNodeSafe","valueType","typeCheckSuccess","typeCheckFailure","typeCache","cached","isValidSnapshot","thing","Type","TypeWithoutSTN","SnapshotType","CreationType","ComplexType","getDefaultSnapshot","isMatchingSnapshotId","tryToReconcileNode","newValue","isMutable","reconcile","newNode","getSubTypes","SimpleType","res","argNumber","runningActions","createActionTrackingMiddleware","hooks","onStart","onResume","async","onSuspend","onSuccess","onFail","rootId","RunningAction","flowsPending","running","finish","onFinish","incFlowsPending","decFlowsPending","hasFlowsPending","createActionTrackingMiddleware2","middlewareHooks","parentRunningAction","newCall","env","parentCall","passesFilter","runningAction","serializeTheUnserializable","baseType","$MST_UNSERIALIZABLE","applyAction","runInAction","resolvedTarget","v","deserializeArgument","Date","baseApplyAction","recordActions","listener","onAction","attachAfter","addMiddleware","rawCall","sourceNode","info","arg","actionName","$MST_DATE","getTime","isPrimitive","isPlainObject","JSON","stringify","serializeArgument","currentActionContext","nextActionId","getNextActionId","runWithActionContext","baseIsRunningAction","previousContext","baseCall","originalFn","CollectedMiddlewares","isEmpty","runNextMiddleware","getNextMiddleware","nextInvoked","abortInvoked","call2","node2","tree","runMiddleWares","getParentActionContext","parentContext","parentActionContext","argsToArray","arguments","parentId","allParentIds","parentEvent","decorate","$mst_middleware","arrayIndex","inArrayIndex","n","array","_isActionContextThisOrChildOf","sameOrParent","includeSame","isActionContextChildOf","isActionContextThisOrChildOf","parentOrThis","prettyPrintValue","safeStringify","toErrorString","fullPath","join","pathPrefix","currentTypename","isSnapshotCompatible","isPrimitiveType","describe","getContextForPath","popContext","pop","EMPTY_ARRAY","isTypeCheckingEnabled","typecheck","valueInString","substring","validationErrorsToString","identifierCacheId","cacheId","observable","lastCacheModificationPerId","updateLastCacheModificationPerId","lcm","getLastCacheModificationPerId","modificationId","lastCacheUpdate","mobxShallow","values","nodes","remove","splitNode","newCache","basePath","modified","some","candidate","matches","createObjectNode","existingNode","createScalarNode","isNode","$treenode","doubleDot","_","baseParts","targetParts","joinJsonPath","failIfResolveFails","pathParts","part","process$1","asyncAction","deprecated","flow","plainObjectString","_getGlobalState","useProxies","deep","proxy","identity","isInteger","isObservableArray","proto","getPrototypeOf","RegExp","includeDate","deepFreeze","propKey","isFrozen","isSerializable","isObservableObject","defineProperty$1","propName","addHiddenWritableProp","EventHandler","handlers","emitting","pendingUnregisters","f","eventHandlers","stringStartsWith","str","beginning","ids","hasOwnProperty","msg","warn","process","_devMode","setDevMode","typeName","min","max","canBeEmpty","s","setImmediateWithFallback","queueMicrotask","setImmediate","setTimeout","generator","spawner","runId","contextBase","wrap","gen","init","onFulfilled","ret","cancelError","r","throw","onRejected","err","createFlowSpawner","castFlowReturn","toGeneratorFunction","toGenerator","op","oldValue","unescapeJsonPath","getPathStr","split","shift","$preProcessorFailed","SnapshotProcessor","_subtype","_processors","flags","preProcessSnapshot","sn","preProcessor","preProcessSnapshotSafe","postProcessSnapshot","postProcessor","_fixNode","nodeType","snapshotProcessorType","methods","proxyNodeTypeMethods","oldGetSnapshot","isUnionType","processedInitialValue","processedSn","needsIdentifierError","tryCollectModelTypes","modelTypes","subtypes","subtypesArray","subtype","ModelType","MapIdentifierMode","MSTMap","ObservableMap","initialData","enhancer","put","mapNode","mapType","identifierMode","YES","mapIdentifierAttribute","MapType","_subType","UNKNOWN","hookInitializers","_determineIdentifierMode","concat","reduce","NO","objNode","subType","_interceptReads","initializer","actionInvoker","intercept","willChange","observe","didChange","change","processIdentifier","expected","processed","oldSnapshot","currentKeys","isMapType","ArrayType","item","_getAdministration","dehancer","updatedNodes","reconcileArrayChildren","removedCount","added","addedNodes","removed","addedCount","childType","oldNodes","newValues","newPaths","nothingChanged","hasNewNode","oldNode","newPath","areSame","valueAsNode","oldMatch","j","getNewNode","oldNodeType","isArrayType","PRE_PROCESS_SNAPSHOT","POST_PROCESS_SNAPSHOT","objectTypeToString","defaultObjectOptions","initializers","propertyNames","opts","declaredProps","keysList","alreadySeenKeys","optional","string","number","boolean","DatePrimitive","getPrimitiveFactoryFromValue","toPropertiesObject","_getIdentifierAttribute","forAllProps","propType","Identifier","cloneAndEnhance","instantiateActions","action2","baseAction","specializedAction","boundAction","named","instantiateVolatileState","rest","instantiateViews","makeObservable","currentPreprocessor","currentPostprocessor","applySnapshotPreProcessor","chg","oldChildValue","adm","raw","getAtom","applySnapshotPostProcessor","preProcessedSnapshot","CoreType","checker","integer","Integer","float","Float","isFloat","finite","Finite","isFinite","Boolean","nullType","Null","undefinedType","Undefined","_DatePrimitive","Literal","literal","isLiteralType","Refinement","_predicate","_message","subtypeErrors","isRefinementType","Union","_types","_dispatcher","_eager","eager","dispatcher","determineType","reconcileCurrentType","quickMatch","tryQuickMatch","snapshotLooksLikeType","find","tryMatchPrimitive","typesToCheck","isOptional","Optional","propValue","allErrors","applicableTypes","flat","union","optionsOrType","otherTypes","types","o","OptionalValue","_defaultValue","optionalValues","defaultInstanceOrSnapshot","getDefaultInstanceOrSnapshot","defaultValueOrFunction","checkOptionalPreconditions","undefinedAsOptionalValues","isOptionalType","optionalUndefinedType","optionalNullType","maybe","Late","_definition","getSubType","mustSucceed","ReferenceError","isLateType","Lazy","loadedType","pendingNodeList","when","shouldLoadPredicate","loadType","Frozen","untypedFrozenInstance","isFrozenType","StoredReference","targetType","resolvedReference","targetNode","updateResolvedReference","normalizedId","lastCacheModification","resolvedValue","m","setPrototypeOf","BaseReferenceType","onInvalidated","Reference","fireInvalidated","cause","storedRefNode","referenceId","refTargetNode","storedRefParentNode","storedRefParentValue","invalidTarget","invalidId","replaceRef","newRef","removeRef","addTargetNodeWatcher","refTargetValue","refTargetNodeHook","getInvalidationCause","refTargetDetachHookDisposer","refTargetDestroyHookDisposer","watchTargetNodeForInvalidations","customGetSet","onRefTargetDestroyedHookDisposer","startWatching","sync","refTargetNodeExists","IdentifierReferenceType","storedRef","compareByValue","CustomReferenceType","newIdentifier","reference","getSetOptions","isReferenceType","BaseIdentifierType","validType","identifierNumber","isIdentifierType","CustomType","Custom","isTargetType","typeError","getValidationMessage","toSnapshot","fromSnapshot","isSnapshot","valueToStore","enumeration","realOptions","option","model","compose","hasTypename","prev","cur","custom","safeReference","refType","ev","acceptsUndefined","maybeNull","refinement","predicate","frozen","late","nameOrType","maybeType","lazy","null","snapshotProcessor","processors"],"ignoreList":[],"sourceRoot":""}