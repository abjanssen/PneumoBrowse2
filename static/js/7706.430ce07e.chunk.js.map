{"version":3,"file":"static/js/7706.430ce07e.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/bgzf-filehandle/src/unzip-pako.ts","../../../node_modules/@gmod/bgzf-filehandle/src/gziIndex.ts","../../../node_modules/@gmod/bgzf-filehandle/src/bgzFilehandle.ts"],"sourcesContent":["import { Buffer } from 'buffer'\n//@ts-ignore\nimport { Z_SYNC_FLUSH, Inflate } from 'pako'\n\ninterface VirtualOffset {\n  blockPosition: number\n  dataPosition: number\n}\ninterface Chunk {\n  minv: VirtualOffset\n  maxv: VirtualOffset\n}\n\n// browserify-zlib, which is the zlib shim used by default in webpacked code,\n// does not properly uncompress bgzf chunks that contain more than\n// one bgzf block, so export an unzip function that uses pako directly\n// if we are running in a browser.\nasync function unzip(inputData: Buffer) {\n  try {\n    let strm\n    let pos = 0\n    let i = 0\n    const chunks = []\n    let totalSize = 0\n    let inflator\n    do {\n      const remainingInput = inputData.subarray(pos)\n      inflator = new Inflate()\n      //@ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      pos += strm.next_in\n      chunks[i] = inflator.result as Uint8Array\n      totalSize += chunks[i].length\n      i += 1\n    } while (strm.avail_in)\n\n    const result = new Uint8Array(totalSize)\n    for (let i = 0, offset = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset)\n      offset += chunks[i].length\n    }\n    return Buffer.from(result)\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\n// similar to pakounzip, except it does extra counting\n// to return the positions of compressed and decompressed\n// data offsets\nasync function unzipChunk(inputData: Buffer) {\n  try {\n    let strm\n    let cpos = 0\n    let dpos = 0\n    const blocks = []\n    const cpositions = []\n    const dpositions = []\n    do {\n      const remainingInput = inputData.slice(cpos)\n      const inflator = new Inflate()\n      // @ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      const buffer = Buffer.from(inflator.result)\n      blocks.push(buffer)\n\n      cpositions.push(cpos)\n      dpositions.push(dpos)\n\n      cpos += strm.next_in\n      dpos += buffer.length\n    } while (strm.avail_in)\n\n    const buffer = Buffer.concat(blocks)\n    return { buffer, cpositions, dpositions }\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\n// similar to unzipChunk above but slices (0,minv.dataPosition) and\n// (maxv.dataPosition,end) off\nasync function unzipChunkSlice(inputData: Buffer, chunk: Chunk) {\n  try {\n    let strm\n    const { minv, maxv } = chunk\n    let cpos = minv.blockPosition\n    let dpos = minv.dataPosition\n    const chunks = []\n    const cpositions = []\n    const dpositions = []\n\n    let totalSize = 0\n    let i = 0\n    do {\n      const remainingInput = inputData.subarray(cpos - minv.blockPosition)\n      const inflator = new Inflate()\n      // @ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      const buffer = inflator.result\n      chunks.push(buffer as Uint8Array)\n      let len = buffer.length\n\n      cpositions.push(cpos)\n      dpositions.push(dpos)\n      if (chunks.length === 1 && minv.dataPosition) {\n        // this is the first chunk, trim it\n        chunks[0] = chunks[0].subarray(minv.dataPosition)\n        len = chunks[0].length\n      }\n      const origCpos = cpos\n      cpos += strm.next_in\n      dpos += len\n\n      if (origCpos >= maxv.blockPosition) {\n        // this is the last chunk, trim it and stop decompressing\n        // note if it is the same block is minv it subtracts that already\n        // trimmed part of the slice length\n\n        chunks[i] = chunks[i].subarray(\n          0,\n          maxv.blockPosition === minv.blockPosition\n            ? maxv.dataPosition - minv.dataPosition + 1\n            : maxv.dataPosition + 1,\n        )\n\n        cpositions.push(cpos)\n        dpositions.push(dpos)\n        totalSize += chunks[i].length\n        break\n      }\n      totalSize += chunks[i].length\n      i++\n    } while (strm.avail_in)\n\n    const result = new Uint8Array(totalSize)\n    for (let i = 0, offset = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset)\n      offset += chunks[i].length\n    }\n    const buffer = Buffer.from(result)\n\n    return { buffer, cpositions, dpositions }\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\nfunction nodeUnzip() {\n  throw new Error('nodeUnzip not implemented.')\n}\n\nexport { unzip, unzipChunk, unzipChunkSlice, unzip as pakoUnzip, nodeUnzip }\n","import Long from 'long'\nimport { Buffer } from 'buffer'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\n// const COMPRESSED_POSITION = 0\nconst UNCOMPRESSED_POSITION = 1\n\nexport default class GziIndex {\n  filehandle: GenericFilehandle\n\n  index?: any\n\n  constructor({\n    filehandle,\n    path,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('either filehandle or path must be defined')\n    }\n  }\n\n  _readLongWithOverflow(buf: Buffer, offset = 0, unsigned = true) {\n    //@ts-ignore\n    const long = Long.fromBytesLE(buf.slice(offset, offset + 8), unsigned)\n    if (\n      long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n      long.lessThan(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new TypeError('integer overflow')\n    }\n\n    return long.toNumber()\n  }\n\n  _getIndex() {\n    if (!this.index) {\n      this.index = this._readIndex()\n    }\n    return this.index\n  }\n\n  async _readIndex() {\n    let buf = Buffer.allocUnsafe(8)\n    await this.filehandle.read(buf, 0, 8, 0)\n    const numEntries = this._readLongWithOverflow(buf, 0, true)\n    if (!numEntries) {\n      return [[0, 0]]\n    }\n\n    const entries = new Array(numEntries + 1)\n    entries[0] = [0, 0]\n\n    // TODO rewrite this to make an index-index that stays in memory\n    const bufSize = 8 * 2 * numEntries\n    if (bufSize > Number.MAX_SAFE_INTEGER) {\n      throw new TypeError('integer overflow')\n    }\n    buf = Buffer.allocUnsafe(bufSize)\n    await this.filehandle.read(buf, 0, bufSize, 8)\n    for (let entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {\n      const compressedPosition = this._readLongWithOverflow(\n        buf,\n        entryNumber * 16,\n      )\n      const uncompressedPosition = this._readLongWithOverflow(\n        buf,\n        entryNumber * 16 + 8,\n      )\n      entries[entryNumber + 1] = [compressedPosition, uncompressedPosition]\n    }\n\n    return entries\n  }\n\n  async getLastBlock() {\n    const entries = await this._getIndex()\n    if (!entries.length) {\n      return undefined\n    }\n    return entries[entries.length - 1]\n  }\n\n  async getRelevantBlocksForRead(length: number, position: number) {\n    const endPosition = position + length\n    if (length === 0) {\n      return []\n    }\n    const entries = await this._getIndex()\n    const relevant = []\n\n    // binary search to find the block that the\n    // read starts in and extend forward from that\n    const compare = (entry: any, nextEntry: any) => {\n      const uncompressedPosition = entry[UNCOMPRESSED_POSITION]\n      const nextUncompressedPosition = nextEntry\n        ? nextEntry[UNCOMPRESSED_POSITION]\n        : Infinity\n      // block overlaps read start\n      if (\n        uncompressedPosition <= position &&\n        nextUncompressedPosition > position\n      ) {\n        return 0\n        // block is before read start\n      }\n      if (uncompressedPosition < position) {\n        return -1\n      }\n      // block is after read start\n      return 1\n    }\n\n    let lowerBound = 0\n    let upperBound = entries.length - 1\n    let searchPosition = Math.floor(entries.length / 2)\n\n    let comparison = compare(\n      entries[searchPosition],\n      entries[searchPosition + 1],\n    )\n    while (comparison !== 0) {\n      if (comparison > 0) {\n        upperBound = searchPosition - 1\n      } else if (comparison < 0) {\n        lowerBound = searchPosition + 1\n      }\n      searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound\n      comparison = compare(entries[searchPosition], entries[searchPosition + 1])\n    }\n\n    // here's where we read forward\n    relevant.push(entries[searchPosition])\n    let i = searchPosition + 1\n    for (; i < entries.length; i += 1) {\n      relevant.push(entries[i])\n      if (entries[i][UNCOMPRESSED_POSITION] >= endPosition) {\n        break\n      }\n    }\n    if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {\n      relevant.push([])\n    }\n    return relevant\n  }\n}\n","import { Buffer } from 'buffer'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\n// locals\nimport { unzip } from './unzip'\nimport GziIndex from './gziIndex'\n\nexport default class BgzFilehandle {\n  filehandle: GenericFilehandle\n  gzi: GziIndex\n\n  constructor({\n    filehandle,\n    path,\n    gziFilehandle,\n    gziPath,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n    gziFilehandle?: GenericFilehandle\n    gziPath?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('either filehandle or path must be defined')\n    }\n\n    if (!gziFilehandle && !gziPath && !path) {\n      throw new TypeError('either gziFilehandle or gziPath must be defined')\n    }\n\n    this.gzi = new GziIndex({\n      filehandle: gziFilehandle,\n      path: !gziFilehandle && !gziPath && path ? gziPath : `${path}.gzi`,\n    })\n  }\n\n  async stat() {\n    const compressedStat = await this.filehandle.stat()\n    return Object.assign(compressedStat, {\n      size: await this.getUncompressedFileSize(),\n      blocks: undefined,\n      blksize: undefined,\n    })\n  }\n\n  async getUncompressedFileSize() {\n    // read the last block's ISIZE (see gzip RFC),\n    // and add it to its uncompressedPosition\n    const [, uncompressedPosition] = await this.gzi.getLastBlock()\n\n    const { size } = await this.filehandle.stat()\n\n    const buf = Buffer.allocUnsafe(4)\n    // note: there should be a 28-byte EOF marker (an empty block) at\n    // the end of the file, so we skip backward past that\n    const { bytesRead } = await this.filehandle.read(buf, 0, 4, size - 28 - 4)\n    if (bytesRead !== 4) {\n      throw new Error('read error')\n    }\n    const lastBlockUncompressedSize = buf.readUInt32LE(0)\n    return uncompressedPosition + lastBlockUncompressedSize\n  }\n\n  async _readAndUncompressBlock(\n    blockBuffer: Buffer,\n    [compressedPosition]: [number],\n    [nextCompressedPosition]: [number],\n  ) {\n    let next = nextCompressedPosition\n    if (!next) {\n      next = (await this.filehandle.stat()).size\n    }\n\n    // read the compressed data into the block buffer\n    const blockCompressedLength = next - compressedPosition\n\n    await this.filehandle.read(\n      blockBuffer,\n      0,\n      blockCompressedLength,\n      compressedPosition,\n    )\n\n    // uncompress it\n    const unzippedBuffer = await unzip(\n      blockBuffer.slice(0, blockCompressedLength),\n    )\n\n    return unzippedBuffer as Buffer\n  }\n\n  async read(buf: Buffer, offset: number, length: number, position: number) {\n    // get the block positions for this read\n    const blockPositions = await this.gzi.getRelevantBlocksForRead(\n      length,\n      position,\n    )\n    const blockBuffer = Buffer.allocUnsafe(32768 * 2)\n    // uncompress the blocks and read from them one at a time to keep memory usage down\n    let destinationOffset = offset\n    let bytesRead = 0\n    for (\n      let blockNum = 0;\n      blockNum < blockPositions.length - 1;\n      blockNum += 1\n    ) {\n      // eslint-disable-next-line no-await-in-loop\n      const uncompressedBuffer = await this._readAndUncompressBlock(\n        blockBuffer,\n        blockPositions[blockNum],\n        blockPositions[blockNum + 1],\n      )\n      const [, uncompressedPosition] = blockPositions[blockNum]\n      const sourceOffset =\n        uncompressedPosition >= position ? 0 : position - uncompressedPosition\n      const sourceEnd =\n        Math.min(\n          position + length,\n          uncompressedPosition + uncompressedBuffer.length,\n        ) - uncompressedPosition\n      if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {\n        uncompressedBuffer.copy(buf, destinationOffset, sourceOffset, sourceEnd)\n        destinationOffset += sourceEnd - sourceOffset\n        bytesRead += sourceEnd - sourceOffset\n      }\n    }\n\n    return { bytesRead, buffer: buf }\n  }\n}\n"],"names":["async","unzip","inputData","strm","pos","i","chunks","inflator","totalSize","remainingInput","subarray","Inflate","push","Z_SYNC_FLUSH","err","Error","msg","next_in","result","length","avail_in","Uint8Array","offset","set","from","e","match","unzipChunkSlice","chunk","minv","maxv","cpos","blockPosition","dpos","dataPosition","cpositions","dpositions","buffer","len","origCpos","GziIndex","constructor","filehandle","path","this","TypeError","_readLongWithOverflow","buf","unsigned","long","slice","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","_getIndex","index","_readIndex","allocUnsafe","read","numEntries","entries","Array","bufSize","entryNumber","compressedPosition","uncompressedPosition","getLastBlock","getRelevantBlocksForRead","position","endPosition","relevant","compare","entry","nextEntry","nextUncompressedPosition","Infinity","lowerBound","upperBound","searchPosition","Math","floor","comparison","ceil","BgzFilehandle","gziFilehandle","gziPath","gzi","stat","compressedStat","Object","assign","size","getUncompressedFileSize","blocks","undefined","blksize","bytesRead","readUInt32LE","_readAndUncompressBlock","blockBuffer","nextCompressedPosition","next","blockCompressedLength","blockPositions","destinationOffset","blockNum","uncompressedBuffer","sourceOffset","sourceEnd","min","copy"],"sourceRoot":""}