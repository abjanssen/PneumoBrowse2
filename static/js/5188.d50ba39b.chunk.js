"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[5188],{95670(e,t,n){n.d(t,{A:()=>a});class i{}class s{constructor(){this.signals=new Set,this.abortController=new AbortController}addSignal(e=new i){if(this.signal.aborted)throw new Error("cannot add a signal, already aborted!");this.signals.add(e),e.aborted?this.handleAborted(e):"function"==typeof e.addEventListener&&e.addEventListener("abort",()=>{this.handleAborted(e)})}handleAborted(e){this.signals.delete(e),0===this.signals.size&&this.abortController.abort()}get signal(){return this.abortController.signal}abort(){this.abortController.abort()}}class r{constructor(){this.callbacks=new Set}addCallback(e=()=>{}){this.callbacks.add(e),this.currentMessage&&e(this.currentMessage)}callback(e){this.currentMessage=e;for(const t of this.callbacks)t(e)}}class a{constructor({fill:e,cache:t}){if("function"!=typeof e)throw new TypeError("must pass a fill function");if("object"!=typeof t)throw new TypeError("must pass a cache object");if("function"!=typeof t.get||"function"!=typeof t.set||"function"!=typeof t.delete)throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");this.cache=t,this.fillCallback=e}static isAbortException(e){return"AbortError"===e.name||"ERR_ABORTED"===e.code||"AbortError: aborted"===e.message||"Error: aborted"===e.message}evict(e,t){this.cache.get(e)===t&&this.cache.delete(e)}fill(e,t,n,i){const a=new s,o=new r;o.addCallback(i);const c={aborter:a,promise:this.fillCallback(t,a.signal,e=>{o.callback(e)}),settled:!1,statusReporter:o,get aborted(){return this.aborter.signal.aborted}};c.aborter.addSignal(n),c.aborter.signal.addEventListener("abort",()=>{c.settled||this.evict(e,c)}),c.promise.then(()=>{c.settled=!0},()=>{c.settled=!0,this.evict(e,c)}).catch(e=>{throw console.error(e),e}),this.cache.set(e,c)}static checkSinglePromise(e,t){function n(){if(t?.aborted)throw Object.assign(new Error("aborted"),{code:"ERR_ABORTED"})}return e.then(e=>(n(),e),e=>{throw n(),e})}has(e){return this.cache.has(e)}get(e,t,n,i){if(!n&&t instanceof AbortSignal)throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");const s=this.cache.get(e);return s?s.aborted&&!s.settled?(this.evict(e,s),this.get(e,t,n,i)):s.settled?s.promise:(s.aborter.addSignal(n),s.statusReporter.addCallback(i),a.checkSinglePromise(s.promise,n)):(this.fill(e,t,n,i),a.checkSinglePromise(this.cache.get(e).promise,n))}delete(e){const t=this.cache.get(e);t&&(t.settled||t.aborter.abort(),this.cache.delete(e))}clear(){const e=this.cache.keys();let t=0;for(let n=e.next();!n.done;n=e.next())this.delete(n.value),t+=1;return t}}},45188(e,t,n){n.d(t,{wD:()=>v});var i=n(95670),s=n(91219),r=n(47664),a=n(99496),o=n(6794);class c{constructor(e,t,n,i){this.minv=e,this.maxv=t,this.bin=n,this._fetchedSize=i}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return void 0!==this._fetchedSize?this._fetchedSize:this.maxv.blockPosition+65536-this.minv.blockPosition}}class l{constructor({filehandle:e,renameRefSeqs:t=e=>e}){this.filehandle=e,this.renameRefSeq=t}async getMetadata(e={}){const{indices:t,...n}=await this.parse(e);return n}_findFirstData(e,t){return e?e.compareTo(t)>0?t:e:t}async parse(e={}){return this.parseP||(this.parseP=this._parse(e).catch(e=>{throw this.parseP=void 0,e})),this.parseP}async hasRefSeq(e,t={}){const n=await this.parse(t);return!!n.indices[e]?.binIndex}_parseNameBytes(e){let t=0,n=0;const i=[],s={},r=new TextDecoder("utf8");for(let a=0;a<e.length;a+=1)if(!e[a]){if(n<a){const o=this.renameRefSeq(r.decode(e.subarray(n,a)));i[t]=o,s[o]=t}n=a+1,t+=1}return{refNameToId:s,refIdToName:i}}}function h(e,t=0){const n=e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24;return 4294967296*((e[t+4]|e[t+5]<<8|e[t+6]<<16|e[t+7]<<24)>>>0)+(n>>>0)}function d(e,t){return t.minv.blockPosition-e.maxv.blockPosition<65e3&&t.maxv.blockPosition-e.minv.blockPosition<5e6}function f(e,t){const n=[];let i;if(0===e.length)return e;e.sort(function(e,t){const n=e.minv.blockPosition-t.minv.blockPosition;return 0===n?e.minv.dataPosition-t.minv.dataPosition:n});for(const s of e)(!t||s.maxv.compareTo(t)>0)&&(void 0===i?(n.push(s),i=s):d(i,s)?s.maxv.compareTo(i.maxv)>0&&(i.maxv=s.maxv):(n.push(s),i=s));return n}class u{constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}}function m(e,t=0){return new u(1099511627776*e[t+7]+4294967296*e[t+6]+16777216*e[t+5]+65536*e[t+4]+256*e[t+3]+e[t+2],e[t+1]<<8|e[t])}const b={0:"generic",1:"SAM",2:"VCF"};function g(e,t){return e*2**t}function w(e,t){return Math.floor(e/2**t)}class p extends l{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e,t={}){const n=await this.parse(t),i=n.refNameToId[e];if(void 0===i)return-1;if(!n.indices[i])return-1;const{stats:s}=n.indices[i];return s?s.lineCount:-1}indexCov(){throw new Error("CSI indexes do not support indexcov")}parseAuxData(e,t){const n=new DataView(e.buffer),i=n.getInt32(t,!0),s=65536&i?"zero-based-half-open":"1-based-closed",r=b[15&i];if(!r)throw new Error(`invalid Tabix preset format flags ${i}`);const a={ref:n.getInt32(t+4,!0),start:n.getInt32(t+8,!0),end:n.getInt32(t+12,!0)},o=n.getInt32(t+16,!0),c=o?String.fromCharCode(o):void 0,l=n.getInt32(t+20,!0),h=n.getInt32(t+24,!0),{refIdToName:d,refNameToId:f}=this._parseNameBytes(e.subarray(t+28,t+28+h));return{refIdToName:d,refNameToId:f,skipLines:l,metaChar:c,columnNumbers:a,format:r,coordinateType:s}}async _parse(e={}){const t=await(0,s.$1)(await this.filehandle.readFile(e)),n=new DataView(t.buffer);let i;if(21582659===n.getUint32(0,!0))i=1;else{if(38359875!==n.getUint32(0,!0))throw new Error("Not a CSI file");i=2}this.minShift=n.getInt32(4,!0),this.depth=n.getInt32(8,!0),this.maxBinNumber=((1<<3*(this.depth+1))-1)/7;const r=2**(this.minShift+3*this.depth),a=n.getInt32(12,!0),o=a&&a>=30?this.parseAuxData(t,16):{refIdToName:[],refNameToId:{},metaChar:void 0,columnNumbers:{ref:0,start:1,end:2},coordinateType:"zero-based-half-open",format:"generic"},l=n.getInt32(16+a,!0);let h,d=16+a+4;const f=new Array(l).fill(0).map(()=>{const e=n.getInt32(d,!0);d+=4;const i={};let s;for(let r=0;r<e;r+=1){const e=n.getUint32(d,!0);if(e>this.maxBinNumber)s=this.parsePseudoBin(t,d+4),d+=48;else{const s=m(t,d+4);h=this._findFirstData(h,s);const r=n.getInt32(d+12,!0);d+=16;const a=new Array(r);for(let n=0;n<r;n+=1){const i=m(t,d),s=m(t,d+8);d+=16,a[n]=new c(i,s,e)}i[e]=a}}return{binIndex:i,stats:s}});return{...o,csi:!0,refCount:l,maxBlockSize:65536,firstDataLine:h,csiVersion:i,indices:f,depth:this.depth,maxBinNumber:this.maxBinNumber,maxRefLength:r}}parsePseudoBin(e,t){return{lineCount:h(e,t+28)}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const s=await this.parse(i),r=s.refNameToId[e];if(void 0===r)return[];const a=s.indices[r];if(!a)return[];const o=this.reg2bins(t,n),l=[];for(const[e,t]of o)for(let n=e;n<=t;n++)if(a.binIndex[n])for(const e of a.binIndex[n])l.push(new c(e.minv,e.maxv,n));return f(l,new u(0,0))}reg2bins(e,t){(e-=1)<1&&(e=1),t>2**50&&(t=2**34),t-=1;let n=0,i=0,s=this.minShift+3*this.depth;const r=[];for(;n<=this.depth;s-=3,i+=g(1,3*n),n+=1){const n=i+w(e,s),a=i+w(t,s);if(a-n+r.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);r.push([n,a])}return r}}class x extends l{async lineCount(e,t={}){const n=await this.parse(t),i=n.refNameToId[e];return void 0===i?-1:n.indices[i]?n.indices[i].stats?.lineCount??-1:-1}async _parse(e={}){const t=await this.filehandle.readFile(e),n=await(0,s.$1)(t),i=new DataView(n.buffer);if(21578324!==i.getUint32(0,!0))throw new Error("Not a TBI file");const r=i.getUint32(4,!0),a=i.getUint32(8,!0),o=65536&a?"zero-based-half-open":"1-based-closed",l={0:"generic",1:"SAM",2:"VCF"}[15&a];if(!l)throw new Error(`invalid Tabix preset format flags ${a}`);const h={ref:i.getInt32(12,!0),start:i.getInt32(16,!0),end:i.getInt32(20,!0)},d=i.getInt32(24,!0),f=d?String.fromCharCode(d):void 0,u=i.getInt32(28,!0),b=i.getInt32(32,!0),{refNameToId:g,refIdToName:w}=this._parseNameBytes(n.slice(36,36+b));let p,x=36+b;return{indices:new Array(r).fill(0).map(()=>{const e=i.getInt32(x,!0);x+=4;const t={};let s;for(let r=0;r<e;r+=1){const e=i.getUint32(x,!0);if(x+=4,e>37450)throw new Error("tabix index contains too many bins, please use a CSI index");if(37450===e){const e=i.getInt32(x,!0);x+=4,2===e&&(s=this.parsePseudoBin(n,x)),x+=16*e}else{const s=i.getInt32(x,!0);x+=4;const r=new Array(s);for(let t=0;t<s;t+=1){const i=m(n,x),s=m(n,x+8);x+=16,p=this._findFirstData(p,i),r[t]=new c(i,s,e)}t[e]=r}}const r=i.getInt32(x,!0);x+=4;const a=new Array(r);for(let e=0;e<r;e+=1)a[e]=m(n,x),x+=8,p=this._findFirstData(p,a[e]);return{binIndex:t,linearIndex:a,stats:s}}),metaChar:f,maxBinNumber:37449,maxRefLength:536870912,skipLines:u,firstDataLine:p,columnNumbers:h,coordinateType:o,format:l,refIdToName:w,refNameToId:g,maxBlockSize:65536}}parsePseudoBin(e,t){return{lineCount:h(e,t+16)}}async blocksForRange(e,t,n,i={}){t<0&&(t=0);const s=await this.parse(i),r=s.refNameToId[e];if(void 0===r)return[];const a=s.indices[r];if(!a)return[];(a.linearIndex.length>0?a.linearIndex[t>>14>=a.linearIndex.length?a.linearIndex.length-1:t>>14]:new u(0,0))||console.warn("querying outside of possible tabix range");const o=(l=t,h=n,[[0,0],[1+((l+=1)>>26),1+((h-=1)>>26)],[9+(l>>23),9+(h>>23)],[73+(l>>20),73+(h>>20)],[585+(l>>17),585+(h>>17)],[4681+(l>>14),4681+(h>>14)]]);var l,h;const d=[];for(const[e,t]of o)for(let n=e;n<=t;n++)if(a.binIndex[n])for(const e of a.binIndex[n])d.push(new c(e.minv,e.maxv,n));const m=a.linearIndex.length;let b;const g=Math.min(t>>14,m-1),w=Math.min(n>>14,m-1);for(let e=g;e<=w;++e){const t=a.linearIndex[e];t&&(!b||t.compareTo(b)<0)&&(b=t)}return f(d,b)}}class v{constructor({path:e,filehandle:t,url:n,tbiPath:s,tbiUrl:c,tbiFilehandle:l,csiPath:h,csiUrl:d,csiFilehandle:f,renameRefSeqs:u,chunkCacheSize:m=5242880}){this.cache=new r.A({maxSize:1e3});const b=u??(e=>e);if(t)this.filehandle=t;else if(e)this.filehandle=new a.EY(e);else{if(!n)throw new TypeError("must provide either filehandle or path");this.filehandle=new o.A(n)}if(l)this.index=new x({filehandle:l,renameRefSeqs:b});else if(f)this.index=new p({filehandle:f,renameRefSeqs:b});else if(s)this.index=new x({filehandle:new a.EY(s),renameRefSeqs:b});else if(h)this.index=new p({filehandle:new a.EY(h),renameRefSeqs:b});else if(e)this.index=new x({filehandle:new a.EY(`${e}.tbi`),renameRefSeqs:b});else if(d)this.index=new p({filehandle:new o.A(d)});else if(c)this.index=new x({filehandle:new o.A(c)});else{if(!n)throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl");this.index=new x({filehandle:new o.A(`${n}.tbi`)})}this.renameRefSeq=b,this.hasCustomRenameRefSeq=void 0!==u,this.chunkCache=new i.A({cache:new r.A({maxSize:Math.floor(m/65536)}),fill:(e,t)=>this.readChunk(e,{signal:t})})}calculateFileOffset(e,t,n,i,s){return 256*e[n]+(i-t[n])+s+1}async getLines(e,t,n,i){let s,r,a={};"function"==typeof i?r=i:(a=i,r=i.lineCallback,s=i.signal);const o=await this.index.getMetadata(a),c=t??0,l=n??o.maxRefLength;if(!(c<=l))throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");if(c===l)return;const h=await this.index.blocksForRange(e,c,l,a),d=new TextDecoder("utf8"),f="VCF"===o.format,u={ref:o.columnNumbers.ref||0,start:o.columnNumbers.start||0,end:f?8:o.columnNumbers.end||0},m=Math.max(u.ref,u.start,u.end),b=o.metaChar?.charCodeAt(0),g="1-based-closed"===o.coordinateType?-1:0,w=!this.hasCustomRenameRefSeq;for(const t of h){const{buffer:n,cpositions:i,dpositions:a}=await this.chunkCache.get(t.toString(),t,s);let o=0,h=0;const p=d.decode(n);if(n.length==p.length)for(;o<p.length;){const n=p.indexOf("\n",o);if(-1===n)break;const s=p.slice(o,n);if(a){const e=o+t.minv.dataPosition;for(;h<a.length&&e>=a[h];)h++}const d=this.checkLine(e,c,l,s,u.ref,u.start,u.end,m,b,g,f,w);if(null===d)return;void 0!==d&&r(s,this.calculateFileOffset(i,a,h,o,t.minv.dataPosition),d.start,d.end),o=n+1}else for(;o<n.length;){const s=n.indexOf("\n".charCodeAt(0),o);if(-1===s)break;const p=n.slice(o,s),x=d.decode(p);if(a){const e=o+t.minv.dataPosition;for(;h<a.length&&e>=a[h];)h++}const v=this.checkLine(e,c,l,x,u.ref,u.start,u.end,m,b,g,f,w);if(null===v)return;void 0!==v&&r(x,this.calculateFileOffset(i,a,h,o,t.minv.dataPosition),v.start,v.end),o=s+1}}}async getMetadata(e={}){return this.index.getMetadata(e)}async getHeaderBuffer(e={}){const{firstDataLine:t,metaChar:n,maxBlockSize:i}=await this.getMetadata(e),r=(t?.blockPosition||0)+i,a=await this.filehandle.read(r,0,e),o=await(0,s.$1)(a);if(n){let e=-1;const t="\n".charCodeAt(0),i=n.charCodeAt(0);for(let n=0,s=o.length;n<s;n++){const s=o[n];if(n===e+1&&s!==i)break;s===t&&(e=n)}return o.subarray(0,e+1)}return o}async getHeader(e={}){const t=new TextDecoder("utf8"),n=await this.getHeaderBuffer(e);return t.decode(n)}async getReferenceSequenceNames(e={}){return(await this.getMetadata(e)).refIdToName}checkLine(e,t,n,i,s,r,a,o,c,l,h,d){if(void 0!==c&&i.charCodeAt(0)===c)return;if(i.length<500){const o=i.split("\t"),c=o[s-1];if(!(d?c===e:this.renameRefSeq(c)===e))return;const f=+o[r-1]+l;if(f>=n)return null;let u;if(u=0===a||a===r?f+1:h?this._getVcfEnd(f,o[3],o[a-1]):+o[a-1],u<=t)return;return{start:f,end:u}}let f=-1;const u=[-1];for(let e=0;e<o;e++){const e=i.indexOf("\t",f+1);if(-1===e){u.push(i.length);break}u.push(e),f=e}const m=i.slice(u[s-1]+1,u[s]);if(!(d?m===e:this.renameRefSeq(m)===e))return;const b=+i.slice(u[r-1]+1,u[r])+l;if(b>=n)return null;let g;return g=0===a||a===r?b+1:h?this._getVcfEnd(b,i.slice(u[3]+1,u[4]),i.slice(u[a-1]+1,u[a])):+i.slice(u[a-1]+1,u[a]),g<=t?void 0:{start:b,end:g}}_getVcfEnd(e,t,n){let i=e+t.length;if(n.includes("SVTYPE=TRA"))return e+1;if("."!==n[0]){const e=n.indexOf("END=");if(-1!==e&&(0===e||";"===n[e-1])){const t=e+4;let s=n.indexOf(";",t);-1===s&&(s=n.length),i=Number.parseInt(n.slice(t,s),10)}}return i}async lineCount(e,t={}){return this.index.lineCount(e,t)}async readChunk(e,t={}){const n=await this.filehandle.read(e.fetchedSize(),e.minv.blockPosition,t);return(0,s.i2)(n,e,this.cache)}}}}]);
//# sourceMappingURL=5188.d50ba39b.chunk.js.map