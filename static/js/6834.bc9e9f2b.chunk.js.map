{"version":3,"file":"static/js/6834.bc9e9f2b.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BigBedAdapter/BigBedAdapter.ts","../../../plugins/bed/src/util.ts"],"sourcesContent":["import { BigBed } from '@gmod/bbi'\nimport BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport {\n  doesIntersect2,\n  max,\n  min,\n  Feature,\n  SimpleFeature,\n} from '@jbrowse/core/util'\nimport { Observer } from 'rxjs'\nimport { SimpleFeatureSerializedNoId } from '@jbrowse/core/util/simpleFeature'\n\n// locals\nimport {\n  isUcscProcessedTranscript,\n  makeBlocks,\n  ucscProcessedTranscript,\n} from '../util'\n\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n  private cached?: Promise<{\n    bigbed: BigBed\n    header: Awaited<ReturnType<BigBed['getHeader']>>\n    parser: BED\n  }>\n\n  public async configurePre(opts?: BaseOptions) {\n    const pm = this.pluginManager\n    const bigbed = new BigBed({\n      filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n    })\n    const header = await bigbed.getHeader(opts)\n    const parser = new BED({ autoSql: header.autoSql })\n    return { bigbed, header, parser }\n  }\n\n  public async configure(opts?: BaseOptions) {\n    if (!this.cached) {\n      this.cached = this.configurePre(opts).catch((e: unknown) => {\n        this.cached = undefined\n        throw e\n      })\n    }\n    return this.cached\n  }\n\n  public async getRefNames(opts?: BaseOptions) {\n    const { header } = await this.configure(opts)\n    return Object.keys(header.refsByName)\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { parser, header } = await this.configure(opts)\n    const { version, fileType } = header\n    const { fields, ...rest } = parser.autoSql\n    return {\n      version,\n      fileType,\n      autoSql: { ...rest },\n      fields: Object.fromEntries(\n        fields.map(({ name, comment }) => [name, comment]),\n      ),\n    }\n  }\n\n  public async getFeaturesHelper(\n    query: Region,\n    opts: BaseOptions,\n    observer: Observer<Feature>,\n    allowRedispatch: boolean,\n    originalQuery = query,\n  ) {\n    const { signal } = opts\n    const scoreColumn = this.getConf('scoreColumn')\n    const aggregateField = this.getConf('aggregateField')\n    const { parser, bigbed } = await this.configure(opts)\n    const feats = await bigbed.getFeatures(\n      query.refName,\n      query.start,\n      query.end,\n      {\n        signal,\n        basesPerSpan: query.end - query.start,\n      },\n    )\n    if (allowRedispatch && feats.length) {\n      let minStart = Number.POSITIVE_INFINITY\n      let maxEnd = Number.NEGATIVE_INFINITY\n      for (const feat of feats) {\n        if (feat.start < minStart) {\n          minStart = feat.start\n        }\n        if (feat.end > maxEnd) {\n          maxEnd = feat.end\n        }\n      }\n      if (maxEnd > query.end || minStart < query.start) {\n        await this.getFeaturesHelper(\n          { ...query, start: minStart, end: maxEnd },\n          opts,\n          observer,\n          false,\n          query,\n        )\n        return\n      }\n    }\n\n    const parentAggregation = {} as Record<\n      string,\n      SimpleFeatureSerializedNoId[]\n    >\n\n    if (feats.some(f => f.uniqueId === undefined)) {\n      throw new Error('found uniqueId undefined')\n    }\n    for (const feat of feats) {\n      const data = parser.parseLine(\n        `${query.refName}\\t${feat.start}\\t${feat.end}\\t${feat.rest}`,\n        { uniqueId: feat.uniqueId! },\n      )\n\n      const aggr = data[aggregateField]\n      if (!parentAggregation[aggr]) {\n        parentAggregation[aggr] = []\n      }\n      const {\n        uniqueId,\n        type,\n        chromStart,\n        chromStarts,\n        blockStarts,\n        blockCount,\n        blockSizes,\n        chromEnd,\n        thickStart,\n        thickEnd,\n        chrom,\n        score,\n        ...rest\n      } = data\n\n      const subfeatures = blockCount\n        ? makeBlocks({\n            chromStarts,\n            blockStarts,\n            blockCount,\n            blockSizes,\n            uniqueId,\n            refName: query.refName,\n            start: feat.start,\n          })\n        : []\n\n      if (isUcscProcessedTranscript(data)) {\n        const f = ucscProcessedTranscript({\n          ...rest,\n          uniqueId,\n          type,\n          start: feat.start,\n          end: feat.end,\n          refName: query.refName,\n          score: scoreColumn ? +data[scoreColumn] : score,\n          chromStarts,\n          blockCount,\n          blockSizes,\n          thickStart,\n          thickEnd,\n          subfeatures,\n        })\n        if (aggr) {\n          parentAggregation[aggr].push(f)\n        } else {\n          if (\n            doesIntersect2(\n              f.start,\n              f.end,\n              originalQuery.start,\n              originalQuery.end,\n            )\n          ) {\n            observer.next(\n              new SimpleFeature({ id: `${this.id}-${uniqueId}`, data: f }),\n            )\n          }\n        }\n      } else {\n        if (\n          doesIntersect2(\n            feat.start,\n            feat.end,\n            originalQuery.start,\n            originalQuery.end,\n          )\n        ) {\n          observer.next(\n            new SimpleFeature({\n              id: `${this.id}-${uniqueId}`,\n              data: {\n                ...rest,\n                uniqueId,\n                type,\n                start: feat.start,\n                score: scoreColumn ? +data[scoreColumn] : score,\n                end: feat.end,\n                refName: query.refName,\n                subfeatures,\n              },\n            }),\n          )\n        }\n      }\n    }\n\n    Object.entries(parentAggregation).map(([name, subfeatures]) => {\n      const s = min(subfeatures.map(f => f.start))\n      const e = max(subfeatures.map(f => f.end))\n      if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n        const { uniqueId, strand } = subfeatures[0]!\n        observer.next(\n          new SimpleFeature({\n            id: `${this.id}-${uniqueId}-parent`,\n            data: {\n              type: 'gene',\n              subfeatures,\n              strand,\n              name,\n              start: s,\n              end: e,\n              refName: query.refName,\n            },\n          }),\n        )\n      }\n    })\n    observer.complete()\n  }\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        await this.getFeaturesHelper(query, opts, observer, true)\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","import BED from '@gmod/bed'\nimport { SimpleFeature } from '@jbrowse/core/util'\n\nexport interface MinimalFeature {\n  type: string\n  start: number\n  end: number\n  refName: string\n  [key: string]: unknown\n}\nexport interface TranscriptFeat extends MinimalFeature {\n  thickStart: number\n  thickEnd: number\n  blockCount: number\n  blockSizes: number[]\n  chromStarts: number[]\n  refName: string\n  strand?: number\n  subfeatures: MinimalFeature[]\n}\n\nexport function ucscProcessedTranscript(feature: TranscriptFeat) {\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    blockSizes,\n    chromStarts,\n    refName,\n    strand = 0,\n    ...rest\n  } = feature\n\n  if (!thickStart || !thickEnd || !strand) {\n    return feature\n  }\n\n  const subfeatures: MinimalFeature[] = []\n  oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n    .forEach(block => {\n      const start = block.start\n      const end = block.end\n      if (thickStart >= end) {\n        // left-side UTR\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n        // UTR | CDS\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push(\n          {\n            type: `${prime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            start: thickStart,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd >= end) {\n        // CDS\n        subfeatures.push({\n          type: 'CDS',\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd < end) {\n        // UTR | CDS | UTR\n        const leftPrime = strand > 0 ? 'five' : 'three'\n        const rightPrime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: `${leftPrime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            start: thickStart,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${rightPrime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n        // CDS | UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: 'CDS',\n            start,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${prime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickEnd <= start) {\n        // right-side UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      }\n    })\n\n  return { ...rest, strand, type: 'mRNA', refName, subfeatures }\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  const obj = Object.fromEntries(\n    line.split('\\t').map((f, i) => [fields[i]!, f] as const),\n  )\n  const {\n    blockStarts,\n    blockCount,\n    chromStarts,\n    thickEnd,\n    thickStart,\n    blockSizes,\n    ...rest\n  } = obj\n\n  return {\n    ...rest,\n    blockStarts: blockStarts?.split(',').map(r => +r),\n    chromStarts: chromStarts?.split(',').map(r => +r),\n    blockSizes: blockSizes?.split(',').map(r => +r),\n    thickStart: thickStart ? +thickStart : undefined,\n    thickEnd: thickEnd ? +thickEnd : undefined,\n    blockCount: blockCount ? +blockCount : undefined,\n  } as Record<string, unknown>\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes: number[]\n  blockStarts?: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts || blockStarts || []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] || 0) + start\n    const bmax = bmin + (blockSizes[b] || 0)\n    subfeatures.push({\n      uniqueId: `${uniqueId}-${b}`,\n      start: bmin,\n      end: bmax,\n      refName,\n      type: 'block',\n    })\n  }\n  return subfeatures\n}\nexport function featureData(\n  line: string,\n  colRef: number,\n  colStart: number,\n  colEnd: number,\n  scoreColumn: string,\n  parser: BED,\n  uniqueId: string,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const refName = l[colRef]!\n  const start = +l[colStart]!\n  const colSame = colStart === colEnd ? 1 : 0\n  const end = +l[colEnd]! + colSame\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n\n  const {\n    blockCount,\n    blockSizes,\n    blockStarts,\n    chromStarts,\n    thickStart,\n    thickEnd,\n    type,\n    score,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n  const subfeatures = blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts,\n        blockCount,\n        blockSizes,\n        blockStarts,\n      })\n    : []\n  const f = {\n    ...rest,\n    type,\n    score: scoreColumn ? +data[scoreColumn] : score,\n    start,\n    end,\n    refName,\n    uniqueId,\n    subfeatures,\n  }\n  return new SimpleFeature({\n    id: uniqueId,\n    data: isUcscProcessedTranscript(data)\n      ? ucscProcessedTranscript({\n          thickStart: thickStart!,\n          thickEnd: thickEnd!,\n          blockCount: blockCount!,\n          blockSizes: blockSizes!,\n          chromStarts: chromStarts,\n          ...f,\n        })\n      : f,\n  })\n}\n\nexport function isUcscProcessedTranscript(f: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return f.thickStart && f.blockCount && f.strand !== 0\n}\n"],"names":["BigBedAdapter","BaseFeatureDataAdapter","configurePre","opts","pm","this","pluginManager","bigbed","BigBed","filehandle","openLocation","getConf","header","getHeader","parser","BED","autoSql","configure","cached","catch","e","undefined","getRefNames","Object","keys","refsByName","version","fileType","fields","rest","fromEntries","map","name","comment","getFeaturesHelper","query","observer","allowRedispatch","originalQuery","signal","scoreColumn","aggregateField","feats","getFeatures","refName","start","end","basesPerSpan","length","minStart","Number","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","feat","parentAggregation","some","f","uniqueId","Error","data","parseLine","aggr","type","chromStart","chromStarts","blockStarts","blockCount","blockSizes","chromEnd","thickStart","thickEnd","chrom","score","subfeatures","makeBlocks","isUcscProcessedTranscript","ucscProcessedTranscript","push","doesIntersect2","next","SimpleFeature","id","entries","s","min","max","strand","complete","ObservableCreate","async","error","freeResources","feature","oldSubfeatures","filter","child","sort","a","b","forEach","block","prime","leftPrime","rightPrime","starts","bmin","bmax","featureData","line","colRef","colStart","colEnd","names","l","split","colSame","obj","i","r","defaultParser","_1","_2","_3"],"sourceRoot":""}