{"version":3,"file":"static/js/7192.0d0f9919.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/SNPCoverageRenderer/makeImage.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\nimport {\n  bpSpanPx,\n  featureSpanPx,\n  forEachWithStopTokenCheck,\n} from '@jbrowse/core/util'\nimport {\n  YSCALEBAR_LABEL_OFFSET,\n  getOrigin,\n  getScale,\n} from '@jbrowse/plugin-wiggle'\n\nimport { alphaColor } from '../shared/util'\n\nimport type { RenderArgsDeserializedWithFeatures } from './types'\nimport type { BaseCoverageBin } from '../shared/types'\n\n// width/height of the triangle above e.g. insertion indicators\nconst INTERBASE_INDICATOR_WIDTH = 7\nconst INTERBASE_INDICATOR_HEIGHT = 4.5\n\n// minimum read depth to draw the insertion indicators, below this the\n// 'statistical significance' is low\nconst MINIMUM_INTERBASE_INDICATOR_READ_DEPTH = 7\n\nconst complementBase = {\n  C: 'G',\n  G: 'C',\n  A: 'T',\n  T: 'A',\n} as const\n\nconst fudgeFactor = 0.6\n\ninterface StrandCounts {\n  readonly entryDepth: number\n  readonly '1': number\n  readonly '-1': number\n  readonly '0': number\n}\n\ninterface ModificationCountsParams {\n  readonly base: string\n  readonly isSimplex: boolean\n  readonly refbase: string | undefined\n  readonly snps: Readonly<Record<string, Partial<StrandCounts>>>\n  readonly ref: StrandCounts\n  readonly score0: number\n}\n\ninterface ModificationCountsResult {\n  readonly modifiable: number\n  readonly detectable: number\n}\n\n/**\n * Calculate modifiable and detectable counts for a modification following IGV's algorithm.\n *\n * @param params.base - The canonical base (e.g., 'A' for A+a modification)\n * @param params.isSimplex - Whether this modification is simplex (only on one strand)\n * @param params.refbase - The reference base at this position\n * @param params.snps - SNP counts at this position\n * @param params.ref - Reference match counts at this position\n * @param params.score0 - Total coverage at this position\n * @returns Object with modifiable and detectable counts\n */\nfunction calculateModificationCounts({\n  base,\n  isSimplex,\n  refbase,\n  snps,\n  ref,\n  score0,\n}: ModificationCountsParams): ModificationCountsResult {\n  // Handle N base (all bases are modifiable/detectable)\n  if (base === 'N') {\n    return { modifiable: score0, detectable: score0 }\n  }\n\n  const cmp = complementBase[base as keyof typeof complementBase]\n\n  // Calculate total reads for base and complement\n  // IGV: getCount(pos, base) = reads matching that base (from SNPs or ref)\n  const baseCount =\n    (snps[base]?.entryDepth || 0) + (refbase === base ? ref.entryDepth : 0)\n  const complCount =\n    (snps[cmp]?.entryDepth || 0) + (refbase === cmp ? ref.entryDepth : 0)\n\n  // Modifiable: reads that COULD have this modification (base or complement)\n  // IGV: modifiable = getCount(pos, base) + getCount(pos, compl)\n  const modifiable = baseCount + complCount\n\n  // Detectable: reads where we can DETECT this modification\n  // For simplex: only specific strands (+ for base, - for complement)\n  // For duplex: all reads (same as modifiable)\n  // IGV: detectable = simplex ? getPosCount(base) + getNegCount(compl) : modifiable\n  const detectable = isSimplex\n    ? (snps[base]?.['1'] || 0) +\n      (snps[cmp]?.['-1'] || 0) +\n      (refbase === base ? ref['1'] : 0) +\n      (refbase === cmp ? ref['-1'] : 0)\n    : modifiable\n\n  return { modifiable, detectable }\n}\n\nexport async function makeImage(\n  ctx: CanvasRenderingContext2D,\n  props: RenderArgsDeserializedWithFeatures,\n) {\n  const {\n    features,\n    regions,\n    bpPerPx,\n    colorBy,\n    displayCrossHatches,\n    visibleModifications = {},\n    simplexModifications = [],\n    scaleOpts,\n    height: unadjustedHeight,\n    theme: configTheme,\n    config: cfg,\n    ticks,\n    stopToken,\n  } = props\n  const theme = createJBrowseTheme(configTheme)\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the\n  // wiggle display, and makes the height of the actual drawn area add\n  // \"padding\" to the top and bottom of the display\n  const offset = YSCALEBAR_LABEL_OFFSET\n  const height = unadjustedHeight - offset * 2\n\n  const opts = { ...scaleOpts, range: [0, height] }\n  const viewScale = getScale(opts)\n\n  // clipping and insertion indicators, uses a smaller height/2 scale\n  const indicatorViewScale = getScale({\n    ...opts,\n    range: [0, height / 2],\n    scaleType: 'linear',\n  })\n  const originY = getOrigin(scaleOpts.scaleType)\n  const originLinear = getOrigin('linear')\n\n  const indicatorThreshold = readConfObject(cfg, 'indicatorThreshold')\n  const showInterbaseCounts = readConfObject(cfg, 'showInterbaseCounts')\n  const showArcs = readConfObject(cfg, 'showArcs')\n  const showInterbaseIndicators = readConfObject(cfg, 'showInterbaseIndicators')\n\n  // get the y coordinate that we are plotting at, this can be log scale\n  const toY = (n: number) => height - (viewScale(n) || 0) + offset\n  const toHeight = (n: number) => toY(originY) - toY(n)\n  // used specifically for indicator\n  const toY2 = (n: number) => height - (indicatorViewScale(n) || 0) + offset\n  const toHeight2 = (n: number) => toY2(originLinear) - toY2(n)\n\n  const { bases, softclip, hardclip, insertion } = theme.palette\n  const colorMap: Record<string, string> = {\n    A: bases.A.main,\n    C: bases.C.main,\n    G: bases.G.main,\n    T: bases.T.main,\n    insertion,\n    softclip,\n    hardclip,\n    total: readConfObject(cfg, 'color'),\n    mod_NONE: 'blue',\n    cpg_meth: 'red',\n    cpg_unmeth: 'blue',\n  }\n\n  // Use two pass rendering, which helps in visualizing the SNPs at higher\n  // bpPerPx First pass: draw the gray background\n  ctx.fillStyle = colorMap.total!\n  forEachWithStopTokenCheck(features.values(), stopToken, feature => {\n    if (feature.get('type') === 'skip') {\n      return\n    }\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n    const w = rightPx - leftPx + fudgeFactor\n    const score = feature.get('score') as number\n    ctx.fillRect(leftPx, toY(score), w, toHeight(score))\n  })\n\n  // Keep track of previous total which we will use it to draw the interbase\n  // indicator (if there is a sudden clip, there will be no read coverage but\n  // there will be \"clip\" coverage) at that position beyond the read.\n  //\n  // if the clip is right at a block boundary then prevTotal will not be\n  // available, so this is a best attempt to plot interbase indicator at the\n  // \"cliffs\"\n  let prevTotal = 0\n\n  // extraHorizontallyFlippedOffset is used to draw interbase items, which\n  // are located to the left when forward and right when reversed\n  const extraHorizontallyFlippedOffset = region.reversed ? 1 / bpPerPx : 0\n\n  const drawingModifications = colorBy.type === 'modifications'\n  const drawingMethylation = colorBy.type === 'methylation'\n  const isolatedModification = colorBy.modifications?.isolatedModification\n  // Pre-create Set for O(1) simplex lookups during rendering\n  const simplexSet = new Set(simplexModifications)\n\n  // Second pass: draw the SNP data, and add a minimum feature width of 1px\n  // which can be wider than the actual bpPerPx This reduces overdrawing of\n  // the grey background over the SNPs\n  forEachWithStopTokenCheck(features.values(), stopToken, feature => {\n    if (feature.get('type') === 'skip') {\n      return\n    }\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n    const snpinfo = feature.get('snpinfo') as BaseCoverageBin\n    const w = Math.max(rightPx - leftPx, 1)\n    const score0 = feature.get('score')\n    if (drawingModifications) {\n      let curr = 0\n      const refbase = snpinfo.refbase?.toUpperCase()\n      const { nonmods, mods, snps, ref } = snpinfo\n      // Sort keys once outside the loop\n      const nonmodKeys = Object.keys(nonmods).sort().reverse()\n      for (const m of nonmodKeys) {\n        // Remove prefix once for lookup\n        const modKey = m.replace(/^(nonmod_|mod_)/, '')\n        const mod = visibleModifications[modKey]\n        if (!mod) {\n          console.warn(`${m} not known yet`)\n          continue\n        }\n        if (isolatedModification && mod.type !== isolatedModification) {\n          continue\n        }\n        const { modifiable, detectable } = calculateModificationCounts({\n          base: mod.base,\n          isSimplex: simplexSet.has(mod.type),\n          refbase,\n          snps,\n          ref,\n          score0,\n        })\n\n        const { entryDepth, avgProbability = 0 } = snpinfo.nonmods[m]!\n        const modFraction = (modifiable / score0) * (entryDepth / detectable)\n        const nonModColor = 'blue'\n        const c = alphaColor(nonModColor, avgProbability)\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n\n        ctx.fillStyle = c\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - (curr + modFraction * height),\n          w,\n          modFraction * height,\n        )\n        curr += modFraction * height\n      }\n      // Sort keys once outside the loop\n      const modKeys = Object.keys(mods).sort().reverse()\n      for (const m of modKeys) {\n        const modKey = m.replace('mod_', '')\n        const mod = visibleModifications[modKey]\n        if (!mod) {\n          console.warn(`${m} not known yet`)\n          continue\n        }\n        if (isolatedModification && mod.type !== isolatedModification) {\n          continue\n        }\n        const { modifiable, detectable } = calculateModificationCounts({\n          base: mod.base,\n          isSimplex: simplexSet.has(mod.type),\n          refbase,\n          snps,\n          ref,\n          score0,\n        })\n\n        const { entryDepth, avgProbability = 0 } = mods[m]!\n        const modFraction = (modifiable / score0) * (entryDepth / detectable)\n        const baseColor = mod.color || 'black'\n        const c = alphaColor(baseColor, avgProbability)\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n\n        ctx.fillStyle = c\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - (curr + modFraction * height),\n          w,\n          modFraction * height,\n        )\n        curr += modFraction * height\n      }\n    } else if (drawingMethylation) {\n      const { depth, nonmods, mods } = snpinfo\n      let curr = 0\n\n      for (const base of Object.keys(mods).sort().reverse()) {\n        const { entryDepth } = mods[base]!\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n        ctx.fillStyle = colorMap[base] || 'black'\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - ((entryDepth + curr) / depth) * height,\n          w,\n          (entryDepth / depth) * height,\n        )\n        curr += entryDepth\n      }\n      for (const base of Object.keys(nonmods).sort().reverse()) {\n        const { entryDepth } = nonmods[base]!\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n        ctx.fillStyle = colorMap[base] || 'black'\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - ((entryDepth + curr) / depth) * height,\n          w,\n          (entryDepth / depth) * height,\n        )\n        curr += entryDepth\n      }\n    } else {\n      const { depth, snps } = snpinfo\n      let curr = 0\n      for (const base of Object.keys(snps).sort().reverse()) {\n        const { entryDepth } = snps[base]!\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n        ctx.fillStyle = colorMap[base] || 'black'\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - ((entryDepth + curr) / depth) * height,\n          w,\n          (entryDepth / depth) * height,\n        )\n        curr += entryDepth\n      }\n    }\n\n    const interbaseEvents = Object.keys(snpinfo.noncov)\n    if (showInterbaseCounts) {\n      let curr = 0\n      for (const base of interbaseEvents) {\n        const { entryDepth } = snpinfo.noncov[base]!\n        const r = 0.6\n        ctx.fillStyle = colorMap[base]!\n        ctx.fillRect(\n          leftPx - r + extraHorizontallyFlippedOffset,\n          INTERBASE_INDICATOR_HEIGHT + toHeight2(curr),\n          r * 2,\n          toHeight2(entryDepth),\n        )\n        curr += entryDepth\n      }\n    }\n\n    if (showInterbaseIndicators) {\n      let accum = 0\n      let max = 0\n      let maxBase = ''\n      for (const base of interbaseEvents) {\n        const { entryDepth } = snpinfo.noncov[base]!\n        accum += entryDepth\n        if (entryDepth > max) {\n          max = entryDepth\n          maxBase = base\n        }\n      }\n\n      // avoid drawing a bunch of indicators if coverage is very low. note:\n      // also uses the prev total in the case of the \"cliff\"\n      const indicatorComparatorScore = Math.max(score0, prevTotal)\n      if (\n        accum > indicatorComparatorScore * indicatorThreshold &&\n        indicatorComparatorScore > MINIMUM_INTERBASE_INDICATOR_READ_DEPTH\n      ) {\n        ctx.fillStyle = colorMap[maxBase]!\n        ctx.beginPath()\n        const l = leftPx + extraHorizontallyFlippedOffset\n        ctx.moveTo(l - INTERBASE_INDICATOR_WIDTH / 2, 0)\n        ctx.lineTo(l + INTERBASE_INDICATOR_WIDTH / 2, 0)\n        ctx.lineTo(l, INTERBASE_INDICATOR_HEIGHT)\n        ctx.fill()\n      }\n    }\n    prevTotal = score0\n  })\n\n  if (showArcs) {\n    forEachWithStopTokenCheck(features.values(), stopToken, feature => {\n      if (feature.get('type') !== 'skip') {\n        return\n      }\n      const s = feature.get('start')\n      const e = feature.get('end')\n      const [left, right] = bpSpanPx(s, e, region, bpPerPx)\n\n      ctx.beginPath()\n      const effectiveStrand = feature.get('effectiveStrand')\n      const pos = 'rgba(255,200,200,0.7)'\n      const neg = 'rgba(200,200,255,0.7)'\n      const neutral = 'rgba(200,200,200,0.7)'\n\n      if (effectiveStrand === 1) {\n        ctx.strokeStyle = pos\n      } else if (effectiveStrand === -1) {\n        ctx.strokeStyle = neg\n      } else {\n        ctx.strokeStyle = neutral\n      }\n\n      ctx.lineWidth = Math.log(feature.get('score') + 1)\n      ctx.moveTo(left, height - offset * 2)\n      ctx.bezierCurveTo(left, 0, right, 0, right, height - offset * 2)\n      ctx.stroke()\n    })\n  }\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(140,140,140,0.8)'\n    for (const tick of ticks.values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n}\n"],"names":["INTERBASE_INDICATOR_WIDTH","INTERBASE_INDICATOR_HEIGHT","MINIMUM_INTERBASE_INDICATOR_READ_DEPTH","complementBase","C","G","A","T","fudgeFactor","calculateModificationCounts","base","isSimplex","refbase","snps","ref","score0","modifiable","detectable","cmp","entryDepth","async","makeImage","ctx","props","features","regions","bpPerPx","colorBy","displayCrossHatches","visibleModifications","simplexModifications","scaleOpts","height","unadjustedHeight","theme","configTheme","config","cfg","ticks","stopToken","createJBrowseTheme","region","width","end","start","offset","YSCALEBAR_LABEL_OFFSET","opts","range","viewScale","getScale","indicatorViewScale","scaleType","originY","getOrigin","originLinear","indicatorThreshold","readConfObject","showInterbaseCounts","showArcs","showInterbaseIndicators","toY","n","toHeight","toY2","toHeight2","bases","softclip","hardclip","insertion","palette","colorMap","main","total","mod_NONE","cpg_meth","cpg_unmeth","fillStyle","forEachWithStopTokenCheck","values","feature","get","leftPx","rightPx","featureSpanPx","w","score","fillRect","prevTotal","extraHorizontallyFlippedOffset","reversed","drawingModifications","type","drawingMethylation","isolatedModification","modifications","simplexSet","Set","snpinfo","Math","max","curr","toUpperCase","nonmods","mods","nonmodKeys","Object","keys","sort","reverse","m","modKey","replace","mod","console","warn","has","avgProbability","modFraction","nonModColor","c","alphaColor","bottom","round","modKeys","baseColor","color","depth","interbaseEvents","noncov","r","accum","maxBase","indicatorComparatorScore","beginPath","l","moveTo","lineTo","fill","s","e","left","right","bpSpanPx","effectiveStrand","strokeStyle","lineWidth","log","bezierCurveTo","stroke","tick"],"sourceRoot":""}