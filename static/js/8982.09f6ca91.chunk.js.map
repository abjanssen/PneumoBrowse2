{"version":3,"file":"static/js/8982.09f6ca91.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/alignments/src/RenderLinearReadCloudDisplayRPC/drawFeatsStack.ts","webpack://@jbrowse/web/../../plugins/alignments/src/RenderLinearReadCloudDisplayRPC/executeRenderLinearReadCloudDisplay.ts","webpack://@jbrowse/web/../../plugins/alignments/src/shared/insertSizeStats.ts"],"sourcesContent":["import { PileupLayout } from '@jbrowse/core/util/layouts'\n\nimport type { ComputedChain } from './drawFeatsCommon.ts'\n\n/**\n * Calculate Y-offsets using PileupLayout for stack mode\n */\nexport function calculateStackYOffsetsUtil(\n  computedChains: ComputedChain[],\n  featureHeight: number,\n  noSpacing: boolean,\n  maxHeight: number,\n) {\n  const layout = new PileupLayout({\n    featureHeight,\n    spacing: noSpacing ? 0 : 2,\n    maxHeight,\n  })\n\n  const chainYOffsets = new Map<string, number>()\n  for (const { id, minX, maxX } of computedChains) {\n    const topPx = layout.addRect(id, minX, maxX, featureHeight)\n    if (topPx !== null) {\n      chainYOffsets.set(id, topPx)\n    }\n  }\n\n  return { chainYOffsets, layoutHeight: layout.getTotalHeight() }\n}\n","import { getAdapter } from '@jbrowse/core/data_adapters/dataAdapterCache'\nimport {\n  collectTransferables,\n  dedupe,\n  groupBy,\n  max,\n  min,\n  renderToAbstractCanvas,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { bpToPx } from '@jbrowse/core/util/Base1DUtils'\nimport Base1DView from '@jbrowse/core/util/Base1DViewModel'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\nimport { getSnapshot } from '@jbrowse/mobx-state-tree'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport { calculateCloudYOffsetsUtil } from './drawFeatsCloud.ts'\nimport {\n  computeChainBounds,\n  drawFeatsCore,\n  filterChains,\n  sortComputedChains,\n} from './drawFeatsCommon.ts'\nimport { calculateStackYOffsetsUtil } from './drawFeatsStack.ts'\nimport { getInsertSizeStats } from '../shared/insertSizeStats.ts'\n\nimport type { RenderLinearReadCloudDisplayArgs } from './RenderLinearReadCloudDisplay.ts'\nimport type { ComputedChain } from './drawFeatsCommon.ts'\nimport type PluginManager from '@jbrowse/core/PluginManager'\nimport type { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\n\ninterface RenderToAbstractCanvasOptions {\n  exportSVG?: { rasterizeLayers?: boolean; scale?: number }\n  highResolutionScaling?: number\n}\n\nexport async function executeRenderLinearReadCloudDisplay({\n  pluginManager,\n  args,\n}: {\n  pluginManager: PluginManager\n  args: RenderLinearReadCloudDisplayArgs\n}) {\n  const {\n    sessionId,\n    view: viewSnapshot,\n    adapterConfig,\n    sequenceAdapter,\n    config,\n    theme,\n    featureHeight,\n    noSpacing,\n    drawCloud,\n    colorBy,\n    drawSingletons,\n    drawProperPairs,\n    flipStrandLongReadChains,\n    trackMaxHeight,\n    cloudModeHeight,\n    highResolutionScaling,\n    exportSVG,\n    statusCallback = () => {},\n    stopToken,\n    visibleModifications,\n    hideSmallIndels,\n    hideMismatches,\n    hideLargeIndels,\n    showOutline,\n  } = args\n\n  const stopTokenCheck = createStopTokenChecker(stopToken)\n\n  // Recreate the view from the snapshot (displayedRegions already have renamed refNames)\n  const view = Base1DView.create(viewSnapshot)\n  // Set the volatile width which is not part of the snapshot\n  if (viewSnapshot.width) {\n    view.setVolatileWidth(viewSnapshot.width)\n  }\n\n  // Extract properties from the recreated view\n  const { bpPerPx, offsetPx } = view\n  const width = view.staticBlocks.totalWidthPx\n  // contentBlocks are derived from displayedRegions, so they have correct refNames\n  const regions = view.staticBlocks.contentBlocks\n  const assemblyName = view.assemblyNames[0]\n  if (!assemblyName) {\n    throw new Error('No assembly name found in view')\n  }\n\n  // Create a snapshot from the live view including computed properties\n  // staticBlocks is a getter so must be included explicitly\n  const snap = getSnapshot(view)\n  const viewSnap = {\n    ...snap,\n    width: view.width,\n    staticBlocks: view.staticBlocks,\n    bpToPx(arg: { refName: string; coord: number }) {\n      const res = bpToPx({\n        self: this,\n        refName: arg.refName,\n        coord: arg.coord,\n      })\n      return res !== undefined\n        ? { offsetPx: res.offsetPx, index: res.index }\n        : undefined\n    },\n  }\n\n  // Fetch chainData directly in the RPC to avoid serializing features from main thread\n  const dataAdapter = (\n    await getAdapter(pluginManager, sessionId, adapterConfig)\n  ).dataAdapter as BaseFeatureDataAdapter\n\n  // Set sequenceAdapterConfig on the adapter for CRAM files that need it\n  if (sequenceAdapter && !dataAdapter.sequenceAdapterConfig) {\n    dataAdapter.setSequenceAdapterConfig(sequenceAdapter)\n  }\n\n  const featuresArray = await updateStatus(\n    'Fetching alignments',\n    statusCallback,\n    () =>\n      firstValueFrom(\n        dataAdapter.getFeaturesInMultipleRegions(regions, args).pipe(toArray()),\n      ),\n  )\n\n  // Check stop token after fetching features\n  checkStopToken2(stopTokenCheck)\n\n  // Dedupe features by ID while preserving full Feature objects\n  const deduped = dedupe(featuresArray, f => f.id())\n\n  // Process chain data with status updates\n  const { chains, stats } = await updateStatus(\n    'Processing alignments',\n    statusCallback,\n    async () => {\n      // Single pass: collect valid TLENs for stats calculation\n      // Only use reads with proper paired flag (flag 2), skip secondary/supplementary\n      const tlens: number[] = []\n      for (const f of deduped) {\n        const flags = f.get('flags')\n        // Only keep reads mapped in proper pair (flag 2)\n        // Skip secondary (256) and supplementary (2048) alignments\n        if (flags & 2 && !(flags & 256) && !(flags & 2048)) {\n          const tlen = f.get('template_length')\n          if (tlen !== 0 && !Number.isNaN(tlen)) {\n            tlens.push(Math.abs(tlen))\n          }\n        }\n      }\n\n      let statsResult\n      if (tlens.length > 0) {\n        const insertSizeStats = getInsertSizeStats(tlens)\n        statsResult = {\n          ...insertSizeStats,\n          max: max(tlens),\n          min: min(tlens),\n        }\n      }\n\n      const chainsResult = Object.values(groupBy(deduped, f => f.get('name')))\n      return {\n        chains: chainsResult,\n        stats: statsResult,\n      }\n    },\n  )\n\n  const chainData = { chains, stats }\n\n  // Check stop token after processing chain data\n  checkStopToken2(stopTokenCheck)\n\n  // Pre-calculate actual layout height to avoid oversized canvas\n  const { computedChains } = await updateStatus(\n    'Calculating layout',\n    statusCallback,\n    async () => {\n      const filtered = filterChains(\n        chains,\n        drawSingletons,\n        drawProperPairs,\n        colorBy.type || 'insertSizeAndOrientation',\n        chainData,\n      )\n      const computed = computeChainBounds(filtered, viewSnap)\n      sortComputedChains(computed)\n      return {\n        filteredChains: filtered,\n        computedChains: computed,\n      }\n    },\n  )\n\n  let actualHeight: number\n  if (drawCloud) {\n    if (cloudModeHeight === undefined) {\n      throw new Error('cloudModeHeight is required when drawCloud is true')\n    }\n    actualHeight = cloudModeHeight\n  } else {\n    actualHeight = calculateStackYOffsetsUtil(\n      computedChains,\n      featureHeight,\n      noSpacing,\n      trackMaxHeight ?? 1200,\n    ).layoutHeight\n  }\n\n  const renderOpts: RenderToAbstractCanvasOptions = {\n    highResolutionScaling,\n    exportSVG,\n  }\n\n  // Render using renderToAbstractCanvas with actual height\n  const result = await updateStatus(\n    'Rendering alignments',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, actualHeight, renderOpts, async ctx => {\n        const {\n          layoutHeight,\n          cloudMaxDistance,\n          featuresForFlatbush,\n          mismatchFlatbush,\n          mismatchItems,\n        } = drawFeatsCore({\n          ctx,\n          params: {\n            chainData,\n            featureHeight,\n            canvasWidth: width,\n            noSpacing,\n            colorBy,\n            drawSingletons,\n            drawProperPairs,\n            flipStrandLongReadChains,\n            trackMaxHeight,\n            config,\n            theme,\n            regions,\n            bpPerPx,\n            stopTokenCheck,\n            visibleModifications,\n            hideSmallIndels,\n            hideMismatches,\n            hideLargeIndels,\n            showOutline,\n          },\n          view: viewSnap,\n          calculateYOffsets: (chains: ComputedChain[]) => {\n            return drawCloud\n              ? calculateCloudYOffsetsUtil(chains, actualHeight)\n              : calculateStackYOffsetsUtil(\n                  chains,\n                  featureHeight,\n                  noSpacing,\n                  trackMaxHeight ?? 1200,\n                )\n          },\n        })\n        return {\n          layoutHeight,\n          cloudMaxDistance,\n          featuresForFlatbush,\n          mismatchFlatbush,\n          mismatchItems,\n        }\n      }),\n  )\n\n  // Include the offsetPx in the result so the main thread can position the canvas correctly\n  const serialized = { ...result, offsetPx }\n  return rpcResult(serialized, collectTransferables(result))\n}\n","import { sum } from '@jbrowse/core/util'\n\nimport type { ReducedFeature } from './types.ts'\n\nexport function getInsertSizeStats(filtered: number[]) {\n  const len = filtered.length\n  const s = sum(filtered)\n  let sumSquared = 0\n  for (let i = 0; i < len; i++) {\n    const elt = filtered[i]!\n    sumSquared += elt * elt\n  }\n  const avg = s / len\n  const sd = Math.sqrt((len * sumSquared - s * s) / (len * len))\n  const upper = avg + 3 * sd\n  const lower = avg - 3 * sd\n  return {\n    upper,\n    lower,\n    avg,\n    sd,\n  }\n}\n\nexport function filterForPairs(features: ReducedFeature[]) {\n  return features.filter(\n    f => f.flags & 2 && !(f.flags & 256) && !(f.flags & 2048),\n  )\n}\n"],"names":["calculateStackYOffsetsUtil","computedChains","featureHeight","noSpacing","maxHeight","layout","PileupLayout","spacing","chainYOffsets","Map","id","minX","maxX","topPx","addRect","set","layoutHeight","getTotalHeight","async","executeRenderLinearReadCloudDisplay","pluginManager","args","sessionId","view","viewSnapshot","adapterConfig","sequenceAdapter","config","theme","drawCloud","colorBy","drawSingletons","drawProperPairs","flipStrandLongReadChains","trackMaxHeight","cloudModeHeight","highResolutionScaling","exportSVG","statusCallback","stopToken","visibleModifications","hideSmallIndels","hideMismatches","hideLargeIndels","showOutline","stopTokenCheck","createStopTokenChecker","Base1DView","create","width","setVolatileWidth","bpPerPx","offsetPx","staticBlocks","totalWidthPx","regions","contentBlocks","assemblyNames","Error","viewSnap","getSnapshot","bpToPx","arg","res","self","this","refName","coord","undefined","index","dataAdapter","getAdapter","sequenceAdapterConfig","setSequenceAdapterConfig","featuresArray","updateStatus","firstValueFrom","getFeaturesInMultipleRegions","pipe","toArray","checkStopToken2","deduped","dedupe","f","chains","stats","tlens","flags","get","tlen","Number","isNaN","push","Math","abs","statsResult","length","getInsertSizeStats","max","min","Object","values","groupBy","chainData","filtered","filterChains","type","computed","computeChainBounds","sortComputedChains","filteredChains","actualHeight","renderOpts","result","renderToAbstractCanvas","cloudMaxDistance","featuresForFlatbush","mismatchFlatbush","mismatchItems","drawFeatsCore","ctx","params","canvasWidth","calculateYOffsets","calculateCloudYOffsetsUtil","serialized","rpcResult","collectTransferables","len","s","sum","sumSquared","i","elt","avg","sd","sqrt","upper","lower"],"sourceRoot":""}