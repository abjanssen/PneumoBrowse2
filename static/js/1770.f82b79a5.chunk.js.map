{"version":3,"file":"static/js/1770.f82b79a5.chunk.js","mappings":"+NASO,MAAMA,EAAkB,SAE/B,SAASC,EAAUC,GAIjB,MAAO,OAHGC,KAAKC,MAAMF,EAAM,OAAe,OAChCC,KAAKC,MAAMF,EAAM,KAAO,OACxBA,EAAM,MAElB,CAmBA,MAAMG,EAAqB,CACzBC,EAAG,QACHC,EAAG,QACHC,EAAG,QACHC,EAAG,QACHC,EAAG,QACH,IAAK,SAcDC,EAAe,CACnBC,QAAS,CACPC,YAAaR,GAEfS,OAAQ,CACNC,SAAU,MACVC,SAAU,OACVH,YAjBsB,CACxBP,EAAG,QACHC,EAAG,UACHC,EAAG,UACHC,EAAG,QACHC,EAAG,QACH,IAAK,UAaLO,MAAO,CACLJ,YAAaR,IAMjB,SAASa,EAAWC,EAAeC,GAEjC,OAAc,IAAVA,EACKD,GAEFE,EAAAA,EAAAA,GAAOF,GAAOC,MAAMA,GAAOE,OACpC,CAEA,MAAMC,EAAY,EAEZC,EAAW,KAEV,SAASC,EAAMC,EAAWC,EAAWC,EAAWC,GACrD,OAAO1B,KAAKC,OAAW,IAAJsB,EAAU,IAAU,IAAJC,EAAUC,EAAI,GAAKC,EACxD,CAEO,SAASC,EACdC,EACAC,GAEA,MAAMC,GAAOC,EAAAA,EAAAA,mBAAkBH,GACzBI,EAAaF,EAAKE,WAClBC,EAAYH,EAAKG,UACjBC,EAAuBJ,EAAKI,sBAC5B,MAAEC,EAAK,OAAEC,EAAM,cAAEC,GAAkBT,EACnCU,EAAQR,EAAKQ,MACbC,EAAWT,EAAKU,MAAMC,IAAIC,GAAKA,EAAEC,SAEvCd,EAAoBe,uBAAwB,EAC5Cf,EAAoBgB,UAAU,EAAG,EAAGP,EAAOF,GAE3C,MAAMU,EAAUhB,EAAKU,MAAMC,IAAIC,GAAKA,EAAEK,UAGhCC,EAAc,EAAIT,EAASJ,GAC3Bc,EAAc,EAAIV,EAASJ,EAAQ,GAEzC,IAAK,MAAM,IAAEe,EAAG,IAAEC,EAAG,IAAEC,EAAG,IAAEC,EAAG,EAAEC,EAAC,MAAEC,KAAWlB,EAAe,CAC5D,MAAMmB,EAAMN,EAAIH,SAAWD,EAAQX,GAC7BsB,EAAMN,EAAIJ,SAAWD,EAAQX,GAC7BuB,EAAMN,EAAIL,SAAWD,EAAQX,EAAQ,GACrCwB,EAAMN,EAAIN,SAAWD,EAAQX,EAAQ,GACrCyB,EAAK5D,KAAK6D,IAAIJ,EAAMD,GACpBM,EAAK9D,KAAK6D,IAAIF,EAAMD,GACpBK,EAAO/D,KAAKgE,IAAIN,EAAKC,GACrBM,EAAOjE,KAAKkE,IAAIR,EAAKC,GACrBQ,EAAK,EACLC,EAAKhC,EACLiC,GAAOD,EAAKD,GAAM,EAExB,KACIP,GAAMxC,GAAa0C,GAAM1C,KAC3BkD,EAAAA,EAAAA,gBAAeP,EAAME,GAAO5C,EAAUS,EAAKQ,MAAQjB,GACnD,CACA,MAAMkD,EAAKjB,EAAEkB,IAAI,UACXC,GAAa,IAARF,EAAYd,EAAMD,EAGvBkB,EAAOD,IAFM,IAARF,EAAYf,EAAMC,GAEN,GAAK,EACtBkB,GAAQjB,EAAMC,EAAM,GAAK,GAAKY,EAEpC,IAAIK,EAAMH,EACNI,GAAc,IAARN,EAAYZ,EAAMD,EAC5B,GAAIH,EAAMuB,QAAU7C,EAAW,CAC7B,IAAI8C,GAAiB,EACjBC,EAAM,EACNC,EAAM,EACV,MAAMC,EAAkBlF,KAAKC,MAAMJ,EAAkB0D,EAAMuB,QAE3D,IAAK,IAAIK,EAAI,EAAGA,EAAI5B,EAAMuB,OAAQK,GAAK,EAAG,CACxC,MAAMC,GAAO7B,EAAM4B,GACbE,EAAK9B,EAAM4B,EAAI,GAEhBJ,IACHC,EAAMJ,EACNK,EAAMJ,GAGR,MAAMS,EAAKF,EAAMpC,EACXuC,EAAKH,EAAMnC,EAajB,GAXW,MAAPoC,GAAqB,MAAPA,GAAqB,MAAPA,GAC9BT,GAAOU,EAAKZ,EACZG,GAAOU,EAAKZ,GACI,MAAPU,GAAqB,MAAPA,EACvBT,GAAOU,EAAKZ,EAGE,MAAPW,IACPR,GAAOU,EAAKZ,KAKV3E,KAAKkE,IAAIc,EAAKC,EAAKL,EAAKC,GAAO,GAC/B7E,KAAKgE,IAAIgB,EAAKC,EAAKL,EAAKC,GAAOvC,GAEjC,CACA,MAAMkD,EAAYL,EAAI5B,EAAMuB,OAAS,EACrC,GACE9E,KAAK6D,IAAIe,EAAMI,IAAQ,GACvBhF,KAAK6D,IAAIgB,EAAMI,IAAQ,GACvBO,EAEAT,GAAiB,OAYjB,GAVAA,GAAiB,GAKd7C,IACQ,MAAPmD,GAAqB,MAAPA,GAAqB,MAAPA,IAC5BrF,KAAK6D,IAAIe,EAAMI,GAAO,GACtBhF,KAAK6D,IAAIgB,EAAMI,GAAO,EAEV,CACd,MAAMlF,EAAMoF,EAAID,EAAkB,EAClCrD,EAAoB4D,UAAY3F,EAAUC,IAC1C2F,EAAAA,EAAAA,IACE7D,EACAmD,EACAJ,EACAT,EACAU,EACAI,EACAb,EACAC,EACArC,GAEFH,EAAoB8D,MACtB,CAEJ,CACF,CACF,CACF,CACF,CACF,CAEO,SAASC,EACdhE,EACAiE,GAEA,MAAM/D,GAAOC,EAAAA,EAAAA,mBAAkBH,GACzBI,EAAaF,EAAKE,WAClBC,EAAYH,EAAKG,UACjBC,EAAuBJ,EAAKI,qBAC5B4D,EAA6BhE,EAAKiE,qBAClC,MAAE5D,EAAK,OAAEC,EAAM,cAAEC,EAAa,MAAEpB,EAAK,mBAAE+E,EAAkB,QAAEC,GAC/DrE,EACIU,EAAQR,EAAKQ,MACbC,EAAWT,EAAKU,MAAMC,IAAIC,GAAKA,EAAEC,SAIjCuD,EAAoB,IAAIC,IAC9B,GAAIH,EAAqB,EACvB,IAAK,MAAM,EAAE1C,KAAOjB,EAAe,CACjC,MAAM+D,EAAY9C,EAAEkB,IAAI,SAAWlB,EAAEkB,IAAI,OAASlB,EAAE+C,KAC9CC,EAAkBtG,KAAK6D,IAAIP,EAAEkB,IAAI,OAASlB,EAAEkB,IAAI,UAChD+B,EAAeL,EAAkB1B,IAAI4B,IAAc,EACzDF,EAAkBM,IAAIJ,EAAWG,EAAeD,EAClD,CAIF,MAGMG,GADJjG,EAAayF,IAA2BzF,EAAaC,SACnBC,YAG9BE,EAAuB,WAAZqF,EAAuBzF,EAAaG,OAAOC,SAAW,MACjEC,EAAuB,WAAZoF,EAAuBzF,EAAaG,OAAOE,SAAW,OAGjE6F,EAAoB,CACxBvG,EAAGY,EAAW0F,EAAetG,EAAGc,GAChCb,EAAGW,EAAW0F,EAAerG,EAAGa,GAChCZ,EAAGU,EAAW0F,EAAepG,EAAGY,GAChCX,EAAGS,EAAW0F,EAAenG,EAAGW,GAChCV,EAAGQ,EAAW0F,EAAelG,EAAGU,GAChC,IAAKF,EAAW0F,EAAe,KAAMxF,IAIjC0F,EAAoB5F,EAAWH,EAAUK,GACzC2F,EAAoB7F,EAAWF,EAAUI,GAGzC4F,EAAkB,IAAIV,IAEtBW,EAA0BV,IAC9B,IAAKS,EAAgBE,IAAIX,GAAY,CACnC,MAAMpF,EA5OZ,SAAuBoF,GACrB,MAAMY,EAZR,SAAoBC,GAClB,IAAID,EAAO,EACX,IAAK,IAAIE,EAAI,EAAGA,EAAID,EAAInC,OAAQoC,IAE9BF,GAAQA,GAAQ,GAAKA,EADRC,EAAIE,WAAWD,GAE5BF,GAAcA,EAEhB,OAAOhH,KAAK6D,IAAImD,EAClB,CAIeI,CAAWhB,GACxB,OAAOiB,EAAAA,WAAWL,EAAOK,EAAAA,WAAWvC,OACtC,CAyOoBwC,CAAclB,GAC5BS,EAAgBL,IAAIJ,EAAWrF,EAAWC,EAAOC,GACnD,CACA,OAAO4F,EAAgBrC,IAAI4B,IAG7BP,EAAW0B,YACX,MAAMzE,EAAUhB,EAAKU,MAAMC,IAAIC,GAAKA,EAAEK,UAChCyE,EAAY1E,EAAQX,GACpBsF,EAAY3E,EAAQX,EAAQ,GAC5BT,EAAiB1B,KAAKC,MAAMJ,EAAkBwC,EAAcyC,QAE5DV,EAAKhC,EACLiC,GAAOD,EAFF,GAEa,EAGlBsD,EAAiC,WAAZzB,EACrB0B,EAAgC,UAAZ1B,EAE1BJ,EAAWJ,UAAYiB,EAAkBnG,EACzCsF,EAAW+B,YAAclB,EAAkBnG,EAG3C,MAAMsH,EAAmB,IAAI1B,IAK7B,IAAK,MAAM,IAAEjD,EAAG,IAAEC,EAAG,IAAEC,EAAG,IAAEC,EAAG,EAAEC,KAAOjB,EAAe,CAErD,GAAI2D,EAAqB,EAAG,CAC1B,MAAMI,EAAY9C,EAAEkB,IAAI,SAAWlB,EAAEkB,IAAI,OAASlB,EAAE+C,KAEpD,IADoBH,EAAkB1B,IAAI4B,IAAc,GACtCJ,EAChB,QAEJ,CAEA,MAAMxC,EAAMN,EAAIH,SAAWyE,EACrB/D,EAAMN,EAAIJ,SAAWyE,EACrB9D,EAAMN,EAAIL,SAAW0E,EACrB9D,EAAMN,EAAIN,SAAW0E,EACrB7D,EAAK5D,KAAK6D,IAAIJ,EAAMD,GACpBM,EAAK9D,KAAK6D,IAAIF,EAAMD,GAI1B,GACEE,GAAMxC,GACN0C,GAAM1C,GACNsC,EAAMpB,EAAQjB,GACdqC,GAAOrC,EACP,CAEA,IAAIyG,EAAW,UACXJ,EAEFI,GAAuB,IADRxE,EAAEkB,IAAI,UACM,MAAQ,MAC1BmD,IACTG,EAAWxE,EAAEkB,IAAI,YAGdqD,EAAiBd,IAAIe,IACxBD,EAAiBrB,IAAIsB,EAAU,IAEjCD,EAAiBrD,IAAIsD,GAAWC,KAAK,CAAEvE,MAAKE,MAAKS,GAtD1C,EAsD8CC,KAAIC,OAC3D,CACF,CAGA,IAAK,MAAOyD,EAAUE,KAAUH,EAAkB,CAchD,GAXEhC,EAAW+B,YADI,QAAbE,EACuBnB,EACH,QAAbmB,EACgBlB,EACH,YAAbkB,EACgBhB,EAAuBgB,GAEvBpB,EAAkBnG,EAI7CsF,EAAW0B,YACPvF,EACF,IAAK,MAAM,IAAEwB,EAAG,IAAEE,EAAG,GAAES,EAAE,GAAEC,EAAE,IAAEC,KAAS2D,EACtCnC,EAAWoC,OAAOzE,EAAKW,GACvB0B,EAAWqC,cAAc1E,EAAKa,EAAKX,EAAKW,EAAKX,EAAKU,QAGpD,IAAK,MAAM,IAAEZ,EAAG,IAAEE,EAAG,GAAES,EAAE,GAAEC,KAAQ4D,EACjCnC,EAAWoC,OAAOzE,EAAKW,GACvB0B,EAAWsC,OAAOzE,EAAKU,GAG3ByB,EAAWuC,QACb,CAGA,MAAMC,EAAW9F,EAASJ,GACpBmG,EAAW/F,EAASJ,EAAQ,GAC5Ba,EAAc,EAAIqF,EAClBpF,EAAc,EAAIqF,EAGlBC,EAA6B,WAAZtC,EACjBuC,EAA4B,UAAZvC,EAEtBJ,EAAWJ,UAAYiB,EAAkBnG,EACzCsF,EAAW+B,YAAclB,EAAkBnG,EAC3C,IAAK,MAAM,IAAE2C,EAAG,IAAEC,EAAG,IAAEC,EAAG,IAAEC,EAAG,EAAEC,EAAC,MAAEC,KAAWlB,EAAe,CAE5D,MAAM1B,EAAS2C,EAAEkB,IAAI,UACfiE,EAAUnF,EAAEkB,IAAI,WAGtB,GAAIwB,EAAqB,EAAG,CAC1B,MAAMI,EAAY9C,EAAEkB,IAAI,SAAWlB,EAAEkB,IAAI,OAASlB,EAAE+C,KAEpD,IADoBH,EAAkB1B,IAAI4B,IAAc,GACtCJ,EAChB,QAEJ,CAEA,MAAMxC,EAAMN,EAAIH,SAAWyE,EACrB/D,EAAMN,EAAIJ,SAAWyE,EACrB9D,EAAMN,EAAIL,SAAW0E,EACrB9D,EAAMN,EAAIN,SAAW0E,EACrB7D,EAAK5D,KAAK6D,IAAIJ,EAAMD,GACpBM,EAAK9D,KAAK6D,IAAIF,EAAMD,GACpBK,EAAO/D,KAAKgE,IAAIN,EAAKC,GACrBM,EAAOjE,KAAKkE,IAAIR,EAAKC,GAE3B,KACIC,GAAMxC,GAAa0C,GAAM1C,KAC3BkD,EAAAA,EAAAA,gBAAeP,EAAME,GAAO5C,EAAUS,EAAKQ,MAAQjB,GACnD,CACA,MACMoD,GAAa,IADR9D,EACY8C,EAAMD,EAKvBkB,EAAOD,IAJM,IAFR9D,EAEY6C,EAAMC,GAIN,GAAK,EACtBkB,GAAQjB,EAAMC,EAAM,GAAK,GAPpBhD,EAUX,IAAIiE,EAAMH,EACNI,GAAc,IAXPlE,EAWWgD,EAAMD,EAC5B,GAAIH,EAAMuB,QAAU7C,EAAW,CAE7B,IAAI8C,GAAiB,EAGjBC,EAAM,EACNC,EAAM,EAEV,IAAK,IAAIE,EAAI,EAAGA,EAAI5B,EAAMuB,OAAQK,GAAK,EAAG,CACxC,MAAMC,GAAO7B,EAAM4B,GACbE,EAAK9B,EAAM4B,EAAI,GAEhBJ,IACHC,EAAMJ,EACNK,EAAMJ,GAGR,MAAMS,EAAKF,EAAMpC,EACXuC,EAAKH,EAAMnC,EAejB,GAbW,MAAPoC,GAAqB,MAAPA,GAAqB,MAAPA,GAC9BT,GAAOU,EAAKZ,EACZG,GAAOU,EAAKZ,GACI,MAAPU,GAAqB,MAAPA,EACvBT,GAAOU,EAAKZ,EAGE,MAAPW,IACPR,GAAOU,EAAKZ,KAOV3E,KAAKkE,IAAIc,EAAKC,EAAKL,EAAKC,GAAO,GAC/B7E,KAAKgE,IAAIgB,EAAKC,EAAKL,EAAKC,GAAOvC,GAEjC,CAIA,MAAMkD,EAAYL,EAAI5B,EAAMuB,OAAS,EACrC,GACE9E,KAAK6D,IAAIe,EAAMI,IAAQ,GACvBhF,KAAK6D,IAAIgB,EAAMI,IAAQ,GACvBO,EAEAT,GAAiB,MACZ,CAIL,MAAM2D,EAAU3D,GAAkBO,EAAK,GAAMC,EAAK,EAAIF,EAAK,IAIrDsD,EACO,MAAXD,GAA6B,MAAXA,GAA6B,MAAXA,EAEpC7C,EAAWJ,UADT8C,IAAmBI,GAEP,IAAZhI,EAAgBiG,EAAoBD,EAC7B6B,IAAkBG,EACJ7B,EAAuB2B,GAEvB/B,EAAkBgC,GAG3C3D,GAAiB,EAEb7C,EACa,MAAXwG,KACFhD,EAAAA,EAAAA,IAAKG,EAAYb,EAAKJ,EAlN3B,EAkNoCC,EAAKI,EAAKb,EAAIC,EAAKrC,GAClD6D,EAAWF,OACPG,IACFC,EAAAA,EAAAA,IACEF,EACAb,EACAJ,EAxNT,EA0NSC,EACAI,EACAb,EACAC,EACAgE,EACAC,EACAtG,MAKN0D,EAAAA,EAAAA,IAAKG,EAAYb,EAAKJ,EArOzB,EAqOkCC,EAAKI,EAAKb,EAAIC,EAAKrC,GAClD6D,EAAWF,OACPG,IACFC,EAAAA,EAAAA,IACEF,EACAb,EACAJ,EA3OP,EA6OOC,EACAI,EACAb,EACAC,EACAgE,EACAC,EACAtG,GAIR,CACF,CACF,CACF,MAEMuG,EACF1C,EAAWJ,WACG,IAAZ9E,EAAgBiG,EAAoBD,EAC7B6B,IACT3C,EAAWJ,UAAYqB,EAAuB2B,KAGhD/C,EAAAA,EAAAA,IAAKG,EAAYrC,EAAKC,EAnQjB,EAmQ0BE,EAAKD,EAAKU,EAAIC,EAAKrC,GAClD6D,EAAWF,QAGP4C,GAAkBC,KACpB3C,EAAWJ,UAAYiB,EAAkBnG,EAG/C,CACF,CAGA,MAAMqI,EAAOhH,EAAMiH,gBAAgBC,WAAW,MAC9C,GAAKF,EAAL,CAGAA,EAAKhG,uBAAwB,EAC7BgG,EAAK/F,UAAU,EAAG,EAAGP,EAAOF,GAG5B,IAAK,IAAI8E,EAAI,EAAGA,EAAI7E,EAAcyC,OAAQoC,IAAK,CAC7C,MAAM6B,EAAU1G,EAAc6E,GAG9B,GAAIlB,EAAqB,EAAG,CAC1B,MAAMI,EACJ2C,EAAQzF,EAAEkB,IAAI,SAAWuE,EAAQzF,EAAEkB,IAAI,OAASuE,EAAQzF,EAAE+C,KAE5D,IADoBH,EAAkB1B,IAAI4B,IAAc,GACtCJ,EAChB,QAEJ,CAEA,MAAMjG,EAAMmH,EAAIxF,EAAiB,EACjCkH,EAAKnD,UAAY3F,EAAUC,IAG3BiJ,EAAAA,EAAAA,IAAgB,CACdC,GAAIC,IACFA,EAAIvD,QAENoD,UACAG,IAAKN,EACL5G,aACAG,QACAW,UACAzB,WACA8H,UAAWrH,EAAKQ,MAChB8G,UAAU,EACVhH,UAEJ,CApCA,CAqCF,CAEO,SAASiH,EAAsBzH,GACpC,MAAM,MAAEO,EAAK,QAAEmH,EAAO,YAAEC,GAAgB3H,EAElCE,GAAOC,EAAAA,EAAAA,mBAAkBH,GACzBI,EAAaF,EAAKE,WAClBI,EAASR,EAAMQ,OACfE,EAAQR,EAAKQ,MACb4G,EAAMtH,EAAM4H,iBAAiBV,WAAW,MACxChG,EAAUhB,EAAKU,MAAMC,IAAIC,GAAKA,EAAEK,UAEtC,IAAKmG,EACH,OAEFA,EAAIO,iBACJP,EAAIQ,MAZ0B,KAa9BR,EAAIrG,UAAU,EAAG,EAAGP,EAAOF,GAC3B8G,EAAItB,YAAc,qBAClBsB,EAAIzD,UAAY,qBAChB,MAAMkE,EAAW/H,EAAMgI,QAAQL,GAAe,IAC1CI,IACFX,EAAAA,EAAAA,IAAgB,CACdC,GAAIC,IACFA,EAAIvD,QAENoD,QAASY,EACTxH,QACA+G,MACA7H,WACA8H,UAAWrH,EAAKQ,MAChBN,aACAc,UACAV,WAGJ,MAAMyH,EAAWjI,EAAMgI,QAAQN,GAAW,IACtCO,IACFb,EAAAA,EAAAA,IAAgB,CACdC,GAAIC,IACFA,EAAId,UAENW,QAASc,EACTX,MACA/G,QACAd,WACA8H,UAAWrH,EAAKQ,MAChBN,aACAc,UACAV,UAGN,C,2GC5lBO,SAAS4G,GAAgB,QAC9BD,EAAO,IACPG,EAAG,QACHpG,EAAO,MACPX,EAAK,GACL8G,EAAE,OACF7G,EAAM,WACNJ,EAAU,SACVX,EAAQ,UACR8H,EAAS,SACTC,IAaA,MAAM,IAAElG,EAAG,IAAEC,EAAG,IAAEC,EAAG,IAAEC,GAAQ0F,EAEzBvF,EAAMN,EAAIH,SAAWD,EAAQX,GAC7BsB,EAAMN,EAAIJ,SAAWD,EAAQX,GAC7BuB,EAAMN,EAAIL,SAAWD,EAAQX,EAAQ,GACrCwB,EAAMN,EAAIN,SAAWD,EAAQX,EAAQ,GAErCyB,EAAK5D,KAAK6D,IAAIJ,EAAMD,GACpBM,EAAK9D,KAAK6D,IAAIF,EAAMD,GAEpBU,EAAKhC,EACLiC,GAAOD,EAFF,GAEa,EAClBL,EAAO/D,KAAKgE,IAAIN,EAAKC,GACrBM,EAAOjE,KAAKkE,IAAIR,EAAKC,IAEtBW,EAAAA,EAAAA,gBAAeP,EAAME,GAAO5C,EAAU8H,EAAY9H,KAMnDuC,GAAM,GAAKE,GAAM,EAGdsF,IACHF,EAAI3B,YACJ2B,EAAIjB,OAAOzE,EAjBJ,GAkBHxB,EACFkH,EAAIhB,cAAc1E,EAAKa,EAAKX,EAAKW,EAAKX,EAAKU,GAE3C8E,EAAIf,OAAOzE,EAAKU,GAElB8E,EAAId,WAGN1C,EAAKwD,EAAK1F,EAAKC,EA1BN,EA0BeE,EAAKD,EAAKU,EAAIC,EAAKrC,GAC3CiH,EAAGC,IAEP,CAEO,SAASxD,EACdwD,EACAY,EACAC,EACA5F,EACA6F,EACAC,EACA7F,EACAC,EACArC,GAEIA,EAqFC,SACLkH,EACAY,EACAC,EACA5F,EACA6F,EACAC,EACA7F,EACAC,GAEA,MAAM6F,EAAOlK,KAAK6D,IAAIiG,EAAKC,GACrBI,EAAOnK,KAAK6D,IAAIiG,EAAKC,GAK3B,GAAIG,EAAO,GAAKC,EAAO,GAAKJ,EAAKD,GAAM9J,KAAK6D,IAAIiG,EAAKE,GAAM,IAAK,CAC9D,MAAMI,EAAMN,EACZA,EAAKC,EACLA,EAAKK,CACP,CACAlB,EAAI3B,YACJ2B,EAAIjB,OAAO6B,EAAI3F,GACf+E,EAAIf,OAAO4B,EAAI5F,GACf+E,EAAIhB,cAAc6B,EAAI1F,EAAK2F,EAAI3F,EAAK2F,EAAI5F,GACxC8E,EAAIf,OAAO8B,EAAI7F,GACf8E,EAAIhB,cAAc+B,EAAI5F,EAAKyF,EAAIzF,EAAKyF,EAAI3F,GACxC+E,EAAImB,WACN,CAhHIC,CAAcpB,EAAKY,EAAIC,EAAI5F,EAAI6F,EAAIC,EAAI7F,EAAIC,GAmExC,SACL6E,EACAY,EACAC,EACA5F,EACA6F,EACAC,EACA7F,GAEA8E,EAAI3B,YACJ2B,EAAIjB,OAAO6B,EAAI3F,GACf+E,EAAIf,OAAO4B,EAAI5F,GACf+E,EAAIf,OAAO6B,EAAI5F,GACf8E,EAAIf,OAAO8B,EAAI7F,GACf8E,EAAImB,WACN,CAhFIE,CAAQrB,EAAKY,EAAIC,EAAI5F,EAAI6F,EAAIC,EAAI7F,EAErC,CAEO,SAAS2B,EACdmD,EACAY,EACAC,EACA5F,EACA6F,EACAC,EACA7F,EACAC,EACAiE,EACAkC,EACAxI,GAEA,MAEMyI,GAFSzK,KAAK6D,IAAIkG,EAAKD,GACd9J,KAAK6D,IAAIoG,EAAKD,IACY,EAGzC,GAAIS,EAAe,GACjB,OAKF,MACMC,EAAa1K,KAAKkE,IACtB,EACAlE,KAAKC,MAAMwK,EAHc,IAGuB,GAG5CE,EAAkBzB,EAAItB,YACtBgD,EAAgB1B,EAAI2B,UAO1B,GALA3B,EAAItB,YAAc,sBAClBsB,EAAI2B,UAAY,GAGhB3B,EAAI3B,YACAvF,EACF,IAAK,IAAI8I,EAAO,EAAGA,EAAOJ,EAAYI,IAAQ,CAC5C,MAAMC,EAAID,EAAOJ,EACXM,EAAOlB,GAAMC,EAAKD,GAAMiB,EACxBE,EAAUhB,GAAMD,EAAKC,GAAMc,EACjC7B,EAAIjB,OAAO+C,EAAM7G,GACjB+E,EAAIhB,cAAc8C,EAAM3G,EAAK4G,EAAS5G,EAAK4G,EAAS7G,EACtD,MAEA,IAAK,IAAI0G,EAAO,EAAGA,EAAOJ,EAAYI,IAAQ,CAC5C,MAAMC,EAAID,EAAOJ,EACXM,EAAOlB,GAAMC,EAAKD,GAAMiB,EACxBE,EAAUhB,GAAMD,EAAKC,GAAMc,EACjC7B,EAAIjB,OAAO+C,EAAM7G,GACjB+E,EAAIf,OAAO8C,EAAS7G,EACtB,CAEF8E,EAAId,SAEJc,EAAItB,YAAc+C,EAClBzB,EAAI2B,UAAYD,CAClB,CAiDO,SAASM,EACdC,EACAvJ,GAEA,MAAME,GAAOC,EAAAA,EAAAA,mBAAkBH,GACzBwJ,GAAQC,EAAAA,EAAAA,oBAAmBzJ,IAC3B,cACJS,EAAa,SACbiJ,EACAzC,eAAgB0C,EAChB1J,oBAAqB2J,EAAI,MACzBrJ,GACEP,EACJ,IAAK2J,IAASC,EACZ,OAEF,MAAMC,EAAOF,EAAKG,wBACZC,EAAOJ,EAAKzC,WAAW,MACvBF,EAAO4C,EAAK1C,WAAW,MAC7B,IAAK6C,IAAS/C,EACZ,OAEF,MAAMgD,EAAIT,EAAMU,QAAUJ,EAAKK,KACzBC,EAAIZ,EAAMa,QAAUP,EAAKQ,KACxBC,EAAIC,EAAIC,GAAMT,EAAKU,aAAaT,EAAGG,EAAG,EAAG,GAAGO,KAC7C5K,EAAiB1B,KAAKC,MAAMJ,EAAAA,GAAkByL,GAE9CiB,EAAOlK,GADFf,EAAAA,EAAAA,IAAM4K,EAAKC,EAAKC,EAAK1K,IAEhC,GAAI6K,EAAM,CACR,MAAM,EAAEjJ,GAAMiJ,EACd3K,EAAM4K,WAAWlJ,EAAE+C,MACnB,MAAMoG,GAAUC,EAAAA,EAAAA,YAAW9K,IACvB+K,EAAAA,EAAAA,2BAA0BF,IAC5BA,EAAQG,WACNH,EAAQI,UAAU,uBAAwB,iBAAkB,CAC1D/K,OACAsJ,QACA0B,YAAaxJ,EAAEyJ,SACf5K,UAIR,CACA,OAAOoK,CACT,CAEO,SAASS,EACd7B,EACAvJ,EACAqL,GAEA9B,EAAM+B,iBACN,MAAM3B,EAAO3J,EAAMiH,eACb2C,EAAO5J,EAAMC,oBACnB,IAAK0J,IAASC,EACZ,OAEF,MAAMC,EAAOF,EAAKG,wBACZC,EAAOJ,EAAKzC,WAAW,MACvBF,EAAO4C,EAAK1C,WAAW,MAC7B,IAAK6C,IAAS/C,EACZ,OAEF,MAAM,QAAEiD,EAAO,QAAEG,GAAYb,EACvBS,EAAIC,EAAUJ,EAAKK,KACnBC,EAAIC,EAAUP,EAAKQ,KAClBC,EAAIC,EAAIC,GAAMT,EAAKU,aAAaT,EAAGG,EAAG,EAAG,GAAGO,KAC7C5K,EAAiB1B,KAAKC,MAAMJ,EAAAA,GAAkB+B,EAAM0J,UACpDjF,GAAK/E,EAAAA,EAAAA,IAAM4K,EAAKC,EAAKC,EAAK1K,GAC1B4B,EAAI1B,EAAMS,cAAcgE,GAC1B/C,IACF1B,EAAM4K,WAAWlJ,EAAEA,EAAE+C,MACrB4G,EAAY,CACVpB,UACAG,UACAjD,QAASzF,IAGf,CAEO,SAAS6J,GAAW,QACzBpE,EAAO,QACPqE,EAAO,WACPC,IAOA,MAAMC,EAAKvE,EAAQgE,SAebQ,EAAKD,EAAGE,KACR5J,EAAK0J,EAAGG,IAAMH,EAAGI,MACjB5J,EAAKyJ,EAAGE,IAAMF,EAAGG,MACjBC,EAAWL,EAAGK,SACdC,EAAKN,EAAGO,KACRC,EAAKP,EAAGM,KACd,MAAO,CACL,UAASE,EAAAA,EAAAA,mBAAkBT,KAC3B,UAASS,EAAAA,EAAAA,mBAAkBR,KAC3B,cAA4B,IAAfD,EAAG3M,SAChB,cAAciD,EAAGoK,eAAe,WAChC,eAAelK,EAAGkK,eAAe,WACjCL,EAAW,aAAaA,EAASM,YAAY,KAAO,GACpDb,EAAU,oBAAmBc,EAAAA,EAAAA,WAAUb,KAAeD,IAAY,GAClEQ,EAAK,WAAWA,IAAO,GACvBE,EAAK,WAAWA,IAAO,IAEtBK,OAAO7K,KAAOA,GACd8K,KAAK,QACV,C","sources":["../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawSynteny.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/components/util.ts"],"sourcesContent":["import { category10 } from '@jbrowse/core/ui/colors'\nimport { doesIntersect2, getContainingView } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\n\nimport { draw, drawLocationMarkers, drawMatchSimple } from './components/util'\n\nimport type { LinearSyntenyDisplayModel } from './model'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model'\n\nexport const MAX_COLOR_RANGE = 255 * 255 * 255 // max color range\n\nfunction makeColor(idx: number) {\n  const r = Math.floor(idx / (255 * 255)) % 255\n  const g = Math.floor(idx / 255) % 255\n  const b = idx % 255\n  return `rgb(${r},${g},${b})`\n}\n\n// Simple hash function to generate consistent colors for query names\nfunction hashString(str: string) {\n  let hash = 0\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = (hash << 5) - hash + char\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return Math.abs(hash)\n}\n\n// Generate a color from a query name using the category10 color palette\nfunction getQueryColor(queryName: string) {\n  const hash = hashString(queryName)\n  return category10[hash % category10.length]!\n}\n// Default CIGAR operation colors\nconst defaultCigarColors = {\n  I: '#ff03',\n  N: '#0a03',\n  D: '#00f3',\n  X: 'brown',\n  M: '#f003',\n  '=': '#f003',\n}\n\n// Strand-specific CIGAR operation colors (purple deletion instead of blue)\nconst strandCigarColors = {\n  I: '#ff03',\n  N: '#a020f0', // Purple for deletion\n  D: '#a020f0', // Purple for deletion\n  X: 'brown',\n  M: '#f003',\n  '=': '#f003',\n}\n\n// Color scheme configuration\nconst colorSchemes = {\n  default: {\n    cigarColors: defaultCigarColors,\n  },\n  strand: {\n    posColor: 'red',\n    negColor: 'blue',\n    cigarColors: strandCigarColors,\n  },\n  query: {\n    cigarColors: defaultCigarColors,\n  },\n}\n\ntype ColorScheme = keyof typeof colorSchemes\n\nfunction applyAlpha(color: string, alpha: number) {\n  // Skip colord processing if alpha is 1 (optimization)\n  if (alpha === 1) {\n    return color\n  }\n  return colord(color).alpha(alpha).toHex()\n}\n\nconst lineLimit = 3\n\nconst oobLimit = 1600\n\nexport function getId(r: number, g: number, b: number, unitMultiplier: number) {\n  return Math.floor((r * 255 * 255 + g * 255 + b - 1) / unitMultiplier)\n}\n\nexport function drawCigarClickMap(\n  model: LinearSyntenyDisplayModel,\n  cigarClickMapCanvas: CanvasRenderingContext2D,\n) {\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const drawCIGAR = view.drawCIGAR\n  const drawCIGARMatchesOnly = view.drawCIGARMatchesOnly\n  const { level, height, featPositions } = model\n  const width = view.width\n  const bpPerPxs = view.views.map(v => v.bpPerPx)\n\n  cigarClickMapCanvas.imageSmoothingEnabled = false\n  cigarClickMapCanvas.clearRect(0, 0, width, height)\n\n  const offsets = view.views.map(v => v.offsetPx)\n\n  // Cache reciprocals for division in CIGAR loop\n  const bpPerPxInv0 = 1 / bpPerPxs[level]!\n  const bpPerPxInv1 = 1 / bpPerPxs[level + 1]!\n\n  for (const { p11, p12, p21, p22, f, cigar } of featPositions) {\n    const x11 = p11.offsetPx - offsets[level]!\n    const x12 = p12.offsetPx - offsets[level]!\n    const x21 = p21.offsetPx - offsets[level + 1]!\n    const x22 = p22.offsetPx - offsets[level + 1]!\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const minX = Math.min(x21, x22)\n    const maxX = Math.max(x21, x22)\n    const y1 = 0\n    const y2 = height\n    const mid = (y2 - y1) / 2\n\n    if (\n      !(l1 <= lineLimit && l2 <= lineLimit) &&\n      doesIntersect2(minX, maxX, -oobLimit, view.width + oobLimit)\n    ) {\n      const s1 = f.get('strand')\n      const k1 = s1 === -1 ? x12 : x11\n      const k2 = s1 === -1 ? x11 : x12\n\n      const rev1 = k1 < k2 ? 1 : -1\n      const rev2 = (x21 < x22 ? 1 : -1) * s1\n\n      let cx1 = k1\n      let cx2 = s1 === -1 ? x22 : x21\n      if (cigar.length && drawCIGAR) {\n        let continuingFlag = false\n        let px1 = 0\n        let px2 = 0\n        const unitMultiplier2 = Math.floor(MAX_COLOR_RANGE / cigar.length)\n\n        for (let j = 0; j < cigar.length; j += 2) {\n          const len = +cigar[j]!\n          const op = cigar[j + 1] as keyof typeof defaultCigarColors\n\n          if (!continuingFlag) {\n            px1 = cx1\n            px2 = cx2\n          }\n\n          const d1 = len * bpPerPxInv0\n          const d2 = len * bpPerPxInv1\n\n          if (op === 'M' || op === '=' || op === 'X') {\n            cx1 += d1 * rev1\n            cx2 += d2 * rev2\n          } else if (op === 'D' || op === 'N') {\n            cx1 += d1 * rev1\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          else if (op === 'I') {\n            cx2 += d2 * rev2\n          }\n\n          if (\n            !(\n              Math.max(px1, px2, cx1, cx2) < 0 ||\n              Math.min(px1, px2, cx1, cx2) > width\n            )\n          ) {\n            const isNotLast = j < cigar.length - 2\n            if (\n              Math.abs(cx1 - px1) <= 1 &&\n              Math.abs(cx2 - px2) <= 1 &&\n              isNotLast\n            ) {\n              continuingFlag = true\n            } else {\n              continuingFlag = false\n              // When drawCIGARMatchesOnly is enabled, only draw match operations (M, =, X)\n              // Skip insertions (I) and deletions (D, N)\n              // Also skip very thin rectangles which tend to be glitchy\n              const shouldDraw =\n                !drawCIGARMatchesOnly ||\n                ((op === 'M' || op === '=' || op === 'X') &&\n                  Math.abs(cx1 - px1) > 1 &&\n                  Math.abs(cx2 - px2) > 1)\n\n              if (shouldDraw) {\n                const idx = j * unitMultiplier2 + 1\n                cigarClickMapCanvas.fillStyle = makeColor(idx)\n                draw(\n                  cigarClickMapCanvas,\n                  px1,\n                  cx1,\n                  y1,\n                  cx2,\n                  px2,\n                  y2,\n                  mid,\n                  drawCurves,\n                )\n                cigarClickMapCanvas.fill()\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nexport function drawRef(\n  model: LinearSyntenyDisplayModel,\n  mainCanvas: CanvasRenderingContext2D,\n) {\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const drawCIGAR = view.drawCIGAR\n  const drawCIGARMatchesOnly = view.drawCIGARMatchesOnly\n  const drawLocationMarkersEnabled = view.drawLocationMarkers\n  const { level, height, featPositions, alpha, minAlignmentLength, colorBy } =\n    model\n  const width = view.width\n  const bpPerPxs = view.views.map(v => v.bpPerPx)\n\n  // Calculate total alignment length per query sequence\n  // Group by query name and sum up all alignment lengths\n  const queryTotalLengths = new Map<string, number>()\n  if (minAlignmentLength > 0) {\n    for (const { f } of featPositions) {\n      const queryName = f.get('name') || f.get('id') || f.id()\n      const alignmentLength = Math.abs(f.get('end') - f.get('start'))\n      const currentTotal = queryTotalLengths.get(queryName) || 0\n      queryTotalLengths.set(queryName, currentTotal + alignmentLength)\n    }\n  }\n\n  // Get the appropriate color map for the current scheme\n  const schemeConfig =\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    colorSchemes[colorBy as ColorScheme] || colorSchemes.default\n  const activeColorMap = schemeConfig.cigarColors\n\n  // Define colors for strand-based coloring\n  const posColor = colorBy === 'strand' ? colorSchemes.strand.posColor : 'red'\n  const negColor = colorBy === 'strand' ? colorSchemes.strand.negColor : 'blue'\n\n  // Precalculate colors with alpha applied to avoid repeated calls\n  const colorMapWithAlpha = {\n    I: applyAlpha(activeColorMap.I, alpha),\n    N: applyAlpha(activeColorMap.N, alpha),\n    D: applyAlpha(activeColorMap.D, alpha),\n    X: applyAlpha(activeColorMap.X, alpha),\n    M: applyAlpha(activeColorMap.M, alpha),\n    '=': applyAlpha(activeColorMap['='], alpha),\n  }\n\n  // Precalculate strand colors with alpha\n  const posColorWithAlpha = applyAlpha(posColor, alpha)\n  const negColorWithAlpha = applyAlpha(negColor, alpha)\n\n  // Cache for query colors with alpha applied\n  const queryColorCache = new Map<string, string>()\n\n  const getQueryColorWithAlpha = (queryName: string) => {\n    if (!queryColorCache.has(queryName)) {\n      const color = getQueryColor(queryName)\n      queryColorCache.set(queryName, applyAlpha(color, alpha))\n    }\n    return queryColorCache.get(queryName)!\n  }\n\n  mainCanvas.beginPath()\n  const offsets = view.views.map(v => v.offsetPx)\n  const offsetsL0 = offsets[level]!\n  const offsetsL1 = offsets[level + 1]!\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / featPositions.length)\n  const y1 = 0\n  const y2 = height\n  const mid = (y2 - y1) / 2\n\n  // Cache colorBy checks outside loop for performance\n  const useStrandColorThin = colorBy === 'strand'\n  const useQueryColorThin = colorBy === 'query'\n\n  mainCanvas.fillStyle = colorMapWithAlpha.M\n  mainCanvas.strokeStyle = colorMapWithAlpha.M\n\n  // Group features by color to batch state changes\n  const thinLinesByColor = new Map<\n    string,\n    { x11: number; x21: number; y1: number; y2: number; mid: number }[]\n  >()\n\n  for (const { p11, p12, p21, p22, f } of featPositions) {\n    // Filter by total alignment length for this query sequence\n    if (minAlignmentLength > 0) {\n      const queryName = f.get('name') || f.get('id') || f.id()\n      const totalLength = queryTotalLengths.get(queryName) || 0\n      if (totalLength < minAlignmentLength) {\n        continue\n      }\n    }\n\n    const x11 = p11.offsetPx - offsetsL0\n    const x12 = p12.offsetPx - offsetsL0\n    const x21 = p21.offsetPx - offsetsL1\n    const x22 = p22.offsetPx - offsetsL1\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n\n    // drawing a line if the results are thin results in much less pixellation\n    // than filling in a thin polygon\n    if (\n      l1 <= lineLimit &&\n      l2 <= lineLimit &&\n      x21 < width + oobLimit &&\n      x21 > -oobLimit\n    ) {\n      // Determine color key for batching\n      let colorKey = 'default'\n      if (useStrandColorThin) {\n        const strand = f.get('strand')\n        colorKey = strand === -1 ? 'neg' : 'pos'\n      } else if (useQueryColorThin) {\n        colorKey = f.get('refName')\n      }\n\n      if (!thinLinesByColor.has(colorKey)) {\n        thinLinesByColor.set(colorKey, [])\n      }\n      thinLinesByColor.get(colorKey)!.push({ x11, x21, y1, y2, mid })\n    }\n  }\n\n  // Now draw all thin lines batched by color\n  for (const [colorKey, lines] of thinLinesByColor) {\n    // Set color once for all lines in this batch\n    if (colorKey === 'pos') {\n      mainCanvas.strokeStyle = posColorWithAlpha\n    } else if (colorKey === 'neg') {\n      mainCanvas.strokeStyle = negColorWithAlpha\n    } else if (colorKey !== 'default') {\n      mainCanvas.strokeStyle = getQueryColorWithAlpha(colorKey)\n    } else {\n      mainCanvas.strokeStyle = colorMapWithAlpha.M\n    }\n\n    // Create single path for all lines with same color\n    mainCanvas.beginPath()\n    if (drawCurves) {\n      for (const { x11, x21, y1, y2, mid } of lines) {\n        mainCanvas.moveTo(x11, y1)\n        mainCanvas.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      }\n    } else {\n      for (const { x11, x21, y1, y2 } of lines) {\n        mainCanvas.moveTo(x11, y1)\n        mainCanvas.lineTo(x21, y2)\n      }\n    }\n    mainCanvas.stroke()\n  }\n\n  // Cache bpPerPx values and reciprocals for division in CIGAR loop\n  const bpPerPx0 = bpPerPxs[level]!\n  const bpPerPx1 = bpPerPxs[level + 1]!\n  const bpPerPxInv0 = 1 / bpPerPx0\n  const bpPerPxInv1 = 1 / bpPerPx1\n\n  // Cache colorBy checks outside loop for performance\n  const useStrandColor = colorBy === 'strand'\n  const useQueryColor = colorBy === 'query'\n\n  mainCanvas.fillStyle = colorMapWithAlpha.M\n  mainCanvas.strokeStyle = colorMapWithAlpha.M\n  for (const { p11, p12, p21, p22, f, cigar } of featPositions) {\n    // Cache feature properties at loop start\n    const strand = f.get('strand')\n    const refName = f.get('refName')\n\n    // Filter by total alignment length for this query sequence\n    if (minAlignmentLength > 0) {\n      const queryName = f.get('name') || f.get('id') || f.id()\n      const totalLength = queryTotalLengths.get(queryName) || 0\n      if (totalLength < minAlignmentLength) {\n        continue\n      }\n    }\n\n    const x11 = p11.offsetPx - offsetsL0\n    const x12 = p12.offsetPx - offsetsL0\n    const x21 = p21.offsetPx - offsetsL1\n    const x22 = p22.offsetPx - offsetsL1\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const minX = Math.min(x21, x22)\n    const maxX = Math.max(x21, x22)\n\n    if (\n      !(l1 <= lineLimit && l2 <= lineLimit) &&\n      doesIntersect2(minX, maxX, -oobLimit, view.width + oobLimit)\n    ) {\n      const s1 = strand\n      const k1 = s1 === -1 ? x12 : x11\n      const k2 = s1 === -1 ? x11 : x12\n\n      // rev1/rev2 flip the direction of the CIGAR drawing in horizontally flipped\n      // modes. somewhat heuristically determined, but tested for\n      const rev1 = k1 < k2 ? 1 : -1\n      const rev2 = (x21 < x22 ? 1 : -1) * s1\n\n      // cx1/cx2 are the current x positions on top and bottom rows\n      let cx1 = k1\n      let cx2 = s1 === -1 ? x22 : x21\n      if (cigar.length && drawCIGAR) {\n        // continuingFlag skips drawing commands on very small CIGAR features\n        let continuingFlag = false\n\n        // px1/px2 are the previous x positions on the top and bottom rows\n        let px1 = 0\n        let px2 = 0\n\n        for (let j = 0; j < cigar.length; j += 2) {\n          const len = +cigar[j]!\n          const op = cigar[j + 1] as keyof typeof defaultCigarColors\n\n          if (!continuingFlag) {\n            px1 = cx1\n            px2 = cx2\n          }\n\n          const d1 = len * bpPerPxInv0\n          const d2 = len * bpPerPxInv1\n\n          if (op === 'M' || op === '=' || op === 'X') {\n            cx1 += d1 * rev1\n            cx2 += d2 * rev2\n          } else if (op === 'D' || op === 'N') {\n            cx1 += d1 * rev1\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          else if (op === 'I') {\n            cx2 += d2 * rev2\n          }\n\n          // check that we are even drawing in view here, e.g. that all\n          // points are not all less than 0 or greater than width\n          if (\n            !(\n              Math.max(px1, px2, cx1, cx2) < 0 ||\n              Math.min(px1, px2, cx1, cx2) > width\n            )\n          ) {\n            // if it is a small feature and not the last element of the\n            // CIGAR (which could skip rendering it entire if we did turn\n            // it on), then turn on continuing flag\n            const isNotLast = j < cigar.length - 2\n            if (\n              Math.abs(cx1 - px1) <= 1 &&\n              Math.abs(cx2 - px2) <= 1 &&\n              isNotLast\n            ) {\n              continuingFlag = true\n            } else {\n              // allow rendering the dominant color when using continuing\n              // flag if the last element of continuing was a large\n              // feature, else just use match\n              const letter = (continuingFlag && d1 > 1) || d2 > 1 ? op : 'M'\n\n              // Use custom coloring based on colorBy setting\n              // Always keep yellow/blue for insertions/deletions regardless of colorBy\n              const isInsertionOrDeletion =\n                letter === 'I' || letter === 'D' || letter === 'N'\n              if (useStrandColor && !isInsertionOrDeletion) {\n                mainCanvas.fillStyle =\n                  strand === -1 ? negColorWithAlpha : posColorWithAlpha\n              } else if (useQueryColor && !isInsertionOrDeletion) {\n                mainCanvas.fillStyle = getQueryColorWithAlpha(refName)\n              } else {\n                mainCanvas.fillStyle = colorMapWithAlpha[letter]\n              }\n\n              continuingFlag = false\n\n              if (drawCIGARMatchesOnly) {\n                if (letter === 'M') {\n                  draw(mainCanvas, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                  mainCanvas.fill()\n                  if (drawLocationMarkersEnabled) {\n                    drawLocationMarkers(\n                      mainCanvas,\n                      px1,\n                      cx1,\n                      y1,\n                      cx2,\n                      px2,\n                      y2,\n                      mid,\n                      bpPerPx0,\n                      bpPerPx1,\n                      drawCurves,\n                    )\n                  }\n                }\n              } else {\n                draw(mainCanvas, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                mainCanvas.fill()\n                if (drawLocationMarkersEnabled) {\n                  drawLocationMarkers(\n                    mainCanvas,\n                    px1,\n                    cx1,\n                    y1,\n                    cx2,\n                    px2,\n                    y2,\n                    mid,\n                    bpPerPx0,\n                    bpPerPx1,\n                    drawCurves,\n                  )\n                }\n              }\n            }\n          }\n        }\n      } else {\n        // Use custom coloring based on colorBy setting\n        if (useStrandColor) {\n          mainCanvas.fillStyle =\n            strand === -1 ? negColorWithAlpha : posColorWithAlpha\n        } else if (useQueryColor) {\n          mainCanvas.fillStyle = getQueryColorWithAlpha(refName)\n        }\n\n        draw(mainCanvas, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n        mainCanvas.fill()\n\n        // Reset to default color if needed\n        if (useStrandColor || useQueryColor) {\n          mainCanvas.fillStyle = colorMapWithAlpha.M\n        }\n      }\n    }\n  }\n\n  // draw click map\n  const ctx2 = model.clickMapCanvas?.getContext('2d')\n  if (!ctx2) {\n    return\n  }\n  ctx2.imageSmoothingEnabled = false\n  ctx2.clearRect(0, 0, width, height)\n\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let i = 0; i < featPositions.length; i++) {\n    const feature = featPositions[i]!\n\n    // Filter by total alignment length for this query sequence\n    if (minAlignmentLength > 0) {\n      const queryName =\n        feature.f.get('name') || feature.f.get('id') || feature.f.id()\n      const totalLength = queryTotalLengths.get(queryName) || 0\n      if (totalLength < minAlignmentLength) {\n        continue\n      }\n    }\n\n    const idx = i * unitMultiplier + 1\n    ctx2.fillStyle = makeColor(idx)\n\n    // too many click map false positives with colored stroked lines\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.fill()\n      },\n      feature,\n      ctx: ctx2,\n      drawCurves,\n      level,\n      offsets,\n      oobLimit,\n      viewWidth: view.width,\n      hideTiny: true,\n      height,\n    })\n  }\n}\n\nexport function drawMouseoverClickMap(model: LinearSyntenyDisplayModel) {\n  const { level, clickId, mouseoverId } = model\n  const highResolutionScaling = 1\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const height = model.height\n  const width = view.width\n  const ctx = model.mouseoverCanvas?.getContext('2d')\n  const offsets = view.views.map(v => v.offsetPx)\n\n  if (!ctx) {\n    return\n  }\n  ctx.resetTransform()\n  ctx.scale(highResolutionScaling, highResolutionScaling)\n  ctx.clearRect(0, 0, width, height)\n  ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)'\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'\n  const feature1 = model.featMap[mouseoverId || '']\n  if (feature1) {\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.fill()\n      },\n      feature: feature1,\n      level,\n      ctx,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n  const feature2 = model.featMap[clickId || '']\n  if (feature2) {\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.stroke()\n      },\n      feature: feature2,\n      ctx,\n      level,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n}\n","import type React from 'react'\n\nimport {\n  assembleLocString,\n  doesIntersect2,\n  getContainingTrack,\n  getContainingView,\n  getSession,\n  isSessionModelWithWidgets,\n  toLocale,\n} from '@jbrowse/core/util'\n\nimport { MAX_COLOR_RANGE, getId } from '../drawSynteny'\n\nimport type { LinearSyntenyDisplayModel } from '../model'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface Pos {\n  offsetPx: number\n}\n\nexport interface ClickCoord {\n  clientX: number\n  clientY: number\n  feature: { f: Feature }\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\nexport function drawMatchSimple({\n  feature,\n  ctx,\n  offsets,\n  level,\n  cb,\n  height,\n  drawCurves,\n  oobLimit,\n  viewWidth,\n  hideTiny,\n}: {\n  feature: FeatPos\n  ctx: CanvasRenderingContext2D\n  offsets: number[]\n  level: number\n  oobLimit: number\n  viewWidth: number\n  cb: (ctx: CanvasRenderingContext2D) => void\n  height: number\n  drawCurves?: boolean\n  hideTiny?: boolean\n}) {\n  const { p11, p12, p21, p22 } = feature\n\n  const x11 = p11.offsetPx - offsets[level]!\n  const x12 = p12.offsetPx - offsets[level]!\n  const x21 = p21.offsetPx - offsets[level + 1]!\n  const x22 = p22.offsetPx - offsets[level + 1]!\n\n  const l1 = Math.abs(x12 - x11)\n  const l2 = Math.abs(x22 - x21)\n  const y1 = 0\n  const y2 = height\n  const mid = (y2 - y1) / 2\n  const minX = Math.min(x21, x22)\n  const maxX = Math.max(x21, x22)\n\n  if (!doesIntersect2(minX, maxX, -oobLimit, viewWidth + oobLimit)) {\n    return\n  }\n\n  // drawing a line if the results are thin: drawing a line results in much\n  // less pixellation than filling in a thin polygon\n  if (l1 <= 1 && l2 <= 1) {\n    // hideTiny can be used to avoid drawing mouseover for thin lines in this\n    // case\n    if (!hideTiny) {\n      ctx.beginPath()\n      ctx.moveTo(x11, y1)\n      if (drawCurves) {\n        ctx.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        ctx.lineTo(x21, y2)\n      }\n      ctx.stroke()\n    }\n  } else {\n    draw(ctx, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n    cb(ctx)\n  }\n}\n\nexport function draw(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n  drawCurves?: boolean,\n) {\n  if (drawCurves) {\n    drawBezierBox(ctx, x1, x2, y1, x3, x4, y2, mid)\n  } else {\n    drawBox(ctx, x1, x2, y1, x3, x4, y2)\n  }\n}\n\nexport function drawLocationMarkers(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n  bpPerPx1: number,\n  bpPerPx2: number,\n  drawCurves?: boolean,\n) {\n  const width1 = Math.abs(x2 - x1)\n  const width2 = Math.abs(x4 - x3)\n  const averageWidth = (width1 + width2) / 2\n\n  // Only draw markers for sufficiently large matches (wider than ~30 pixels)\n  if (averageWidth < 30) {\n    return\n  }\n\n  // Aim for markers at consistent pixel spacing for even visual density\n  // Target spacing of ~20 pixels between markers regardless of feature size\n  const targetPixelSpacing = 20\n  const numMarkers = Math.max(\n    2,\n    Math.floor(averageWidth / targetPixelSpacing) + 1,\n  )\n\n  const prevStrokeStyle = ctx.strokeStyle\n  const prevLineWidth = ctx.lineWidth\n\n  ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)' // Dark semi-transparent line\n  ctx.lineWidth = 0.5\n\n  // Create single path for all markers\n  ctx.beginPath()\n  if (drawCurves) {\n    for (let step = 0; step < numMarkers; step++) {\n      const t = step / numMarkers\n      const topX = x1 + (x2 - x1) * t\n      const bottomX = x4 + (x3 - x4) * t\n      ctx.moveTo(topX, y1)\n      ctx.bezierCurveTo(topX, mid, bottomX, mid, bottomX, y2)\n    }\n  } else {\n    for (let step = 0; step < numMarkers; step++) {\n      const t = step / numMarkers\n      const topX = x1 + (x2 - x1) * t\n      const bottomX = x4 + (x3 - x4) * t\n      ctx.moveTo(topX, y1)\n      ctx.lineTo(bottomX, y2)\n    }\n  }\n  ctx.stroke()\n\n  ctx.strokeStyle = prevStrokeStyle\n  ctx.lineWidth = prevLineWidth\n}\n\nexport function drawBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n) {\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.lineTo(x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.closePath()\n}\n\nexport function drawBezierBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n) {\n  const len1 = Math.abs(x1 - x2)\n  const len2 = Math.abs(x1 - x2)\n\n  // heuristic to not draw hourglass inversions with bezier curves when they\n  // are thin and far apart because it results in areas that are not drawn well\n  // demo https://codesandbox.io/s/fast-glitter-q3b1or?file=/src/index.js\n  if (len1 < 5 && len2 < 5 && x2 < x1 && Math.abs(x1 - x3) > 100) {\n    const tmp = x1\n    x1 = x2\n    x2 = tmp\n  }\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.bezierCurveTo(x2, mid, x3, mid, x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.bezierCurveTo(x4, mid, x1, mid, x1, y1)\n  ctx.closePath()\n}\n\nexport function onSynClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n) {\n  const view = getContainingView(model)\n  const track = getContainingTrack(model)\n  const {\n    featPositions,\n    numFeats,\n    clickMapCanvas: ref1,\n    cigarClickMapCanvas: ref2,\n    level,\n  } = model\n  if (!ref1 || !ref2) {\n    return\n  }\n  const rect = ref1.getBoundingClientRect()\n  const ctx1 = ref1.getContext('2d')\n  const ctx2 = ref2.getContext('2d')\n  if (!ctx1 || !ctx2) {\n    return\n  }\n  const x = event.clientX - rect.left\n  const y = event.clientY - rect.top\n  const [r1, g1, b1] = ctx1.getImageData(x, y, 1, 1).data\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / numFeats)\n  const id = getId(r1!, g1!, b1!, unitMultiplier)\n  const feat = featPositions[id]\n  if (feat) {\n    const { f } = feat\n    model.setClickId(f.id())\n    const session = getSession(model)\n    if (isSessionModelWithWidgets(session)) {\n      session.showWidget(\n        session.addWidget('SyntenyFeatureWidget', 'syntenyFeature', {\n          view,\n          track,\n          featureData: f.toJSON(),\n          level,\n        }),\n      )\n    }\n  }\n  return feat\n}\n\nexport function onSynContextClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n  setAnchorEl: (arg: ClickCoord) => void,\n) {\n  event.preventDefault()\n  const ref1 = model.clickMapCanvas\n  const ref2 = model.cigarClickMapCanvas\n  if (!ref1 || !ref2) {\n    return\n  }\n  const rect = ref1.getBoundingClientRect()\n  const ctx1 = ref1.getContext('2d')\n  const ctx2 = ref2.getContext('2d')\n  if (!ctx1 || !ctx2) {\n    return\n  }\n  const { clientX, clientY } = event\n  const x = clientX - rect.left\n  const y = clientY - rect.top\n  const [r1, g1, b1] = ctx1.getImageData(x, y, 1, 1).data\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / model.numFeats)\n  const id = getId(r1!, g1!, b1!, unitMultiplier)\n  const f = model.featPositions[id]\n  if (f) {\n    model.setClickId(f.f.id())\n    setAnchorEl({\n      clientX,\n      clientY,\n      feature: f,\n    })\n  }\n}\n\nexport function getTooltip({\n  feature,\n  cigarOp,\n  cigarOpLen,\n}: {\n  feature: Feature\n  cigarOpLen?: string\n  cigarOp?: string\n}) {\n  // @ts-expect-error\n  const f1 = feature.toJSON() as {\n    refName: string\n    start: number\n    end: number\n    strand?: number\n    assemblyName: string\n    identity?: number\n    name?: string\n    mate: {\n      start: number\n      end: number\n      refName: string\n      name: string\n    }\n  }\n  const f2 = f1.mate\n  const l1 = f1.end - f1.start\n  const l2 = f2.end - f2.start\n  const identity = f1.identity\n  const n1 = f1.name\n  const n2 = f2.name\n  return [\n    `Loc1: ${assembleLocString(f1)}`,\n    `Loc2: ${assembleLocString(f2)}`,\n    `Inverted: ${f1.strand === -1}`,\n    `Query len: ${l1.toLocaleString('en-US')}`,\n    `Target len: ${l2.toLocaleString('en-US')}`,\n    identity ? `Identity: ${identity.toPrecision(2)}` : '',\n    cigarOp ? `CIGAR operator: ${toLocale(+cigarOpLen!)}${cigarOp}` : '',\n    n1 ? `Name 1: ${n1}` : '',\n    n2 ? `Name 2: ${n2}` : '',\n  ]\n    .filter(f => !!f)\n    .join('<br/>')\n}\n"],"names":["MAX_COLOR_RANGE","makeColor","idx","Math","floor","defaultCigarColors","I","N","D","X","M","colorSchemes","default","cigarColors","strand","posColor","negColor","query","applyAlpha","color","alpha","colord","toHex","lineLimit","oobLimit","getId","r","g","b","unitMultiplier","drawCigarClickMap","model","cigarClickMapCanvas","view","getContainingView","drawCurves","drawCIGAR","drawCIGARMatchesOnly","level","height","featPositions","width","bpPerPxs","views","map","v","bpPerPx","imageSmoothingEnabled","clearRect","offsets","offsetPx","bpPerPxInv0","bpPerPxInv1","p11","p12","p21","p22","f","cigar","x11","x12","x21","x22","l1","abs","l2","minX","min","maxX","max","y1","y2","mid","doesIntersect2","s1","get","k1","rev1","rev2","cx1","cx2","length","continuingFlag","px1","px2","unitMultiplier2","j","len","op","d1","d2","isNotLast","fillStyle","draw","fill","drawRef","mainCanvas","drawLocationMarkersEnabled","drawLocationMarkers","minAlignmentLength","colorBy","queryTotalLengths","Map","queryName","id","alignmentLength","currentTotal","set","activeColorMap","colorMapWithAlpha","posColorWithAlpha","negColorWithAlpha","queryColorCache","getQueryColorWithAlpha","has","hash","str","i","charCodeAt","hashString","category10","getQueryColor","beginPath","offsetsL0","offsetsL1","useStrandColorThin","useQueryColorThin","strokeStyle","thinLinesByColor","colorKey","push","lines","moveTo","bezierCurveTo","lineTo","stroke","bpPerPx0","bpPerPx1","useStrandColor","useQueryColor","refName","letter","isInsertionOrDeletion","ctx2","clickMapCanvas","getContext","feature","drawMatchSimple","cb","ctx","viewWidth","hideTiny","drawMouseoverClickMap","clickId","mouseoverId","mouseoverCanvas","resetTransform","scale","feature1","featMap","feature2","x1","x2","x3","x4","len1","len2","tmp","closePath","drawBezierBox","drawBox","bpPerPx2","averageWidth","numMarkers","prevStrokeStyle","prevLineWidth","lineWidth","step","t","topX","bottomX","onSynClick","event","track","getContainingTrack","numFeats","ref1","ref2","rect","getBoundingClientRect","ctx1","x","clientX","left","y","clientY","top","r1","g1","b1","getImageData","data","feat","setClickId","session","getSession","isSessionModelWithWidgets","showWidget","addWidget","featureData","toJSON","onSynContextClick","setAnchorEl","preventDefault","getTooltip","cigarOp","cigarOpLen","f1","f2","mate","end","start","identity","n1","name","n2","assembleLocString","toLocaleString","toPrecision","toLocale","filter","join"],"sourceRoot":""}