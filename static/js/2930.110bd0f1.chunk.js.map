{"version":3,"file":"static/js/2930.110bd0f1.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/twobit/src/bigint-polyfill/pure.ts","../../../node_modules/@gmod/twobit/src/bigint-polyfill/polyfill.ts","../../../node_modules/@gmod/twobit/src/twoBitFile.ts","../../../plugins/sequence/src/TwoBitAdapter/TwoBitAdapter.ts"],"sourcesContent":["const BigInt32 = BigInt(32)\n\nexport function getBigInt64(\n  dataView: DataView,\n  byteOffset: number,\n  littleEndian: boolean | undefined,\n): bigint {\n  const littleEndianMask = Number(!!littleEndian)\n  const bigEndianMask = Number(!littleEndian)\n\n  return (\n    (BigInt(\n      dataView.getInt32(byteOffset, littleEndian) * bigEndianMask +\n        dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask,\n    ) <<\n      BigInt32) |\n    BigInt(\n      dataView.getUint32(byteOffset, littleEndian) * littleEndianMask +\n        dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask,\n    )\n  )\n}\n\nexport function getBigUint64(\n  dataView: DataView,\n  byteOffset: number,\n  littleEndian: boolean | undefined,\n): bigint {\n  const a = dataView.getUint32(byteOffset, littleEndian)\n  const b = dataView.getUint32(byteOffset + 4, littleEndian)\n\n  const littleEndianMask = Number(!!littleEndian)\n  const bigEndianMask = Number(!littleEndian)\n\n  // This branch-less optimization is 77x faster than normal ternary operator.\n  // and only 3% slower than native implementation\n  // https://jsbench.me/p8kyhg1eqv/1\n  return (\n    (BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32) |\n    BigInt(a * littleEndianMask + b * bigEndianMask)\n  )\n}\n","import { getBigInt64, getBigUint64 } from './pure.ts'\n\nif (!('getBigInt64' in DataView)) {\n  DataView.prototype.getBigInt64 = function (byteOffset, littleEndian) {\n    return getBigInt64(this, byteOffset, littleEndian)\n  }\n}\n\nif (!('getBigUint64' in DataView)) {\n  DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n    return getBigUint64(this, byteOffset, littleEndian)\n  }\n}\n","import { LocalFile } from 'generic-filehandle2'\n\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nconst TWOBIT_MAGIC = 0x1a412743\n\nconst twoBit = ['T', 'C', 'A', 'G']\n// byteTo4Bases is an array of byteValue -> 'ACTG'\nconst byteTo4Bases = [] as string[]\nfor (let index = 0; index < 256; index++) {\n  byteTo4Bases.push(\n    twoBit[(index >> 6) & 3] +\n      twoBit[(index >> 4) & 3] +\n      twoBit[(index >> 2) & 3] +\n      twoBit[index & 3],\n  )\n}\n\nconst maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase())\n\nexport default class TwoBitFile {\n  private filehandle: GenericFilehandle\n  private version?: number\n  private headerP: ReturnType<typeof this._getHeader> | undefined\n  private indexP: ReturnType<typeof this._getIndex> | undefined\n\n  /**\n   * @param {object} args\n   * @param {string} [args.path] filesystem path for the .2bit file to open\n   * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n   *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n   */\n  constructor({\n    filehandle,\n    path,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new Error('must supply path or filehandle')\n    }\n  }\n\n  async _detectEndianness() {\n    const buffer = await this.filehandle.read(8, 0)\n    const dataView = new DataView(buffer.buffer)\n    const magic = dataView.getInt32(0, true)\n    if (magic === TWOBIT_MAGIC) {\n      this.version = dataView.getInt32(0, true)\n    } else {\n      throw new Error('not a 2bit file')\n    }\n  }\n\n  getHeader() {\n    if (!this.headerP) {\n      this.headerP = this._getHeader().catch((error: unknown) => {\n        this.headerP = undefined\n        throw error\n      })\n    }\n    return this.headerP\n  }\n\n  async _getHeader() {\n    await this._detectEndianness()\n\n    const b = await this.filehandle.read(16, 0)\n    const le = true\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    let offset = 0\n    const magic = dataView.getInt32(offset, le)\n    offset += 4\n    if (magic !== 0x1a412743) {\n      throw new Error(`Wrong magic number ${magic}`)\n    }\n    const version = dataView.getInt32(offset, le)\n    offset += 4\n    const sequenceCount = dataView.getUint32(offset, le)\n    offset += 4\n    const reserved = dataView.getUint32(offset, le)\n\n    return {\n      version,\n      magic,\n      sequenceCount,\n      reserved,\n    }\n  }\n\n  getIndex() {\n    if (!this.indexP) {\n      this.indexP = this._getIndex().catch((error: unknown) => {\n        this.indexP = undefined\n        throw error\n      })\n    }\n    return this.indexP\n  }\n\n  async _getIndex() {\n    const header = await this.getHeader()\n    const maxIndexLength =\n      8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4))\n    const b = await this.filehandle.read(maxIndexLength, 8)\n\n    const le = true\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    let offset = 0\n    const sequenceCount = dataView.getUint32(offset, le)\n    offset += 4\n    // const reserved = dataView.getUint32(offset, le)\n    offset += 4\n    const indexData = []\n    const decoder = new TextDecoder('utf8')\n    for (let i = 0; i < sequenceCount; i++) {\n      const nameLength = dataView.getUint8(offset)\n      offset += 1\n      const name = decoder.decode(b.subarray(offset, offset + nameLength))\n      offset += nameLength\n      if (header.version === 1) {\n        const dataOffset = Number(dataView.getBigUint64(offset, le))\n        offset += 8\n        indexData.push({ offset: dataOffset, name })\n      } else {\n        const dataOffset = dataView.getUint32(offset, le)\n        offset += 4\n        indexData.push({ offset: dataOffset, name })\n      }\n    }\n\n    return Object.fromEntries(\n      indexData.map(({ name, offset }) => [name, offset] as const),\n    )\n  }\n\n  /**\n   * @returns for an array of string sequence names that are found in the file\n   */\n  async getSequenceNames() {\n    const index = await this.getIndex()\n    return Object.keys(index)\n  }\n\n  /**\n   * @returns object listing the lengths of all sequences like `{seqName:\n   * length, ...}`.\n   *\n   * note: this is a relatively slow operation especially if there are many\n   * refseqs in the file, if you can get this information from a different file\n   * e.g. a chrom.sizes file, it will be much faster\n   */\n  async getSequenceSizes() {\n    const index = await this.getIndex()\n    const seqNames = Object.keys(index)\n    const sizes = await Promise.all(\n      Object.values(index).map(offset => this._getSequenceSize(offset)),\n    )\n    const returnObject = {} as Record<string, number>\n    for (const [index_, seqName] of seqNames.entries()) {\n      returnObject[seqName] = sizes[index_]\n    }\n    return returnObject\n  }\n\n  /**\n   * @param seqName name of the sequence\n   *\n   * @returns sequence length, or undefined if it is not in the file\n   */\n  async getSequenceSize(seqName: string) {\n    const index = await this.getIndex()\n    const offset = index[seqName]\n    return offset ? this._getSequenceSize(offset) : undefined\n  }\n\n  async _getSequenceSize(offset: number) {\n    return this._record1(offset).then(f => f.dnaSize)\n  }\n\n  async _record1(offset2: number, len = 8) {\n    const b = await this.filehandle.read(len, offset2)\n    const le = true\n    let offset = 0\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n\n    const dnaSize = dataView.getUint32(offset, le)\n    offset += 4\n    const nBlockCount = dataView.getUint32(offset, le)\n    offset += 4\n    return { dnaSize, nBlockCount }\n  }\n\n  async _record2(offset2: number, len: number) {\n    const b = await this.filehandle.read(len, offset2)\n    const le = true\n    let offset = 0\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n\n    const nBlockCount = dataView.getUint32(offset, le)\n    offset += 4\n    const nBlockStarts = [] as number[]\n    for (let i = 0; i < nBlockCount; i++) {\n      const elt = dataView.getUint32(offset, le)\n      offset += 4\n      nBlockStarts.push(elt)\n    }\n    const nBlockSizes = [] as number[]\n    for (let i = 0; i < nBlockCount; i++) {\n      const elt = dataView.getUint32(offset, le)\n      offset += 4\n      nBlockSizes.push(elt)\n    }\n    const maskBlockCount = dataView.getUint32(offset, le)\n    return {\n      maskBlockCount,\n      nBlockSizes,\n      nBlockStarts,\n    }\n  }\n  async _record3(offset2: number, len: number) {\n    const b = await this.filehandle.read(len, offset2)\n    const le = true\n    let offset = 0\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n\n    const maskBlockCount = dataView.getUint32(offset, le)\n    offset += 4\n    const maskBlockStarts = [] as number[]\n    for (let i = 0; i < maskBlockCount; i++) {\n      const elt = dataView.getUint32(offset, le)\n      offset += 4\n      maskBlockStarts.push(elt)\n    }\n    const maskBlockSizes = [] as number[]\n    for (let i = 0; i < maskBlockCount; i++) {\n      const elt = dataView.getUint32(offset, le)\n      offset += 4\n      maskBlockSizes.push(elt)\n    }\n    const reserved = dataView.getInt32(offset, le)\n    return {\n      maskBlockCount,\n      maskBlockSizes,\n      maskBlockStarts,\n      reserved,\n    }\n  }\n\n  async _getSequenceRecord(offset: number) {\n    const rec1 = await this._record1(offset)\n    const rec2DataLen = rec1.nBlockCount * 8 + 8\n    const rec2 = await this._record2(offset + 4, rec2DataLen)\n    const rec3DataLen = rec2.maskBlockCount * 8 + 8\n    const rec3 = await this._record3(offset + 4 + rec2DataLen - 4, rec3DataLen)\n\n    const rec = {\n      dnaSize: rec1.dnaSize,\n      nBlocks: {\n        starts: rec2.nBlockStarts,\n        sizes: rec2.nBlockSizes,\n      },\n      maskBlocks: {\n        starts: rec3.maskBlockStarts,\n        sizes: rec3.maskBlockSizes,\n      },\n      dnaPosition: offset + 4 + rec2DataLen - 4 + rec3DataLen,\n    }\n    return rec\n  }\n\n  /**\n   * @param seqName name of the sequence you want\n   *\n   * @param [regionStart] optional 0-based half-open start of the sequence\n   * region to fetch.\n   *\n   * @param [regionEnd] optional 0-based half-open end of the sequence region\n   * to fetch. defaults to end of the sequence\n   *\n   * @returns for a string of sequence bases\n   */\n  async getSequence(\n    seqName: string,\n    regionStart = 0,\n    regionEnd = Number.POSITIVE_INFINITY,\n  ) {\n    const index = await this.getIndex()\n    const offset = index[seqName]\n    if (!offset) {\n      return undefined\n    }\n    // fetch the record for the seq\n    const record = await this._getSequenceRecord(offset)\n\n    if (regionStart < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    // end defaults to the end of the sequence\n    if (regionEnd > record.dnaSize) {\n      regionEnd = record.dnaSize\n    }\n\n    const nBlocks = this._getOverlappingBlocks(\n      regionStart,\n      regionEnd,\n      record.nBlocks.starts,\n      record.nBlocks.sizes,\n    )\n    const maskBlocks = this._getOverlappingBlocks(\n      regionStart,\n      regionEnd,\n      record.maskBlocks.starts,\n      record.maskBlocks.sizes,\n    )\n\n    const baseBytesLen = Math.ceil((regionEnd - regionStart) / 4) + 1\n    const baseBytesOffset = Math.floor(regionStart / 4)\n    const buffer = await this.filehandle.read(\n      baseBytesLen,\n      record.dnaPosition + baseBytesOffset,\n    )\n\n    let sequenceBases = ''\n    for (\n      let genomicPosition = regionStart;\n      genomicPosition < regionEnd;\n      genomicPosition += 1\n    ) {\n      // check whether we are currently masked\n      while (maskBlocks.length > 0 && maskBlocks[0].end <= genomicPosition) {\n        maskBlocks.shift()\n      }\n      const baseIsMasked =\n        maskBlocks[0] &&\n        maskBlocks[0].start <= genomicPosition &&\n        maskBlocks[0].end > genomicPosition\n\n      // process the N block if we have one\n      if (\n        nBlocks[0] &&\n        genomicPosition >= nBlocks[0].start &&\n        genomicPosition < nBlocks[0].end\n      ) {\n        const currentNBlock = nBlocks.shift()\n        for (\n          ;\n          genomicPosition < currentNBlock.end && genomicPosition < regionEnd;\n          genomicPosition += 1\n        ) {\n          sequenceBases += baseIsMasked ? 'n' : 'N'\n        }\n        genomicPosition -= 1\n      } else {\n        const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset\n        const subPosition = genomicPosition % 4\n        const byte = buffer[bytePosition]\n        sequenceBases += baseIsMasked\n          ? maskedByteTo4Bases[byte][subPosition]\n          : byteTo4Bases[byte][subPosition]\n      }\n    }\n\n    return sequenceBases\n  }\n\n  _getOverlappingBlocks(\n    regionStart: number,\n    regionEnd: number,\n    blockStarts: number[],\n    blockSizes: number[],\n  ) {\n    // find the start and end indexes of the blocks that match\n    let startIndex: number | undefined\n    let endIndex: number | undefined\n    for (const [index, blockStart] of blockStarts.entries()) {\n      const blockSize = blockSizes[index]\n      if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n        // block does not overlap the region\n        if (startIndex !== undefined) {\n          endIndex = index\n          break\n        }\n      } else if (startIndex === undefined) {\n        startIndex = index\n      } // block does overlap the region, record this if it is the first\n    }\n\n    if (startIndex === undefined) {\n      return []\n    }\n\n    // now format some block objects to return\n    if (endIndex === undefined) {\n      endIndex = blockStarts.length\n    }\n\n    const blocks = new Array(endIndex - startIndex)\n    for (\n      let blockNumber = startIndex;\n      blockNumber < endIndex;\n      blockNumber += 1\n    ) {\n      blocks[blockNumber - startIndex] = {\n        start: blockStarts[blockNumber],\n        end: blockStarts[blockNumber] + blockSizes[blockNumber],\n        size: blockSizes[blockNumber],\n      }\n    }\n    return blocks\n  }\n}\n","import { TwoBitFile } from '@gmod/twobit'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\n\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { NoAssemblyRegion } from '@jbrowse/core/util/types'\n\nexport default class TwoBitAdapter extends BaseSequenceAdapter {\n  protected setupP?: Promise<{\n    twobit: TwoBitFile\n    chromSizesData: Record<string, number> | undefined\n  }>\n\n  private async initChromSizes() {\n    const conf = readConfObject(this.config, 'chromSizesLocation')\n    if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {\n      const file = openLocation(conf, this.pluginManager)\n      const data = await file.readFile('utf8')\n      return Object.fromEntries(\n        data\n          .split(/\\n|\\r\\n|\\r/)\n          .filter(line => !!line.trim())\n          .map(line => {\n            const [name, length] = line.split('\\t')\n            return [name!, +length!] as const\n          }),\n      )\n    }\n    return undefined\n  }\n\n  async setupPre() {\n    return {\n      twobit: new TwoBitFile({\n        filehandle: openLocation(\n          this.getConf('twoBitLocation'),\n          this.pluginManager,\n        ),\n      }),\n      chromSizesData: await this.initChromSizes(),\n    }\n  }\n  async setup() {\n    if (!this.setupP) {\n      this.setupP = this.setupPre().catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  public async getRefNames() {\n    const { chromSizesData, twobit } = await this.setup()\n    return chromSizesData\n      ? Object.keys(chromSizesData)\n      : twobit.getSequenceNames()\n  }\n\n  public async getRegions() {\n    const { chromSizesData, twobit } = await this.setup()\n    if (chromSizesData) {\n      return Object.keys(chromSizesData).map(refName => ({\n        refName,\n        start: 0,\n        end: chromSizesData[refName]!,\n      }))\n    } else {\n      const refSizes = await twobit.getSequenceSizes()\n      return Object.keys(refSizes).map(refName => ({\n        refName,\n        start: 0,\n        end: refSizes[refName]!,\n      }))\n    }\n  }\n\n  /**\n   * Fetch features for a certain region\n   * @param param -\n   * @returns Observable of Feature objects in the region\n   */\n  public getFeatures({ refName, start, end }: NoAssemblyRegion) {\n    return ObservableCreate<Feature>(async observer => {\n      const { twobit } = await this.setup()\n      const size = await twobit.getSequenceSize(refName)\n      const regionEnd = size !== undefined ? Math.min(size, end) : end\n      const seq = await twobit.getSequence(refName, start, regionEnd)\n      if (seq) {\n        observer.next(\n          new SimpleFeature({\n            id: `${refName} ${start}-${regionEnd}`,\n            data: { refName, start, end: regionEnd, seq },\n          }),\n        )\n      }\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region will not be\n   * needed for the foreseeable future and can be purged from caches, etc\n   */\n}\n"],"names":["BigInt32","BigInt","DataView","prototype","getBigInt64","byteOffset","littleEndian","dataView","littleEndianMask","Number","bigEndianMask","getInt32","getUint32","this","getBigUint64","a","b","twoBit","byteTo4Bases","index","push","maskedByteTo4Bases","map","bases","toLowerCase","TwoBitFile","constructor","filehandle","path","Error","_detectEndianness","buffer","read","version","getHeader","headerP","_getHeader","catch","error","undefined","le","length","offset","magic","sequenceCount","reserved","getIndex","indexP","_getIndex","header","maxIndexLength","indexData","decoder","TextDecoder","i","nameLength","getUint8","name","decode","subarray","dataOffset","Object","fromEntries","getSequenceNames","keys","getSequenceSizes","seqNames","sizes","Promise","all","values","_getSequenceSize","returnObject","index_","seqName","entries","getSequenceSize","_record1","then","f","dnaSize","offset2","len","nBlockCount","_record2","nBlockStarts","elt","nBlockSizes","maskBlockCount","_record3","maskBlockStarts","maskBlockSizes","_getSequenceRecord","rec1","rec2DataLen","rec2","rec3DataLen","rec3","nBlocks","starts","maskBlocks","dnaPosition","getSequence","regionStart","regionEnd","POSITIVE_INFINITY","record","TypeError","_getOverlappingBlocks","baseBytesLen","Math","ceil","baseBytesOffset","floor","sequenceBases","genomicPosition","end","shift","baseIsMasked","start","currentNBlock","subPosition","byte","blockStarts","blockSizes","startIndex","endIndex","blockStart","blocks","Array","blockNumber","size","TwoBitAdapter","BaseSequenceAdapter","initChromSizes","conf","readConfObject","config","uri","file","openLocation","pluginManager","data","readFile","split","filter","line","trim","setupPre","twobit","getConf","chromSizesData","setup","setupP","e","getRefNames","getRegions","refName","refSizes","getFeatures","ObservableCreate","async","min","seq","observer","next","SimpleFeature","id","complete"],"sourceRoot":""}