{"version":3,"file":"static/js/8343.1a64a334.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region, Feature, fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport VCF from '@gmod/vcf'\n\n// local\nimport VcfFeature from '../VcfFeature'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  vcfFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { header } = await this.setup()\n    const parser = new VCF({ header })\n    return parser.getMetadata()\n  }\n\n  public async setupP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const loc = openLocation(this.getConf('vcfLocation'), this.pluginManager)\n    const buffer = await fetchAndMaybeUnzip(loc, opts)\n    const headerLines = []\n    const featureMap = {} as Record<string, string[]>\n    let blockStart = 0\n\n    const decoder = new TextDecoder('utf8')\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf('\\n', blockStart)\n      // could be a non-newline ended file, so slice to end of file if n===-1\n      const b =\n        n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n)\n      const line = decoder.decode(b).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = []\n          }\n          featureMap[refName].push(line)\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${Math.floor(blockStart / 1_000_000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1_000_000).toLocaleString('en-US')} MB`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const header = headerLines.join('\\n')\n    const parser = new VCF({ header })\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing VCF data')\n            let idx = 0\n            const intervalTree = new IntervalTree()\n            for (const line of lines) {\n              const f = new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-${refName}-${idx++}`,\n              })\n              intervalTree.insert([f.get('start'), f.get('end')], f)\n            }\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header,\n      intervalTreeMap,\n    }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch((e: unknown) => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.setup()\n    return Object.keys(intervalTreeMap)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { intervalTreeMap } = await this.setup()\n        intervalTreeMap[refName]?.(opts.statusCallback)\n          .search([start, end])\n          .forEach(f => {\n            observer.next(f)\n          })\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","getHeader","header","this","setup","getMetadata","VCF","setupP","opts","statusCallback","loc","openLocation","getConf","pluginManager","buffer","fetchAndMaybeUnzip","headerLines","featureMap","blockStart","decoder","TextDecoder","i","length","n","indexOf","b","subarray","line","decode","trim","startsWith","push","ret","refName","slice","Math","floor","toLocaleString","join","parser","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","idx","intervalTree","IntervalTree","f","VcfFeature","variant","parseLine","id","insert","get","vcfFeatures","catch","e","undefined","getRefNames","_","keys","getFeatures","region","ObservableCreate","async","start","end","search","forEach","observer","next","complete","error","signal","freeResources"],"sourceRoot":""}