{"version":3,"file":"static/js/8708.481ee11c.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","webpack://@jbrowse/web/../../plugins/alignments/src/CramAdapter/readFeaturesToNumericCIGAR.ts","webpack://@jbrowse/web/../../plugins/alignments/src/CramAdapter/CramAdapter.ts","webpack://@jbrowse/web/../../plugins/alignments/src/PileupRenderer/renderers/cigarUtil.ts"],"sourcesContent":["import { readFeaturesToNumericCIGAR } from './readFeaturesToNumericCIGAR.ts'\nimport { CHAR_FROM_CODE } from '../PileupRenderer/renderers/cigarUtil.ts'\nimport {\n  DELETION_TYPE,\n  HARDCLIP_TYPE,\n  INSERTION_TYPE,\n  MISMATCH_TYPE,\n  SKIP_TYPE,\n  SOFTCLIP_TYPE,\n} from '../shared/forEachMismatchTypes.ts'\nimport { cacheGetter, convertTagsToPlainArrays } from '../shared/util.ts'\n\nimport type CramAdapter from './CramAdapter.ts'\nimport type { MismatchCallback } from '../shared/forEachMismatchTypes.ts'\nimport type { Mismatch } from '../shared/types.ts'\nimport type { CramRecord } from '@gmod/cram'\nimport type { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\n\n// Module-level constant for CIGAR code conversion (avoids recreation on each call)\n// Maps packed CIGAR op codes to ASCII: M=77, I=73, D=68, N=78, S=83, H=72, P=80, ==61, X=88\nconst NUMERIC_CIGAR_CODES = new Uint8Array([\n  77, 73, 68, 78, 83, 72, 80, 61, 88, 63, 63, 63, 63, 63, 63, 63,\n])\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  private record: CramRecord\n  private _store: CramAdapter\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(record: CramRecord, _store: CramAdapter) {\n    this.record = record\n    this._store = _store\n  }\n\n  get name() {\n    return this.record.readName\n  }\n\n  get start() {\n    return this.record.alignmentStart - 1\n  }\n\n  get end() {\n    return this.start + (this.record.lengthOnRef ?? 1)\n  }\n\n  get score() {\n    return this.record.mappingQuality\n  }\n\n  get flags() {\n    return this.record.flags\n  }\n\n  get strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  get qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  get qualRaw() {\n    return this.record.qualityScores\n  }\n\n  get refName() {\n    return this._store.refIdToName(this.record.sequenceId)!\n  }\n\n  get pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  get template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  get next_ref() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  get next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  get is_paired() {\n    return !!this.record.mate\n  }\n\n  get next_pos() {\n    return this.record.mate?.alignmentStart\n  }\n\n  get tags() {\n    const RG = this._store.samHeader?.readGroups[this.record.readGroupId]\n    return RG !== undefined ? { ...this.record.tags, RG } : this.record.tags\n  }\n\n  get seq() {\n    // CRAM stores sequences as strings, not packed like BAM\n    // So we return the string directly without encoding/decoding\n    return this.record.getReadBases()\n  }\n\n  // generate packed NUMERIC_CIGAR as Uint32Array\n  get NUMERIC_CIGAR() {\n    return readFeaturesToNumericCIGAR(\n      this.record.readFeatures,\n      this.record.alignmentStart,\n      this.record.readLength,\n    )\n  }\n\n  // generate a CIGAR string from NUMERIC_CIGAR\n  get CIGAR() {\n    const numeric = this.NUMERIC_CIGAR\n    let result = ''\n    for (let i = 0, l = numeric.length; i < l; i++) {\n      const packed = numeric[i]!\n      const length = packed >> 4\n      const opCode = NUMERIC_CIGAR_CODES[packed & 0xf]!\n      result += length + CHAR_FROM_CODE[opCode]!\n    }\n    return result\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string): any {\n    switch (field) {\n      case 'mismatches':\n        return this.mismatches\n      case 'qual':\n        return this.qual\n      case 'CIGAR':\n        return this.CIGAR\n      case 'NUMERIC_CIGAR':\n        return this.NUMERIC_CIGAR\n      default:\n        return this.fields[field]\n    }\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  get mismatches() {\n    const mismatches: Mismatch[] = []\n    this.forEachMismatch(\n      (type, start, length, base, qual, altbase, cliplen) => {\n        if (type === MISMATCH_TYPE) {\n          mismatches.push({\n            type: 'mismatch',\n            start,\n            length,\n            base,\n            qual: qual !== undefined && qual >= 0 ? qual : undefined,\n            altbase:\n              altbase !== undefined && altbase > 0\n                ? CHAR_FROM_CODE[altbase]\n                : undefined,\n          })\n        } else if (type === INSERTION_TYPE) {\n          mismatches.push({\n            type: 'insertion',\n            start,\n            length,\n            insertlen: cliplen!,\n            insertedBases: base,\n          })\n        } else if (type === SOFTCLIP_TYPE) {\n          mismatches.push({\n            type: 'softclip',\n            start,\n            length,\n            cliplen: cliplen!,\n          })\n        } else if (type === HARDCLIP_TYPE) {\n          mismatches.push({\n            type: 'hardclip',\n            start,\n            length,\n            cliplen: cliplen!,\n          })\n        } else {\n          mismatches.push({\n            type: type === 2 ? 'deletion' : 'skip',\n            start,\n            length,\n          })\n        }\n      },\n    )\n    return mismatches\n  }\n\n  forEachMismatch(callback: MismatchCallback) {\n    const readFeatures = this.record.readFeatures\n    if (!readFeatures) {\n      return\n    }\n\n    const featStart = this.start\n    const qual = this.qualRaw\n    const hasQual = !!qual\n    const len = readFeatures.length\n\n    let refPos = 0\n    let lastPos = featStart\n    let insertedBases = ''\n    let insertedBasesLen = 0\n\n    for (let i = 0; i < len; i++) {\n      const rf = readFeatures[i]!\n      const sublen = refPos - lastPos\n      lastPos = refPos\n\n      // Flush accumulated single-base insertions\n      if (sublen && insertedBasesLen > 0) {\n        callback(\n          INSERTION_TYPE,\n          refPos,\n          0,\n          insertedBases,\n          -1,\n          0,\n          insertedBasesLen,\n        )\n        insertedBases = ''\n        insertedBasesLen = 0\n      }\n      refPos = rf.refPos - 1 - featStart\n\n      const { code } = rf\n\n      if (code === 'X') {\n        const refCharCode = rf.ref ? rf.ref.charCodeAt(0) & ~0x20 : 0\n        callback(\n          MISMATCH_TYPE,\n          refPos,\n          1,\n          rf.sub ?? '',\n          hasQual ? qual[rf.pos - 1]! : -1,\n          refCharCode,\n          0,\n        )\n      } else if (code === 'I') {\n        callback(INSERTION_TYPE, refPos, 0, rf.data, -1, 0, rf.data.length)\n      } else if (code === 'N') {\n        callback(SKIP_TYPE, refPos, rf.data, 'N', -1, 0, 0)\n      } else if (code === 'S') {\n        const dataLen = rf.data.length\n        callback(SOFTCLIP_TYPE, refPos, 1, `S${dataLen}`, -1, 0, dataLen)\n      } else if (code === 'H') {\n        callback(HARDCLIP_TYPE, refPos, 1, `H${rf.data}`, -1, 0, rf.data)\n      } else if (code === 'D') {\n        callback(DELETION_TYPE, refPos, rf.data, '*', -1, 0, 0)\n      } else if (code === 'i') {\n        insertedBases += rf.data\n        insertedBasesLen++\n      }\n    }\n\n    // Flush any remaining accumulated insertions\n    if (insertedBasesLen > 0) {\n      callback(\n        INSERTION_TYPE,\n        refPos,\n        0,\n        insertedBases,\n        -1,\n        0,\n        insertedBasesLen,\n      )\n    }\n  }\n\n  get fields(): SimpleFeatureSerialized {\n    return {\n      start: this.start,\n      name: this.name,\n      end: this.end,\n      score: this.score,\n      strand: this.strand,\n      template_length: this.template_length,\n      flags: this.flags,\n      tags: convertTagsToPlainArrays(this.tags),\n      refName: this.refName,\n      seq: this.seq,\n      type: 'match',\n      pair_orientation: this.pair_orientation,\n      next_ref: this.next_ref,\n      next_pos: this.next_pos,\n      next_segment_position: this.next_segment_position,\n      uniqueId: this.id(),\n    }\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...this.fields,\n      // lazy\n      CIGAR: this.CIGAR,\n      // lazy\n      qual: this.qual,\n    }\n  }\n}\n\ncacheGetter(CramSlightlyLazyFeature, 'fields')\ncacheGetter(CramSlightlyLazyFeature, 'CIGAR')\ncacheGetter(CramSlightlyLazyFeature, 'NUMERIC_CIGAR')\ncacheGetter(CramSlightlyLazyFeature, 'mismatches')\n","import type { CramRecord } from '@gmod/cram'\n\ntype ReadFeatures = CramRecord['readFeatures']\n\n// CIGAR operation char codes to indices (from BAM spec)\nconst CIGAR_OP_M = 0\nconst CIGAR_OP_I = 1\nconst CIGAR_OP_D = 2\nconst CIGAR_OP_N = 3\nconst CIGAR_OP_S = 4\nconst CIGAR_OP_H = 5\nconst CIGAR_OP_P = 6\n\n// Generates packed NUMERIC_CIGAR format: Uint32Array where each value is (length << 4) | opIndex\nexport function readFeaturesToNumericCIGAR(\n  readFeatures: ReadFeatures,\n  alignmentStart: number,\n  readLen: number,\n): ArrayLike<number> {\n  const cigarParts: number[] = []\n  let op = CIGAR_OP_M\n  let oplen = 0\n  let lastPos = alignmentStart\n  let insLen = 0\n  let seqLen = 0\n\n  if (readFeatures !== undefined) {\n    for (let i = 0, l = readFeatures.length; i < l; i++) {\n      const rf = readFeatures[i]!\n      const { code, refPos } = rf\n      const sublen = refPos - lastPos\n      seqLen += sublen\n      lastPos = refPos\n\n      // Flush pending insertions if we have a match region\n      if (insLen && sublen) {\n        cigarParts.push((insLen << 4) | CIGAR_OP_I)\n        insLen = 0\n      }\n      // Flush previous non-match operation\n      if (oplen && op !== CIGAR_OP_M) {\n        cigarParts.push((oplen << 4) | op)\n        oplen = 0\n      }\n      // Accumulate match length\n      if (sublen) {\n        op = CIGAR_OP_M\n        oplen += sublen\n      }\n\n      if (code === 'b') {\n        const addedLen = rf.data.split(',').length\n        seqLen += addedLen\n        lastPos += addedLen\n        oplen += addedLen\n      } else if (code === 'B' || code === 'X') {\n        seqLen++\n        lastPos++\n        oplen++\n      } else if (code === 'D' || code === 'N') {\n        lastPos += rf.data\n        if (oplen) {\n          cigarParts.push((oplen << 4) | op)\n          oplen = 0\n        }\n        const opIndex = code === 'D' ? CIGAR_OP_D : CIGAR_OP_N\n        cigarParts.push((rf.data << 4) | opIndex)\n      } else if (code === 'I' || code === 'S') {\n        const dataLen = rf.data.length\n        seqLen += dataLen\n        if (oplen) {\n          cigarParts.push((oplen << 4) | op)\n          oplen = 0\n        }\n        const opIndex = code === 'I' ? CIGAR_OP_I : CIGAR_OP_S\n        cigarParts.push((dataLen << 4) | opIndex)\n      } else if (code === 'i') {\n        if (oplen) {\n          cigarParts.push((oplen << 4) | op)\n          oplen = 0\n        }\n        insLen++\n        seqLen++\n      } else if (code === 'P' || code === 'H') {\n        if (oplen) {\n          cigarParts.push((oplen << 4) | op)\n          oplen = 0\n        }\n        const opIndex = code === 'P' ? CIGAR_OP_P : CIGAR_OP_H\n        cigarParts.push((rf.data << 4) | opIndex)\n      }\n    }\n  }\n\n  // Handle remaining sequence length\n  const remaining = readLen - seqLen\n  if (remaining) {\n    if (oplen && op !== CIGAR_OP_M) {\n      cigarParts.push((oplen << 4) | op)\n      oplen = 0\n    }\n    op = CIGAR_OP_M\n    oplen += remaining\n  }\n\n  // Flush pending insertions\n  if (remaining && insLen) {\n    cigarParts.push((insLen << 4) | CIGAR_OP_I)\n  }\n  // Flush final operation\n  if (oplen) {\n    cigarParts.push((oplen << 4) | op)\n  }\n\n  return cigarParts\n}\n","import { CraiIndex, IndexedCramFile } from '@gmod/cram'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { sum, updateStatus } from '@jbrowse/core/util'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature.ts'\nimport {\n  filterReadFlag,\n  filterTagValue,\n  parseSamHeader,\n} from '../shared/util.ts'\n\nimport type { FilterBy } from '../shared/types.ts'\nimport type { ParsedSamHeader } from '../shared/util.ts'\nimport type {\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  public samHeader?: ParsedSamHeader\n\n  private setupP?: Promise<{\n    samHeader: ParsedSamHeader\n    cram: IndexedCramFile\n  }>\n\n  private configureResult?: { cram: IndexedCramFile }\n\n  private sequenceAdapterP?: Promise<BaseSequenceAdapter>\n\n  private ultraLongFeatureCache = new QuickLRU<number, Feature>({\n    maxSize: 500,\n  })\n\n  private seqIdToOriginalRefName: string[] = []\n\n  private configure() {\n    if (!this.configureResult) {\n      const cramLocation = this.getConf('cramLocation')\n      const craiLocation = this.getConf('craiLocation')\n\n      this.configureResult = {\n        cram: new IndexedCramFile({\n          cramFilehandle: openLocation(cramLocation, this.pluginManager),\n          index: new CraiIndex({\n            filehandle: openLocation(craiLocation, this.pluginManager),\n          }),\n          seqFetch: async (seqId: number, start: number, end: number) => {\n            const sequenceAdapter = await this.getSequenceAdapter()\n            if (!sequenceAdapter) {\n              throw new Error('no sequenceAdapter available')\n            }\n            const refName =\n              this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n            if (!refName) {\n              throw new Error('unknown refName')\n            }\n\n            return (\n              (await sequenceAdapter.getSequence({\n                refName,\n                start: start - 1,\n                end,\n              })) ?? ''\n            )\n          },\n          checkSequenceMD5: false,\n        }),\n      }\n    }\n    return this.configureResult\n  }\n\n  async getSequenceAdapter() {\n    const config = this.sequenceAdapterConfig\n    if (!config || !this.getSubAdapter) {\n      return undefined\n    }\n    this.sequenceAdapterP ??= this.getSubAdapter(config)\n      .then(r => r.dataAdapter as BaseSequenceAdapter)\n      .catch((e: unknown) => {\n        this.sequenceAdapterP = undefined\n        throw e\n      })\n    return this.sequenceAdapterP\n  }\n\n  async getHeader(_opts?: BaseOptions) {\n    const { cram } = this.configure()\n    return cram.cram.getHeaderText()\n  }\n\n  private async setup(_opts?: BaseOptions) {\n    this.setupP ??= (async () => {\n      const { cram } = this.configure()\n      const rawHeader = await cram.cram.getSamHeader()\n      const samHeader = parseSamHeader(rawHeader)\n      this.samHeader = samHeader\n      return { samHeader, cram }\n    })().catch((e: unknown) => {\n      this.setupP = undefined\n      this.configureResult = undefined\n      throw e\n    })\n\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { samHeader } = await this.setup(opts)\n    return samHeader.idToName\n  }\n\n  refNameToId(refName: string) {\n    return this.samHeader?.nameToId[refName]\n  }\n\n  refIdToName(refId: number) {\n    return this.samHeader?.idToName[refId]\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy?: FilterBy\n    },\n  ) {\n    const { stopToken, filterBy, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      const { cram, samHeader } = await this.setup(opts)\n\n      const refId = this.refNameToId(refName)\n      if (refId === undefined) {\n        console.warn('Unknown refName', refName)\n        observer.complete()\n        return\n      }\n\n      if (originalRefName) {\n        this.seqIdToOriginalRefName[refId] = originalRefName\n      }\n      let records\n      try {\n        records = await updateStatus(\n          'Downloading alignments',\n          statusCallback,\n          () => cram.getRecordsForRange(refId, start, end),\n        )\n      } catch (e) {\n        // Clear caches on error so reload works\n        this.setupP = undefined\n        this.configureResult = undefined\n        throw e\n      }\n      checkStopToken(stopToken)\n      await updateStatus('Processing alignments', statusCallback, () => {\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n        } = filterBy || {}\n\n        for (const record of records) {\n          if (filterReadFlag(record.flags, flagInclude, flagExclude)) {\n            continue\n          }\n          if (\n            tagFilter &&\n            filterTagValue(\n              tagFilter.tag === 'RG'\n                ? samHeader.readGroups[record.readGroupId]\n                : record.tags[tagFilter.tag],\n              tagFilter.value,\n            )\n          ) {\n            continue\n          }\n          if (readName && record.readName !== readName) {\n            continue\n          }\n\n          if (record.readLength > 5_000) {\n            const ret = this.ultraLongFeatureCache.get(record.uniqueId)\n            if (ret) {\n              observer.next(ret)\n            } else {\n              const elt = new CramSlightlyLazyFeature(record, this)\n              this.ultraLongFeatureCache.set(record.uniqueId, elt)\n              observer.next(elt)\n            }\n          } else {\n            observer.next(new CramSlightlyLazyFeature(record, this))\n          }\n        }\n\n        observer.complete()\n      })\n    }, stopToken)\n  }\n\n  /**\n   * we return the configured fetchSizeLimit, and the bytes for the region\n   */\n  async getMultiRegionFeatureDensityStats(regions: Region[]) {\n    const bytes = await this.bytesForRegions(regions)\n    const fetchSizeLimit = this.getConf('fetchSizeLimit')\n    return {\n      bytes,\n      fetchSizeLimit,\n    }\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   */\n  private async bytesForRegions(regions: Region[]) {\n    const { cram } = this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region => {\n        const { refName, start, end } = region\n        const chrId = this.refNameToId(refName)\n        return chrId !== undefined\n          ? cram.index.getEntriesForRange(chrId, start, end)\n          : Promise.resolve([{ sliceBytes: 0 }])\n      }),\n    )\n\n    return sum(blockResults.flat().map(a => a.sliceBytes))\n  }\n}\n","import { parseCigar2 } from '../../MismatchParser/index.ts'\n\n// CIGAR operation indices (from BAM spec) - used in packed Uint32Array format\nexport const CIGAR_M = 0\nexport const CIGAR_I = 1\nexport const CIGAR_D = 2\nexport const CIGAR_N = 3\nexport const CIGAR_S = 4\nexport const CIGAR_H = 5\nexport const CIGAR_P = 6\nexport const CIGAR_EQ = 7\nexport const CIGAR_X = 8\n\n// Bitmasks for CIGAR operation categories (use with: (1 << op) & MASK)\n// Alignment match ops (M=0, ==7) - may contain mismatches, need MD tag\nexport const CIGAR_M_EQ_MASK = 0b10000001 // (1<<0)|(1<<7) = 129\n// Match/mismatch ops that consume both ref and seq (M=0, ==7, X=8)\nexport const CIGAR_MATCH_MASK = 0b110000001 // (1<<0)|(1<<7)|(1<<8) = 385\n// Seq-only ops (S=4, I=1)\nexport const CIGAR_SEQ_ONLY_MASK = 0b10010 // (1<<1)|(1<<4) = 18\n// Ref-skip ops (D=2, N=3)\nexport const CIGAR_REF_SKIP_MASK = 0b1100 // (1<<2)|(1<<3) = 12\n// Ref-consuming ops (M=0, D=2, ==7, X=8)\nexport const CIGAR_REF_CONSUMING_MASK = 0b110000101 // (1<<0)|(1<<2)|(1<<7)|(1<<8) = 389\n\n// BAM 4-bit encoded sequence lookup table\nexport const SEQRET = '=ACMGRSVTWYHKDBN'\n\n// Numeric decoder - returns char codes directly (lowercase for case-insensitive comparison)\n// '=' = 61, 'a' = 97, 'c' = 99, 'm' = 109, 'g' = 103, 'r' = 114, 's' = 115, 'v' = 118,\n// 't' = 116, 'w' = 119, 'y' = 121, 'h' = 104, 'k' = 107, 'd' = 100, 'b' = 98, 'n' = 110\nexport const SEQRET_NUMERIC_DECODER = new Uint8Array([\n  61, 97, 99, 109, 103, 114, 115, 118, 116, 119, 121, 104, 107, 100, 98, 110,\n])\n\n// Pre-computed char lookup for ASCII codes (avoids String.fromCharCode in hot loops)\nexport const CHAR_FROM_CODE: string[] = Array.from({ length: 128 }, (_, i) =>\n  String.fromCharCode(i),\n)\n\n// Helper to ensure we have Uint32Array (packed format)\nexport function getCigarOps(\n  cigar: Uint32Array | string | undefined,\n): ArrayLike<number> {\n  return typeof cigar === 'string' ? parseCigar2(cigar) : cigar || []\n}\n"],"names":["NUMERIC_CIGAR_CODES","Uint8Array","CramSlightlyLazyFeature","constructor","record","_store","this","name","readName","start","alignmentStart","end","lengthOnRef","score","mappingQuality","flags","strand","isReverseComplemented","qual","qualityScores","join","qualRaw","refName","refIdToName","sequenceId","pair_orientation","isPaired","getPairOrientation","undefined","template_length","templateLength","templateSize","next_ref","mate","next_segment_position","is_paired","next_pos","tags","RG","samHeader","readGroups","readGroupId","seq","getReadBases","NUMERIC_CIGAR","readFeatures","readLen","cigarParts","op","oplen","lastPos","insLen","seqLen","i","l","length","rf","code","refPos","sublen","push","addedLen","data","split","opIndex","dataLen","remaining","readFeaturesToNumericCIGAR","readLength","CIGAR","numeric","result","packed","opCode","CHAR_FROM_CODE","id","uniqueId","get","field","mismatches","fields","parent","children","forEachMismatch","type","base","altbase","cliplen","MISMATCH_TYPE","INSERTION_TYPE","insertlen","insertedBases","SOFTCLIP_TYPE","HARDCLIP_TYPE","callback","featStart","hasQual","len","insertedBasesLen","refCharCode","ref","charCodeAt","sub","pos","SKIP_TYPE","DELETION_TYPE","convertTagsToPlainArrays","toJSON","cacheGetter","CramAdapter","BaseFeatureDataAdapter","ultraLongFeatureCache","QuickLRU","maxSize","seqIdToOriginalRefName","configure","configureResult","cramLocation","getConf","craiLocation","cram","IndexedCramFile","cramFilehandle","openLocation","pluginManager","index","CraiIndex","filehandle","seqFetch","async","seqId","sequenceAdapter","getSequenceAdapter","Error","refIdToOriginalName","getSequence","checkSequenceMD5","config","sequenceAdapterConfig","getSubAdapter","sequenceAdapterP","then","r","dataAdapter","catch","e","getHeader","_opts","getHeaderText","setup","setupP","rawHeader","getSamHeader","parseSamHeader","getRefNames","opts","idToName","refNameToId","nameToId","refId","getFeatures","region","stopToken","filterBy","statusCallback","originalRefName","ObservableCreate","console","warn","observer","complete","records","updateStatus","getRecordsForRange","checkStopToken","flagInclude","flagExclude","tagFilter","filterReadFlag","filterTagValue","tag","value","ret","next","elt","set","getMultiRegionFeatureDensityStats","regions","bytes","bytesForRegions","fetchSizeLimit","blockResults","Promise","all","map","chrId","getEntriesForRange","resolve","sliceBytes","sum","flat","a","CIGAR_M","CIGAR_I","CIGAR_D","CIGAR_N","CIGAR_S","CIGAR_H","CIGAR_EQ","CIGAR_X","CIGAR_M_EQ_MASK","CIGAR_REF_CONSUMING_MASK","SEQRET","SEQRET_NUMERIC_DECODER","Array","from","_","String","fromCharCode","getCigarOps","cigar","parseCigar2"],"sourceRoot":""}