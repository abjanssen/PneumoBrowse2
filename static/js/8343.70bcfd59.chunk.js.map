{"version":3,"file":"static/js/8343.70bcfd59.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree'\nimport VcfParser from '@gmod/vcf'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { fetchAndMaybeUnzip, getProgressDisplayStr } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport VcfFeature from '../VcfFeature'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  vcfFeatures?: Promise<{\n    header: string\n    parser: VcfParser\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { parser } = await this.setup()\n    return parser.getMetadata()\n  }\n\n  public async setupP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const loc = openLocation(this.getConf('vcfLocation'), this.pluginManager)\n    const buffer = await fetchAndMaybeUnzip(loc, opts)\n    const headerLines = []\n    const featureMap = {} as Record<string, string[]>\n    let blockStart = 0\n\n    const decoder = new TextDecoder('utf8')\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf(10, blockStart)\n      // could be a non-newline ended file, so slice to end of file if n===-1\n      const b =\n        n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n)\n      const line = decoder.decode(b).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = []\n          }\n          featureMap[refName].push(line)\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const header = headerLines.join('\\n')\n    const parser = new VcfParser({ header })\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing VCF data')\n            let idx = 0\n            const intervalTree = new IntervalTree()\n            for (const line of lines) {\n              const f = new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-${refName}-${idx++}`,\n              })\n              intervalTree.insert([f.get('start'), f.get('end')], f)\n            }\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header,\n      parser,\n      intervalTreeMap,\n    }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch((e: unknown) => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.setup()\n    return Object.keys(intervalTreeMap)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { intervalTreeMap } = await this.setup()\n        for (const f of intervalTreeMap[refName]?.(opts.statusCallback).search([\n          start,\n          end,\n        ]) || []) {\n          observer.next(f)\n        }\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n\n  async getSources() {\n    const conf = this.getConf('samplesTsvLocation')\n    if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n      const { parser } = await this.setup()\n      return parser.samples.map(name => ({\n        name,\n      }))\n    } else {\n      const txt = await openLocation(conf).readFile('utf8')\n      const lines = txt.split(/\\n|\\r\\n|\\r/)\n      const header = lines[0]!.split('\\t')\n      const { parser } = await this.setup()\n      const s = new Set(parser.samples)\n      return lines\n        .slice(1)\n        .map(line => {\n          const cols = line.split('\\t')\n          return {\n            name: cols[0]!,\n            ...Object.fromEntries(\n              // force col 0 to be called name\n              cols.slice(1).map((c, idx) => [header[idx + 1]!, c] as const),\n            ),\n          }\n        })\n        .filter(f => s.has(f.name))\n    }\n  }\n}\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","getHeader","header","this","setup","getMetadata","parser","setupP","opts","statusCallback","loc","openLocation","getConf","pluginManager","buffer","fetchAndMaybeUnzip","headerLines","featureMap","blockStart","decoder","TextDecoder","i","length","n","indexOf","b","subarray","line","decode","trim","startsWith","push","ret","refName","slice","getProgressDisplayStr","join","VcfParser","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","idx","intervalTree","IntervalTree","f","VcfFeature","variant","parseLine","id","insert","get","vcfFeatures","catch","e","undefined","getRefNames","_","keys","getFeatures","region","ObservableCreate","async","start","end","search","observer","next","complete","error","stopToken","getSources","conf","uri","samples","name","readFile","split","s","Set","cols","c","filter","has"],"sourceRoot":""}