"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[9280],{79280:(e,t,n)=>{n.r(t),n.d(t,{default:()=>d});const s=BigInt(32);"getBigInt64"in DataView||(DataView.prototype.getBigInt64=function(e,t){return function(e,t,n){const i=Number(!!n),a=Number(!n);return BigInt(e.getInt32(t,n)*a+e.getInt32(t+4,n)*i)<<s|BigInt(e.getUint32(t,n)*i+e.getUint32(t+4,n)*a)}(this,e,t)}),"getBigUint64"in DataView||(DataView.prototype.getBigUint64=function(e,t){return function(e,t,n){const i=e.getUint32(t,n),a=e.getUint32(t+4,n),r=Number(!!n),o=Number(!n);return BigInt(i*o+a*r)<<s|BigInt(i*r+a*o)}(this,e,t)});var i=n(95624);const a=["T","C","A","G"],r=[];for(let e=0;e<256;e++)r.push(a[e>>6&3]+a[e>>4&3]+a[e>>2&3]+a[3&e]);const o=r.map((e=>e.toLowerCase()));class c{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else{if(!t)throw new Error("must supply path or filehandle");this.filehandle=new i.EY(t)}}async _detectEndianness(){const e=await this.filehandle.read(8,0),t=new DataView(e.buffer);if(440477507!==t.getInt32(0,!0))throw new Error("not a 2bit file");this.version=t.getInt32(0,!0)}getHeader(){return this.headerP||(this.headerP=this._getHeader().catch((e=>{throw this.headerP=void 0,e}))),this.headerP}async _getHeader(){await this._detectEndianness();const e=await this.filehandle.read(16,0),t=!0,n=new DataView(e.buffer,e.byteOffset,e.length);let s=0;const i=n.getInt32(s,t);if(s+=4,440477507!==i)throw new Error(`Wrong magic number ${i}`);const a=n.getInt32(s,t);s+=4;const r=n.getUint32(s,t);return s+=4,{version:a,magic:i,sequenceCount:r,reserved:n.getUint32(s,t)}}getIndex(){return this.indexP||(this.indexP=this._getIndex().catch((e=>{throw this.indexP=void 0,e}))),this.indexP}async _getIndex(){const e=await this.getHeader(),t=8+e.sequenceCount*(257+(1===this.version?8:4)),n=await this.filehandle.read(t,8),s=!0,i=new DataView(n.buffer,n.byteOffset,n.length);let a=0;const r=i.getUint32(a,s);a+=4,a+=4;const o=[],c=new TextDecoder("utf8");for(let t=0;t<r;t++){const t=i.getUint8(a);a+=1;const r=c.decode(n.subarray(a,a+t));if(a+=t,1===e.version){const e=Number(i.getBigUint64(a,s));a+=8,o.push({offset:e,name:r})}else{const e=i.getUint32(a,s);a+=4,o.push({offset:e,name:r})}}return Object.fromEntries(o.map((({name:e,offset:t})=>[e,t])))}async getSequenceNames(){const e=await this.getIndex();return Object.keys(e)}async getSequenceSizes(){const e=await this.getIndex(),t=Object.keys(e),n=await Promise.all(Object.values(e).map((e=>this._getSequenceSize(e)))),s={};for(const[e,i]of t.entries())s[i]=n[e];return s}async getSequenceSize(e){const t=(await this.getIndex())[e];return t?this._getSequenceSize(t):void 0}async _getSequenceSize(e){return this._record1(e).then((e=>e.dnaSize))}async _record1(e,t=8){const n=await this.filehandle.read(t,e),s=!0;let i=0;const a=new DataView(n.buffer,n.byteOffset,n.length),r=a.getUint32(i,s);i+=4;const o=a.getUint32(i,s);return i+=4,{dnaSize:r,nBlockCount:o}}async _record2(e,t){const n=await this.filehandle.read(t,e),s=!0;let i=0;const a=new DataView(n.buffer,n.byteOffset,n.length),r=a.getUint32(i,s);i+=4;const o=[];for(let e=0;e<r;e++){const e=a.getUint32(i,s);i+=4,o.push(e)}const c=[];for(let e=0;e<r;e++){const e=a.getUint32(i,s);i+=4,c.push(e)}return{maskBlockCount:a.getUint32(i,s),nBlockSizes:c,nBlockStarts:o}}async _record3(e,t){const n=await this.filehandle.read(t,e),s=!0;let i=0;const a=new DataView(n.buffer,n.byteOffset,n.length),r=a.getUint32(i,s);i+=4;const o=[];for(let e=0;e<r;e++){const e=a.getUint32(i,s);i+=4,o.push(e)}const c=[];for(let e=0;e<r;e++){const e=a.getUint32(i,s);i+=4,c.push(e)}return{maskBlockCount:r,maskBlockSizes:c,maskBlockStarts:o,reserved:a.getInt32(i,s)}}async _getSequenceRecord(e){const t=await this._record1(e),n=8*t.nBlockCount+8,s=await this._record2(e+4,n),i=8*s.maskBlockCount+8,a=await this._record3(e+4+n-4,i);return{dnaSize:t.dnaSize,nBlocks:{starts:s.nBlockStarts,sizes:s.nBlockSizes},maskBlocks:{starts:a.maskBlockStarts,sizes:a.maskBlockSizes},dnaPosition:e+4+n-4+i}}async getSequence(e,t=0,n=Number.POSITIVE_INFINITY){const s=(await this.getIndex())[e];if(!s)return;const i=await this._getSequenceRecord(s);if(t<0)throw new TypeError("regionStart cannot be less than 0");n>i.dnaSize&&(n=i.dnaSize);const a=this._getOverlappingBlocks(t,n,i.nBlocks.starts,i.nBlocks.sizes),c=this._getOverlappingBlocks(t,n,i.maskBlocks.starts,i.maskBlocks.sizes),h=Math.ceil((n-t)/4)+1,u=Math.floor(t/4),l=await this.filehandle.read(h,i.dnaPosition+u);let g="";for(let e=t;e<n;e+=1){for(;c.length>0&&c[0].end<=e;)c.shift();const t=c[0]&&c[0].start<=e&&c[0].end>e;if(a[0]&&e>=a[0].start&&e<a[0].end){const s=a.shift();for(;e<s.end&&e<n;e+=1)g+=t?"n":"N";e-=1}else{const n=e%4,s=l[Math.floor(e/4)-u];g+=t?o[s][n]:r[s][n]}}return g}_getOverlappingBlocks(e,t,n,s){let i,a;for(const[r,o]of n.entries())if(e>=o+s[r]||t<=o){if(void 0!==i){a=r;break}}else void 0===i&&(i=r);if(void 0===i)return[];void 0===a&&(a=n.length);const r=new Array(a-i);for(let e=i;e<a;e+=1)r[e-i]={start:n[e],end:n[e]+s[e],size:s[e]};return r}}var h=n(68584),u=n(46377),l=n(99834),g=n(66885),f=n(6434);class d extends u.BaseSequenceAdapter{async initChromSizes(){const e=(0,h.readConfObject)(this.config,"chromSizesLocation");if("/path/to/default.chrom.sizes"!==e.uri&&""!==e.uri){const t=(0,l.openLocation)(e,this.pluginManager),n=await t.readFile("utf8");return Object.fromEntries(n.split(/\n|\r\n|\r/).filter((e=>!!e.trim())).map((e=>{const[t,n]=e.split("\t");return[t,+n]})))}}async setupPre(){return{twobit:new c({filehandle:(0,l.openLocation)(this.getConf("twoBitLocation"),this.pluginManager)}),chromSizesData:await this.initChromSizes()}}async setup(){return this.setupP||(this.setupP=this.setupPre().catch((e=>{throw this.setupP=void 0,e}))),this.setupP}async getRefNames(){const{chromSizesData:e,twobit:t}=await this.setup();return e?Object.keys(e):t.getSequenceNames()}async getRegions(){const{chromSizesData:e,twobit:t}=await this.setup();if(e)return Object.keys(e).map((t=>({refName:t,start:0,end:e[t]})));{const e=await t.getSequenceSizes();return Object.keys(e).map((t=>({refName:t,start:0,end:e[t]})))}}getFeatures({refName:e,start:t,end:n}){return(0,g.ObservableCreate)((async s=>{const{twobit:i}=await this.setup(),a=await i.getSequenceSize(e),r=void 0!==a?Math.min(a,n):n,o=await i.getSequence(e,t,r);o&&s.next(new f.A({id:`${e} ${t}-${r}`,data:{refName:e,start:t,end:r,seq:o}})),s.complete()}))}freeResources(){}}}}]);
//# sourceMappingURL=9280.2e858b4f.chunk.js.map