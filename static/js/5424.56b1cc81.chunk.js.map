{"version":3,"file":"static/js/5424.56b1cc81.chunk.js","mappings":"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","sources":["../../../plugins/linear-genome-view/src/BaseLinearDisplay/SVGLegend.tsx","../../../plugins/linear-genome-view/src/LinearGenomeView/SVGErrorBox.tsx","../../../plugins/linear-genome-view/src/BaseLinearDisplay/models/calculateLabelPositions.ts","../../../plugins/linear-genome-view/src/BaseLinearDisplay/renderSvg.tsx"],"sourcesContent":["import { measureText } from '@jbrowse/core/util'\n\nimport type { LegendItem } from './components/FloatingLegend.tsx'\n\nconst LEGEND_FONT_SIZE = 10\nconst LEGEND_BOX_SIZE = 12\nconst LEGEND_PADDING = 3\n\nexport default function SVGLegend({\n  items,\n  width,\n  legendAreaWidth,\n}: {\n  items: LegendItem[]\n  width: number\n  legendAreaWidth?: number\n}) {\n  if (items.length === 0) {\n    return null\n  }\n\n  const itemHeight = LEGEND_BOX_SIZE + 2\n  const legendHeight = items.length * itemHeight + LEGEND_PADDING * 2\n\n  // Calculate legend width based on longest label\n  const maxLabelWidth = Math.max(\n    ...items.map(item => measureText(item.label, LEGEND_FONT_SIZE)),\n  )\n  const legendWidth = LEGEND_BOX_SIZE + 8 + maxLabelWidth + LEGEND_PADDING * 2\n\n  // If legendAreaWidth is provided, position legend to the right of the figure\n  // Otherwise, position it inside the figure area (top-right corner)\n  const x = legendAreaWidth ? width + 10 : width - legendWidth - 10\n  const y = 10\n\n  return (\n    <g transform={`translate(${x}, ${y})`}>\n      <rect\n        x={0}\n        y={0}\n        width={legendWidth}\n        height={legendHeight}\n        fill=\"rgba(255,255,255,0.9)\"\n        stroke=\"#ccc\"\n        strokeWidth={1}\n        rx={4}\n      />\n      {items.map((item, idx) => (\n        <g\n          key={`legend-${idx}`}\n          transform={`translate(${LEGEND_PADDING}, ${LEGEND_PADDING + idx * itemHeight})`}\n        >\n          {item.color ? (\n            <rect\n              x={0}\n              y={0}\n              width={LEGEND_BOX_SIZE}\n              height={LEGEND_BOX_SIZE}\n              fill={item.color}\n            />\n          ) : null}\n          <text\n            x={LEGEND_BOX_SIZE + 6}\n            y={LEGEND_BOX_SIZE - 2}\n            fontSize={LEGEND_FONT_SIZE}\n            fill=\"black\"\n          >\n            {item.label}\n          </text>\n        </g>\n      ))}\n    </g>\n  )\n}\n","export function ErrorBox({\n  error,\n  width,\n  height,\n}: {\n  error: unknown\n  width: number\n  height: number\n}) {\n  return (\n    <>\n      <rect x={0} y={0} width={width} height={height} fill=\"#ffdddd\" />\n      <text x={10} y={height / 2} fill=\"#cc0000\" fontSize={14}>\n        {`${error}`}\n      </text>\n    </>\n  )\n}\n","import { clamp, measureText } from '@jbrowse/core/util'\n\nimport type { LinearGenomeViewModel } from '../../LinearGenomeView/index.ts'\nimport type { BaseLinearDisplayModel } from '../model.ts'\nimport type { Assembly } from '@jbrowse/core/assemblyManager/assembly'\n\nexport interface RenderProps {\n  rendererType: any\n  renderArgs: Record<string, any>\n  renderProps: Record<string, any>\n  displayError: unknown\n  rpcManager: { call: (...args: unknown[]) => void }\n  cannotBeRenderedReason: string\n}\nexport interface LabelData {\n  key: string\n  label: string\n  description: string\n  leftPos: number\n  topPos: number\n}\n\nexport interface ErrorProps {\n  displayError: string\n}\n/**\n * Calculate positions for floating feature labels\n * Labels are \"floating\" in that they clamp to the left edge of the viewport\n * when the feature scrolls off-screen to the left\n */\nexport function calculateLabelPositions(\n  model: BaseLinearDisplayModel,\n  view: LinearGenomeViewModel,\n  assembly: Assembly | undefined,\n  offsetPx: number,\n): LabelData[] {\n  if (!assembly) {\n    return []\n  }\n\n  const fontSize = 11\n  const result: LabelData[] = []\n\n  for (const [key, val] of model.layoutFeatures.entries()) {\n    if (!val?.[4]) {\n      continue\n    }\n\n    const [left, , right, bottom, feature] = val\n    const { refName, description, label, totalLayoutWidth } = feature\n\n    if (!label) {\n      continue\n    }\n\n    const r0 = assembly.getCanonicalRefName2(refName)\n    const px1 = view.bpToPx({\n      refName: r0,\n      coord: left,\n    })?.offsetPx\n    const px2 = view.bpToPx({\n      refName: r0,\n      coord: right,\n    })?.offsetPx\n\n    if (px1 === undefined) {\n      continue\n    }\n\n    // Normalize pixel positions: leftPx is always visual left, rightPx is visual right\n    // When region is reversed, genomic left maps to visual right (px1 > px2)\n    const leftPx = px2 !== undefined ? Math.min(px1, px2) : px1\n    const rightPx = px2 !== undefined ? Math.max(px1, px2) : px1\n\n    // Cache text measurement\n    const labelWidth = getCachedMeasureText(label, fontSize)\n\n    // Calculate clamped position - this is the \"floating\" behavior\n    // Labels stick to the left edge (0) when features scroll off-screen\n    // Use totalLayoutWidth if available to determine the effective right edge\n    const effectiveRightPx =\n      totalLayoutWidth !== undefined ? leftPx + totalLayoutWidth : rightPx\n    const leftPos = clamp(\n      0,\n      leftPx - offsetPx,\n      effectiveRightPx - offsetPx - labelWidth,\n    )\n\n    const topPos = bottom - 14 * (+!!description + +!!label)\n\n    result.push({\n      key,\n      label,\n      description: description || '',\n      leftPos,\n      topPos,\n    })\n  }\n\n  return result\n}\n\n// Cache for text measurements to avoid re-measuring same text\nconst textMeasureCache = new Map<string, number>()\n\nfunction getCachedMeasureText(text: string, fontSize: number): number {\n  const key = `${text}:${fontSize}`\n  let width = textMeasureCache.get(key)\n  if (width === undefined) {\n    width = measureText(text, fontSize)\n    // Keep cache size reasonable (max 500 entries)\n    if (textMeasureCache.size > 500) {\n      const firstKey = textMeasureCache.keys().next().value\n      if (firstKey) {\n        textMeasureCache.delete(firstKey)\n      }\n    }\n    textMeasureCache.set(key, width)\n  }\n  return width\n}\n","import { Fragment } from 'react'\n\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\nimport {\n  ReactRendering,\n  getContainingView,\n  getSession,\n} from '@jbrowse/core/util'\n\nimport SVGLegend from './SVGLegend.tsx'\nimport BlockState, {\n  renderBlockData,\n} from './models/serverSideRenderedBlock.ts'\nimport { getId } from './models/util.ts'\nimport { ErrorBox } from '../LinearGenomeView/SVGErrorBox.tsx'\nimport { calculateLabelPositions } from './models/calculateLabelPositions.ts'\n\nimport type { BaseLinearDisplayModel } from './model.ts'\nimport type { ExportSvgDisplayOptions } from './types.ts'\nimport type { LinearGenomeViewModel } from '../LinearGenomeView/index.ts'\n\nexport async function renderBaseLinearDisplaySvg(\n  self: BaseLinearDisplayModel,\n  opts: ExportSvgDisplayOptions,\n) {\n  const { height, id } = self\n  const { overrideHeight } = opts\n  const view = getContainingView(self) as LinearGenomeViewModel\n  const { offsetPx: viewOffsetPx, roundedDynamicBlocks, width } = view\n\n  if (self.error) {\n    return <ErrorBox error={self.error} width={width} height={height} />\n  }\n\n  const renderings = await Promise.all(\n    roundedDynamicBlocks.map(async block => {\n      const blockState = BlockState.create({\n        key: block.key,\n        region: block,\n      })\n\n      // regionCannotBeRendered can return jsx so look for plaintext\n      // version, or just get the default if none available\n      const cannotBeRenderedReason =\n        self.regionCannotBeRenderedText(block) ||\n        self.regionCannotBeRendered(block)\n\n      if (cannotBeRenderedReason) {\n        return [\n          block,\n          {\n            reactElement: (\n              <>\n                <rect x={0} y={0} width={width} height={20} fill=\"#aaa\" />\n                <text x={0} y={15}>\n                  {cannotBeRenderedReason}\n                </text>\n              </>\n            ),\n          },\n        ] as const\n      }\n\n      const {\n        rpcManager,\n        renderArgs,\n        renderProps,\n        renderingProps,\n        rendererType,\n      } = renderBlockData(blockState, self)\n\n      return [\n        block,\n        await rendererType.renderInClient(rpcManager, {\n          ...renderArgs,\n          ...renderProps,\n          renderingProps,\n          exportSVG: opts,\n          theme: opts.theme || renderProps.theme,\n        }),\n      ] as const\n    }),\n  )\n\n  // Calculate label positions for SVG export\n  const { assemblyManager } = getSession(self)\n  const { offsetPx } = view\n  const assemblyName = view.assemblyNames[0]\n  const assembly = assemblyName ? assemblyManager.get(assemblyName) : undefined\n  const labelData = calculateLabelPositions(self, view, assembly, offsetPx)\n\n  // Create a clip path ID for the labels that covers the entire view\n  const labelsClipId = getId(id, 'labels')\n\n  // Get legend items if legend is enabled\n  const theme = createJBrowseTheme(opts.theme)\n  const legendItems = self.showLegend ? self.legendItems(theme) : []\n\n  return (\n    <>\n      {renderings.map(([block, rendering], index) => {\n        const { offsetPx, widthPx } = block\n        const offset = offsetPx - viewOffsetPx\n        const clipid = getId(id, index)\n\n        return (\n          <Fragment key={`frag-${index}`}>\n            <defs>\n              <clipPath id={clipid}>\n                <rect\n                  x={0}\n                  y={0}\n                  width={widthPx}\n                  height={overrideHeight || height}\n                />\n              </clipPath>\n            </defs>\n            <g transform={`translate(${offset} 0)`}>\n              <g clipPath={`url(#${clipid})`}>\n                <ReactRendering rendering={rendering} />\n              </g>\n            </g>\n          </Fragment>\n        )\n      })}\n      {/* Render floating labels with clipping */}\n      <defs>\n        <clipPath id={labelsClipId}>\n          <rect x={0} y={0} width={width} height={overrideHeight || height} />\n        </clipPath>\n      </defs>\n      <g clipPath={`url(#${labelsClipId})`}>\n        {labelData.map(({ key, label, description, leftPos, topPos }) => (\n          <g\n            key={`label-${key}`}\n            transform={`translate(${leftPos}, ${topPos})`}\n          >\n            <text x={0} y={11} fontSize={11} fill=\"currentColor\">\n              {label}\n            </text>\n            {description ? (\n              <text x={0} y={25} fontSize={11} fill=\"blue\">\n                {description}\n              </text>\n            ) : null}\n          </g>\n        ))}\n      </g>\n      {legendItems.length > 0 ? (\n        <SVGLegend\n          items={legendItems}\n          width={width}\n          legendAreaWidth={opts.legendWidth}\n        />\n      ) : null}\n    </>\n  )\n}\n"],"names":["SVGLegend","t0","$","_c","items","width","legendAreaWidth","length","legendHeight","LEGEND_BOX_SIZE","LEGEND_PADDING","t1","Math","max","map","_temp","legendWidth","t2","t3","t4","t5","_jsx","x","y","fill","stroke","strokeWidth","rx","Symbol","for","item_0","idx","_jsxs","transform","children","item","color","LEGEND_FONT_SIZE","label","measureText","ErrorBox","error","height","fontSize","_Fragment","textMeasureCache","Map","getCachedMeasureText","text","key","get","undefined","size","firstKey","keys","next","value","delete","set","async","renderBaseLinearDisplaySvg","self","opts","id","overrideHeight","view","getContainingView","offsetPx","viewOffsetPx","roundedDynamicBlocks","renderings","Promise","all","blockState","BlockState","create","block","region","cannotBeRenderedReason","regionCannotBeRenderedText","regionCannotBeRendered","reactElement","rpcManager","renderArgs","renderProps","renderingProps","rendererType","renderBlockData","renderInClient","exportSVG","theme","assemblyManager","getSession","assemblyName","assemblyNames","assembly","labelData","model","result","val","layoutFeatures","entries","left","right","bottom","feature","refName","description","totalLayoutWidth","r0","getCanonicalRefName2","px1","bpToPx","coord","px2","leftPx","min","rightPx","labelWidth","effectiveRightPx","leftPos","clamp","topPos","push","calculateLabelPositions","labelsClipId","getId","createJBrowseTheme","legendItems","showLegend","rendering","index","widthPx","offset","clipid","Fragment","clipPath","ReactRendering"],"ignoreList":[],"sourceRoot":""}