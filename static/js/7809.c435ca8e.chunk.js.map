{"version":3,"file":"static/js/7809.c435ca8e.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts","../../../plugins/gff3/src/featureData.ts"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { fetchAndMaybeUnzip, getProgressDisplayStr } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { parseStringSync } from 'gff-nostream'\n\nimport { featureData } from '../featureData'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { NoAssemblyRegion } from '@jbrowse/core/util/types'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  gffFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  private async loadDataP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const buffer = await fetchAndMaybeUnzip(\n      openLocation(this.getConf('gffLocation'), this.pluginManager),\n      opts,\n    )\n\n    const headerLines = []\n    const featureMap = {} as Record<string, string>\n    const decoder = new TextDecoder('utf8')\n    let blockStart = 0\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf(10, blockStart)\n      // could be a non-newline ended file, so subarray to end of file if n===-1\n      const b =\n        n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n)\n      const line = decoder.decode(b).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else if (line.startsWith('>')) {\n          break\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = ''\n          }\n          featureMap[refName] += `${line}\\n`\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing GFF data')\n            const intervalTree = new IntervalTree()\n            for (const obj of parseStringSync(lines)\n              .flat()\n              .map(\n                (f, i) =>\n                  new SimpleFeature({\n                    data: featureData(f),\n                    id: `${this.id}-${refName}-${i}`,\n                  }),\n              )) {\n              intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n            }\n\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header: headerLines.join('\\n'),\n      intervalTreeMap,\n    }\n  }\n\n  private async loadData(opts: BaseOptions) {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.loadData(opts)\n    return Object.keys(intervalTreeMap)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTreeMap } = await this.loadData(opts)\n        for (const f of intervalTreeMap[refName]?.(opts.statusCallback).search([\n          start,\n          end,\n        ]) || []) {\n          observer.next(f)\n        }\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n}\n","import type { GFF3FeatureLineWithRefs } from 'gff-nostream'\n\ninterface GFF3Feature {\n  start: number\n  end: number\n  strand?: number\n  type: string | null\n  source: string | null\n  refName: string\n  derived_features: unknown[] | null\n  phase?: number\n  score?: number\n  subfeatures: GFF3Feature[] | undefined\n  [key: string]: unknown\n}\n\nexport function featureData(data: GFF3FeatureLineWithRefs): GFF3Feature {\n  const {\n    end,\n    start,\n    child_features,\n    derived_features,\n    attributes,\n    type,\n    source,\n    phase,\n    seq_id,\n    score,\n    strand,\n  } = data\n\n  let strand2: number | undefined\n  if (strand === '+') {\n    strand2 = 1\n  } else if (strand === '-') {\n    strand2 = -1\n  } else if (strand === '.') {\n    strand2 = 0\n  }\n\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_id',\n    'score',\n    'type',\n    'source',\n    'phase',\n    'strand',\n  ])\n  const dataAttributes = attributes || {}\n  const resultAttributes = {} as Record<string, unknown>\n  for (const a of Object.keys(dataAttributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (dataAttributes[a] && a !== '_lineHash') {\n      let attr: string | string[] | undefined = dataAttributes[a]\n      if (Array.isArray(attr) && attr.length === 1) {\n        ;[attr] = attr\n      }\n      resultAttributes[b] = attr\n    }\n  }\n\n  return {\n    ...resultAttributes,\n    start: start! - 1,\n    end: end!,\n    strand: strand2,\n    type,\n    source,\n    refName: seq_id!,\n    derived_features,\n    phase: phase === null ? undefined : Number(phase),\n    score: score === null ? undefined : score,\n    subfeatures: child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    ),\n  }\n}\n"],"names":["Gff3Adapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","loadDataP","opts","statusCallback","buffer","fetchAndMaybeUnzip","openLocation","this","getConf","pluginManager","headerLines","featureMap","decoder","TextDecoder","blockStart","i","length","n","indexOf","b","subarray","line","decode","trim","startsWith","push","ret","refName","slice","getProgressDisplayStr","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","intervalTree","IntervalTree","obj","parseStringSync","flat","f","SimpleFeature","data","featureData","id","insert","get","header","join","loadData","gffFeatures","catch","e","undefined","getRefNames","keys","getHeader","getFeatures","query","ObservableCreate","async","start","end","search","observer","next","complete","error","stopToken","child_features","derived_features","attributes","type","source","phase","seq_id","score","strand","strand2","defaultFields","Set","dataAttributes","resultAttributes","a","toLowerCase","has","attr","Array","isArray","Number","subfeatures","flatMap","childLocs","childLoc"],"sourceRoot":""}