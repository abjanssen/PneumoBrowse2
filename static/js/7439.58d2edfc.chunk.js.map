{"version":3,"file":"static/js/7439.58d2edfc.chunk.js","mappings":"yJAcO,SAASA,EACdC,EACAC,EACAC,EAAiCA,QAEjC,MAAMC,EAAU,IAAIC,YAAY,QAChC,IAAIC,EAAa,EACbC,EAAI,EAER,KAAOD,EAAaL,EAAOO,QAAQ,CACjC,MAAMC,EAAIR,EAAOS,QAAQ,GAAIJ,GAEvBK,GAAiB,IAAPF,EAAWR,EAAOO,OAASC,EACrCG,EAAIX,EAAOY,SAASP,EAAYK,GAChCG,EAAOV,EAAQW,OAAOH,GAAGI,OAE/B,GAAIF,IAEqB,IADAZ,EAAaY,EAAMP,GAExC,MAIAA,IAAM,KAAW,GACnBJ,EACE,YAAWc,EAAAA,EAAAA,uBAAsBX,EAAYL,EAAOO,WAKxDF,EAAaK,EAAU,CACzB,CACF,C,iICsJe,MAAMO,UAA4BC,EAAAA,uBAG/C,oBAA6B,CAAC,cAAe,eAE7CC,OAAAA,CAAQC,GAON,OANKC,KAAKC,OACRD,KAAKC,KAAOD,KAAKE,MAAMH,GAAMI,MAAOC,IAElC,MADAJ,KAAKC,UAAOI,EACND,KAGHJ,KAAKC,IACd,CAEA,WAAMC,CAAMH,GACV,MAAMO,GAAkBC,EAAAA,EAAAA,gBAAeP,KAAKQ,OAAQ,WAC9CC,EAAQ,GAIRC,EA7FV,SAA+BJ,GAC7B,MAAMK,EAAcL,EAAQZ,OAAOkB,MAAM,KACnCC,EAAcF,EAAYvB,QAAQ,UACxC,IAAqB,IAAjByB,EACF,MAAM,IAAIC,MAAM,oCAElB,MAAMC,EAAcJ,EAAYvB,QAAQ,UACxC,IAAqB,IAAjB2B,EACF,MAAM,IAAID,MAAM,oCAElB,MAAME,EAAcL,EAAYvB,QAAQ,UACxC,IAAqB,IAAjB4B,EACF,MAAM,IAAIF,MAAM,oCAElB,MAAMG,EAAYN,EAAYvB,QAAQ,QACtC,IAAmB,IAAf6B,EACF,MAAM,IAAIH,MAAM,kCAElB,MAAMI,EAAcP,EAAYvB,QAAQ,UACxC,IAAqB,IAAjB8B,EACF,MAAM,IAAIJ,MAAM,oCAElB,MAAMK,EAAYR,EAAYvB,QAAQ,QACtC,IAAmB,IAAf+B,EACF,MAAM,IAAIL,MAAM,kCAElB,MAAMM,EAAgB,IAAIC,IACxBV,EACGW,IAAI,CAACC,EAAGC,IAAQ,CAACD,EAAGC,IACpBC,OACCC,IACG,CAAC,SAAU,SAAU,SAAU,OAAQ,SAAU,QAAQC,SACxDD,EAAE,MAIZ,OAAQlC,IACN,GAAIA,EAAKoC,WAAW,KAClB,OAEF,MAAMC,EAAMrC,EAAKoB,MAAM,MACjBkB,EAASD,EAAIhB,GACbkB,EAASF,EAAId,GACbiB,EAASH,EAAIb,GACbiB,EAAOJ,EAAIZ,GACXiB,EAASL,EAAIX,GACbiB,EAAON,EAAIV,GACjB,KAAMW,GAAUC,GAAUC,GAAUC,GAAQC,GAAUC,GAGpD,OAFAC,QAAQC,KAAK,2BACbD,QAAQC,KAAK7C,GAGf,MAAM8C,EAAsB,CAC1BR,SACAC,SACAC,OAAQO,OAAOC,SAASR,GACxBC,KAAMM,OAAOC,SAASP,GACtBC,OAAQK,OAAOC,SAASN,GACxBC,KAAMI,OAAOC,SAASL,IAExB,IAAK,MAAOM,EAAYjB,KAAQJ,EAAcsB,UAAW,CACvD,MAAMC,EAAQd,EAAIL,GACbmB,IAILL,EAAOG,GAAcE,EACvB,CACA,OAAOL,EAEX,CAuBeM,CAAsBtC,GAkBjC,OAjBA5B,EAAAA,EAAAA,SACQmE,EAAAA,EAAAA,qBACJC,EAAAA,EAAAA,eACEvC,EAAAA,EAAAA,gBAAeP,KAAKQ,OAAQ,sBAC5BR,KAAK+C,eAEPhD,GAEFP,IACE,MAAMwD,EAAMtC,EAAGlB,GAIf,OAHIwD,GACFvC,EAAMwC,KAAKD,IAEN,GAETjD,GAAMlB,gBAED4B,CACT,CAEA,uBAAMyC,GAIJ,OAAO,CACT,CAEAC,gBAAAA,GACE,MAAMC,EAAgBpD,KAAKqD,QAAQ,iBACnC,OAA6B,IAAzBD,EAAclE,OAGT,CAFOc,KAAKqD,QAAQ,iBACZrD,KAAKqD,QAAQ,mBAGvBD,CACT,CAEA,iBAAME,CAAYvD,EAAoB,CAAC,GAErC,MAAMwD,EAAKxD,EAAKyD,UAAU,GAAGC,aACvBC,QAAc1D,KAAKF,QAAQC,GAE3ByB,EAAMxB,KAAKmD,mBAAmB/D,QAAQmE,GAC5C,IAAa,IAAT/B,EAAY,CACd,MAAMmC,EAAM,IAAIC,IAChB,IAAK,MAAMC,KAAQH,EACjBC,EAAIG,IAAY,IAARtC,EAAYqC,EAAK/B,OAAS+B,EAAK9B,QAEzC,MAAO,IAAI4B,EACb,CAEA,OADAvB,QAAQC,KAAK,wCACN,EACT,CAEA0B,WAAAA,CAAYC,EAAejE,EAAoB,CAAC,GAC9C,OAAOkE,EAAAA,EAAAA,kBAA0BC,UAC/B,MAAMC,QAAqBnE,KAAKF,QAAQC,IACjCqE,EAAeC,GAAkBrE,KAAKmD,oBAK3CmB,QAASC,EACTd,aAAce,EACdC,MAAOC,EACPC,IAAKC,GACHZ,EACJ,GACEQ,IAAsBH,GACtBG,IAAsBJ,EAItB,OAFAhC,QAAQC,KAAK,GAAGmC,oCAChBK,EAASC,WAKX,IAAK,IAAI7F,EAAI,EAAGA,EAAIkF,EAAajF,OAAQD,IAAK,CAC5C,MAAM8F,EAAIZ,EAAalF,GACvB,IAAIwF,EACAE,EACAL,EACAb,EACAuB,EACAC,EACAC,EACAC,EAEJ,MAAM,OAAErD,EAAM,OAAEC,EAAM,OAAEC,EAAM,KAAEC,EAAI,OAAEC,EAAM,KAAEC,KAASiD,GAASL,EAC5DP,IAAsBJ,GACxBK,EAAQzC,EACR2C,EAAM1C,EACNqC,EAAUxC,EACV2B,EAAeW,EACfY,EAAY9C,EACZ+C,EAAU9C,EACV+C,EAAcnD,EACdoD,EAAmBd,IAEnBI,EAAQvC,EACRyC,EAAMxC,EACNmC,EAAUvC,EACV0B,EAAeY,EACfW,EAAYhD,EACZiD,EAAUhD,EACViD,EAAcpD,EACdqD,EAAmBf,GAErB,IAAIiB,EAAS,EACTC,EAAa,EACbb,EAAQE,KACRF,EAAOE,GAAO,CAACA,EAAKF,GACtBY,GAAU,GAERL,EAAYC,KACZD,EAAWC,GAAW,CAACA,EAASD,GAClCM,GAAc,GAGdhB,IAAYC,IACZgB,EAAAA,EAAAA,gBAAeb,EAAYE,EAAUH,EAAOE,IAE5CE,EAASW,KACP,IAAIC,EAAAA,EAAe,CACjBC,SAAUzG,EAAIuF,EACdf,eACAgB,QACAE,MACAgB,KAAM,QACNrB,UACAe,OAAQA,EAASC,EACjBM,UAAW3G,KACRmG,EACHS,KAAM,CACJpB,MAAOO,EACPL,IAAKM,EACLX,QAASY,EACTzB,aAAc0B,KAKxB,CAEAN,EAASC,YAEb,E,6DCzWF,MAAM,cAAEgB,GAAkBC,EAAAA,GAEX,MAAMN,UAAuBO,EAAAA,cAC1CC,GAAAA,CAAIC,GACF,MAAY,eAARA,EACKJ,EAAc9F,KAAKiG,IAAI,UAEzBE,MAAMF,IAAIC,EACnB,E","sources":["../../../packages/core/util/parseLineByLine.ts","../../../plugins/comparative-adapters/src/BlastTabularAdapter/BlastTabularAdapter.ts","../../../plugins/comparative-adapters/src/SyntenyFeature/index.ts"],"sourcesContent":["import { getProgressDisplayStr } from './index'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { doesIntersect2, fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport SyntenyFeature from '../SyntenyFeature'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\n// Blast output column names/descriptions taken from\n// https://www.ncbi.nlm.nih.gov/books/NBK279684/#_appendices_Options_for_the_commandline_a_\ninterface BlastColumns {\n  /** Query Seq-id */\n  qseqid?: string\n  /** Query GI */\n  qgi?: string\n  /** Query accesion */\n  qacc?: string\n  /** Subject Seq-id */\n  sseqid?: string\n  /** All subject Seq-id(s), separated by a ';' */\n  sallseqid?: string\n  /** Subject GI */\n  sgi?: string\n  /** All subject GIs */\n  sallgi?: string\n  /** Subject accession */\n  sacc?: string\n  /** All subject accessions */\n  sallacc?: string\n  /** Start of alignment in query */\n  qstart?: number\n  /** End of alignment in query */\n  qend?: number\n  /** Start of alignment in subject */\n  sstart?: number\n  /** End of alignment in subject */\n  send?: number\n  /** Aligned part of query sequence */\n  qseq?: string\n  /** Aligned part of subject sequence */\n  sseq?: string\n  /** Expect value */\n  evalue?: string\n  /** Bit score */\n  bitscore?: string\n  /** Raw score */\n  score?: string\n  /** Alignment length */\n  length?: string\n  /** Percentage of identical matches */\n  pident?: string\n  /** Number of identical matches */\n  nident?: string\n  /** Number of mismatches */\n  mismatch?: string\n  /** Number of positive-scoring matches */\n  positive?: string\n  /** Number of gap openings */\n  gapopen?: string\n  /** Total number of gap */\n  gaps?: string\n  /** Percentage of positive-scoring matches */\n  ppos?: string\n  /** Query and subject frames separated by a '/' */\n  frames?: string\n  /** Query frame */\n  qframe?: string\n  /** Subject frame */\n  sframe?: string\n  /** Blast traceback operations (BTOP) */\n  btop?: string\n  /** Unique Subject Taxonomy ID(s), separated by a ';'(in numerical order) */\n  staxids?: string\n  /** Unique Subject Scientific Name(s), separated by a ';' */\n  sscinames?: string\n  /** Unique Subject Common Name(s), separated by a ';' */\n  scomnames?: string\n  /**\n   * Unique Subject Blast Name(s), separated by a ';' (in alphabetical order)\n   */\n  sblastnames?: string\n  /**\n   * Unique Subject Super Kingdom(s), separated by a ';' (in alphabetical order)\n   */\n  sskingdoms?: string\n  /** Subject Title */\n  stitle?: string\n  /** All Subject Title(s), separated by a '<>' */\n  salltitles?: string\n  /** Subject Strand */\n  sstrand?: string\n  /** Query Coverage Per Subject (for all HSPs) */\n  qcovs?: string\n  /** Query Coverage Per HSP */\n  qcovhsp?: string\n  /**\n   * A measure of Query Coverage that counts a position in a subject sequence\n   * for this measure only once. The second time the position is aligned to the\n   * query is not counted towards this measure.\n   */\n  qcovus?: string\n}\n\n// Blast output column names/descriptions taken from\n// https://www.ncbi.nlm.nih.gov/books/NBK279684/#_appendices_Options_for_the_commandline_a_\ninterface BlastRecord extends BlastColumns {\n  /** Query Seq-id */\n  qseqid: string\n  /** Subject Seq-id */\n  sseqid: string\n  /** Start of alignment in query */\n  qstart: number\n  /** End of alignment in query */\n  qend: number\n  /** Start of alignment in subject */\n  sstart: number\n  /** End of alignment in subject */\n  send: number\n}\n\nfunction createBlastLineParser(columns: string) {\n  const columnNames = columns.trim().split(' ') as (keyof BlastRecord)[]\n  const qseqidIndex = columnNames.indexOf('qseqid')\n  if (qseqidIndex === -1) {\n    throw new Error('Missing required column \"qseqid\"')\n  }\n  const sseqidIndex = columnNames.indexOf('sseqid')\n  if (sseqidIndex === -1) {\n    throw new Error('Missing required column \"sseqid\"')\n  }\n  const qstartIndex = columnNames.indexOf('qstart')\n  if (qstartIndex === -1) {\n    throw new Error('Missing required column \"qstart\"')\n  }\n  const qendIndex = columnNames.indexOf('qend')\n  if (qendIndex === -1) {\n    throw new Error('Missing required column \"qend\"')\n  }\n  const sstartIndex = columnNames.indexOf('sstart')\n  if (sstartIndex === -1) {\n    throw new Error('Missing required column \"sstart\"')\n  }\n  const sendIndex = columnNames.indexOf('send')\n  if (sendIndex === -1) {\n    throw new Error('Missing required column \"send\"')\n  }\n  const columnNameSet = new Map<string, number>(\n    columnNames\n      .map((c, idx) => [c, idx] as const)\n      .filter(\n        f =>\n          !['qseqid', 'sseqid', 'qstart', 'qend', 'sstart', 'send'].includes(\n            f[0],\n          ),\n      ),\n  )\n  return (line: string): BlastRecord | undefined => {\n    if (line.startsWith('#')) {\n      return\n    }\n    const row = line.split('\\t')\n    const qseqid = row[qseqidIndex]\n    const sseqid = row[sseqidIndex]\n    const qstart = row[qstartIndex]\n    const qend = row[qendIndex]\n    const sstart = row[sstartIndex]\n    const send = row[sendIndex]\n    if (!(qseqid && sseqid && qstart && qend && sstart && send)) {\n      console.warn('Invalid BLAST line')\n      console.warn(line)\n      return\n    }\n    const record: BlastRecord = {\n      qseqid,\n      sseqid,\n      qstart: Number.parseInt(qstart),\n      qend: Number.parseInt(qend),\n      sstart: Number.parseInt(sstart),\n      send: Number.parseInt(send),\n    }\n    for (const [columnName, idx] of columnNameSet.entries()) {\n      const value = row[idx]\n      if (!value) {\n        continue\n      }\n      // @ts-expect-error\n      record[columnName] = value\n    }\n    return record\n  }\n}\n\nexport default class BlastTabularAdapter extends BaseFeatureDataAdapter {\n  private data: Promise<BlastRecord[]> | undefined\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  getData(opts?: BaseOptions): Promise<BlastRecord[]> {\n    if (!this.data) {\n      this.data = this.setup(opts).catch((e: unknown) => {\n        this.data = undefined\n        throw e\n      })\n    }\n    return this.data\n  }\n\n  async setup(opts?: BaseOptions): Promise<BlastRecord[]> {\n    const columns: string = readConfObject(this.config, 'columns')\n    const lines = [] as NonNullable<\n      ReturnType<ReturnType<typeof createBlastLineParser>>\n    >[]\n\n    const cb = createBlastLineParser(columns)\n    parseLineByLine(\n      await fetchAndMaybeUnzip(\n        openLocation(\n          readConfObject(this.config, 'blastTableLocation'),\n          this.pluginManager,\n        ),\n        opts,\n      ),\n      line => {\n        const res = cb(line)\n        if (res) {\n          lines.push(res)\n        }\n        return true\n      },\n      opts?.statusCallback,\n    )\n    return lines\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures\n    // so is not really that important, and has to be true or else\n    // getFeatures is never called (BaseAdapter filters it out)\n    return true\n  }\n\n  getAssemblyNames() {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    if (assemblyNames.length === 0) {\n      const query = this.getConf('queryAssembly') as string\n      const target = this.getConf('targetAssembly') as string\n      return [query, target]\n    }\n    return assemblyNames\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    // @ts-expect-error\n    const r1 = opts.regions?.[0].assemblyName\n    const feats = await this.getData(opts)\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    if (idx !== -1) {\n      const set = new Set<string>()\n      for (const feat of feats) {\n        set.add(idx === 0 ? feat.qseqid : feat.sseqid)\n      }\n      return [...set]\n    }\n    console.warn('Unable to do ref renaming on adapter')\n    return []\n  }\n\n  getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const blastRecords = await this.getData(opts)\n      const [queryAssembly, targetAssembly] = this.getAssemblyNames()\n\n      // The index of the assembly name in the query list corresponds to the\n      // adapter in the subadapters list\n      const {\n        refName: queryRefName,\n        assemblyName: queryAssemblyName,\n        start: queryStart,\n        end: queryEnd,\n      } = query\n      if (\n        queryAssemblyName !== targetAssembly &&\n        queryAssemblyName !== queryAssembly\n      ) {\n        console.warn(`${queryAssemblyName} not found in this adapter`)\n        observer.complete()\n        return\n      }\n\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let i = 0; i < blastRecords.length; i++) {\n        const r = blastRecords[i]!\n        let start: number\n        let end: number\n        let refName: string\n        let assemblyName: string | undefined\n        let mateStart: number\n        let mateEnd: number\n        let mateRefName: string\n        let mateAssemblyName: string | undefined\n\n        const { qseqid, sseqid, qstart, qend, sstart, send, ...rest } = r\n        if (queryAssemblyName === queryAssembly) {\n          start = qstart\n          end = qend\n          refName = qseqid\n          assemblyName = queryAssembly\n          mateStart = sstart\n          mateEnd = send\n          mateRefName = sseqid\n          mateAssemblyName = targetAssembly\n        } else {\n          start = sstart\n          end = send\n          refName = sseqid\n          assemblyName = targetAssembly\n          mateStart = qstart\n          mateEnd = qend\n          mateRefName = qseqid\n          mateAssemblyName = queryAssembly\n        }\n        let strand = 1\n        let mateStrand = 1\n        if (start > end) {\n          ;[start, end] = [end, start]\n          strand = -1\n        }\n        if (mateStart > mateEnd) {\n          ;[mateStart, mateEnd] = [mateEnd, mateStart]\n          mateStrand = -1\n        }\n        if (\n          refName === queryRefName &&\n          doesIntersect2(queryStart, queryEnd, start, end)\n        ) {\n          observer.next(\n            new SyntenyFeature({\n              uniqueId: i + queryAssemblyName,\n              assemblyName,\n              start,\n              end,\n              type: 'match',\n              refName,\n              strand: strand * mateStrand,\n              syntenyId: i,\n              ...rest,\n              mate: {\n                start: mateStart,\n                end: mateEnd,\n                refName: mateRefName,\n                assemblyName: mateAssemblyName,\n              },\n            }),\n          )\n        }\n      }\n\n      observer.complete()\n    })\n  }\n}\n","import { SimpleFeature } from '@jbrowse/core/util'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\n\nconst { getMismatches } = MismatchParser\n\nexport default class SyntenyFeature extends SimpleFeature {\n  get(arg: string): any {\n    if (arg === 'mismatches') {\n      return getMismatches(this.get('CIGAR'))\n    }\n    return super.get(arg)\n  }\n}\n"],"names":["parseLineByLine","buffer","lineCallback","statusCallback","decoder","TextDecoder","blockStart","i","length","n","indexOf","lineEnd","b","subarray","line","decode","trim","getProgressDisplayStr","BlastTabularAdapter","BaseFeatureDataAdapter","getData","opts","this","data","setup","catch","e","undefined","columns","readConfObject","config","lines","cb","columnNames","split","qseqidIndex","Error","sseqidIndex","qstartIndex","qendIndex","sstartIndex","sendIndex","columnNameSet","Map","map","c","idx","filter","f","includes","startsWith","row","qseqid","sseqid","qstart","qend","sstart","send","console","warn","record","Number","parseInt","columnName","entries","value","createBlastLineParser","fetchAndMaybeUnzip","openLocation","pluginManager","res","push","hasDataForRefName","getAssemblyNames","assemblyNames","getConf","getRefNames","r1","regions","assemblyName","feats","set","Set","feat","add","getFeatures","query","ObservableCreate","async","blastRecords","queryAssembly","targetAssembly","refName","queryRefName","queryAssemblyName","start","queryStart","end","queryEnd","observer","complete","r","mateStart","mateEnd","mateRefName","mateAssemblyName","rest","strand","mateStrand","doesIntersect2","next","SyntenyFeature","uniqueId","type","syntenyId","mate","getMismatches","MismatchParser","SimpleFeature","get","arg","super"],"sourceRoot":""}