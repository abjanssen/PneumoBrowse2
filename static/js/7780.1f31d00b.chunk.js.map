{"version":3,"file":"static/js/7780.1f31d00b.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/wiggle/src/LinePlotRenderer/renderLinePlot.ts","webpack://@jbrowse/web/../../plugins/wiggle/src/drawLine.ts"],"sourcesContent":["import { renderToAbstractCanvas, updateStatus } from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\n\nimport { drawLine } from '../drawLine.ts'\nimport { getColorCallback, serializeWiggleFeature } from '../util.ts'\n\nimport type { RenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderLinePlot(\n  renderProps: RenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    config,\n    height,\n    regions,\n    bpPerPx,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const colorCallback = getColorCallback(config, { defaultColor: 'grey' })\n\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx =>\n        drawLine(ctx, {\n          ...renderProps,\n          features,\n          colorCallback,\n        }),\n      ),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp } from '@jbrowse/core/util'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { WIGGLE_CLIP_HEIGHT, WIGGLE_FUDGE_FACTOR, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type {\n  Feature,\n  LastStopTokenCheck,\n  Region,\n  StopToken,\n} from '@jbrowse/core/util'\n\nexport function drawLine(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    regions: Region[]\n    bpPerPx: number\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    displayCrossHatches: boolean\n    colorCallback: (f: Feature, score: number) => string\n    config: AnyConfigurationModel\n    offset?: number\n    stopToken?: StopToken\n    lastCheck?: LastStopTokenCheck\n    // when color is static (e.g. in Multi renderers), set strokeStyle once and skip callback\n    staticColor?: string\n  },\n) {\n  const {\n    features,\n    regions,\n    bpPerPx,\n    scaleOpts,\n    height: unadjustedHeight,\n    ticks: { values },\n    displayCrossHatches,\n    colorCallback,\n    config,\n    offset = 0,\n    staticColor,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const regionStart = region.start\n  const regionEnd = region.end\n  const reversed = region.reversed\n  const invBpPerPx = 1 / bpPerPx\n  const width = (regionEnd - regionStart) * invBpPerPx\n\n  const height = unadjustedHeight - offset * 2\n  const clipColor = readConfObject(config, 'clipColor')\n\n  // Use d3-scale only to get the \"niced\" domain, then use simple arithmetic\n  const scale = getScale({ ...scaleOpts, range: [0, height] })\n  const domain = scale.domain() as [number, number]\n  const niceMin = domain[0]\n  const niceMax = domain[1]\n  const domainSpan = niceMax - niceMin\n  const isLog = scaleOpts.scaleType === 'log'\n\n  // Precompute values for linear scale\n  const linearRatio = domainSpan !== 0 ? height / domainSpan : 0\n\n  // Precompute values for log scale (base 2)\n  const log2 = Math.log(2)\n  const logMin = Math.log(niceMin) / log2\n  const logMax = Math.log(niceMax) / log2\n  const logSpan = logMax - logMin\n  const logRatio = logSpan !== 0 ? height / logSpan : 0\n\n  // Simple arithmetic scale function - avoid d3-scale overhead in hot path\n  const toY = isLog\n    ? (n: number) =>\n        clamp(height - (Math.log(n) / log2 - logMin) * logRatio, 0, height) +\n        offset\n    : (n: number) =>\n        clamp(height - (n - niceMin) * linearRatio, 0, height) + offset\n\n  let lastVal: number | undefined\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n\n  // when staticColor is set, batch all path operations into a single stroke\n  if (staticColor) {\n    ctx.beginPath()\n    ctx.strokeStyle = staticColor\n    const clippingFeatures: { leftPx: number; w: number; high: boolean }[] = []\n\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = reversed\n        ? (regionEnd - fEnd) * invBpPerPx\n        : (fStart - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - fStart) * invBpPerPx\n        : (fEnd - regionStart) * invBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      // bitwise OR is faster than Math.floor for positive numbers\n      if ((leftPx | 0) !== (prevLeftPx | 0) || rightPx - leftPx > 1) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      const score = feature.get('score')\n      const scoreY = toY(score)\n\n      // track clipping\n      if (score > niceMax) {\n        clippingFeatures.push({\n          leftPx,\n          w: rightPx - leftPx + WIGGLE_FUDGE_FACTOR,\n          high: true,\n        })\n      } else if (score < niceMin && !isLog) {\n        clippingFeatures.push({\n          leftPx,\n          w: rightPx - leftPx + WIGGLE_FUDGE_FACTOR,\n          high: false,\n        })\n      }\n\n      const startY = lastVal !== undefined ? toY(lastVal) : scoreY\n      if (!reversed) {\n        ctx.moveTo(leftPx, startY)\n        ctx.lineTo(leftPx, scoreY)\n        ctx.lineTo(rightPx, scoreY)\n      } else {\n        ctx.moveTo(rightPx, startY)\n        ctx.lineTo(rightPx, scoreY)\n        ctx.lineTo(leftPx, scoreY)\n      }\n      lastVal = score\n    }\n    // single stroke for entire path\n    ctx.stroke()\n\n    // draw clipping indicators\n    if (clippingFeatures.length > 0) {\n      ctx.fillStyle = clipColor\n      for (const { leftPx, w, high } of clippingFeatures) {\n        if (high) {\n          ctx.fillRect(leftPx, offset, w, WIGGLE_CLIP_HEIGHT)\n        } else {\n          ctx.fillRect(\n            leftPx,\n            height - WIGGLE_CLIP_HEIGHT,\n            w,\n            WIGGLE_CLIP_HEIGHT,\n          )\n        }\n      }\n    }\n  } else {\n    // non-static color: stroke per feature (original behavior)\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = reversed\n        ? (regionEnd - fEnd) * invBpPerPx\n        : (fStart - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - fStart) * invBpPerPx\n        : (fEnd - regionStart) * invBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      // bitwise OR is faster than Math.floor for positive numbers\n      if ((leftPx | 0) !== (prevLeftPx | 0) || rightPx - leftPx > 1) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      const score = feature.get('score')\n      const scoreY = toY(score)\n      const w = rightPx - leftPx + WIGGLE_FUDGE_FACTOR\n\n      const c = colorCallback(feature, score)\n\n      ctx.beginPath()\n      ctx.strokeStyle = c\n      const startY = lastVal !== undefined ? toY(lastVal) : scoreY\n      if (!reversed) {\n        ctx.moveTo(leftPx, startY)\n        ctx.lineTo(leftPx, scoreY)\n        ctx.lineTo(rightPx, scoreY)\n      } else {\n        ctx.moveTo(rightPx, startY)\n        ctx.lineTo(rightPx, scoreY)\n        ctx.lineTo(leftPx, scoreY)\n      }\n      ctx.stroke()\n      lastVal = score\n\n      if (score > niceMax) {\n        ctx.fillStyle = clipColor\n        ctx.fillRect(leftPx, offset, w, WIGGLE_CLIP_HEIGHT)\n      } else if (score < niceMin && !isLog) {\n        ctx.fillStyle = clipColor\n        ctx.fillRect(leftPx, height - WIGGLE_CLIP_HEIGHT, w, WIGGLE_CLIP_HEIGHT)\n      }\n    }\n  }\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    for (const tick of values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n  return {\n    reducedFeatures,\n  }\n}\n"],"names":["async","renderLinePlot","renderProps","features","config","height","regions","bpPerPx","statusCallback","region","width","end","start","colorCallback","getColorCallback","defaultColor","reducedFeatures","rest","updateStatus","renderToAbstractCanvas","ctx","drawLine","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables","props","scaleOpts","unadjustedHeight","ticks","values","displayCrossHatches","offset","staticColor","stopToken","lastCheck","createStopTokenChecker","regionStart","regionEnd","reversed","invBpPerPx","clipColor","readConfObject","domain","getScale","range","niceMin","niceMax","domainSpan","isLog","scaleType","linearRatio","log2","Math","log","logMin","logSpan","logRatio","toY","n","clamp","lastVal","prevLeftPx","Number","NEGATIVE_INFINITY","beginPath","strokeStyle","clippingFeatures","feature","checkStopToken2","fStart","get","fEnd","leftPx","rightPx","push","score","scoreY","w","WIGGLE_FUDGE_FACTOR","high","startY","undefined","moveTo","lineTo","stroke","length","fillStyle","fillRect","WIGGLE_CLIP_HEIGHT","c","lineWidth","tick","round"],"sourceRoot":""}