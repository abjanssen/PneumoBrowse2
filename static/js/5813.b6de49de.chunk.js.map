{"version":3,"file":"static/js/5813.b6de49de.chunk.js","mappings":"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","sources":["../../../node_modules/string-template/index.js","../../../plugins/rdf/src/SPARQLAdapter/SPARQLAdapter.ts"],"sourcesContent":["var nargs = /\\{([0-9a-zA-Z_]+)\\}/g\n\nmodule.exports = template\n\nfunction template(string) {\n    var args\n\n    if (arguments.length === 2 && typeof arguments[1] === \"object\") {\n        args = arguments[1]\n    } else {\n        args = new Array(arguments.length - 1)\n        for (var i = 1; i < arguments.length; ++i) {\n            args[i - 1] = arguments[i]\n        }\n    }\n\n    if (!args || !args.hasOwnProperty) {\n        args = {}\n    }\n\n    return string.replace(nargs, function replaceArg(match, i, index) {\n        var result\n\n        if (string[index - 1] === \"{\" &&\n            string[index + match.length] === \"}\") {\n            return i\n        } else {\n            result = args.hasOwnProperty(i) ? args[i] : null\n            if (result === null || result === undefined) {\n                return \"\"\n            }\n\n            return result\n        }\n    })\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport format from 'string-template'\n\nimport type MyConfigSchema from './configSchema'\nimport type PluginManager from '@jbrowse/core/PluginManager'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport type { Instance } from 'mobx-state-tree'\n\ninterface SPARQLEntry {\n  type: string\n  value: string\n  dataTypes?: string\n}\n\ntype SPARQLBinding = Record<string, SPARQLEntry>\n\ninterface SPARQLResponseHead {\n  vars: string[]\n}\n\ninterface SPARQLResponseResults {\n  bindings?: SPARQLBinding[]\n}\n\ninterface SPARQLResponse {\n  head: SPARQLResponseHead\n  results: SPARQLResponseResults\n}\n\ninterface SPARQLFeatureData {\n  start: number\n  end: number\n  strand: number\n  refName: string\n  subfeatures?: SPARQLFeatureData[]\n  uniqueId: string\n\n  [propName: string]: any\n}\n\ninterface SPARQLFeature {\n  data: SPARQLFeatureData\n}\n\nexport default class SPARQLAdapter extends BaseFeatureDataAdapter {\n  private endpoint: string\n\n  private queryTemplate: string\n\n  private refNamesQueryTemplate: string\n\n  private additionalQueryParams: string[]\n\n  private configRefNames: string[]\n\n  private refNames: string[] | undefined\n\n  public constructor(\n    config: Instance<typeof MyConfigSchema>,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    this.endpoint = readConfObject(config, 'endpoint').uri\n    this.queryTemplate = readConfObject(config, 'queryTemplate')\n    this.additionalQueryParams = readConfObject(config, 'additionalQueryParams')\n    this.refNamesQueryTemplate = readConfObject(config, 'refNamesQueryTemplate')\n    this.configRefNames = readConfObject(config, 'refNames')\n  }\n\n  public async getRefNames(opts?: BaseOptions): Promise<string[]> {\n    if (this.refNames) {\n      return this.refNames\n    }\n    if (this.refNamesQueryTemplate) {\n      const queryTemplate = encodeURIComponent(this.refNamesQueryTemplate)\n      const results = await this.querySparql(queryTemplate, opts)\n      this.refNames = this.resultsToRefNames(results)\n    } else {\n      this.refNames = this.configRefNames\n    }\n    return this.refNames\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const filledTemplate = encodeURIComponent(\n        format(this.queryTemplate, query),\n      )\n      const { refName } = query\n      const results = await this.querySparql(filledTemplate, opts)\n      const features = this.resultsToFeatures(results, refName)\n      for (const feature of features) {\n        observer.next(feature)\n      }\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  private async querySparql(query: string, _opts?: BaseOptions): Promise<any> {\n    let additionalQueryParams = ''\n    if (this.additionalQueryParams.length) {\n      additionalQueryParams = `&${this.additionalQueryParams.join('&')}`\n    }\n    // TODO:ABORT\n    const url = `${this.endpoint}?query=${query}${additionalQueryParams}`\n    const response = await fetch(url, {\n      headers: {\n        accept: 'application/json,application/sparql-results+json',\n      },\n    })\n    return response.json()\n  }\n\n  private resultsToRefNames(response: SPARQLResponse): string[] {\n    const rows = response.results.bindings || []\n    const fields = response.head.vars\n    if (!fields.includes('refName')) {\n      throw new Error('\"refName\" not found in refNamesQueryTemplate response')\n    }\n    return rows.map(row => row.refName!.value)\n  }\n\n  private resultsToFeatures(\n    results: SPARQLResponse,\n    refName: string,\n  ): SimpleFeature[] {\n    const rows = results.results.bindings || []\n    const fields = results.head.vars\n    const requiredFields = ['start', 'end', 'uniqueId']\n    for (const requiredField of requiredFields) {\n      if (!fields.includes(requiredField)) {\n        console.error(\n          `Required field ${requiredField} missing from feature data`,\n        )\n      }\n    }\n    const seenFeatures: Record<string, SPARQLFeature> = {}\n    for (const row of rows) {\n      const rawData: Record<string, string>[] = [{}]\n      for (let field of fields) {\n        if (field in row) {\n          const { value } = row[field]!\n          let idx = 0\n          while (field.startsWith('sub_')) {\n            field = field.slice(4)\n            idx += 1\n          }\n          while (idx > rawData.length - 1) {\n            rawData.push({})\n          }\n          rawData[idx]![field] = value\n        }\n      }\n\n      for (const [idx, rd] of rawData.entries()) {\n        const { uniqueId, start, end, strand } = rd\n        if (idx < rawData.length - 1) {\n          rawData[idx + 1]!.parentUniqueId = uniqueId!\n        }\n        seenFeatures[uniqueId!] = {\n          data: {\n            ...rd,\n            uniqueId: uniqueId!,\n            refName,\n            start: Number.parseInt(start!, 10),\n            end: Number.parseInt(end!, 10),\n            strand: Number.parseInt(strand!, 10) || 0,\n          },\n        }\n      }\n    }\n\n    // resolve subfeatures, keeping only top-level features in seenFeatures\n    for (const [uniqueId, f] of Object.entries(seenFeatures)) {\n      const pid = f.data.parentUniqueId\n      f.data.parentUniqueId = undefined\n      if (pid) {\n        const p = seenFeatures[pid]\n        if (p) {\n          if (!p.data.subfeatures) {\n            p.data.subfeatures = []\n          }\n          p.data.subfeatures.push({\n            ...f.data,\n            uniqueId,\n          })\n          delete seenFeatures[uniqueId]\n        } else {\n          const subfeatures = Object.values(seenFeatures)\n            .map(sf => sf.data.subfeatures)\n            .filter(sf => !!sf)\n            .flat()\n          let found = false\n          for (const subfeature of subfeatures) {\n            if (subfeature.uniqueId === pid) {\n              if (!subfeature.subfeatures) {\n                subfeature.subfeatures = []\n              }\n              subfeature.subfeatures.push({\n                ...f.data,\n                uniqueId,\n              })\n              delete seenFeatures[uniqueId]\n              found = true\n              break\n            }\n            if (subfeature.subfeatures) {\n              subfeatures.push(...subfeature.subfeatures)\n            }\n          }\n          if (!found) {\n            console.error(`Could not find parentID ${pid}`)\n          }\n        }\n      }\n    }\n\n    return Object.keys(seenFeatures).map(\n      seenFeature =>\n        new SimpleFeature({\n          ...seenFeatures[seenFeature]!.data,\n          uniqueId: seenFeature,\n          subfeatures: seenFeatures[seenFeature]!.data.subfeatures,\n        }),\n    )\n  }\n\n  public async hasDataForRefName(\n    refName: string,\n    opts: BaseOptions = {},\n  ): Promise<boolean> {\n    const refNames = await this.getRefNames(opts)\n    if (refNames.length && !refNames.includes(refName)) {\n      return false\n    }\n    return true\n  }\n}\n"],"names":["nargs","module","exports","string","args","arguments","length","Array","i","hasOwnProperty","replace","match","index","result","SPARQLAdapter","BaseFeatureDataAdapter","constructor","config","getSubAdapter","pluginManager","super","this","endpoint","readConfObject","uri","queryTemplate","additionalQueryParams","refNamesQueryTemplate","configRefNames","getRefNames","opts","refNames","encodeURIComponent","results","querySparql","resultsToRefNames","getFeatures","query","ObservableCreate","async","filledTemplate","format","refName","features","resultsToFeatures","feature","observer","next","complete","stopToken","_opts","join","url","fetch","headers","accept","json","response","rows","bindings","head","vars","includes","Error","map","row","value","fields","requiredFields","requiredField","console","error","seenFeatures","rawData","field","idx","startsWith","slice","push","rd","entries","uniqueId","start","end","strand","parentUniqueId","data","Number","parseInt","f","Object","pid","undefined","p","subfeatures","values","sf","filter","flat","found","subfeature","keys","seenFeature","SimpleFeature","hasDataForRefName"],"sourceRoot":""}