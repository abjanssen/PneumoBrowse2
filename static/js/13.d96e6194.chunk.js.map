{"version":3,"file":"static/js/13.d96e6194.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/util.ts","../../../plugins/comparative-adapters/src/SyntenyFeature/index.ts","../../../plugins/comparative-adapters/src/PairwiseIndexedPAFAdapter/PairwiseIndexedPAFAdapter.ts"],"sourcesContent":["import { fetchAndMaybeUnzipText } from '@jbrowse/core/util'\n\nimport type { PAFRecord } from './PAFAdapter/util.ts'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f && !f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start!,\n            end: +end!,\n            score: +score!,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  return fetchAndMaybeUnzipText(file, opts)\n}\n\nexport function zip(a: number[], b: number[]) {\n  return a.map((e, i) => [e, b[i]] as [number, number])\n}\n\nexport function parsePAFLine(line: string) {\n  const parts = line.split('\\t')\n  const extraFields = parts.slice(12)\n  const extra: Record<string, string | number> = {\n    numMatches: +parts[9]!,\n    blockLen: +parts[10]!,\n    mappingQual: +parts[11]!,\n  }\n\n  // Process extra fields only if they exist\n  if (extraFields.length) {\n    for (const field of extraFields) {\n      const colonIndex = field.indexOf(':')\n      extra[field.slice(0, colonIndex)] = field.slice(colonIndex + 3)\n    }\n  }\n\n  return {\n    tname: parts[5],\n    tstart: +parts[7]!,\n    tend: +parts[8]!,\n    qname: parts[0],\n    qstart: +parts[2]!,\n    qend: +parts[3]!,\n    strand: parts[4] === '-' ? -1 : 1,\n    extra,\n  } as PAFRecord\n}\n\nexport function flipCigar(cigar: string[]) {\n  const arr = []\n  for (let i = cigar.length - 2; i >= 0; i -= 2) {\n    arr.push(cigar[i])\n    const op = cigar[i + 1]\n    if (op === 'D') {\n      arr.push('I')\n    } else if (op === 'I') {\n      arr.push('D')\n    } else {\n      arr.push(op)\n    }\n  }\n  return arr\n}\n\nexport function swapIndelCigar(cigar: string) {\n  return cigar.replaceAll('D', 'K').replaceAll('I', 'D').replaceAll('K', 'I')\n}\n","import { SimpleFeature } from '@jbrowse/core/util'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\n\nconst { getMismatches } = MismatchParser\n\nexport default class SyntenyFeature extends SimpleFeature {\n  get(arg: string): any {\n    return arg === 'mismatches'\n      ? getMismatches(this.get('CIGAR'))\n      : super.get(arg)\n  }\n}\n","import { TabixIndexedFile } from '@gmod/tabix'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport SyntenyFeature from '../SyntenyFeature/index.ts'\nimport { parsePAFLine } from '../util.ts'\n\nimport type PluginManager from '@jbrowse/core/PluginManager'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { FileLocation, Region } from '@jbrowse/core/util/types'\n\ninterface PAFOptions extends BaseOptions {\n  config?: AnyConfigurationModel\n}\n\nexport default class PAFAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  protected pif: TabixIndexedFile\n\n  public constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const pifGzLoc = this.getConf('pifGzLocation') as FileLocation\n    const type = this.getConf(['index', 'indexType'])\n    const loc = this.getConf(['index', 'location'])\n    const pm = this.pluginManager\n\n    this.pif = new TabixIndexedFile({\n      filehandle: openLocation(pifGzLoc, pm),\n      csiFilehandle: type === 'CSI' ? openLocation(loc, pm) : undefined,\n      tbiFilehandle: type !== 'CSI' ? openLocation(loc, pm) : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n  }\n  async getHeader(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading header', statusCallback, () =>\n      this.pif.getHeader(),\n    )\n  }\n\n  getAssemblyNames(): string[] {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    return assemblyNames.length === 0\n      ? [\n          this.getConf('queryAssembly') as string,\n          this.getConf('targetAssembly') as string,\n        ]\n      : assemblyNames\n  }\n\n  public async hasDataForRefName() {\n    return true\n  }\n\n  async getRefNames(opts: BaseOptions & { regions?: Region[] } = {}) {\n    const r1 = opts.regions?.[0]?.assemblyName\n    if (!r1) {\n      throw new Error('no assembly name provided')\n    }\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    const names = await this.pif.getReferenceSequenceNames(opts)\n    if (idx === 0) {\n      return names.filter(n => n.startsWith('q')).map(n => n.slice(1))\n    } else if (idx === 1) {\n      return names.filter(n => n.startsWith('t')).map(n => n.slice(1))\n    } else {\n      return []\n    }\n  }\n\n  getFeatures(query: Region, opts: PAFOptions = {}) {\n    const { statusCallback = () => {} } = opts\n    return ObservableCreate<Feature>(async observer => {\n      const { assemblyName } = query\n\n      // assemblyNames = [queryAssembly, targetAssembly]\n      const assemblyNames = this.getAssemblyNames()\n      const index = assemblyNames.indexOf(assemblyName)\n\n      // flip=true when viewing from query assembly perspective\n      // flip=false when viewing from target assembly perspective\n      const flip = index === 0\n\n      // PIF format indexes lines by perspective:\n      // - 'q' prefix lines are indexed by query coordinates\n      // - 't' prefix lines are indexed by target coordinates\n      const letter = flip ? 'q' : 't'\n\n      // The \"other\" assembly is the mate\n      const mateAssemblyName = assemblyNames[flip ? 1 : 0]\n\n      await updateStatus('Downloading features', statusCallback, () =>\n        this.pif.getLines(letter + query.refName, query.start, query.end, {\n          lineCallback: (line, fileOffset) => {\n            const r = parsePAFLine(line)\n            const { extra, strand } = r\n            const { numMatches = 0, blockLen = 1, cg, ...rest } = extra\n\n            // PIF format pre-orients each line from its perspective:\n            // - When querying 'q' lines: columns 2-3 have query coords (the \"main\" feature)\n            // - When querying 't' lines: columns 2-3 have target coords (the \"main\" feature)\n            // The first column has the indexed refName (with q/t prefix to strip)\n            // The 6th column (tname) has the mate's refName (no prefix)\n            //\n            // This means r.qstart/qend always represent the \"main\" feature coords\n            // for whichever perspective we're viewing from, and r.tstart/tend\n            // represent the mate coords\n            const start = r.qstart\n            const end = r.qend\n            const refName = r.qname.slice(1) // Strip 'q'/'t' prefix\n            const mateName = r.tname\n            const mateStart = r.tstart\n            const mateEnd = r.tend\n\n            // PIF format already has pre-computed CIGARs for each perspective\n            // (q-lines have Dâ†”I swapped relative to t-lines)\n            const CIGAR = extra.cg\n\n            observer.next(\n              new SyntenyFeature({\n                uniqueId: fileOffset + assemblyName,\n                assemblyName,\n                start,\n                end,\n                type: 'match',\n                refName,\n                strand,\n                ...rest,\n                CIGAR,\n                syntenyId: fileOffset,\n                identity: numMatches / blockLen,\n                numMatches,\n                blockLen,\n                mate: {\n                  start: mateStart,\n                  end: mateEnd,\n                  refName: mateName,\n                  assemblyName: mateAssemblyName,\n                },\n              }),\n            )\n          },\n          stopToken: opts.stopToken,\n        }),\n      )\n\n      observer.complete()\n    })\n  }\n}\n"],"names":["parseBed","text","Map","split","filter","f","startsWith","map","line","refName","start","end","name","score","strand","async","readFile","file","opts","fetchAndMaybeUnzipText","parsePAFLine","parts","extraFields","slice","extra","numMatches","blockLen","mappingQual","length","field","colonIndex","indexOf","tname","tstart","tend","qname","qstart","qend","flipCigar","cigar","arr","i","push","op","swapIndelCigar","replaceAll","getMismatches","MismatchParser","SyntenyFeature","SimpleFeature","get","arg","this","super","PAFAdapter","BaseFeatureDataAdapter","constructor","config","getSubAdapter","pluginManager","pifGzLoc","getConf","type","loc","pm","pif","TabixIndexedFile","filehandle","openLocation","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","getHeader","statusCallback","updateStatus","getAssemblyNames","assemblyNames","hasDataForRefName","getRefNames","r1","regions","assemblyName","Error","idx","names","getReferenceSequenceNames","n","getFeatures","query","ObservableCreate","flip","letter","mateAssemblyName","getLines","lineCallback","fileOffset","r","cg","rest","mateName","mateStart","mateEnd","CIGAR","observer","next","uniqueId","syntenyId","identity","mate","stopToken","complete"],"ignoreList":[],"sourceRoot":""}