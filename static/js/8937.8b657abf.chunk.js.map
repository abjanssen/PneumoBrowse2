{"version":3,"file":"static/js/8937.8b657abf.chunk.js","mappings":"0OAqDO,SAASA,GAGd,KAAEC,EAAI,cAAEC,EAAa,aAAEC,EAAY,SAAEC,IACrC,OAAOC,UACL,MAAMC,GAAOC,EAAAA,EAAAA,mBAAkBN,GAE/B,IACGK,EAAKE,aACNP,EAAKQ,QACJR,EAAKS,6CAEN,OAGF,MAAM,QAAEC,GAAYL,EAEpB,IACE,MAAMM,GAAUC,EAAAA,EAAAA,YAAWZ,IACrB,WAAEa,EAAU,gBAAEC,GAAoBH,EAClCI,EAAeV,EAAKW,cAAc,GACxC,IAAKD,EACH,OAGF,MAAME,EAAWH,EAAgBI,IAAIH,GAC/BI,EAAwBF,GAAUG,eAAeC,UAAUC,QAC3DC,EAAkBJ,GACpBK,EAAAA,EAAAA,aAAYL,QACZM,EAEEC,GAAgBC,EAAAA,EAAAA,WAAU,IAAM3B,EAAK4B,oBACvCF,IACFG,EAAAA,EAAAA,IAAcH,GAGhB,MAAMI,GAAYC,EAAAA,EAAAA,MAClB/B,EAAKgC,sBAAsBF,GAC3B9B,EAAKiC,YAAW,GAEhB,MAAMC,EAAe,CACnBC,iBAAkBC,gBAAgB/B,EAAK8B,kBACvCzB,QAASL,EAAKK,QACd2B,SAAUhC,EAAKgC,SACfC,wBAAyBjC,EAAKiC,wBAC9BC,kBAAmBlC,EAAKkC,kBACxBC,MAAOnC,EAAKmC,OAGRC,GAAYC,EAAAA,EAAAA,iBAAgB1C,GAC5B2C,EAAgB3C,EAAK2C,cACrBC,GAASpB,EAAAA,EAAAA,aAAYxB,EAAKoB,eAC1ByB,QAAgBhC,EAAWiC,KAAKL,EAAWxC,EAAe,CAC9DwC,YACApC,KAAM6B,EACNS,gBACApB,kBACAqB,SACAG,eAAiBC,KACXC,EAAAA,EAAAA,SAAQjD,IACVA,EAAKkD,mBAAmBF,IAG5BlB,eACG5B,EAAa,CAAEG,OAAMM,UAASY,kBAAiBO,gBAGhDe,EAAOM,YACTnD,EAAKoD,sBAAsBP,EAAOM,gBACV1B,IAApBoB,EAAOR,UACTrC,EAAKqD,qBAAqBR,EAAOR,UAEnClC,EAAS0C,IAGX7C,EAAKsD,oBAAoB5C,EAC3B,CAAE,MAAOF,IACF+C,EAAAA,EAAAA,IAAiB/C,IACpBR,EAAKwD,SAAShD,EAElB,CAAE,QACAR,EAAKgC,2BAAsBP,GAC3BzB,EAAKiC,YAAW,EAClB,EAEJ,CAEO,SAASwB,EACdzD,IAEA0D,EAAAA,EAAAA,IACE1D,EACAI,WACEuD,EAAAA,EAAAA,IAAoB3D,EAAK4D,IAAK5D,EAAK6D,qBAErC,CACEC,KAAM,uBAGZ,C,oFC9IO,SAASC,EAAiB/D,GAC/B,MAAMgE,GAAgBjE,EAAAA,EAAAA,GAAwB,CAC5CC,OACAC,cAAe,8BACfC,aAAcA,IAAMF,EAAKiE,cACzB9D,SAAUA,UAGZuD,EAAAA,EAAAA,IACE1D,EACAI,WACO6C,EAAAA,EAAAA,SAAQjD,IAIbgE,KAEF,CACEE,MAAO,IACPJ,KAAM,mBAIVL,EAAAA,EAAAA,GAA4BzD,EAC9B,C","sources":["../../../plugins/alignments/src/shared/createRPCRenderingSetup.ts","../../../plugins/alignments/src/LinearReadArcsDisplay/afterAttachRPC.tsx"],"sourcesContent":["import {\n  getContainingView,\n  getSession,\n  isAbortException,\n} from '@jbrowse/core/util'\nimport { createStopToken, stopStopToken } from '@jbrowse/core/util/stopToken'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\nimport { getSnapshot, isAlive } from '@jbrowse/mobx-state-tree'\nimport { drawCanvasImageData } from '@jbrowse/plugin-linear-genome-view'\nimport { untracked } from 'mobx'\n\nimport { createAutorun } from '../util.ts'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface RPCRenderableModel {\n  id: string\n  error: unknown\n  featureDensityStatsReadyAndRegionNotTooLarge: boolean\n  effectiveRpcDriverName: string\n  adapterConfig: unknown\n  configuration: AnyConfigurationModel\n  renderingStopToken?: StopToken\n  setRenderingStopToken: (token?: StopToken) => void\n  setLoading: (loading: boolean) => void\n  setError: (error: unknown) => void\n  setRenderingImageData: (imageData: ImageBitmap | undefined) => void\n  setLastDrawnOffsetPx: (offsetPx: number) => void\n  setLastDrawnBpPerPx: (bpPerPx: number) => void\n  ref: HTMLCanvasElement | null\n  renderingImageData?: ImageBitmap\n  setStatusMessage?: (msg: string) => void\n}\n\nexport interface RPCRenderSetupParams<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n> {\n  self: T\n  rpcMethodName: string\n  getRPCParams: (params: {\n    view: LGV\n    session: ReturnType<typeof getSession>\n    sequenceAdapter: unknown\n    stopToken: StopToken\n  }) => Record<string, unknown>\n  onResult: (result: R) => void\n}\n\nexport function createRPCRenderFunction<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n>({ self, rpcMethodName, getRPCParams, onResult }: RPCRenderSetupParams<T, R>) {\n  return async () => {\n    const view = getContainingView(self) as LGV\n\n    if (\n      !view.initialized ||\n      self.error ||\n      !self.featureDensityStatsReadyAndRegionNotTooLarge\n    ) {\n      return\n    }\n\n    const { bpPerPx } = view\n\n    try {\n      const session = getSession(self)\n      const { rpcManager, assemblyManager } = session\n      const assemblyName = view.assemblyNames[0]\n      if (!assemblyName) {\n        return\n      }\n\n      const assembly = assemblyManager.get(assemblyName)\n      const sequenceAdapterConfig = assembly?.configuration?.sequence?.adapter\n      const sequenceAdapter = sequenceAdapterConfig\n        ? getSnapshot(sequenceAdapterConfig)\n        : undefined\n\n      const previousToken = untracked(() => self.renderingStopToken)\n      if (previousToken) {\n        stopStopToken(previousToken)\n      }\n\n      const stopToken = createStopToken()\n      self.setRenderingStopToken(stopToken)\n      self.setLoading(true)\n\n      const viewSnapshot = {\n        displayedRegions: structuredClone(view.displayedRegions),\n        bpPerPx: view.bpPerPx,\n        offsetPx: view.offsetPx,\n        interRegionPaddingWidth: view.interRegionPaddingWidth,\n        minimumBlockWidth: view.minimumBlockWidth,\n        width: view.width,\n      }\n\n      const sessionId = getRpcSessionId(self)\n      const adapterConfig = self.adapterConfig\n      const config = getSnapshot(self.configuration)\n      const result = (await rpcManager.call(sessionId, rpcMethodName, {\n        sessionId,\n        view: viewSnapshot,\n        adapterConfig,\n        sequenceAdapter,\n        config,\n        statusCallback: (msg: string) => {\n          if (isAlive(self)) {\n            self.setStatusMessage?.(msg)\n          }\n        },\n        stopToken,\n        ...getRPCParams({ view, session, sequenceAdapter, stopToken }),\n      })) as R & { imageData?: ImageBitmap; offsetPx?: number }\n\n      if (result.imageData) {\n        self.setRenderingImageData(result.imageData)\n        if (result.offsetPx !== undefined) {\n          self.setLastDrawnOffsetPx(result.offsetPx)\n        }\n        onResult(result)\n      }\n\n      self.setLastDrawnBpPerPx(bpPerPx)\n    } catch (error) {\n      if (!isAbortException(error)) {\n        self.setError(error)\n      }\n    } finally {\n      self.setRenderingStopToken(undefined)\n      self.setLoading(false)\n    }\n  }\n}\n\nexport function setupCanvasRenderingAutorun<T extends RPCRenderableModel>(\n  self: T,\n) {\n  createAutorun(\n    self,\n    async () => {\n      drawCanvasImageData(self.ref, self.renderingImageData)\n    },\n    {\n      name: 'CanvasRenderAutorun',\n    },\n  )\n}\n","import { isAlive } from '@jbrowse/mobx-state-tree'\n\nimport {\n  createRPCRenderFunction,\n  setupCanvasRenderingAutorun,\n} from '../shared/createRPCRenderingSetup.ts'\nimport { createAutorun } from '../util.ts'\n\nimport type { LinearReadArcsDisplayModel } from './model.ts'\n\nexport function doAfterAttachRPC(self: LinearReadArcsDisplayModel) {\n  const performRender = createRPCRenderFunction({\n    self,\n    rpcMethodName: 'RenderLinearReadArcsDisplay',\n    getRPCParams: () => self.renderProps(),\n    onResult: () => {},\n  })\n\n  createAutorun(\n    self,\n    async () => {\n      if (!isAlive(self)) {\n        return\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      performRender()\n    },\n    {\n      delay: 1000,\n      name: 'PerformRender',\n    },\n  )\n\n  setupCanvasRenderingAutorun(self)\n}\n"],"names":["createRPCRenderFunction","self","rpcMethodName","getRPCParams","onResult","async","view","getContainingView","initialized","error","featureDensityStatsReadyAndRegionNotTooLarge","bpPerPx","session","getSession","rpcManager","assemblyManager","assemblyName","assemblyNames","assembly","get","sequenceAdapterConfig","configuration","sequence","adapter","sequenceAdapter","getSnapshot","undefined","previousToken","untracked","renderingStopToken","stopStopToken","stopToken","createStopToken","setRenderingStopToken","setLoading","viewSnapshot","displayedRegions","structuredClone","offsetPx","interRegionPaddingWidth","minimumBlockWidth","width","sessionId","getRpcSessionId","adapterConfig","config","result","call","statusCallback","msg","isAlive","setStatusMessage","imageData","setRenderingImageData","setLastDrawnOffsetPx","setLastDrawnBpPerPx","isAbortException","setError","setupCanvasRenderingAutorun","createAutorun","drawCanvasImageData","ref","renderingImageData","name","doAfterAttachRPC","performRender","renderProps","delay"],"ignoreList":[],"sourceRoot":""}