{"version":3,"file":"static/js/8781.25b7f3ef.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/PileupRenderer/renderers/renderModifications.ts","../../../plugins/alignments/src/PileupRenderer/renderers/cigarUtil.ts","../../../plugins/alignments/src/ModificationParser/getModProbabilities.ts","../../../plugins/alignments/src/MismatchParser/getNextRefPos.ts","../../../plugins/alignments/src/PileupRenderer/util.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderMismatchesCallback.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts","../../../plugins/alignments/src/ModificationParser/getModPositions.ts"],"sourcesContent":["import { colord } from '@jbrowse/core/util/colord'\n\nimport { getNextRefPos } from '../../MismatchParser/index.ts'\nimport { getModPositions } from '../../ModificationParser/getModPositions.ts'\nimport { getModProbabilities } from '../../ModificationParser/getModProbabilities.ts'\nimport { getMaxProbModAtEachPosition } from '../../shared/getMaximumModificationAtEachPosition.ts'\nimport { getModificationName } from '../../shared/modificationData.ts'\nimport { alphaColor, buildMismatchMap } from '../../shared/util.ts'\nimport { getTagAlt } from '../../util.ts'\n\nimport type { ColorBy, ModificationTypeWithColor } from '../../shared/types.ts'\nimport type { FlatbushItem } from '../types.ts'\nimport type { LayoutFeature } from '../util.ts'\nimport type { Region } from '@jbrowse/core/util'\n\nexport interface RenderModificationsArgs {\n  colorBy?: ColorBy\n  visibleModifications?: Record<string, ModificationTypeWithColor>\n  regionSequence?: string\n}\n\n// Pre-compute colord object for blue color (used in two-color mode)\nconst BLUE_COLORD = colord('blue')\n\n// render modifications stored in MM tag in BAM\nexport function renderModifications({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  renderArgs,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  renderArgs: RenderModificationsArgs\n  cigarOps: ArrayLike<number>\n}) {\n  const items = [] as FlatbushItem[]\n  const coords = [] as number[]\n  const { feature, topPx, heightPx } = feat\n  const { colorBy, visibleModifications = {} } = renderArgs\n\n  const seq = feature.get('seq') as string | undefined\n\n  if (!seq) {\n    return { coords, items }\n  }\n  const start = feature.get('start')\n  const mismatchMap = buildMismatchMap(feature, start)\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  const twoColor = colorBy?.modifications?.twoColor\n  const modificationThreshold = colorBy?.modifications?.threshold ?? 10\n  const thresholdFraction = modificationThreshold / 100\n  const bottomPx = topPx + heightPx\n\n  // Get all modifications with strand info for tooltip\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const modifications = getModPositions(mm, seq, fstrand)\n  const probabilities = getModProbabilities(feature)\n\n  // Build a map of position -> list of modifications with strand info\n  const modsByPosition = new Map<\n    number,\n    { type: string; base: string; strand: string; prob: number }[]\n  >()\n\n  let probIndex = 0\n  for (const { type, base, strand, positions } of modifications) {\n    for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n      const prob =\n        probabilities?.[\n          probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n        ] || 0\n\n      if (!modsByPosition.has(ref)) {\n        modsByPosition.set(ref, [])\n      }\n      modsByPosition.get(ref)!.push({ type, base, strand, prob })\n    }\n    probIndex += positions.length\n  }\n\n  const regionStart = region.start\n  const regionEnd = region.end\n  const reversed = region.reversed\n  const invBpPerPx = 1 / bpPerPx\n\n  // this is a hole-y array, does not work with normal for loop\n  // eslint-disable-next-line unicorn/no-array-for-each\n  getMaxProbModAtEachPosition(feature, cigarOps)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      const r = start + pos\n\n      // Skip positions outside visible region\n      if (r < regionStart || r >= regionEnd) {\n        return\n      }\n\n      const mod = visibleModifications[type]\n      if (!mod || (isolatedModification && mod.type !== isolatedModification)) {\n        return\n      }\n\n      // Check if modification probability exceeds threshold\n      if (prob < thresholdFraction) {\n        return\n      }\n\n      const leftPx = reversed\n        ? (regionEnd - r - 1) * invBpPerPx\n        : (r - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - r) * invBpPerPx\n        : (r + 1 - regionStart) * invBpPerPx\n      const widthPx = rightPx - leftPx + 0.5\n      const col = mod.color || 'black'\n\n      // Compute sum and max in a single pass instead of two utility calls\n      let sumProbs = 0\n      let maxProb = 0\n      for (let i = 0, l = allProbs.length; i < l; i++) {\n        const p = allProbs[i]!\n        sumProbs += p\n        if (p > maxProb) {\n          maxProb = p\n        }\n      }\n      const s = 1 - sumProbs\n\n      ctx.fillStyle =\n        twoColor && s > maxProb\n          ? BLUE_COLORD.alpha(s).toHslString()\n          : alphaColor(col, prob)\n      ctx.fillRect(leftPx, topPx, widthPx, heightPx)\n\n      // Add to flatbush for mouseover with strand-specific info showing all modifications\n      const modsAtPos = modsByPosition.get(pos)\n      if (rightPx - leftPx >= 0.2 && modsAtPos) {\n        const mismatchBase = mismatchMap.get(r)\n        items.push({\n          type: 'modification',\n          info: modsAtPos\n            .map(\n              m =>\n                `${m.base}${m.strand}${m.type} ${getModificationName(m.type)} (${(m.prob * 100).toFixed(1)}%)`,\n            )\n            .join('\\n'),\n          modType: type,\n          probability: prob,\n          start: r,\n          mismatch: mismatchBase,\n        })\n        coords.push(leftPx, topPx, rightPx, bottomPx)\n      }\n\n      pos++\n    },\n  )\n\n  return { coords, items }\n}\n","import { parseCigar2 } from '../../MismatchParser/index.ts'\n\n// CIGAR operation indices (from BAM spec) - used in packed Uint32Array format\nexport const CIGAR_M = 0\nexport const CIGAR_I = 1\nexport const CIGAR_D = 2\nexport const CIGAR_N = 3\nexport const CIGAR_S = 4\nexport const CIGAR_H = 5\nexport const CIGAR_P = 6\nexport const CIGAR_EQ = 7\nexport const CIGAR_X = 8\n\n// Bitmasks for CIGAR operation categories (use with: (1 << op) & MASK)\n// Alignment match ops (M=0, ==7) - may contain mismatches, need MD tag\nexport const CIGAR_M_EQ_MASK = 0b10000001 // (1<<0)|(1<<7) = 129\n// Match/mismatch ops that consume both ref and seq (M=0, ==7, X=8)\nexport const CIGAR_MATCH_MASK = 0b110000001 // (1<<0)|(1<<7)|(1<<8) = 385\n// Seq-only ops (S=4, I=1)\nexport const CIGAR_SEQ_ONLY_MASK = 0b10010 // (1<<1)|(1<<4) = 18\n// Ref-skip ops (D=2, N=3)\nexport const CIGAR_REF_SKIP_MASK = 0b1100 // (1<<2)|(1<<3) = 12\n// Ref-consuming ops (M=0, D=2, ==7, X=8)\nexport const CIGAR_REF_CONSUMING_MASK = 0b110000101 // (1<<0)|(1<<2)|(1<<7)|(1<<8) = 389\n\n// BAM 4-bit encoded sequence lookup table\nexport const SEQRET = '=ACMGRSVTWYHKDBN'\n\n// Numeric decoder - returns char codes directly (lowercase for case-insensitive comparison)\n// '=' = 61, 'a' = 97, 'c' = 99, 'm' = 109, 'g' = 103, 'r' = 114, 's' = 115, 'v' = 118,\n// 't' = 116, 'w' = 119, 'y' = 121, 'h' = 104, 'k' = 107, 'd' = 100, 'b' = 98, 'n' = 110\nexport const SEQRET_NUMERIC_DECODER = new Uint8Array([\n  61, 97, 99, 109, 103, 114, 115, 118, 116, 119, 121, 104, 107, 100, 98, 110,\n])\n\n// Pre-computed char lookup for ASCII codes (avoids String.fromCharCode in hot loops)\nexport const CHAR_FROM_CODE: string[] = Array.from({ length: 128 }, (_, i) =>\n  String.fromCharCode(i),\n)\n\n// Helper to ensure we have Uint32Array (packed format)\nexport function getCigarOps(\n  cigar: Uint32Array | string | undefined,\n): ArrayLike<number> {\n  return typeof cigar === 'string' ? parseCigar2(cigar) : cigar || []\n}\n","import { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getModProbabilities(feature: Feature) {\n  // ML stores probabilities as array of numerics and MP is scaled phred scores\n  // https://github.com/samtools/hts-specs/pull/418/files#diff-e765c6479316309f56b636f88189cdde8c40b854c7bdcce9ee7fe87a4e76febcR596\n  //\n  // - if we have ML or Ml, it is an 8bit probability, divide by 255\n  //\n  // - if we have MP or Mp it is phred scaled ASCII, which can go up to 90 but\n  // has very high likelihood basecalls at that point, we really only care about\n  // low qual calls <20 approx\n  const m = (getTagAlt(feature, 'ML', 'Ml') as number[] | string) || []\n  if (m) {\n    const result = []\n    if (typeof m === 'string') {\n      const parts = m.split(',')\n      for (let i = 0, l = parts.length; i < l; i++) {\n        result.push(+parts[i]! / 255)\n      }\n    } else {\n      for (let i = 0, l = m.length; i < l; i++) {\n        result.push(m[i]! / 255)\n      }\n    }\n    return result\n  } else {\n    const mp = getTagAlt(feature, 'MP', 'Mp') as string | undefined\n    if (mp) {\n      const result = []\n      for (let i = 0, l = mp.length; i < l; i++) {\n        const phred = mp.charCodeAt(i) - 33\n        result.push(Math.min(1, phred / 50))\n      }\n      return result\n    }\n    return undefined\n  }\n}\n","// get relative reference sequence positions for positions given relative to\n// the read sequence\n\nimport {\n  CIGAR_D,\n  CIGAR_EQ,\n  CIGAR_I,\n  CIGAR_M,\n  CIGAR_N,\n  CIGAR_S,\n  CIGAR_X,\n} from '../PileupRenderer/renderers/cigarUtil.ts'\n\n// Handles both packed Uint32Array and unpacked number[] formats\nexport function getNextRefPos(\n  cigarOps: ArrayLike<number>,\n  positions: number[],\n) {\n  let readPos = 0\n  let refPos = 0\n  let currPos = 0\n  const ret = []\n\n  for (\n    let i = 0, l = cigarOps.length, l2 = positions.length;\n    i < l && currPos < l2;\n    i++\n  ) {\n    const packed = cigarOps[i]!\n    const len = packed >> 4\n    const op = packed & 0xf\n    if (op === CIGAR_S || op === CIGAR_I) {\n      for (let j = 0; j < len && currPos < l2; j++) {\n        if (positions[currPos] === readPos + j) {\n          currPos++\n        }\n      }\n      readPos += len\n    } else if (op === CIGAR_D || op === CIGAR_N) {\n      refPos += len\n    } else if (op === CIGAR_M || op === CIGAR_X || op === CIGAR_EQ) {\n      for (let j = 0; j < len && currPos < l2; j++) {\n        if (positions[currPos] === readPos + j) {\n          ret.push({\n            ref: refPos + j,\n            idx: currPos,\n          })\n          currPos++\n        }\n      }\n      readPos += len\n      refPos += len\n    }\n  }\n\n  return ret\n}\n","import { measureText } from '@jbrowse/core/util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport interface LayoutFeature {\n  heightPx: number\n  topPx: number\n  feature: Feature\n}\n\n// Cache measureText results for small numbers (0-99)\n// Most deletions are small, so this avoids calling measureText in hot loops\nconst smallNumberWidthCache10 = new Map<number, number>()\nconst smallNumberWidthCache = new Map<number, number>()\n\nexport function measureTextSmallNumber(n: number, fontSize?: number) {\n  const cache =\n    fontSize === 10 ? smallNumberWidthCache10 : smallNumberWidthCache\n  if (n >= 0 && n < 100) {\n    let width = cache.get(n)\n    if (width === undefined) {\n      width = measureText(String(n), fontSize)\n      cache.set(n, width)\n    }\n    return width\n  }\n  return measureText(String(n), fontSize)\n}\n","import { colord } from '@jbrowse/core/util/colord'\n\nimport {\n  DELETION_TYPE,\n  HARDCLIP_TYPE,\n  INSERTION_TYPE,\n  INTERBASE_MASK,\n  MISMATCH_REV_MAP,\n  MISMATCH_TYPE,\n  SKIP_TYPE,\n  SOFTCLIP_TYPE,\n} from '../../shared/forEachMismatchTypes.ts'\nimport { measureTextSmallNumber } from '../util.ts'\n\nimport type {\n  FeatureWithMismatchIterator,\n  Mismatch,\n} from '../../shared/types.ts'\nimport type { FlatbushItem } from '../types.ts'\nimport type { LayoutFeature } from '../util.ts'\nimport type { Region } from '@jbrowse/core/util'\n\nconst alphaColorCache = new Map<string, string>()\nfunction applyQualAlpha(baseColor: string, qual: number) {\n  const key = `${baseColor},${qual}`\n  const hit = alphaColorCache.get(key)\n  if (hit) {\n    return hit\n  }\n  const result =\n    qual >= 0\n      ? colord(baseColor)\n          .alpha(Math.min(1, qual / 50))\n          .toHslString()\n      : baseColor\n  alphaColorCache.set(key, result)\n  return result\n}\n\nexport function renderMismatchesCallback({\n  ctx,\n  feat,\n  bpPerPx,\n  regions,\n  minSubfeatureWidth,\n  largeInsertionIndicatorScale,\n  mismatchAlpha,\n  charWidth,\n  charHeight,\n  colorMap,\n  colorContrastMap,\n  hideSmallIndels,\n  hideMismatches,\n  hideLargeIndels,\n  canvasWidth,\n  drawSNPsMuted,\n  checkRef,\n  drawIndels = true,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  bpPerPx: number\n  regions: Region[]\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  mismatchAlpha?: boolean\n  drawIndels?: boolean\n  drawSNPsMuted?: boolean\n  minSubfeatureWidth: number\n  largeInsertionIndicatorScale: number\n  hideSmallIndels: boolean\n  hideMismatches?: boolean\n  hideLargeIndels?: boolean\n  checkRef?: boolean\n  charWidth: number\n  charHeight: number\n  canvasWidth: number\n}) {\n  const items = [] as FlatbushItem[]\n  const coords = [] as number[]\n  const { heightPx, topPx, feature } = feat\n  const bottomPx = topPx + heightPx\n  const featStart = feature.get('start')\n  const region = checkRef\n    ? (regions.find(r => {\n        const rn = feature.get('refName')\n        const end = feature.get('end')\n        return r.refName === rn && r.start <= featStart && end <= r.end\n      }) ?? regions[0]!)\n    : regions[0]!\n\n  const invBpPerPx = 1 / bpPerPx\n  const pxPerBp = Math.min(invBpPerPx, 2)\n  const canRenderText = heightPx >= charHeight - 2\n  const useAlpha = mismatchAlpha === true\n  const regionStart = region.start\n  const regionEnd = region.end\n  const reversed = region.reversed\n\n  // extraHorizontallyFlippedOffset is used to draw interbase items\n  const extraHorizontallyFlippedOffset = reversed ? invBpPerPx + 1 : -1\n\n  // Accumulate insertions/clips for second pass\n  const secondPassItems: {\n    type: number\n    start: number\n    base: string\n    cliplen: number\n  }[] = []\n\n  // Counters for optimization stats\n  let mismatchDrawn = 0\n  let mismatchSkipped = 0\n  let deletionDrawn = 0\n  let deletionSkipped = 0\n\n  // Track last drawn X to avoid redundant draws at same pixel\n  let lastMismatchX = Number.NEGATIVE_INFINITY\n\n  // Check if feature has forEachMismatch method (BAM/CRAM adapters)\n  const featureWithIterator = feature as unknown as FeatureWithMismatchIterator\n  const mismatchHandler = (\n    type: number,\n    start: number,\n    length: number,\n    base: string,\n    qualVal: number | undefined,\n    _altbase: number | undefined,\n    cliplen: number | undefined,\n  ) => {\n    const mismatchStart = featStart + start\n    const mismatchEnd = mismatchStart + length\n\n    // Handle insertions/clips in second pass (interbase events)\n    if ((1 << type) & INTERBASE_MASK) {\n      if (mismatchStart >= regionStart && mismatchStart < regionEnd) {\n        secondPassItems.push({\n          type,\n          start,\n          base,\n          cliplen: cliplen!,\n        })\n      }\n      return\n    }\n\n    // Skip items entirely outside visible region\n    if (mismatchEnd <= regionStart || mismatchStart >= regionEnd) {\n      return\n    }\n\n    const leftPx = reversed\n      ? (regionEnd - mismatchEnd) * invBpPerPx\n      : (mismatchStart - regionStart) * invBpPerPx\n    const rightPx = reversed\n      ? (regionEnd - mismatchStart) * invBpPerPx\n      : (mismatchEnd - regionStart) * invBpPerPx\n\n    // if the mismatch is off-screen, don't render it\n    if (rightPx < 0 || leftPx > canvasWidth) {\n      return\n    }\n\n    const widthPx = Math.max(minSubfeatureWidth, rightPx - leftPx)\n\n    if (type === MISMATCH_TYPE) {\n      if (!hideMismatches) {\n        if (rightPx - leftPx >= 0.2) {\n          items.push({\n            type: 'mismatch',\n            base,\n            start: mismatchStart,\n          })\n          coords.push(leftPx, topPx, rightPx, bottomPx)\n        }\n\n        if (!drawSNPsMuted) {\n          const baseColor = colorMap[base] || '#888'\n          const c =\n            useAlpha && qualVal ? applyQualAlpha(baseColor, qualVal) : baseColor\n          const l = Math.round(leftPx)\n          const w = widthPx\n          // Skip drawing at same X coordinate as previous mismatch\n          if (l === lastMismatchX) {\n            mismatchSkipped++\n          } else if (l + w > 0 && l < canvasWidth) {\n            ctx.fillStyle = c\n            ctx.fillRect(l, topPx, w, heightPx)\n            mismatchDrawn++\n            lastMismatchX = l\n          }\n        }\n\n        if (widthPx >= charWidth && canRenderText) {\n          const contrastColor = drawSNPsMuted\n            ? 'black'\n            : colorContrastMap[base] || 'black'\n          const textColor =\n            useAlpha && qualVal\n              ? applyQualAlpha(contrastColor, qualVal)\n              : contrastColor\n          const x = leftPx + (widthPx - charWidth) / 2 + 1\n          if (x > 0 && x < canvasWidth && textColor) {\n            ctx.fillStyle = textColor\n            ctx.fillText(base, x, bottomPx)\n          }\n        }\n      }\n    } else if (type === DELETION_TYPE && drawIndels) {\n      const shouldHide =\n        (length < 10 && hideSmallIndels) || (length >= 10 && hideLargeIndels)\n      if (!shouldHide) {\n        const w = Math.abs(leftPx - rightPx)\n        // Skip drawing sub-pixel width deletions (< 0.3px)\n        if (w >= 0.3 && leftPx + w > 0 && leftPx < canvasWidth) {\n          ctx.fillStyle = colorMap.deletion!\n          ctx.fillRect(leftPx, topPx, w, heightPx)\n          deletionDrawn++\n          // Add deletion items for mouseover tooltip when visible\n          items.push({\n            type: 'deletion',\n            length,\n            start: mismatchStart,\n          })\n          coords.push(leftPx, topPx, rightPx, bottomPx)\n        } else if (w < 0.3) {\n          deletionSkipped++\n        }\n        const txt = String(length)\n        const rwidth = measureTextSmallNumber(length, 10)\n        if (widthPx >= rwidth && canRenderText) {\n          const x = (leftPx + rightPx) / 2 - rwidth / 2\n          if (x > 0 && x < canvasWidth) {\n            ctx.fillStyle = colorContrastMap.deletion!\n            ctx.fillText(txt, x, bottomPx)\n          }\n        }\n      }\n    } else if (type === SKIP_TYPE) {\n      const w = Math.max(widthPx, 1.5)\n      if (leftPx + w > 0 && leftPx < canvasWidth) {\n        ctx.fillStyle = colorMap.skip!\n        ctx.fillRect(leftPx, topPx + heightPx / 2 - 1, w, 1)\n      }\n    }\n  }\n\n  // First pass: draw mismatches, deletions, skips - accumulate insertions/clips\n  if ('forEachMismatch' in feature) {\n    featureWithIterator.forEachMismatch(mismatchHandler)\n  } else {\n    const mismatches = feature.get('mismatches') as Mismatch[] | undefined\n    if (mismatches) {\n      for (let i = 0, l = mismatches.length; i < l; i++) {\n        const m = mismatches[i]!\n        let base: string\n        let cliplen: number | undefined\n        if (m.type === 'mismatch') {\n          base = m.base\n        } else if (m.type === 'insertion') {\n          base = m.insertedBases ?? ''\n          cliplen = m.insertlen\n        } else if (m.type === 'softclip' || m.type === 'hardclip') {\n          base = ''\n          cliplen = m.cliplen\n        } else {\n          base = ''\n        }\n        mismatchHandler(\n          MISMATCH_REV_MAP[m.type],\n          m.start,\n          m.length,\n          base,\n          m.type === 'mismatch' ? m.qual : undefined,\n          m.type === 'mismatch' ? m.altbase?.charCodeAt(0) : undefined,\n          cliplen,\n        )\n      }\n    }\n  }\n\n  // Second pass: draw insertions and clips on top\n  for (const item of secondPassItems) {\n    const { type, start, base, cliplen } = item\n    const mstart = featStart + start\n\n    const leftPx = reversed\n      ? (regionEnd - mstart - 1) * invBpPerPx\n      : (mstart - regionStart) * invBpPerPx\n    const pos = leftPx + extraHorizontallyFlippedOffset\n\n    // if the mismatch is off-screen, don't render it. give 20px buffer\n    if (pos < -20 || pos > canvasWidth + 20) {\n      continue\n    }\n\n    if (type === INSERTION_TYPE && drawIndels) {\n      const len = cliplen\n      const insW = Math.max(0, Math.min(1.2, invBpPerPx))\n\n      if (len < 10) {\n        if (!hideSmallIndels) {\n          const c = colorMap.insertion!\n          if (pos + insW > 0 && pos < canvasWidth) {\n            ctx.fillStyle = c\n            ctx.fillRect(pos, topPx, insW, heightPx)\n          }\n          if (invBpPerPx >= charWidth && canRenderText) {\n            const l = Math.round(pos - insW)\n            const insW3 = insW * 3\n            if (l + insW3 > 0 && l < canvasWidth) {\n              ctx.fillRect(l, topPx, insW3, 1)\n              ctx.fillRect(l, bottomPx - 1, insW3, 1)\n            }\n            const x = pos + 3\n            if (x > 0 && x < canvasWidth) {\n              ctx.fillText(`(${len})`, x, bottomPx)\n            }\n          }\n          if (bpPerPx < 3) {\n            items.push({\n              type: 'insertion',\n              length: len,\n              ...(base ? { sequence: base } : {}),\n              start: mstart,\n            })\n            coords.push(leftPx - 2, topPx, leftPx + insW + 2, bottomPx)\n          }\n        }\n      } else if (!hideLargeIndels) {\n        items.push({\n          type: 'insertion',\n          length: len,\n          ...(base ? { sequence: base } : {}),\n          start: mstart,\n        })\n        const txt = `${len}`\n        if (bpPerPx > largeInsertionIndicatorScale) {\n          coords.push(leftPx - 1, topPx, leftPx + 1, bottomPx)\n          const l = leftPx - 1\n          const w = 2\n          if (l + w > 0 && l < canvasWidth) {\n            ctx.fillStyle = colorMap.insertion!\n            ctx.fillRect(l, topPx, w, heightPx)\n          }\n        } else if (heightPx > charHeight) {\n          const rwidth = measureTextSmallNumber(len)\n          const padding = 5\n          coords.push(\n            leftPx - rwidth / 2 - padding,\n            topPx,\n            leftPx + rwidth / 2 + padding,\n            bottomPx,\n          )\n          const l = leftPx - rwidth / 2 - padding\n          const w = rwidth + 2 * padding\n          if (l + w > 0 && l < canvasWidth) {\n            ctx.fillStyle = colorMap.insertion!\n            ctx.fillRect(l, topPx, w, heightPx)\n          }\n          const x = leftPx - rwidth / 2\n          if (x > 0 && x < canvasWidth) {\n            ctx.fillStyle = colorContrastMap.insertion!\n            ctx.fillText(txt, x, bottomPx)\n          }\n        } else {\n          const padding = 2\n          coords.push(leftPx - padding, topPx, leftPx + padding, bottomPx)\n          const l = leftPx - padding\n          const w = 2 * padding\n          if (l + w > 0 && l < canvasWidth) {\n            ctx.fillStyle = colorMap.insertion!\n            ctx.fillRect(l, topPx, w, heightPx)\n          }\n        }\n      }\n    } else if (\n      (type === SOFTCLIP_TYPE || type === HARDCLIP_TYPE) &&\n      !hideLargeIndels\n    ) {\n      const typeName = type === SOFTCLIP_TYPE ? 'softclip' : 'hardclip'\n      const c = colorMap[typeName]!\n      const clipW = Math.max(minSubfeatureWidth, pxPerBp)\n      if (pos + clipW > 0 && pos < canvasWidth) {\n        ctx.fillStyle = c\n        ctx.fillRect(pos, topPx, clipW, heightPx)\n      }\n      items.push({ type: typeName, length: cliplen, start: mstart })\n      coords.push(pos - clipW, topPx, pos + clipW * 2, bottomPx)\n      if (invBpPerPx >= charWidth && canRenderText) {\n        const l = pos - clipW\n        const clipW3 = clipW * 3\n        if (l + clipW3 > 0 && l < canvasWidth) {\n          ctx.fillStyle = c\n          ctx.fillRect(l, topPx, clipW3, 1)\n          ctx.fillRect(l, bottomPx - 1, clipW3, 1)\n        }\n        const x = pos + 3\n        if (x > 0 && x < canvasWidth) {\n          ctx.fillStyle = c\n          ctx.fillText(`(${base})`, x, bottomPx)\n        }\n      }\n    }\n  }\n\n  return {\n    coords,\n    items,\n    // Return optimization stats for aggregation at higher level\n    stats: {\n      mismatchDrawn,\n      mismatchSkipped,\n      deletionDrawn,\n      deletionSkipped,\n    },\n  }\n}\n","import { getNextRefPos } from '../MismatchParser/index.ts'\nimport { getModPositions } from '../ModificationParser/getModPositions.ts'\nimport { getModProbabilities } from '../ModificationParser/getModProbabilities.ts'\nimport { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  ops: ArrayLike<number>,\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n","import { revcom } from '@jbrowse/core/util'\n\nimport { modificationRegex } from './consts.ts'\n\n/**\n * Parse MM tag to extract modification positions on the read sequence.\n *\n *\n * @param mm - MM tag string (e.g., \"C+m,2,2,1;A+a,0,3\")\n * @param fseq - Read sequence\n * @param fstrand - Read strand (-1, 0, or 1)\n * @returns Array of modification objects with positions\n */\nexport function getModPositions(mm: string, fseq: string, fstrand: number) {\n  const seq = fstrand === -1 ? revcom(fseq) : fseq\n  const seqLength = seq.length\n  const mods = mm.split(';')\n  const result = []\n\n  for (const mod of mods) {\n    // Empty string\n    if (mod === '') {\n      continue\n    }\n\n    const split = mod.split(',')\n    const basemod = split[0]!\n    const matches = modificationRegex.exec(basemod)\n    if (!matches) {\n      throw new Error(`bad format for MM tag: \"${mod}\"`)\n    }\n    const [, base, strand, typestr] = matches\n\n    // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so split,\n    // and they can also be chemical codes (ChEBI) e.g. C+16061\n    const types = typestr!.split(/(\\d+|.)/)\n\n    // Note: Negative strand modifications (e.g., T-a) are now supported\n    // They are processed the same way as positive strand modifications\n    // The strand information is preserved for simplex/duplex detection\n\n    // this logic based on parse_mm.pl from hts-specs\n    for (const type of types) {\n      if (type === '') {\n        continue\n      }\n\n      const splitLength = split.length\n      let currPos = 0\n\n      // For reverse strand, pre-allocate array and fill backwards to avoid reverse()\n      // This is worthwhile because we avoid an O(n) reverse() operation\n      const positions = fstrand === -1 ? new Array(splitLength - 1) : []\n      let writeIndex = fstrand === -1 ? splitLength - 2 : 0\n\n      for (let i = 1; i < splitLength; i++) {\n        let delta = +split[i]!\n        do {\n          if (base === 'N' || base === seq[currPos]) {\n            delta--\n          }\n          currPos++\n        } while (delta >= 0 && currPos < seqLength)\n\n        // Calculate and store position\n        if (fstrand === -1) {\n          const pos = seqLength - currPos\n          if (pos >= 0) {\n            // avoid negative-number-positions in array, seen in #4629 cause\n            // unknown, could warrant some further investigation\n            positions[writeIndex--] = pos\n          } else {\n            // Position is negative (edge case from #4629)\n            // Don't write anything, don't decrement writeIndex\n            // This leaves a gap at the beginning of the array that we'll slice off\n          }\n        } else {\n          positions[writeIndex++] = currPos - 1\n        }\n      }\n\n      // For reverse strand, slice off any unfilled slots at the beginning\n      // (happens when some positions were negative and skipped)\n      const validPositions =\n        fstrand === -1 ? positions.slice(writeIndex + 1) : positions\n\n      result.push({\n        type,\n        base: base!,\n        strand: strand!,\n        positions: validPositions,\n      })\n    }\n  }\n\n  return result\n}\n"],"names":["BLUE_COLORD","colord","renderModifications","ctx","feat","region","bpPerPx","renderArgs","cigarOps","items","coords","feature","topPx","heightPx","colorBy","visibleModifications","seq","get","start","mismatchMap","buildMismatchMap","isolatedModification","modifications","twoColor","thresholdFraction","threshold","bottomPx","fstrand","mm","getTagAlt","getModPositions","probabilities","getModProbabilities","modsByPosition","Map","probIndex","type","base","strand","positions","ref","idx","getNextRefPos","prob","length","has","set","push","regionStart","regionEnd","end","reversed","invBpPerPx","getMaxProbModAtEachPosition","forEach","allProbs","pos","r","mod","leftPx","rightPx","widthPx","col","color","sumProbs","maxProb","i","l","p","s","fillStyle","alpha","toHslString","alphaColor","fillRect","modsAtPos","mismatchBase","info","map","m","getModificationName","toFixed","join","modType","probability","mismatch","CIGAR_M","CIGAR_I","CIGAR_D","CIGAR_N","CIGAR_S","CIGAR_H","CIGAR_EQ","CIGAR_X","CIGAR_M_EQ_MASK","CIGAR_REF_CONSUMING_MASK","SEQRET","SEQRET_NUMERIC_DECODER","Uint8Array","CHAR_FROM_CODE","Array","from","_","String","fromCharCode","getCigarOps","cigar","parseCigar2","result","parts","split","mp","phred","charCodeAt","Math","min","readPos","refPos","currPos","ret","l2","packed","len","op","j","smallNumberWidthCache10","smallNumberWidthCache","measureTextSmallNumber","n","fontSize","cache","width","undefined","measureText","alphaColorCache","applyQualAlpha","baseColor","qual","key","hit","renderMismatchesCallback","regions","minSubfeatureWidth","largeInsertionIndicatorScale","mismatchAlpha","charWidth","charHeight","colorMap","colorContrastMap","hideSmallIndels","hideMismatches","hideLargeIndels","canvasWidth","drawSNPsMuted","checkRef","drawIndels","featStart","find","rn","refName","pxPerBp","canRenderText","useAlpha","extraHorizontallyFlippedOffset","secondPassItems","mismatchDrawn","mismatchSkipped","deletionDrawn","deletionSkipped","lastMismatchX","Number","NEGATIVE_INFINITY","mismatchHandler","qualVal","_altbase","cliplen","mismatchStart","mismatchEnd","INTERBASE_MASK","max","MISMATCH_TYPE","c","round","w","contrastColor","textColor","x","fillText","DELETION_TYPE","abs","deletion","txt","rwidth","SKIP_TYPE","skip","forEachMismatch","mismatches","insertedBases","insertlen","MISMATCH_REV_MAP","altbase","item","mstart","INSERTION_TYPE","insW","insertion","insW3","sequence","padding","SOFTCLIP_TYPE","HARDCLIP_TYPE","typeName","clipW","clipW3","stats","ops","maxProbModForPosition","old","fseq","revcom","seqLength","mods","basemod","matches","modificationRegex","exec","Error","typestr","types","splitLength","writeIndex","delta","validPositions","slice"],"ignoreList":[],"sourceRoot":""}