{"version":3,"file":"static/js/4040.d157b851.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts","../../../node_modules/@gmod/bbi/src/bigint-polyfill/pure.ts","../../../node_modules/@gmod/bbi/src/bigint-polyfill/polyfill.ts","../../../node_modules/@gmod/bbi/src/range.ts","../../../node_modules/@gmod/bbi/src/util.ts","../../../node_modules/@gmod/bbi/src/block-view.ts","../../../node_modules/@gmod/bbi/src/unzip-pako.ts","../../../node_modules/@gmod/bbi/src/bbi.ts","../../../node_modules/@gmod/bbi/src/bigwig.ts","../../../node_modules/@gmod/bbi/src/bigbed.ts","../../../node_modules/@gmod/bbi/node_modules/buffer/index.js"],"sourcesContent":["class NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter {\n  callbacks = new Set<Function>()\n  currentMessage: unknown\n\n  addCallback(callback: Function = () => {}): void {\n    this.callbacks.add(callback)\n    callback(this.currentMessage)\n  }\n\n  callback(message: unknown) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController'\nimport AggregateStatusReporter from './AggregateStatusReporter'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: Function,\n) => Promise<U>\n\ninterface Entry<U> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U>>\n  private fillCallback: FillCallback<T, U>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U>\n    cache: Cache<Entry<U>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(key: string, data: T, signal?: AbortSignal, statusCallback?: Function) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: unknown) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch(error => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      error => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: Function,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n","const BigInt32 = BigInt(32)\n\nexport function getBigInt64(\n  dataView: DataView,\n  byteOffset: number,\n  littleEndian: boolean | undefined,\n): bigint {\n  const littleEndianMask = Number(!!littleEndian)\n  const bigEndianMask = Number(!littleEndian)\n\n  return (\n    (BigInt(\n      dataView.getInt32(byteOffset, littleEndian) * bigEndianMask +\n        dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask,\n    ) <<\n      BigInt32) |\n    BigInt(\n      dataView.getUint32(byteOffset, littleEndian) * littleEndianMask +\n        dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask,\n    )\n  )\n}\n\nexport function getBigUint64(\n  dataView: DataView,\n  byteOffset: number,\n  littleEndian: boolean | undefined,\n): bigint {\n  const a = dataView.getUint32(byteOffset, littleEndian)\n  const b = dataView.getUint32(byteOffset + 4, littleEndian)\n\n  const littleEndianMask = Number(!!littleEndian)\n  const bigEndianMask = Number(!littleEndian)\n\n  // This branch-less optimization is 77x faster than normal ternary operator.\n  // and only 3% slower than native implementation\n  // https://jsbench.me/p8kyhg1eqv/1\n  return (\n    (BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32) |\n    BigInt(a * littleEndianMask + b * bigEndianMask)\n  )\n}\n","import { getBigInt64, getBigUint64 } from './pure'\n\nif (!('getBigInt64' in DataView)) {\n  DataView.prototype.getBigInt64 = function (byteOffset, littleEndian) {\n    return getBigInt64(this, byteOffset, littleEndian)\n  }\n}\n\nif (!('getBigUint64' in DataView)) {\n  DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n    return getBigUint64(this, byteOffset, littleEndian)\n  }\n}\n","/**\n * Adapted from a combination of Range and _Compound in the\n * Dalliance Genome Explorer, (c) Thomas Down 2006-2010.\n */\n\nexport interface IRange {\n  min: number\n  max: number\n}\nexport default class Range {\n  public ranges: IRange[]\n\n  public constructor(arg1: IRange[]) {\n    this.ranges = arg1\n  }\n\n  get min() {\n    return this.ranges[0].min\n  }\n\n  get max() {\n    return this.ranges.at(-1)!.max\n  }\n\n  public contains(pos: number) {\n    for (const r of this.ranges) {\n      if (r.min <= pos && r.max >= pos) {\n        return true\n      }\n    }\n    return false\n  }\n\n  public isContiguous(): boolean {\n    return this.ranges.length > 1\n  }\n\n  public getRanges() {\n    return this.ranges.map(r => new Range([{ min: r.min, max: r.max }]))\n  }\n\n  public toString(): string {\n    return this.ranges.map(r => `[${r.min}-${r.max}]`).join(',')\n  }\n\n  public union(s1: Range) {\n    const ranges = [...this.getRanges(), ...s1.getRanges()].sort((a, b) => {\n      if (a.min < b.min) {\n        return -1\n      } else if (a.min > b.min) {\n        return 1\n      } else if (a.max < b.max) {\n        return -1\n      } else if (b.max > a.max) {\n        return 1\n      } else {\n        return 0\n      }\n    })\n    const oranges = [] as Range[]\n    let current = ranges[0]\n\n    for (const nxt of ranges) {\n      if (nxt.min > current.max + 1) {\n        oranges.push(current)\n        current = nxt\n      } else if (nxt.max > current.max) {\n        current = new Range([{ min: current.min, max: nxt.max }])\n      }\n    }\n    oranges.push(current)\n\n    return oranges.length === 1 ? oranges[0] : new Range(oranges)\n  }\n}\n","export class AbortError extends Error {\n  public code: string\n\n  public constructor(message: string) {\n    super(message)\n    this.code = 'ERR_ABORTED'\n  }\n}\n\ninterface Block {\n  offset: number\n  length: number\n}\n// sort blocks by file offset and\n// group blocks that are within 2KB of eachother\nexport function groupBlocks(blocks: Block[]) {\n  blocks.sort((b0, b1) => b0.offset - b1.offset)\n\n  const blockGroups = []\n  let lastBlock: (Block & { blocks: Block[] }) | undefined\n  let lastBlockEnd: number | undefined\n  for (const block of blocks) {\n    if (lastBlock && lastBlockEnd && block.offset - lastBlockEnd <= 2000) {\n      lastBlock.length =\n        lastBlock.length + block.length - lastBlockEnd + block.offset\n      lastBlock.blocks.push(block)\n    } else {\n      blockGroups.push(\n        (lastBlock = {\n          blocks: [block],\n          length: block.length,\n          offset: block.offset,\n        }),\n      )\n    }\n    lastBlockEnd = lastBlock.offset + lastBlock.length\n  }\n\n  return blockGroups\n}\n\n/**\n * Properly check if the given AbortSignal is aborted. Per the standard, if the\n * signal reads as aborted, this function throws either a DOMException\n * AbortError, or a regular error with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal?: AbortSignal): void {\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    if (typeof DOMException === 'undefined') {\n      const e = new AbortError('aborted')\n      e.code = 'ERR_ABORTED'\n      throw e\n    } else {\n      throw new DOMException('aborted', 'AbortError')\n    }\n  }\n}\n\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal?: AbortSignal): Promise<void> {\n  await Promise.resolve()\n  checkAbortSignal(signal)\n}\n","import { Buffer } from 'buffer'\nimport { Observer } from 'rxjs'\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport QuickLRU from 'quick-lru'\n\n// locals\nimport Range from './range'\nimport { unzip } from './unzip'\nimport { Feature } from './bbi'\nimport { groupBlocks, checkAbortSignal } from './util'\n\nconst decoder =\n  typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined\n\ninterface CoordRequest {\n  chrId: number\n  start: number\n  end: number\n}\n\ninterface ReadData {\n  offset: number\n  length: number\n}\n\ninterface Options {\n  signal?: AbortSignal\n  request?: CoordRequest\n}\n\nfunction coordFilter(s1: number, e1: number, s2: number, e2: number): boolean {\n  return s1 < e2 && e1 >= s2\n}\n\n/**\n * View into a subset of the data in a BigWig file.\n *\n * Adapted by Robert Buels and Colin Diesh from bigwig.js in the Dalliance\n * Genome Explorer by Thomas Down.\n * @constructs\n */\n\nexport class BlockView {\n  private cirTreePromise?: Promise<{ bytesRead: number; buffer: Buffer }>\n\n  private featureCache = new AbortablePromiseCache<ReadData, Buffer>({\n    cache: new QuickLRU({ maxSize: 1000 }),\n\n    fill: async (requestData, signal) => {\n      const len = requestData.length\n      const off = requestData.offset\n      const { buffer } = await this.bbi.read(Buffer.alloc(len), 0, len, off, {\n        signal,\n      })\n      return buffer\n    },\n  })\n\n  public constructor(\n    private bbi: GenericFilehandle,\n    private refsByName: any,\n    private cirTreeOffset: number,\n    private isBigEndian: boolean,\n    private isCompressed: boolean,\n    private blockType: string,\n  ) {\n    if (!(cirTreeOffset >= 0)) {\n      throw new Error('invalid cirTreeOffset!')\n    }\n  }\n\n  public async readWigData(\n    chrName: string,\n    start: number,\n    end: number,\n    observer: Observer<Feature[]>,\n    opts?: Options,\n  ) {\n    try {\n      const { refsByName, bbi, cirTreeOffset, isBigEndian } = this\n      const chrId = refsByName[chrName]\n      if (chrId === undefined) {\n        observer.complete()\n      }\n      const request = { chrId, start, end }\n      if (!this.cirTreePromise) {\n        this.cirTreePromise = bbi.read(\n          Buffer.alloc(48),\n          0,\n          48,\n          cirTreeOffset,\n          opts,\n        )\n      }\n      const { buffer } = await this.cirTreePromise\n      const cirBlockSize = isBigEndian\n        ? buffer.readUInt32BE(4)\n        : buffer.readUInt32LE(4)\n      let blocksToFetch: any[] = []\n      let outstanding = 0\n      const le = true\n\n      const cirFobRecur2 = (\n        cirBlockData: Buffer,\n        offset2: number,\n        level: number,\n      ) => {\n        try {\n          const data = cirBlockData.subarray(offset2)\n\n          const b = data\n          const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n          let offset = 0\n\n          const isLeaf = dataView.getUint8(offset)\n          offset += 2 // 1 skip\n          const cnt = dataView.getUint16(offset, le)\n          offset += 2\n          if (isLeaf === 1) {\n            const blocksToFetch2 = []\n            for (let i = 0; i < cnt; i++) {\n              const startChrom = dataView.getUint32(offset, le)\n              offset += 4\n              const startBase = dataView.getUint32(offset, le)\n              offset += 4\n              const endChrom = dataView.getUint32(offset, le)\n              offset += 4\n              const endBase = dataView.getUint32(offset, le)\n              offset += 4\n              const blockOffset = Number(dataView.getBigUint64(offset, le))\n              offset += 8\n              const blockSize = Number(dataView.getBigUint64(offset, le))\n              offset += 8\n              blocksToFetch2.push({\n                startChrom,\n                startBase,\n                endBase,\n                endChrom,\n                blockOffset,\n                blockSize,\n                offset,\n              })\n            }\n            blocksToFetch = blocksToFetch.concat(\n              blocksToFetch2\n                .filter(f => filterFeats(f))\n                .map(l => ({\n                  offset: l.blockOffset,\n                  length: l.blockSize,\n                })),\n            )\n          } else if (isLeaf === 0) {\n            const recurOffsets = []\n            for (let i = 0; i < cnt; i++) {\n              const startChrom = dataView.getUint32(offset, le)\n              offset += 4\n              const startBase = dataView.getUint32(offset, le)\n              offset += 4\n              const endChrom = dataView.getUint32(offset, le)\n              offset += 4\n              const endBase = dataView.getUint32(offset, le)\n              offset += 4\n              const blockOffset = Number(dataView.getBigUint64(offset, le))\n              offset += 8\n              recurOffsets.push({\n                startChrom,\n                startBase,\n                endChrom,\n                endBase,\n                blockOffset,\n                offset,\n              })\n            }\n            const recurOffsets2 = recurOffsets\n              .filter(f => filterFeats(f))\n              .map(l => l.blockOffset)\n            if (recurOffsets2.length > 0) {\n              cirFobRecur(recurOffsets2, level + 1)\n            }\n          }\n        } catch (e) {\n          observer.error(e)\n        }\n      }\n\n      const filterFeats = (b: {\n        startChrom: number\n        startBase: number\n        endChrom: number\n        endBase: number\n      }) => {\n        const { startChrom, startBase, endChrom, endBase } = b\n        return (\n          (startChrom < chrId || (startChrom === chrId && startBase <= end)) &&\n          (endChrom > chrId || (endChrom === chrId && endBase >= start))\n        )\n      }\n\n      const cirFobStartFetch = async (\n        off: number[],\n        fr: Range,\n        level: number,\n      ) => {\n        try {\n          const length = fr.max - fr.min\n          const offset = fr.min\n          const resultBuffer: Buffer = await this.featureCache.get(\n            `${length}_${offset}`,\n            { length, offset },\n            opts?.signal,\n          )\n          for (const element of off) {\n            if (fr.contains(element)) {\n              cirFobRecur2(resultBuffer, element - offset, level)\n              outstanding -= 1\n              if (outstanding === 0) {\n                this.readFeatures(observer, blocksToFetch, {\n                  ...opts,\n                  request,\n                }).catch((e: unknown) => {\n                  observer.error(e)\n                })\n              }\n            }\n          }\n        } catch (e) {\n          observer.error(e)\n        }\n      }\n      const cirFobRecur = (offset: number[], level: number) => {\n        try {\n          outstanding += offset.length\n\n          // Upper bound on size, based on a completely full leaf node.\n          const maxCirBlockSpan = 4 + cirBlockSize * 32\n          let spans = new Range([\n            {\n              min: offset[0],\n              max: offset[0] + maxCirBlockSpan,\n            },\n          ])\n          for (let i = 1; i < offset.length; i += 1) {\n            const blockSpan = new Range([\n              {\n                min: offset[i],\n                max: offset[i] + maxCirBlockSpan,\n              },\n            ])\n            spans = spans.union(blockSpan)\n          }\n          // eslint-disable-next-line @typescript-eslint/no-floating-promises\n          spans.getRanges().map(fr => cirFobStartFetch(offset, fr, level))\n        } catch (e) {\n          observer.error(e)\n        }\n      }\n\n      cirFobRecur([Number(cirTreeOffset) + 48], 1)\n      return\n    } catch (e) {\n      observer.error(e)\n    }\n  }\n\n  private parseSummaryBlock(\n    b: Buffer,\n    startOffset: number,\n    request?: CoordRequest,\n  ) {\n    const features = [] as any[]\n    let offset = startOffset\n\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    while (offset < b.byteLength) {\n      // this was extracted from looking at the runtime code generated by\n      // binary-parser\n      const chromId = dataView.getUint32(offset, true)\n      offset += 4\n      const start = dataView.getUint32(offset, true)\n      offset += 4\n      const end = dataView.getUint32(offset, true)\n      offset += 4\n      const validCnt = dataView.getUint32(offset, true)\n      offset += 4\n      const minScore = dataView.getFloat32(offset, true)\n      offset += 4\n      const maxScore = dataView.getFloat32(offset, true)\n      offset += 4\n      const sumData = dataView.getFloat32(offset, true)\n      offset += 4\n      // unused\n      // const sumSqData = dataView.getFloat32(offset, true)\n      offset += 4\n\n      if (\n        request\n          ? chromId === request.chrId &&\n            coordFilter(start, end, request.start, request.end)\n          : true\n      ) {\n        features.push({\n          start,\n          end,\n          maxScore,\n          minScore,\n          summary: true,\n          score: sumData / (validCnt || 1),\n        })\n      }\n    }\n\n    return features\n  }\n\n  private parseBigBedBlock(\n    data: Buffer,\n    startOffset: number,\n    offset: number,\n    request?: CoordRequest,\n  ) {\n    const items = [] as Feature[]\n    let currOffset = startOffset\n    const le = true\n    const b = data\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    while (currOffset < data.byteLength) {\n      const c2 = currOffset\n      const chromId = dataView.getUint32(currOffset, le)\n      currOffset += 4\n      const start = dataView.getInt32(currOffset, le)\n      currOffset += 4\n      const end = dataView.getInt32(currOffset, le)\n      currOffset += 4\n      let i = currOffset\n      for (; i < data.length; i++) {\n        if (data[i] === 0) {\n          break\n        }\n      }\n      const b = data.subarray(currOffset, i)\n      const rest = decoder?.decode(b) ?? b.toString()\n      currOffset = i + 1\n      items.push({\n        chromId,\n        start,\n        end,\n        rest,\n        uniqueId: `bb-${offset + c2}`,\n      })\n    }\n\n    return request\n      ? items.filter((f: any) =>\n          coordFilter(f.start, f.end, request.start, request.end),\n        )\n      : items\n  }\n\n  private parseBigWigBlock(\n    buffer: Buffer,\n    startOffset: number,\n    req?: CoordRequest,\n  ) {\n    const b = buffer.subarray(startOffset)\n\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    let offset = 0\n    offset += 4\n    const blockStart = dataView.getInt32(offset, true)\n    offset += 8\n    const itemStep = dataView.getUint32(offset, true)\n    offset += 4\n    const itemSpan = dataView.getUint32(offset, true)\n    offset += 4\n    const blockType = dataView.getUint8(offset)\n    offset += 2\n    const itemCount = dataView.getUint16(offset, true)\n    offset += 2\n    const items = new Array(itemCount)\n    switch (blockType) {\n      case 1: {\n        for (let i = 0; i < itemCount; i++) {\n          const start = dataView.getInt32(offset, true)\n          offset += 4\n          const end = dataView.getInt32(offset, true)\n          offset += 4\n          const score = dataView.getFloat32(offset, true)\n          offset += 4\n          items[i] = {\n            start,\n            end,\n            score,\n          }\n        }\n        break\n      }\n      case 2: {\n        for (let i = 0; i < itemCount; i++) {\n          const start = dataView.getInt32(offset, true)\n          offset += 4\n          const score = dataView.getFloat32(offset, true)\n          offset += 4\n          items[i] = {\n            score,\n            start,\n            end: start + itemSpan,\n          }\n        }\n        break\n      }\n      case 3: {\n        for (let i = 0; i < itemCount; i++) {\n          const score = dataView.getFloat32(offset, true)\n          offset += 4\n          const start = blockStart + i * itemStep\n          items[i] = {\n            score,\n            start,\n            end: start + itemSpan,\n          }\n        }\n        break\n      }\n    }\n\n    return req\n      ? items.filter(f => coordFilter(f.start, f.end, req.start, req.end))\n      : items\n  }\n\n  public async readFeatures(\n    observer: Observer<Feature[]>,\n    blocks: { offset: number; length: number }[],\n    opts: Options = {},\n  ) {\n    try {\n      const { blockType, isCompressed } = this\n      const { signal, request } = opts\n      const blockGroupsToFetch = groupBlocks(blocks)\n      checkAbortSignal(signal)\n      await Promise.all(\n        blockGroupsToFetch.map(async blockGroup => {\n          checkAbortSignal(signal)\n          const { length, offset } = blockGroup\n          const data = await this.featureCache.get(\n            `${length}_${offset}`,\n            blockGroup,\n            signal,\n          )\n          for (const block of blockGroup.blocks) {\n            checkAbortSignal(signal)\n            let blockOffset = Number(block.offset) - Number(blockGroup.offset)\n            let resultData = data\n            if (isCompressed) {\n              resultData = unzip(data.subarray(blockOffset))\n              blockOffset = 0\n            }\n            checkAbortSignal(signal)\n\n            switch (blockType) {\n              case 'summary': {\n                observer.next(\n                  this.parseSummaryBlock(resultData, blockOffset, request),\n                )\n                break\n              }\n              case 'bigwig': {\n                observer.next(\n                  this.parseBigWigBlock(resultData, blockOffset, request),\n                )\n                break\n              }\n              case 'bigbed': {\n                observer.next(\n                  this.parseBigBedBlock(\n                    resultData,\n                    blockOffset,\n                    Number(block.offset) * (1 << 8),\n                    request,\n                  ),\n                )\n                break\n              }\n              default: {\n                console.warn(`Don't know what to do with ${blockType}`)\n              }\n            }\n          }\n        }),\n      )\n      observer.complete()\n    } catch (e) {\n      observer.error(e)\n    }\n  }\n}\n","import { Buffer } from 'buffer'\nimport { inflateRaw } from 'pako'\n\nexport function unzip(input: Buffer) {\n  return inflateRaw(input.subarray(2))\n}\n","import { Buffer } from 'buffer'\nimport { LocalFile, RemoteFile, GenericFilehandle } from 'generic-filehandle'\nimport { firstValueFrom, Observable } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\nimport { BlockView } from './block-view'\n\nconst BIG_WIG_MAGIC = -2003829722\nconst BIG_BED_MAGIC = -2021002517\n\ninterface ZoomLevel {\n  reductionLevel: number\n  reserved: number\n  dataOffset: number\n  indexOffset: number\n}\n\nexport interface Feature {\n  offset?: number\n  chromId: number\n  start: number\n  end: number\n  score?: number\n  rest?: string // for bigbed line\n  minScore?: number // for summary line\n  maxScore?: number // for summary line\n  summary?: boolean // is summary line\n  uniqueId?: string // for bigbed contains uniqueId calculated from file offset\n  field?: number // used in bigbed searching\n}\ninterface Statistics {\n  scoreSum: number\n  basesCovered: number\n  scoreSumSquares: number\n  scoreMin: number\n  scoreMax: number\n}\n\ninterface RefInfo {\n  name: string\n  id: number\n  length: number\n}\n\nexport interface MainHeader {\n  magic: number\n  version: number\n  autoSql: string\n  totalSummary: Statistics\n  asOffset: number\n  zoomLevels: ZoomLevel[]\n  fieldCount: number\n  numZoomLevels: number\n  unzoomedIndexOffset: number\n  totalSummaryOffset: number\n  unzoomedDataOffset: number\n  definedFieldCount: number\n  uncompressBufSize: number\n  chromTreeOffset: number\n  extHeaderOffset: number\n  isBigEndian: boolean\n  fileType: string\n}\nexport interface Header extends MainHeader {\n  refsByName: Record<string, number>\n  refsByNumber: Record<number, RefInfo>\n}\n\nexport interface RequestOptions {\n  signal?: AbortSignal\n  headers?: Record<string, string>\n  [key: string]: unknown\n}\n\nexport abstract class BBI {\n  protected bbi: GenericFilehandle\n\n  private headerP?: Promise<Header>\n\n  protected renameRefSeqs: (a: string) => string\n\n  public getHeader(opts?: RequestOptions) {\n    if (!this.headerP) {\n      this.headerP = this._getHeader(opts).catch((e: unknown) => {\n        this.headerP = undefined\n        throw e\n      })\n    }\n    return this.headerP\n  }\n\n  /*\n   * @param filehandle - a filehandle from generic-filehandle or implementing\n   * something similar to the node10 fs.promises API\n   *\n   * @param path - a Local file path as a string\n   *\n   * @param url - a URL string\n   *\n   * @param renameRefSeqs - an optional method to rename the internal reference\n   * sequences using a mapping function\n   */\n  public constructor(args: {\n    filehandle?: GenericFilehandle\n    path?: string\n    url?: string\n    renameRefSeqs?: (a: string) => string\n  }) {\n    const { filehandle, renameRefSeqs = s => s, path, url } = args\n    this.renameRefSeqs = renameRefSeqs\n    if (filehandle) {\n      this.bbi = filehandle\n    } else if (url) {\n      this.bbi = new RemoteFile(url)\n    } else if (path) {\n      this.bbi = new LocalFile(path)\n    } else {\n      throw new Error('no file given')\n    }\n  }\n\n  private async _getHeader(opts?: RequestOptions) {\n    const header = await this._getMainHeader(opts)\n    const chroms = await this._readChromTree(header, opts)\n    return { ...header, ...chroms }\n  }\n\n  private async _getMainHeader(\n    opts?: RequestOptions,\n    requestSize = 2000,\n  ): Promise<MainHeader> {\n    const le = true\n    const { buffer } = await this.bbi.read(\n      Buffer.alloc(requestSize),\n      0,\n      requestSize,\n      0,\n      opts,\n    )\n    const isBigEndian = this._isBigEndian(buffer)\n    const b = buffer\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    let offset = 0\n    const magic = dataView.getInt32(offset, le)\n    offset += 4\n    const version = dataView.getUint16(offset, le)\n    offset += 2\n    const numZoomLevels = dataView.getUint16(offset, le)\n    offset += 2\n    const chromTreeOffset = Number(dataView.getBigUint64(offset, le))\n    offset += 8\n    const unzoomedDataOffset = Number(dataView.getBigUint64(offset, le))\n    offset += 8\n    const unzoomedIndexOffset = Number(dataView.getBigUint64(offset, le))\n    offset += 8\n    const fieldCount = dataView.getUint16(offset, le)\n    offset += 2\n    const definedFieldCount = dataView.getUint16(offset, le)\n    offset += 2\n    const asOffset = Number(dataView.getBigUint64(offset, le))\n    offset += 8\n    const totalSummaryOffset = Number(dataView.getBigUint64(offset, le))\n    offset += 8\n    const uncompressBufSize = dataView.getUint32(offset, le)\n    offset += 4\n    const extHeaderOffset = Number(dataView.getBigUint64(offset, le))\n    offset += 8\n    const zoomLevels = [] as ZoomLevel[]\n    for (let i = 0; i < numZoomLevels; i++) {\n      const reductionLevel = dataView.getUint32(offset, le)\n      offset += 4\n      const reserved = dataView.getUint32(offset, le)\n      offset += 4\n      const dataOffset = Number(dataView.getBigUint64(offset, le))\n      offset += 8\n      const indexOffset = Number(dataView.getBigUint64(offset, le))\n      offset += 8\n      zoomLevels.push({ reductionLevel, reserved, dataOffset, indexOffset })\n    }\n\n    const fileType = magic === BIG_BED_MAGIC ? 'bigbed' : 'bigwig'\n\n    // refetch header if it is too large on first pass,\n    // 8*5 is the sizeof the totalSummary struct\n    if (asOffset > requestSize || totalSummaryOffset > requestSize - 8 * 5) {\n      return this._getMainHeader(opts, requestSize * 2)\n    }\n\n    let totalSummary: Statistics\n    if (totalSummaryOffset) {\n      const b = buffer.subarray(Number(totalSummaryOffset))\n      let offset = 0\n      const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n      const basesCovered = Number(dataView.getBigUint64(offset, le))\n      offset += 8\n      const scoreMin = dataView.getFloat64(offset, le)\n      offset += 8\n      const scoreMax = dataView.getFloat64(offset, le)\n      offset += 8\n      const scoreSum = dataView.getFloat64(offset, le)\n      offset += 8\n      const scoreSumSquares = dataView.getFloat64(offset, le)\n      offset += 8\n\n      totalSummary = {\n        scoreMin,\n        scoreMax,\n        scoreSum,\n        scoreSumSquares,\n        basesCovered,\n      }\n    } else {\n      throw new Error('no stats')\n    }\n\n    return {\n      zoomLevels,\n      magic,\n      extHeaderOffset,\n      numZoomLevels,\n      fieldCount,\n      totalSummary,\n      definedFieldCount,\n      uncompressBufSize,\n      asOffset,\n      chromTreeOffset,\n      totalSummaryOffset,\n      unzoomedDataOffset,\n      unzoomedIndexOffset,\n      fileType,\n      version,\n      isBigEndian,\n      autoSql: asOffset\n        ? buffer.subarray(asOffset, buffer.indexOf(0, asOffset)).toString()\n        : '',\n    }\n  }\n\n  private _isBigEndian(buffer: Buffer) {\n    let ret = buffer.readInt32LE(0)\n    if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {\n      return false\n    }\n    ret = buffer.readInt32BE(0)\n    if (ret === BIG_WIG_MAGIC || ret === BIG_BED_MAGIC) {\n      return true\n    }\n    throw new Error('not a BigWig/BigBed file')\n  }\n\n  // todo: add progress if long running\n  private async _readChromTree(\n    header: MainHeader,\n    opts?: { signal?: AbortSignal },\n  ) {\n    const isBE = header.isBigEndian\n    const le = !isBE\n    const refsByNumber: Record<\n      number,\n      { name: string; id: number; length: number }\n    > = []\n    const refsByName: Record<string, number> = {}\n\n    let unzoomedDataOffset = header.unzoomedDataOffset\n    const chromTreeOffset = header.chromTreeOffset\n    while (unzoomedDataOffset % 4 !== 0) {\n      unzoomedDataOffset += 1\n    }\n    const off = unzoomedDataOffset - chromTreeOffset\n    const { buffer } = await this.bbi.read(\n      Buffer.alloc(off),\n      0,\n      off,\n      Number(chromTreeOffset),\n      opts,\n    )\n\n    const b = buffer\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    let offset = 0\n    //    const magic = dataView.getUint32(offset, le)\n    offset += 4\n    //   const blockSize = dataView.getUint32(offset, le)\n    offset += 4\n    const keySize = dataView.getUint32(offset, le)\n    offset += 4\n    //  const valSize = dataView.getUint32(offset, le)\n    offset += 4\n    // const itemCount = dataView.getBigUint64(offset, le)\n    offset += 8\n\n    const rootNodeOffset = 32\n    const bptReadNode = async (currentOffset: number) => {\n      let offset = currentOffset\n      if (offset >= buffer.length) {\n        throw new Error('reading beyond end of buffer')\n      }\n      const isLeafNode = dataView.getUint8(offset)\n      offset += 2 //skip 1\n      const cnt = dataView.getUint16(offset, le)\n      offset += 2\n      if (isLeafNode) {\n        for (let n = 0; n < cnt; n++) {\n          const key = buffer\n            .subarray(offset, offset + keySize)\n            .toString()\n            .replaceAll('\\0', '')\n          offset += keySize\n          const refId = dataView.getUint32(offset, le)\n          offset += 4\n          const refSize = dataView.getUint32(offset, le)\n          offset += 4\n\n          const refRec = { name: key, id: refId, length: refSize }\n          refsByName[this.renameRefSeqs(key)] = refId\n          refsByNumber[refId] = refRec\n        }\n      } else {\n        // parse index node\n        const nextNodes = []\n        for (let n = 0; n < cnt; n++) {\n          offset += keySize\n          const childOffset = Number(dataView.getBigUint64(offset, le))\n          offset += 8\n          nextNodes.push(\n            bptReadNode(Number(childOffset) - Number(chromTreeOffset)),\n          )\n        }\n        await Promise.all(nextNodes)\n      }\n    }\n    await bptReadNode(rootNodeOffset)\n    return {\n      refsByName,\n      refsByNumber,\n    }\n  }\n\n  /*\n   * fetches the \"unzoomed\" view of the bigwig data. this is the default for bigbed\n   * @param abortSignal - a signal to optionally abort this operation\n   */\n  protected async getUnzoomedView(opts?: RequestOptions) {\n    const {\n      unzoomedIndexOffset,\n      refsByName,\n      uncompressBufSize,\n      isBigEndian,\n      fileType,\n    } = await this.getHeader(opts)\n    return new BlockView(\n      this.bbi,\n      refsByName,\n      unzoomedIndexOffset,\n      isBigEndian,\n      uncompressBufSize > 0,\n      fileType,\n    )\n  }\n\n  /*\n   * abstract method - get the view for a given scale\n   */\n  protected abstract getView(\n    scale: number,\n    opts?: RequestOptions,\n  ): Promise<BlockView>\n\n  /**\n   * Gets features from a BigWig file\n   *\n   * @param refName - The chromosome name\n   * @param start - The start of a region\n   * @param end - The end of a region\n   * @param opts - An object containing basesPerSpan (e.g. pixels per basepair) or scale used to infer the zoomLevel to use\n   */\n  public async getFeatureStream(\n    refName: string,\n    start: number,\n    end: number,\n    opts?: RequestOptions & { scale?: number; basesPerSpan?: number },\n  ) {\n    await this.getHeader(opts)\n    const chrName = this.renameRefSeqs(refName)\n    let view: BlockView\n    const { basesPerSpan, scale } = opts || {}\n\n    if (basesPerSpan) {\n      view = await this.getView(1 / basesPerSpan, opts)\n    } else if (scale) {\n      view = await this.getView(scale, opts)\n    } else {\n      view = await this.getView(1, opts)\n    }\n\n    return new Observable<Feature[]>(observer => {\n      view\n        .readWigData(chrName, start, end, observer, opts)\n        .catch((e: unknown) => {\n          observer.error(e)\n        })\n    })\n  }\n\n  public async getFeatures(\n    refName: string,\n    start: number,\n    end: number,\n    opts?: RequestOptions & { scale?: number; basesPerSpan?: number },\n  ) {\n    const ob = await this.getFeatureStream(refName, start, end, opts)\n\n    const ret = await firstValueFrom(ob.pipe(toArray()))\n    return ret.flat()\n  }\n}\n","import { BlockView } from './block-view'\nimport { BBI, RequestOptions } from './bbi'\n\nexport class BigWig extends BBI {\n  /**\n   * Retrieves a BlockView of a specific zoomLevel\n   *\n   * @param scale - number\n   *\n   * @param opts - An object containing basesPerSpan (e.g. pixels per basepair)\n   * or scale used to infer the zoomLevel to use\n   */\n  protected async getView(scale: number, opts: RequestOptions) {\n    const { zoomLevels, refsByName, isBigEndian, uncompressBufSize } =\n      await this.getHeader(opts)\n    const basesPerPx = 1 / scale\n    const maxLevel = zoomLevels.length - 1\n\n    for (let i = maxLevel; i >= 0; i -= 1) {\n      const zh = zoomLevels[i]\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (zh && zh.reductionLevel <= 2 * basesPerPx) {\n        return new BlockView(\n          this.bbi,\n          refsByName,\n          zh.indexOffset,\n          isBigEndian,\n          uncompressBufSize > 0,\n          'summary',\n        )\n      }\n    }\n    return this.getUnzoomedView(opts)\n  }\n}\n","import { Buffer } from 'buffer'\nimport { Observable, merge, firstValueFrom } from 'rxjs'\nimport { map, reduce } from 'rxjs/operators'\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport QuickLRU from 'quick-lru'\n\n// locals\nimport { BBI, Feature, RequestOptions } from './bbi'\n\ninterface Loc {\n  key: string\n  offset: number\n  length: number\n  field?: number\n}\n\ninterface Index {\n  type: number\n  fieldcount: number\n  offset: number\n  field: number\n}\n\nexport function filterUndef<T>(ts: (T | undefined)[]): T[] {\n  return ts.filter((t: T | undefined): t is T => !!t)\n}\n\nexport class BigBed extends BBI {\n  public readIndicesCache = new AbortablePromiseCache<RequestOptions, Index[]>({\n    cache: new QuickLRU({ maxSize: 1 }),\n    fill: (args: RequestOptions, signal?: AbortSignal) =>\n      this._readIndices({ ...args, signal }),\n  })\n\n  public readIndices(opts: RequestOptions = {}) {\n    const { signal, ...rest } = opts\n    return this.readIndicesCache.get(JSON.stringify(rest), opts, signal)\n  }\n\n  /*\n   * retrieve unzoomed view for any scale\n   */\n  protected async getView(_scale: number, opts?: RequestOptions) {\n    return this.getUnzoomedView(opts)\n  }\n\n  /*\n   * parse the bigbed extraIndex fields\n   *\n   *\n   * @return a Promise for an array of Index data structure since there can be\n   * multiple extraIndexes in a bigbed, see bedToBigBed documentation\n   */\n  private async _readIndices(opts: RequestOptions) {\n    const { extHeaderOffset, isBigEndian } = await this.getHeader(opts)\n    const { buffer: data } = await this.bbi.read(\n      Buffer.alloc(64),\n      0,\n      64,\n      Number(extHeaderOffset),\n    )\n    const le = !isBigEndian\n\n    const b = data\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    let offset = 0\n    // const _size = dataView.getUint16(offset, le)\n    offset += 2\n    const count = dataView.getUint16(offset, le)\n    offset += 2\n    const dataOffset = Number(dataView.getBigUint64(offset, le))\n    offset += 8\n\n    // no extra index is defined if count==0\n    if (count === 0) {\n      return []\n    }\n\n    const blocklen = 20\n    const len = blocklen * count\n    const { buffer } = await this.bbi.read(\n      Buffer.alloc(len),\n      0,\n      len,\n      Number(dataOffset),\n    )\n\n    const indices = [] as Index[]\n\n    for (let i = 0; i < count; i += 1) {\n      const b = buffer.subarray(i * blocklen)\n      const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n      let offset = 0\n      const type = dataView.getInt16(offset, le)\n      offset += 2\n      const fieldcount = dataView.getInt16(offset, le)\n      offset += 2\n      const dataOffset = Number(dataView.getBigUint64(offset, le))\n      offset += 8 + 4 //4 skip\n      const field = dataView.getInt16(offset, le)\n      indices.push({ type, fieldcount, offset: Number(dataOffset), field })\n    }\n    return indices\n  }\n\n  /*\n   * perform a search in the bigbed extraIndex to find which blocks in the\n   * bigbed data to look for the actual feature data\n   *\n   * @param name - the name to search for\n   * @param opts - a SearchOptions argument with optional signal\n   * @return a Promise for an array of bigbed block Loc entries\n   */\n  private async searchExtraIndexBlocks(\n    name: string,\n    opts: RequestOptions = {},\n  ): Promise<Loc[]> {\n    const { isBigEndian } = await this.getHeader(opts)\n    const indices = await this.readIndices(opts)\n    if (indices.length === 0) {\n      return []\n    }\n    const locs = indices.map(async (index): Promise<Loc | undefined> => {\n      const { offset: offset2, field } = index\n      const { buffer: data } = await this.bbi.read(\n        Buffer.alloc(32),\n        0,\n        32,\n        offset2,\n        opts,\n      )\n      const le = !isBigEndian\n      const b = data\n\n      const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n      let offset = 0\n      // const _magic = dataView.getInt32(offset, le)\n      offset += 4\n      const blockSize = dataView.getInt32(offset, le)\n      offset += 4\n      const keySize = dataView.getInt32(offset, le)\n      offset += 4\n      const valSize = dataView.getInt32(offset, le)\n      offset += 4\n      // const _itemCount = Number(dataView.getBigUint64(offset, le))\n      offset += 8\n\n      const bptReadNode = async (nodeOffset: number) => {\n        const val = Number(nodeOffset)\n        const len = 4 + blockSize * (keySize + valSize)\n        const { buffer } = await this.bbi.read(\n          Buffer.alloc(len),\n          0,\n          len,\n          val,\n          opts,\n        )\n        const b = buffer\n        const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n        let offset = 0\n        const nodeType = dataView.getInt8(offset)\n        offset += 2 //skip 1\n        const cnt = dataView.getInt16(offset, le)\n        offset += 2\n        const keys = []\n        if (nodeType === 0) {\n          const leafkeys = []\n          for (let i = 0; i < cnt; i++) {\n            const key = b\n              .subarray(offset, offset + keySize)\n              .toString()\n              .replaceAll('\\0', '')\n            offset += keySize\n            const dataOffset = Number(dataView.getBigUint64(offset, le))\n            offset += 8\n            leafkeys.push({ key, offset: dataOffset })\n          }\n\n          let lastOffset = 0\n          for (const { key, offset } of leafkeys) {\n            if (name.localeCompare(key) < 0 && lastOffset) {\n              return bptReadNode(lastOffset)\n            }\n            lastOffset = offset\n          }\n          return bptReadNode(lastOffset)\n        } else if (nodeType === 1) {\n          for (let i = 0; i < cnt; i++) {\n            const key = b\n              .subarray(offset, offset + keySize)\n              .toString()\n              .replaceAll('\\0', '')\n            offset += keySize\n            const dataOffset = Number(dataView.getBigUint64(offset, le))\n            offset += 8\n            const length = dataView.getUint32(offset, le)\n            offset += 4\n            const reserved = dataView.getUint32(offset, le)\n            offset += 4\n            keys.push({ key, offset: dataOffset, length, reserved })\n          }\n\n          for (const n of keys) {\n            if (n.key === name) {\n              return { ...n, field }\n            }\n          }\n\n          return undefined\n        }\n      }\n      const rootNodeOffset = 32\n      return bptReadNode(offset2 + rootNodeOffset)\n    })\n    return filterUndef(await Promise.all(locs))\n  }\n\n  /*\n   * retrieve the features from the bigbed data that were found through the\n   * lookup of the extraIndex note that there can be multiple extraIndex, see\n   * the BigBed specification and the -extraIndex argument to bedToBigBed\n   *\n   * @param name - the name to search for\n   * @param opts - a SearchOptions argument with optional signal\n   * @return a Promise for an array of Feature\n   */\n  public async searchExtraIndex(name: string, opts: RequestOptions = {}) {\n    const blocks = await this.searchExtraIndexBlocks(name, opts)\n    if (blocks.length === 0) {\n      return []\n    }\n    const view = await this.getUnzoomedView(opts)\n    const res = blocks.map(block => {\n      return new Observable<Feature[]>(observer => {\n        view.readFeatures(observer, [block], opts).catch((e: unknown) => {\n          observer.error(e)\n        })\n      }).pipe(\n        reduce((acc, curr) => acc.concat(curr)),\n        map(x => {\n          for (const element of x) {\n            element.field = block.field\n          }\n          return x\n        }),\n      )\n    })\n    const ret = await firstValueFrom(merge(...res))\n    return ret.filter(f => f.rest?.split('\\t')[(f.field || 0) - 3] === name)\n  }\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n"],"names":["NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","addSignal","signal","this","aborted","Error","add","handleAborted","addEventListener","delete","size","abort","AggregateStatusReporter","callbacks","addCallback","callback","currentMessage","message","elt","AbortablePromiseCache","constructor","fill","cache","TypeError","get","set","fillCallback","isAbortException","exception","name","code","evict","key","entry","data","statusCallback","aborter","statusReporter","newEntry","promise","settled","then","catch","error","console","checkSinglePromise","checkForSingleAbort","Object","assign","result","has","AbortSignal","cacheEntry","cachedEntry","clear","keyIter","keys","deleteCount","next","done","value","BigInt32","BigInt","DataView","prototype","getBigInt64","byteOffset","littleEndian","dataView","littleEndianMask","Number","bigEndianMask","getInt32","getUint32","getBigUint64","a","b","Range","arg1","ranges","min","max","at","contains","pos","r","isContiguous","length","getRanges","map","toString","join","union","s1","sort","oranges","current","nxt","push","AbortError","super","checkAbortSignal","DOMException","e","decoder","TextDecoder","undefined","coordFilter","e1","s2","e2","BlockView","bbi","refsByName","cirTreeOffset","isBigEndian","isCompressed","blockType","featureCache","A","maxSize","async","requestData","len","off","offset","buffer","read","alloc","readWigData","chrName","start","end","observer","opts","chrId","complete","request","cirTreePromise","cirBlockSize","readUInt32BE","readUInt32LE","blocksToFetch","outstanding","le","cirFobRecur2","cirBlockData","offset2","level","subarray","isLeaf","getUint8","cnt","getUint16","blocksToFetch2","i","startChrom","startBase","endChrom","endBase","blockOffset","blockSize","concat","filter","f","filterFeats","l","recurOffsets","recurOffsets2","cirFobRecur","cirFobStartFetch","fr","resultBuffer","element","readFeatures","maxCirBlockSpan","spans","blockSpan","parseSummaryBlock","startOffset","features","byteLength","chromId","validCnt","minScore","getFloat32","maxScore","sumData","summary","score","parseBigBedBlock","items","currOffset","c2","rest","decode","uniqueId","parseBigWigBlock","req","blockStart","itemStep","itemSpan","itemCount","Array","blocks","blockGroupsToFetch","b0","b1","blockGroups","lastBlock","lastBlockEnd","block","groupBlocks","Promise","all","blockGroup","resultData","input","warn","BIG_WIG_MAGIC","BIG_BED_MAGIC","BBI","getHeader","headerP","_getHeader","args","filehandle","renameRefSeqs","s","path","url","header","_getMainHeader","chroms","_readChromTree","requestSize","_isBigEndian","magic","version","numZoomLevels","chromTreeOffset","unzoomedDataOffset","unzoomedIndexOffset","fieldCount","definedFieldCount","asOffset","totalSummaryOffset","uncompressBufSize","extHeaderOffset","zoomLevels","reductionLevel","reserved","dataOffset","indexOffset","fileType","totalSummary","basesCovered","scoreMin","getFloat64","scoreMax","scoreSum","scoreSumSquares","autoSql","indexOf","ret","readInt32LE","readInt32BE","refsByNumber","keySize","bptReadNode","currentOffset","isLeafNode","n","replaceAll","refId","refSize","refRec","id","nextNodes","childOffset","getUnzoomedView","getFeatureStream","refName","view","basesPerSpan","scale","getView","Observable","getFeatures","ob","firstValueFrom","pipe","toArray","flat","BigWig","basesPerPx","zh","BigBed","readIndicesCache","_readIndices","readIndices","JSON","stringify","_scale","count","indices","type","getInt16","fieldcount","field","searchExtraIndexBlocks","locs","index","valSize","nodeOffset","val","nodeType","getInt8","leafkeys","lastOffset","localeCompare","t","searchExtraIndex","res","reduce","acc","curr","x","merge","split","base64","ieee754","customInspectSymbol","Symbol","exports","Buffer","K_MAX_LENGTH","createBuffer","RangeError","buf","Uint8Array","setPrototypeOf","arg","encodingOrOffset","allocUnsafe","from","string","encoding","isEncoding","actual","write","slice","fromString","ArrayBuffer","isView","arrayView","isInstance","copy","fromArrayBuffer","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","obj","isBuffer","checked","numberIsNaN","isArray","fromObject","toPrimitive","assertSize","array","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","m","bidirectionalIndexOf","dir","arrayIndexOf","call","lastIndexOf","arr","indexSize","arrLength","valLength","String","readUInt16BE","foundIndex","found","j","hexWrite","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","byteArray","charCodeAt","asciiToBytes","base64Write","ucs2Write","units","c","hi","lo","utf16leToBytes","fromByteArray","Math","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","fromCharCode","apply","decodeCodePointsArray","TYPED_ARRAY_SUPPORT","proto","foo","typedArraySupport","defineProperty","enumerable","poolSize","allocUnsafeSlow","_isBuffer","compare","y","list","swap16","swap32","swap64","toLocaleString","equals","inspect","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","toJSON","_arr","out","hexSliceLookupTable","bytes","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","wrtBigUInt64BE","checkIEEE754","writeFloat","noAssert","writeDouble","newBuf","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUInt8","readUint16LE","readUInt16LE","readUint16BE","readUint32LE","readUint32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","last","boundsError","readBigUInt64BE","readIntLE","pow","readIntBE","readInt8","readInt16LE","readInt16BE","readBigInt64LE","readBigInt64BE","readFloatLE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","limit","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","Base","writable","configurable","stack","addNumericalSeparator","range","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","floor","ERR_BUFFER_OUT_OF_BOUNDS","msg","received","isInteger","abs","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","base64clean","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined"],"sourceRoot":""}