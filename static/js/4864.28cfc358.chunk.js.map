{"version":3,"file":"static/js/4864.28cfc358.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedAdapter/BedAdapter.ts","../../../plugins/bed/src/util.ts"],"sourcesContent":["import BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Region, Feature, isGzip } from '@jbrowse/core/util'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\n// locals\nimport { featureData } from '../util'\n\nexport default class BedAdapter extends BaseFeatureDataAdapter {\n  protected bedFeatures?: Promise<{\n    header: string\n    features: Record<string, string[]>\n    parser: BED\n    columnNames: string[]\n    scoreColumn: string\n    colRef: number\n    colStart: number\n    colEnd: number\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree | undefined> | undefined\n  > = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts: BaseOptions = {}) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedLocation')\n    const buf = await openLocation(bedLoc, pm).readFile(opts)\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n    const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const headerLines = []\n    let i = 0\n    for (; i < lines.length && lines[i]!.startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n    const features = {} as Record<string, string[]>\n    for (; i < lines.length; i++) {\n      const line = lines[i]!\n      const tab = line.indexOf('\\t')\n      const refName = line.slice(0, tab)\n      if (!features[refName]) {\n        features[refName] = []\n      }\n      features[refName].push(line)\n    }\n\n    const autoSql = this.getConf('autoSql') as string\n    const parser = new BED({ autoSql })\n    const columnNames = this.getConf('columnNames')\n    const scoreColumn = this.getConf('scoreColumn')\n    const colRef = this.getConf('colRef')\n    const colStart = this.getConf('colStart')\n    const colEnd = this.getConf('colEnd')\n\n    return {\n      header,\n      features,\n      parser,\n      columnNames,\n      scoreColumn,\n      colRef,\n      colStart,\n      colEnd,\n    }\n  }\n\n  private async loadData(opts: BaseOptions = {}) {\n    if (!this.bedFeatures) {\n      this.bedFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { features } = await this.loadData(opts)\n    return Object.keys(features)\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { colRef, colStart, colEnd, features, parser, scoreColumn } =\n      await this.loadData()\n    const lines = features[refName]\n    if (!lines) {\n      return undefined\n    }\n    const names = await this.getNames()\n\n    const intervalTree = new IntervalTree()\n    const ret = lines.map((f, i) => {\n      const uniqueId = `${this.id}-${refName}-${i}`\n      return featureData(\n        f,\n        colRef,\n        colStart,\n        colEnd,\n        scoreColumn,\n        parser,\n        uniqueId,\n        names,\n      )\n    })\n\n    for (const obj of ret) {\n      intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n    }\n    return intervalTree\n  }\n\n  private async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch((e: unknown) => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureIntervalTree(refName)\n      intervalTree?.search([start, end]).forEach(f => {\n        observer.next(f)\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","import BED from '@gmod/bed'\nimport { SimpleFeature } from '@jbrowse/core/util'\n\nexport interface MinimalFeature {\n  type: string\n  start: number\n  end: number\n  refName: string\n  [key: string]: unknown\n}\nexport interface TranscriptFeat extends MinimalFeature {\n  thickStart: number\n  thickEnd: number\n  blockCount: number\n  blockSizes: number[]\n  chromStarts: number[]\n  refName: string\n  strand?: number\n  subfeatures: MinimalFeature[]\n}\n\nexport function ucscProcessedTranscript(feature: TranscriptFeat) {\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    blockSizes,\n    chromStarts,\n    refName,\n    strand = 0,\n    ...rest\n  } = feature\n\n  if (!thickStart || !thickEnd || !strand) {\n    return feature\n  }\n\n  const subfeatures: MinimalFeature[] = []\n  oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n    .forEach(block => {\n      const start = block.start\n      const end = block.end\n      if (thickStart >= end) {\n        // left-side UTR\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n        // UTR | CDS\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push(\n          {\n            type: `${prime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            start: thickStart,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd >= end) {\n        // CDS\n        subfeatures.push({\n          type: 'CDS',\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd < end) {\n        // UTR | CDS | UTR\n        const leftPrime = strand > 0 ? 'five' : 'three'\n        const rightPrime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: `${leftPrime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            start: thickStart,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${rightPrime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n        // CDS | UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: 'CDS',\n            start,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${prime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickEnd <= start) {\n        // right-side UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      }\n    })\n\n  return { ...rest, strand, type: 'mRNA', refName, subfeatures }\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  const obj = Object.fromEntries(\n    line.split('\\t').map((f, i) => [fields[i]!, f] as const),\n  )\n  const {\n    blockStarts,\n    blockCount,\n    chromStarts,\n    thickEnd,\n    thickStart,\n    blockSizes,\n    ...rest\n  } = obj\n\n  return {\n    ...rest,\n    blockStarts: blockStarts?.split(',').map(r => +r),\n    chromStarts: chromStarts?.split(',').map(r => +r),\n    blockSizes: blockSizes?.split(',').map(r => +r),\n    thickStart: thickStart ? +thickStart : undefined,\n    thickEnd: thickEnd ? +thickEnd : undefined,\n    blockCount: blockCount ? +blockCount : undefined,\n  } as Record<string, unknown>\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes: number[]\n  blockStarts?: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts || blockStarts || []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] || 0) + start\n    const bmax = bmin + (blockSizes[b] || 0)\n    subfeatures.push({\n      uniqueId: `${uniqueId}-${b}`,\n      start: bmin,\n      end: bmax,\n      refName,\n      type: 'block',\n    })\n  }\n  return subfeatures\n}\nexport function featureData(\n  line: string,\n  colRef: number,\n  colStart: number,\n  colEnd: number,\n  scoreColumn: string,\n  parser: BED,\n  uniqueId: string,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const refName = l[colRef]!\n  const start = +l[colStart]!\n  const colSame = colStart === colEnd ? 1 : 0\n  const end = +l[colEnd]! + colSame\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n\n  const {\n    blockCount,\n    blockSizes,\n    blockStarts,\n    chromStarts,\n    thickStart,\n    thickEnd,\n    type,\n    score,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n  const subfeatures = blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts,\n        blockCount,\n        blockSizes,\n        blockStarts,\n      })\n    : []\n  const f = {\n    ...rest,\n    type,\n    score: scoreColumn ? +data[scoreColumn] : score,\n    start,\n    end,\n    refName,\n    uniqueId,\n    subfeatures,\n  }\n  return new SimpleFeature({\n    id: uniqueId,\n    data: isUcscProcessedTranscript(data)\n      ? ucscProcessedTranscript({\n          thickStart: thickStart!,\n          thickEnd: thickEnd!,\n          blockCount: blockCount!,\n          blockSizes: blockSizes!,\n          chromStarts: chromStarts,\n          ...f,\n        })\n      : f,\n  })\n}\n\nexport function isUcscProcessedTranscript(f: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return f.thickStart && f.blockCount && f.strand !== 0\n}\n"],"names":["BedAdapter","BaseFeatureDataAdapter","intervalTrees","loadDataP","opts","pm","this","pluginManager","bedLoc","getConf","buf","openLocation","readFile","buffer","isGzip","unzip","length","Error","lines","TextDecoder","fatal","decode","split","filter","f","headerLines","i","startsWith","push","header","join","features","line","tab","indexOf","refName","slice","autoSql","parser","BED","columnNames","scoreColumn","colRef","colStart","colEnd","loadData","bedFeatures","catch","e","undefined","getRefNames","Object","keys","getHeader","getNames","defline","at","includes","map","field","trim","loadFeatureIntervalTreeHelper","names","intervalTree","IntervalTree","ret","uniqueId","id","featureData","obj","insert","get","loadFeatureIntervalTree","getFeatures","query","ObservableCreate","async","start","end","search","forEach","observer","next","complete","signal","freeResources","ucscProcessedTranscript","feature","subfeatures","oldSubfeatures","thickStart","thickEnd","blockCount","blockSizes","chromStarts","strand","rest","child","type","sort","a","b","block","prime","leftPrime","rightPrime","makeBlocks","blockStarts","starts","bmin","bmax","l","colSame","data","fields","fromEntries","r","defaultParser","parseLine","score","chrom","_1","chromStart","_2","chromEnd","_3","SimpleFeature","isUcscProcessedTranscript"],"sourceRoot":""}