{"version":3,"file":"static/js/4058.bdc1e88c.chunk.js","mappings":"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","sources":["../../../packages/core/util/parseLineByLine.ts","../../../plugins/bed/src/BedGraphAdapter/BedGraphAdapter.ts"],"sourcesContent":["import { getProgressDisplayStr } from './index'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n","import { IntervalTree } from '@flatten-js/interval-tree'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { SimpleFeature, fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nexport default class BedGraphAdapter extends BaseFeatureDataAdapter {\n  protected bedFeatures?: Promise<{\n    header: string\n    features: Record<string, string[]>\n    columnNames: string[]\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree<Feature> | undefined> | undefined\n  > = {}\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { features } = await this.loadData()\n    const lines = features[refName]\n    if (!lines) {\n      return undefined\n    }\n    const names = (await this.getNames())?.slice(3) || []\n    const intervalTree = new IntervalTree<Feature>()\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i]!\n      const [refName, s, e, ...rest] = line.split('\\t')\n\n      for (let j = 0, l2 = rest.length; j < l2; j++) {\n        const uniqueId = `${this.id}-${refName}-${i}-${j}`\n        const start = +s!\n        const end = +e!\n        const score = +rest[j]!\n        const source = names[j] || `col${j}`\n        if (score) {\n          intervalTree.insert(\n            [start, end],\n            new SimpleFeature({\n              id: uniqueId,\n              data: {\n                refName,\n                start,\n                end,\n                score,\n                source,\n              },\n            }),\n          )\n        }\n      }\n    }\n\n    return intervalTree\n  }\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { features } = await this.loadData(opts)\n    return Object.keys(features)\n  }\n  private async loadDataP(opts: BaseOptions = {}) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedGraphLocation')\n    const buffer = await fetchAndMaybeUnzip(openLocation(bedLoc, pm), opts)\n    const features = {} as Record<string, string[]>\n    const headerLines = [] as string[]\n    parseLineByLine(\n      buffer,\n      line => {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else {\n          const tab = line.indexOf('\\t')\n          const refName = line.slice(0, tab)\n          if (!features[refName]) {\n            features[refName] = []\n          }\n          features[refName].push(line)\n        }\n        return true\n      },\n      opts.statusCallback,\n    )\n\n    const columnNames = this.getConf('columnNames')\n\n    return {\n      header: headerLines.join('\\n'),\n      features,\n      columnNames,\n    }\n  }\n\n  async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch((e: unknown) => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  async loadData(opts: BaseOptions = {}) {\n    if (!this.bedFeatures) {\n      this.bedFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedFeatures\n  }\n  public getFeatures(query: Region, _opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureIntervalTree(refName)\n      for (const feature of intervalTree?.search([start, end]) || []) {\n        observer.next(feature)\n      }\n      observer.complete()\n    })\n  }\n}\n"],"names":["parseLineByLine","buffer","lineCallback","statusCallback","decoder","TextDecoder","blockStart","i","length","n","indexOf","lineEnd","b","subarray","line","decode","trim","getProgressDisplayStr","BedGraphAdapter","BaseFeatureDataAdapter","intervalTrees","getNames","header","columnNames","this","loadData","defline","split","filter","f","at","includes","slice","map","field","undefined","loadFeatureIntervalTreeHelper","refName","features","lines","names","intervalTree","IntervalTree","l","s","e","rest","j","l2","uniqueId","id","start","end","score","source","insert","SimpleFeature","data","getRefNames","opts","Object","keys","loadDataP","pm","pluginManager","bedLoc","getConf","fetchAndMaybeUnzip","openLocation","headerLines","startsWith","push","tab","join","loadFeatureIntervalTree","catch","bedFeatures","getFeatures","query","_opts","ObservableCreate","async","feature","search","observer","next","complete"],"sourceRoot":""}