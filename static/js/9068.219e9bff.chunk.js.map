{"version":3,"file":"static/js/9068.219e9bff.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../node_modules/.pnpm/@jridgewell+resolve-uri@3.1.2/node_modules/@jridgewell/resolve-uri/src/resolve-uri.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+nclist@3.0.4/node_modules/@gmod/nclist/src/array_representation.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+nclist@3.0.4/node_modules/@gmod/nclist/src/util.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+nclist@3.0.4/node_modules/@gmod/nclist/src/lazy_array.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+nclist@3.0.4/node_modules/@gmod/nclist/src/nclist.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+nclist@3.0.4/node_modules/@gmod/nclist/src/feature_store.ts","webpack://@jbrowse/web/../../plugins/legacy-jbrowse/src/NCListAdapter/NCListFeature.ts","webpack://@jbrowse/web/../../plugins/legacy-jbrowse/src/NCListAdapter/NCListAdapter.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts"],"sourcesContent":["// Matches the scheme of a URL, eg \"http://\"\nconst schemeRegex = /^[\\w+.-]+:\\/\\//;\n\n/**\n * Matches the parts of a URL:\n * 1. Scheme, including \":\", guaranteed.\n * 2. User/password, including \"@\", optional.\n * 3. Host, guaranteed.\n * 4. Port, including \":\", optional.\n * 5. Path, including \"/\", optional.\n * 6. Query, including \"?\", optional.\n * 7. Hash, including \"#\", optional.\n */\nconst urlRegex = /^([\\w+.-]+:)\\/\\/([^@/#?]*@)?([^:/#?]*)(:\\d+)?(\\/[^#?]*)?(\\?[^#]*)?(#.*)?/;\n\n/**\n * File URLs are weird. They dont' need the regular `//` in the scheme, they may or may not start\n * with a leading `/`, they can have a domain (but only if they don't start with a Windows drive).\n *\n * 1. Host, optional.\n * 2. Path, which may include \"/\", guaranteed.\n * 3. Query, including \"?\", optional.\n * 4. Hash, including \"#\", optional.\n */\nconst fileRegex = /^file:(?:\\/\\/((?![a-z]:)[^/#?]*)?)?(\\/?[^#?]*)(\\?[^#]*)?(#.*)?/i;\n\ntype Url = {\n  scheme: string;\n  user: string;\n  host: string;\n  port: string;\n  path: string;\n  query: string;\n  hash: string;\n  type: UrlType;\n};\n\nconst enum UrlType {\n  Empty = 1,\n  Hash = 2,\n  Query = 3,\n  RelativePath = 4,\n  AbsolutePath = 5,\n  SchemeRelative = 6,\n  Absolute = 7,\n}\n\nfunction isAbsoluteUrl(input: string): boolean {\n  return schemeRegex.test(input);\n}\n\nfunction isSchemeRelativeUrl(input: string): boolean {\n  return input.startsWith('//');\n}\n\nfunction isAbsolutePath(input: string): boolean {\n  return input.startsWith('/');\n}\n\nfunction isFileUrl(input: string): boolean {\n  return input.startsWith('file:');\n}\n\nfunction isRelative(input: string): boolean {\n  return /^[.?#]/.test(input);\n}\n\nfunction parseAbsoluteUrl(input: string): Url {\n  const match = urlRegex.exec(input)!;\n  return makeUrl(\n    match[1],\n    match[2] || '',\n    match[3],\n    match[4] || '',\n    match[5] || '/',\n    match[6] || '',\n    match[7] || '',\n  );\n}\n\nfunction parseFileUrl(input: string): Url {\n  const match = fileRegex.exec(input)!;\n  const path = match[2];\n  return makeUrl(\n    'file:',\n    '',\n    match[1] || '',\n    '',\n    isAbsolutePath(path) ? path : '/' + path,\n    match[3] || '',\n    match[4] || '',\n  );\n}\n\nfunction makeUrl(\n  scheme: string,\n  user: string,\n  host: string,\n  port: string,\n  path: string,\n  query: string,\n  hash: string,\n): Url {\n  return {\n    scheme,\n    user,\n    host,\n    port,\n    path,\n    query,\n    hash,\n    type: UrlType.Absolute,\n  };\n}\n\nfunction parseUrl(input: string): Url {\n  if (isSchemeRelativeUrl(input)) {\n    const url = parseAbsoluteUrl('http:' + input);\n    url.scheme = '';\n    url.type = UrlType.SchemeRelative;\n    return url;\n  }\n\n  if (isAbsolutePath(input)) {\n    const url = parseAbsoluteUrl('http://foo.com' + input);\n    url.scheme = '';\n    url.host = '';\n    url.type = UrlType.AbsolutePath;\n    return url;\n  }\n\n  if (isFileUrl(input)) return parseFileUrl(input);\n\n  if (isAbsoluteUrl(input)) return parseAbsoluteUrl(input);\n\n  const url = parseAbsoluteUrl('http://foo.com/' + input);\n  url.scheme = '';\n  url.host = '';\n  url.type = input\n    ? input.startsWith('?')\n      ? UrlType.Query\n      : input.startsWith('#')\n      ? UrlType.Hash\n      : UrlType.RelativePath\n    : UrlType.Empty;\n  return url;\n}\n\nfunction stripPathFilename(path: string): string {\n  // If a path ends with a parent directory \"..\", then it's a relative path with excess parent\n  // paths. It's not a file, so we can't strip it.\n  if (path.endsWith('/..')) return path;\n  const index = path.lastIndexOf('/');\n  return path.slice(0, index + 1);\n}\n\nfunction mergePaths(url: Url, base: Url) {\n  normalizePath(base, base.type);\n\n  // If the path is just a \"/\", then it was an empty path to begin with (remember, we're a relative\n  // path).\n  if (url.path === '/') {\n    url.path = base.path;\n  } else {\n    // Resolution happens relative to the base path's directory, not the file.\n    url.path = stripPathFilename(base.path) + url.path;\n  }\n}\n\n/**\n * The path can have empty directories \"//\", unneeded parents \"foo/..\", or current directory\n * \"foo/.\". We need to normalize to a standard representation.\n */\nfunction normalizePath(url: Url, type: UrlType) {\n  const rel = type <= UrlType.RelativePath;\n  const pieces = url.path.split('/');\n\n  // We need to preserve the first piece always, so that we output a leading slash. The item at\n  // pieces[0] is an empty string.\n  let pointer = 1;\n\n  // Positive is the number of real directories we've output, used for popping a parent directory.\n  // Eg, \"foo/bar/..\" will have a positive 2, and we can decrement to be left with just \"foo\".\n  let positive = 0;\n\n  // We need to keep a trailing slash if we encounter an empty directory (eg, splitting \"foo/\" will\n  // generate `[\"foo\", \"\"]` pieces). And, if we pop a parent directory. But once we encounter a\n  // real directory, we won't need to append, unless the other conditions happen again.\n  let addTrailingSlash = false;\n\n  for (let i = 1; i < pieces.length; i++) {\n    const piece = pieces[i];\n\n    // An empty directory, could be a trailing slash, or just a double \"//\" in the path.\n    if (!piece) {\n      addTrailingSlash = true;\n      continue;\n    }\n\n    // If we encounter a real directory, then we don't need to append anymore.\n    addTrailingSlash = false;\n\n    // A current directory, which we can always drop.\n    if (piece === '.') continue;\n\n    // A parent directory, we need to see if there are any real directories we can pop. Else, we\n    // have an excess of parents, and we'll need to keep the \"..\".\n    if (piece === '..') {\n      if (positive) {\n        addTrailingSlash = true;\n        positive--;\n        pointer--;\n      } else if (rel) {\n        // If we're in a relativePath, then we need to keep the excess parents. Else, in an absolute\n        // URL, protocol relative URL, or an absolute path, we don't need to keep excess.\n        pieces[pointer++] = piece;\n      }\n      continue;\n    }\n\n    // We've encountered a real directory. Move it to the next insertion pointer, which accounts for\n    // any popped or dropped directories.\n    pieces[pointer++] = piece;\n    positive++;\n  }\n\n  let path = '';\n  for (let i = 1; i < pointer; i++) {\n    path += '/' + pieces[i];\n  }\n  if (!path || (addTrailingSlash && !path.endsWith('/..'))) {\n    path += '/';\n  }\n  url.path = path;\n}\n\n/**\n * Attempts to resolve `input` URL/path relative to `base`.\n */\nexport default function resolve(input: string, base: string | undefined): string {\n  if (!input && !base) return '';\n\n  const url = parseUrl(input);\n  let inputType = url.type;\n\n  if (base && inputType !== UrlType.Absolute) {\n    const baseUrl = parseUrl(base);\n    const baseType = baseUrl.type;\n\n    switch (inputType) {\n      case UrlType.Empty:\n        url.hash = baseUrl.hash;\n      // fall through\n\n      case UrlType.Hash:\n        url.query = baseUrl.query;\n      // fall through\n\n      case UrlType.Query:\n      case UrlType.RelativePath:\n        mergePaths(url, baseUrl);\n      // fall through\n\n      case UrlType.AbsolutePath:\n        // The host, user, and port are joined, you can't copy one without the others.\n        url.user = baseUrl.user;\n        url.host = baseUrl.host;\n        url.port = baseUrl.port;\n      // fall through\n\n      case UrlType.SchemeRelative:\n        // The input doesn't have a schema at least, so we need to copy at least that over.\n        url.scheme = baseUrl.scheme;\n    }\n    if (baseType > inputType) inputType = baseType;\n  }\n\n  normalizePath(url, inputType);\n\n  const queryHash = url.query + url.hash;\n  switch (inputType) {\n    // This is impossible, because of the empty checks at the start of the function.\n    // case UrlType.Empty:\n\n    case UrlType.Hash:\n    case UrlType.Query:\n      return queryHash;\n\n    case UrlType.RelativePath: {\n      // The first char is always a \"/\", and we need it to be relative.\n      const path = url.path.slice(1);\n\n      if (!path) return queryHash || '.';\n\n      if (isRelative(base || input) && !isRelative(path)) {\n        // If base started with a leading \".\", or there is no base and input started with a \".\",\n        // then we need to ensure that the relative path starts with a \".\". We don't know if\n        // relative starts with a \"..\", though, so check before prepending.\n        return './' + path + queryHash;\n      }\n\n      return path + queryHash;\n    }\n\n    case UrlType.AbsolutePath:\n      return url.path + queryHash;\n\n    default:\n      return url.scheme + '//' + url.user + url.host + url.port + url.path + queryHash;\n  }\n}\n","//@ts-nocheck\n/**\n * @class ArrayRepr\n *\n * Class for operating on indexed array representations of objects.\n *\n * For example, if we have a lot of objects with similar attributes, e.g.:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: -1},\n *         {start: 5, end: 6, strand: 1},\n *         ...\n *     ]\n * </pre>\n *\n * @description\n * we can represent them more compactly (e.g., in JSON) something like this:\n *\n * <pre class=\"code\">\n *     class = [\"start\", \"end\", \"strand\"]\n *     [\n *         [1, 2, -1],\n *         [5, 6, 1],\n *         ...\n *     ]\n * </pre>\n *\n * If we want to represent a few different kinds of objects in our big list,\n * we can have multiple \"class\" arrays, and tag each object to identify\n * which \"class\" array describes it.\n *\n * For example, if we have a lot of instances of a few types of objects,\n * like this:\n *\n * <pre class=\"code\">\n *     [\n *         {start: 1, end: 2, strand: 1, id: 1},\n *         {start: 5, end: 6, strand: 1, id: 2},\n *         ...\n *         {start: 10, end: 20, chunk: 1},\n *         {start: 30, end: 40, chunk: 2},\n *         ...\n *     ]\n * </pre>\n *\n * We could use the first array position to indicate the \"class\" for the\n * object, like this:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2],\n *         ...\n *         [1, 10, 20, 1],\n *         [1, 30, 40, 1]\n *     ]\n * </pre>\n *\n * Also, if we occasionally want to add an ad-hoc attribute, we could just\n * stick an optional dictionary onto the end:\n *\n * <pre class=\"code\">\n *     classes = [[\"start\", \"end\", \"strand\", \"id\"], [\"start\", \"end\", \"chunk\"]]\n *     [\n *         [0, 1, 2, 1, 1],\n *         [0, 5, 6, 1, 2, {foo: 1}]\n *     ]\n * </pre>\n *\n * Given that individual objects are being represented by arrays, generic\n * code needs some way to differentiate arrays that are meant to be objects\n * from arrays that are actually meant to be arrays.\n * So for each class, we include a dict with <attribute name>: true mappings\n * for each attribute that is meant to be an array.\n *\n * Also, in cases where some attribute values are the same for all objects\n * in a particular set, it may be convenient to define a \"prototype\"\n * with default values for all objects in the set\n *\n * In the end, we get something like this:\n *\n * <pre class=\"code\">\n *     classes=[\n *         {'attributes': ['Start', 'End', 'Subfeatures'],\n *          'proto': {'Chrom': 'chr1'},\n *          'isArrayAttr': {Subfeatures: true}}\n *         ]\n * </pre>\n *\n * That's what this class facilitates.\n */\nclass ArrayRepr {\n  constructor(classes) {\n    this.classes = classes\n    this.fields = []\n    for (let cl = 0; cl < classes.length; cl += 1) {\n      this.fields[cl] = {}\n      for (let f = 0; f < classes[cl].attributes.length; f += 1) {\n        this.fields[cl][classes[cl].attributes[f]] = f + 1\n      }\n      if (classes[cl].proto === undefined) {\n        classes[cl].proto = {}\n      }\n      if (classes[cl].isArrayAttr === undefined) {\n        classes[cl].isArrayAttr = {}\n      }\n    }\n  }\n\n  /**\n   * @private\n   */\n  attrIndices(attr) {\n    return this.classes.map(\n      x =>\n        x.attributes.indexOf(attr) + 1 ||\n        x.attributes.indexOf(attr.toLowerCase()) + 1 ||\n        undefined,\n    )\n  }\n\n  get(obj, attr) {\n    if (attr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][attr]]\n    }\n\n    // try lowercase\n    const lcattr = attr.toLowerCase()\n    if (lcattr in this.fields[obj[0]]) {\n      return obj[this.fields[obj[0]][lcattr]]\n    }\n\n    const adhocIndex = this.classes[obj[0]].attributes.length + 1\n    if (adhocIndex >= obj.length || !(attr in obj[adhocIndex])) {\n      if (attr in this.classes[obj[0]].proto) {\n        return this.classes[obj[0]].proto[attr]\n      }\n      return undefined\n    }\n    return obj[adhocIndex][attr]\n  }\n\n  makeSetter(attr) {\n    return (obj, val) => {\n      this.set(obj, attr, val)\n    }\n  }\n\n  makeGetter(attr) {\n    return obj => {\n      return this.get(obj, attr)\n    }\n  }\n\n  makeFastGetter(attr) {\n    // can be used only if attr is guaranteed to be in\n    // the \"classes\" array for this object\n    const indices = this.attrIndices(attr)\n    return function get(obj) {\n      if (indices[obj[0]] !== undefined) {\n        return obj[indices[obj[0]]]\n      }\n      return undefined\n    }\n  }\n\n  // construct(self, obj, klass) {\n  //   const result = new Array(self.classes[klass].length)\n  //   Object.keys(obj).forEach(attr => {\n  //     this.set(result, attr, obj[attr])\n  //   })\n  //   return result\n  // }\n\n  /**\n   * Returns fast pre-compiled getter and setter functions for use with\n   * Arrays that use this representation.\n   * When the returned <code>get</code> and <code>set</code> functions are\n   * added as methods to an Array that contains data in this\n   * representation, they provide fast access by name to the data.\n   *\n   * @returns {Object} <code>{ get: function() {...}, set: function(val) {...} }</code>\n   *\n   * @example\n   * var accessors = attrs.accessors();\n   * var feature = get_feature_from_someplace();\n   * feature.get = accessors.get;\n   * // print out the feature start and end\n   * console.log( feature.get('start') + ',' + feature.get('end') );\n   */\n  accessors() {\n    if (!this._accessors) {\n      this._accessors = this._makeAccessors()\n    }\n    return this._accessors\n  }\n\n  /**\n   * @private\n   */\n  _makeAccessors() {\n    const indices = {}\n\n    const accessors = {\n      get(field) {\n        const f = this.get.field_accessors[field.toLowerCase()]\n        if (f) {\n          return f.call(this)\n        }\n        return undefined\n      },\n      set(field, val) {\n        const f = this.set.field_accessors[field]\n        if (f) {\n          return f.call(this, val)\n        }\n        return undefined\n      },\n      tags() {\n        return tags[this[0]] || []\n      },\n    }\n    accessors.get.field_accessors = {}\n    accessors.set.field_accessors = {}\n\n    // make a data structure as: { attr_name: [offset,offset,offset], }\n    // that will be convenient for finding the location of the attr\n    // for a given class like: indexForAttr{attrname}[classnum]\n    this.classes.forEach((cdef, classnum) => {\n      ;(cdef.attributes || []).forEach((attrname, offset) => {\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n\n        attrname = attrname.toLowerCase()\n\n        indices[attrname] = indices[attrname] || []\n        indices[attrname][classnum] = offset + 1\n      })\n    })\n\n    // lowercase all the class attributes\n    const tags = this.classes.map(c => c.attributes)\n\n    // use that to make precalculated get and set accessors for each field\n    Object.keys(indices).forEach(attrname => {\n      const attrIndices = indices[attrname]\n      // get\n      accessors.get.field_accessors[attrname] = !attrIndices\n        ? function get() {\n            return undefined\n          }\n        : function get() {\n            return this[attrIndices[this[0]]]\n          }\n\n      // // set\n      // accessors.set.field_accessors[attrname] = !attrIndices\n      //   ? () => undefined\n      //   : v => {\n      //       this[attrIndices[this[0]]] = v\n      //       return v\n      //     }\n    })\n\n    return accessors\n  }\n}\nexport default ArrayRepr\n\n/*\n\nCopyright (c) 2007-2010 The Evolutionary Software Foundation\n\nCreated by Mitchell Skinner <mitch_skinner@berkeley.edu>\n\nThis package and its accompanying libraries are free software; you can\nredistribute it and/or modify it under the terms of the LGPL (either\nversion 2.1, or at your option, any later version) or the Artistic\nLicense 2.0.  Refer to LICENSE for the full license text.\n\n*/\n","//@ts-nocheck\nimport resolve from '@jridgewell/resolve-uri'\n\nexport async function readJSON(url, readFile, options = {}) {\n  const { defaultContent = {} } = options\n  try {\n    const str = await readFile(url, { encoding: 'utf8' })\n    const decoder = new TextDecoder('utf8')\n    return JSON.parse(decoder.decode(str))\n  } catch (error) {\n    if (\n      error.code === 'ENOENT' ||\n      error.status === 404 ||\n      error.message.includes('404') ||\n      error.message.includes('ENOENT')\n    ) {\n      return defaultContent\n    }\n    throw error\n  }\n}\n\nexport function newURL(arg: string, base = '.') {\n  return resolve(arg, base)\n}\n","//@ts-nocheck\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport QuickLRU from '@jbrowse/quick-lru'\n\nimport { newURL, readJSON } from './util.ts'\n\n/**\n * For a JSON array that gets too large to load in one go, this class\n * helps break it up into chunks and provides an\n * async API for using the information in the array.\n */\nexport default class LazyArray {\n  constructor(\n    { urlTemplate, chunkSize, length, cacheSize = 100, readFile },\n    baseUrl,\n  ) {\n    this.urlTemplate = urlTemplate\n    this.chunkSize = chunkSize\n    this.length = length\n    this.baseUrl = baseUrl === undefined ? '' : baseUrl\n    this.readFile = readFile\n    if (!readFile) {\n      throw new Error('must provide readFile callback')\n    }\n    this.chunkCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.getChunk.bind(this),\n    })\n  }\n\n  /**\n   * call the callback on one element of the array\n   * @param i index\n   * @param callback callback, gets called with (i, value, param)\n   * @param param (optional) callback will get this as its last parameter\n   */\n  index(i, callback, param) {\n    this.range(i, i, callback, undefined, param)\n  }\n\n  /**\n   * async generator for the elements in the range [start,end]\n   *\n   * @param start index of first element to call the callback on\n   * @param end index of last element to call the callback on\n   */\n  async *range(start, end) {\n    start = Math.max(0, start)\n    end = Math.min(end, this.length - 1)\n\n    const firstChunk = Math.floor(start / this.chunkSize)\n    const lastChunk = Math.floor(end / this.chunkSize)\n\n    const chunkreadFiles = []\n    for (let chunk = firstChunk; chunk <= lastChunk; chunk += 1) {\n      chunkreadFiles.push(this.chunkCache.get(chunk, chunk))\n    }\n    for (const elt of chunkreadFiles) {\n      const [chunkNumber, chunkData] = await elt\n      yield* this.filterChunkData(start, end, chunkNumber, chunkData)\n    }\n  }\n\n  async getChunk(chunkNumber) {\n    let url = this.urlTemplate.replaceAll(/\\{Chunk\\}/gi, chunkNumber)\n    if (this.baseUrl) {\n      url = newURL(url, this.baseUrl)\n    }\n    const data = await readJSON(url, this.readFile)\n    return [chunkNumber, data]\n  }\n\n  *filterChunkData(queryStart, queryEnd, chunkNumber, chunkData) {\n    // index (in the overall lazy array) of the first position in this chunk\n    const firstIndex = chunkNumber * this.chunkSize\n    const chunkStart = Math.max(0, queryStart - firstIndex)\n    const chunkEnd = Math.min(queryEnd - firstIndex, this.chunkSize - 1)\n    for (let i = chunkStart; i <= chunkEnd; i += 1) {\n      yield [i + firstIndex, chunkData[i]]\n    }\n  }\n}\n","//@ts-nocheck\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport QuickLRU from '@jbrowse/quick-lru'\n\nimport { newURL, readJSON } from './util.ts'\n\nexport default class NCList {\n  constructor({ readFile, cacheSize = 100 }) {\n    this.topList = []\n    this.chunkCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.readChunkItems.bind(this),\n    })\n    this.readFile = readFile\n    if (!this.readFile) {\n      throw new Error(`must provide a \"readFile\" function`)\n    }\n  }\n\n  importExisting(nclist, attrs, baseURL, lazyUrlTemplate, lazyClass) {\n    this.topList = nclist\n    this.attrs = attrs\n    this.start = attrs.makeFastGetter('Start')\n    this.end = attrs.makeFastGetter('End')\n    this.lazyClass = lazyClass\n    this.baseURL = baseURL\n    this.lazyUrlTemplate = lazyUrlTemplate\n  }\n\n  binarySearch(arr, item, getter) {\n    let low = -1\n    let high = arr.length\n    let mid\n\n    while (high - low > 1) {\n      mid = (low + high) >>> 1\n      if (getter(arr[mid]) >= item) {\n        high = mid\n      } else {\n        low = mid\n      }\n    }\n\n    // if we're iterating rightward, return the high index;\n    // if leftward, the low index\n    if (getter === this.end) {\n      return high\n    }\n    return low\n  }\n\n  readChunkItems(chunkNum) {\n    const url = newURL(\n      this.lazyUrlTemplate.replaceAll(/\\{Chunk\\}/gi, chunkNum),\n      this.baseURL,\n    )\n    return readJSON(url, this.readFile, { defaultContent: [] })\n  }\n\n  async *iterateSublist(arr, from, to, inc, searchGet, testGet, path) {\n    const getChunk = this.attrs.makeGetter('Chunk')\n    const getSublist = this.attrs.makeGetter('Sublist')\n\n    const pendingPromises = []\n    for (\n      let i = this.binarySearch(arr, from, searchGet);\n      i < arr.length && i >= 0 && inc * testGet(arr[i]) < inc * to;\n      i += inc\n    ) {\n      if (arr[i][0] === this.lazyClass) {\n        // this is a lazily-loaded chunk of the nclist\n        const chunkNum = getChunk(arr[i])\n        const chunkItemsP = this.chunkCache\n          .get(chunkNum, chunkNum)\n          .then(item => [item, chunkNum])\n        pendingPromises.push(chunkItemsP)\n      } else {\n        // this is just a regular feature\n        yield [arr[i], path.concat(i)]\n      }\n\n      // if this node has a contained sublist, process that too\n      const sublist = getSublist(arr[i])\n      if (sublist) {\n        yield* this.iterateSublist(\n          sublist,\n          from,\n          to,\n          inc,\n          searchGet,\n          testGet,\n          path.concat(i),\n        )\n      }\n    }\n\n    for (const p of pendingPromises) {\n      const [item, chunkNum] = await p\n      if (item) {\n        yield* this.iterateSublist(item, from, to, inc, searchGet, testGet, [\n          ...path,\n          chunkNum,\n        ])\n      }\n    }\n  }\n\n  async *iterate(from, to) {\n    // calls the given function once for each of the\n    // intervals that overlap the given interval\n    // if from <= to, iterates left-to-right, otherwise iterates right-to-left\n\n    // inc: iterate leftward or rightward\n    const inc = from > to ? -1 : 1\n    // searchGet: search on start or end\n    const searchGet = from > to ? this.start : this.end\n    // testGet: test on start or end\n    const testGet = from > to ? this.end : this.start\n\n    if (this.topList.length > 0) {\n      yield* this.iterateSublist(\n        this.topList,\n        from,\n        to,\n        inc,\n        searchGet,\n        testGet,\n        [0],\n      )\n    }\n  }\n\n  async histogram(from, to, numBins) {\n    // calls callback with a histogram of the feature density\n    // in the given interval\n\n    const result = new Array(numBins)\n    result.fill(0)\n    const binWidth = (to - from) / numBins\n    for await (const feat of this.iterate(from, to)) {\n      const firstBin = Math.max(0, ((this.start(feat) - from) / binWidth) | 0)\n      const lastBin = Math.min(\n        numBins,\n        ((this.end(feat) - from) / binWidth) | 0,\n      )\n      for (let bin = firstBin; bin <= lastBin; bin += 1) {\n        result[bin] += 1\n      }\n    }\n    return result\n  }\n}\n","//@ts-nocheck\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport QuickLRU from '@jbrowse/quick-lru'\n\nimport ArrayRepr from './array_representation.ts'\nimport LazyArray from './lazy_array.ts'\nimport GenericNCList from './nclist.ts'\nimport { newURL, readJSON } from './util.ts'\n\nfunction idfunc() {\n  return this._uniqueID\n}\nfunction parentfunc() {\n  return this._parent\n}\nfunction childrenfunc() {\n  return this.get('subfeatures')\n}\n\n/**\n * Sequence feature store using nested containment\n * lists held in JSON files that are lazily read.\n *\n * @param {object} args constructor args\n * @param {string} args.baseUrl base URL for resolving relative URLs\n * @param {string} args.urlTemplate Template string for\n *  the root file of each reference sequence. The reference sequence\n *  name will be interpolated into this string where `{refseq}` appears.\n * @param {function} args.readFile function to use for reading remote from URLs.\n */\nexport default class NCListStore {\n  constructor({ baseUrl, urlTemplate, readFile, cacheSize = 10 }) {\n    this.baseUrl = baseUrl\n    this.urlTemplates = { root: urlTemplate }\n\n    this.readFile = readFile\n    if (!this.readFile) {\n      throw new Error(`must provide a \"readFile\" function argument`)\n    }\n\n    this.dataRootCache = new AbortablePromiseCache({\n      cache: new QuickLRU({ maxSize: cacheSize }),\n      fill: this.fetchDataRoot.bind(this),\n    })\n  }\n\n  makeNCList() {\n    return new GenericNCList({ readFile: this.readFile })\n  }\n\n  loadNCList(refData, trackInfo, listUrl) {\n    refData.nclist.importExisting(\n      trackInfo.intervals.nclist,\n      refData.attrs,\n      listUrl,\n      trackInfo.intervals.urlTemplate,\n      trackInfo.intervals.lazyClass,\n    )\n  }\n\n  getDataRoot(refName) {\n    return this.dataRootCache.get(refName, refName)\n  }\n\n  fetchDataRoot(refName) {\n    const url = newURL(\n      this.urlTemplates.root.replaceAll(/{\\s*refseq\\s*}/g, refName),\n      this.baseUrl,\n    )\n\n    // fetch the trackdata\n    return readJSON(url, this.readFile).then(trackInfo =>\n      // trackInfo = JSON.parse( trackInfo );\n      this.parseTrackInfo(trackInfo, url),\n    )\n  }\n\n  parseTrackInfo(trackInfo, url) {\n    const refData = {\n      nclist: this.makeNCList(),\n      stats: {\n        featureCount: trackInfo.featureCount || 0,\n      },\n    }\n\n    if (trackInfo.intervals) {\n      refData.attrs = new ArrayRepr(trackInfo.intervals.classes)\n      this.loadNCList(refData, trackInfo, url)\n    }\n\n    const { histograms } = trackInfo\n    if (histograms?.meta) {\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < histograms.meta.length; i += 1) {\n        histograms.meta[i].lazyArray = new LazyArray(\n          { ...histograms.meta[i].arrayParams, readFile: this.readFile },\n          url,\n        )\n      }\n      refData._histograms = histograms\n    }\n\n    // parse any strings in the histogram data that look like numbers\n    if (refData._histograms) {\n      Object.keys(refData._histograms).forEach(key => {\n        const entries = refData._histograms[key]\n        entries.forEach(entry => {\n          Object.keys(entry).forEach(key2 => {\n            if (\n              typeof entry[key2] === 'string' &&\n              String(Number(entry[key2])) === entry[key2]\n            ) {\n              entry[key2] = Number(entry[key2])\n            }\n          })\n        })\n      })\n    }\n\n    return refData\n  }\n\n  async getRegionStats(query) {\n    const data = await this.getDataRoot(query.ref)\n    return data.stats\n  }\n\n  /**\n   * fetch binned counts of feature coverage in the given region.\n   *\n   * @param {object} query\n   * @param {string} query.refName reference sequence name\n   * @param {number} query.start region start\n   * @param {number} query.end region end\n   * @param {number} query.numBins number of bins desired in the feature counts\n   * @param {number} query.basesPerBin number of bp desired in each feature counting bin\n   * @returns {object} as:\n   *    `{ bins: hist, stats: statEntry }`\n   */\n  async getRegionFeatureDensities({\n    refName,\n    start,\n    end,\n    numBins,\n    basesPerBin,\n  }) {\n    const data = await this.getDataRoot(refName)\n    if (numBins) {\n      basesPerBin = (end - start) / numBins\n    } else if (basesPerBin) {\n      numBins = Math.ceil((end - start) / basesPerBin)\n    } else {\n      throw new TypeError(\n        'numBins or basesPerBin arg required for getRegionFeatureDensities',\n      )\n    }\n\n    // pick the relevant entry in our pre-calculated stats\n    const stats = data._histograms.stats || []\n    const statEntry = stats.find(entry => entry.basesPerBin >= basesPerBin)\n\n    // The histogramMeta array describes multiple levels of histogram detail,\n    // going from the finest (smallest number of bases per bin) to the coarsest\n    // (largest number of bases per bin).\n    //\n    // We want to use coarsest histogramMeta that's at least as fine as the one\n    // we're currently rendering.\n    //\n    // TODO: take into account that the histogramMeta chosen here might not fit\n    // neatly into the current histogram (e.g., if the current histogram is at\n    // 50,000 bases/bin, and we have server histograms at 20,000 and 2,000\n    // bases/bin, then we should choose the 2,000 histogramMeta rather than the\n    // 20,000)\n    let histogramMeta = data._histograms.meta[0]\n    // eslint-disable-next-line @typescript-eslint/prefer-for-of\n    for (let i = 0; i < data._histograms.meta.length; i += 1) {\n      if (basesPerBin >= data._histograms.meta[i].basesPerBin) {\n        histogramMeta = data._histograms.meta[i]\n      }\n    }\n\n    // number of bins in the server-supplied histogram for each current bin\n    let binRatio = basesPerBin / histogramMeta.basesPerBin\n\n    // if the server-supplied histogram fits neatly into our requested\n    if (binRatio > 0.9 && Math.abs(binRatio - Math.round(binRatio)) < 0.0001) {\n      // console.log('server-supplied',query);\n      // we can use the server-supplied counts\n      const firstServerBin = Math.floor(start / histogramMeta.basesPerBin)\n      binRatio = Math.round(binRatio)\n      const histogram = []\n      for (let bin = 0; bin < numBins; bin += 1) {\n        histogram[bin] = 0\n      }\n\n      for await (const [i, val] of histogramMeta.lazyArray.range(\n        firstServerBin,\n        firstServerBin + binRatio * numBins - 1,\n      )) {\n        // this will count features that span the boundaries of\n        // the original histogram multiple times, so it's not\n        // perfectly quantitative.  Hopefully it's still useful, though.\n        histogram[Math.floor((i - firstServerBin) / binRatio)] += val\n      }\n      return { bins: histogram, stats: statEntry }\n    }\n    // console.log('make own',query);\n    // make our own counts\n    const hist = await data.nclist.histogram(start, end, numBins)\n    return { bins: hist, stats: statEntry }\n  }\n\n  /**\n   * Fetch features in a given region. This method is an asynchronous generator\n   * yielding feature objects.\n   *\n   * @param {object} args\n   * @param {string} args.refName reference sequence name\n   * @param {number} args.start start of region. 0-based half-open.\n   * @param {number} args.end end of region. 0-based half-open.\n   * @yields {object}\n   */\n  async *getFeatures({ refName, start, end }) {\n    const data = await this.getDataRoot(refName)\n    const accessors = data.attrs?.accessors()\n    for await (const [feature, path] of data.nclist.iterate(start, end)) {\n      // the unique ID is a stringification of the path in the\n      // NCList where the feature lives; it's unique across the\n      // top-level NCList (the top-level NCList covers a\n      // track/chromosome combination)\n\n      // only need to decorate a feature once\n      if (!feature.decorated) {\n        const uniqueID = path.join(',')\n        this.decorateFeature(accessors, feature, `${refName},${uniqueID}`)\n      }\n      yield feature\n    }\n  }\n\n  // helper method to recursively add .get and .tags methods to a feature and its\n  // subfeatures\n  decorateFeature(accessors, feature, id, parent) {\n    feature.get = accessors.get\n    feature.tags = accessors.tags\n    feature._uniqueID = id\n    feature.id = idfunc\n    feature._parent = parent\n    feature.parent = parentfunc\n    feature.children = childrenfunc\n    ;(feature.get('subfeatures') || []).forEach((f, i) => {\n      this.decorateFeature(accessors, f, `${id}-${i}`, feature)\n    })\n    feature.decorated = true\n  }\n}\n","import type {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\n\nconst jb2ToJb1 = { refName: 'seq_id' }\n\nconst jb1ToJb2 = { seq_id: 'refName' }\n\n/**\n * wrapper to adapt nclist features to act like jbrowse 2 features\n */\nexport default class NCListFeature implements Feature {\n  private parentHandle?: Feature\n\n  private uniqueId: string\n\n  constructor(\n    private ncFeature: any,\n    parent?: Feature,\n    id?: string,\n  ) {\n    this.uniqueId = id || ncFeature.id()\n    this.parentHandle = parent\n  }\n\n  set(): void {\n    throw new Error('not implemented')\n  }\n\n  jb2TagToJb1Tag(tag: string): string {\n    // @ts-expect-error\n    const mapped = jb2ToJb1[tag] || tag\n    return mapped.toLowerCase()\n  }\n\n  jb1TagToJb2Tag(tag: string): string {\n    const t = tag.toLowerCase()\n    // @ts-expect-error\n    return jb1ToJb2[t] || t\n  }\n\n  get(attrName: string): any {\n    const attr = this.ncFeature.get(this.jb2TagToJb1Tag(attrName))\n    if (attr && attrName === 'subfeatures') {\n      return attr.map((subfeature: any) => new NCListFeature(subfeature, this))\n    }\n    return attr\n  }\n\n  /**\n   * Get an array listing which data keys are present in this feature.\n   */\n  tags(): string[] {\n    return this.ncFeature.tags().map((t: string) => this.jb1TagToJb2Tag(t))\n  }\n\n  /**\n   * Get the unique ID of this feature.\n   */\n  id(): string {\n    return this.uniqueId\n  }\n\n  /**\n   * Get this feature's parent feature, or undefined if none.\n   */\n  parent(): Feature | undefined {\n    return this.parentHandle\n  }\n\n  /**\n   * Get an array of child features, or undefined if none.\n   */\n  children(): Feature[] | undefined {\n    return this.get('subfeatures')\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    // @ts-expect-error\n    const data: SimpleFeatureSerialized = { uniqueId: this.id() }\n\n    for (const tag of this.ncFeature.tags()) {\n      const mappedTag = this.jb1TagToJb2Tag(tag)\n      const value = this.ncFeature.get(tag)\n      if (mappedTag === 'subfeatures') {\n        data.subfeatures = (value || []).map((f: Feature) => {\n          // note: was new NCListFeature(f, `${this.id()}-${i}`, this).toJSON()\n          return new NCListFeature(f, this).toJSON()\n        })\n      } else {\n        data[mappedTag] = value\n      }\n    }\n    return data\n  }\n}\n","import NCListStore from '@gmod/nclist'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\nimport { RemoteFile } from 'generic-filehandle2'\n\nimport NCListFeature from './NCListFeature.ts'\n\nimport type PluginManager from '@jbrowse/core/PluginManager'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { Region } from '@jbrowse/core/util/types'\n\nexport default class NCListAdapter extends BaseFeatureDataAdapter {\n  private nclist: any\n\n  private configRefNames?: string[]\n\n  constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const refNames = this.getConf('refNames')\n    const rootUrlTemplate = this.getConf('rootUrlTemplate')\n    this.configRefNames = refNames\n\n    this.nclist = new NCListStore({\n      baseUrl: '',\n      urlTemplate: rootUrlTemplate.uri,\n      readFile: (url: string) =>\n        new RemoteFile(\n          rootUrlTemplate.baseUri\n            ? new URL(url, rootUrlTemplate.baseUri).toString()\n            : url,\n        ).readFile(),\n    })\n  }\n\n  /**\n   * Fetch features for a certain region. Use getFeaturesInRegion() if you also\n   * want to verify that the store has features for the given reference sequence\n   * before fetching.\n   * @param region -\n   * @param opts - [stopToken] optional stopTokenling object for aborting the fetch\n   * @returns Observable of Feature objects in the region\n   */\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { stopToken } = opts\n      for await (const feature of this.nclist.getFeatures(region, opts)) {\n        checkStopToken(stopToken)\n        observer.next(this.wrapFeature(feature))\n      }\n      observer.complete()\n    })\n  }\n\n  wrapFeature(ncFeature: any): NCListFeature {\n    return new NCListFeature(\n      ncFeature,\n      undefined,\n      `${this.id}-${ncFeature.id()}`,\n    )\n  }\n\n  async hasDataForRefName(refName: string) {\n    const root = await this.nclist.getDataRoot(refName)\n    return !!root?.stats?.featureCount\n  }\n\n  /**\n   * NCList is unable to get list of ref names so returns empty\n   */\n  async getRefNames() {\n    return this.configRefNames || []\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n}\n","// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter<V> {\n  callbacks = new Set<(arg: V) => void>()\n  currentMessage?: V\n\n  addCallback(callback: (arg: V) => void = () => {}): void {\n    this.callbacks.add(callback)\n    if (this.currentMessage) {\n      callback(this.currentMessage)\n    }\n  }\n\n  callback(message: V) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController.ts'\nimport AggregateStatusReporter from './AggregateStatusReporter.ts'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U, V> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: (arg: V) => void,\n) => Promise<U>\n\ninterface Entry<U, V> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter<V>\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U, V = string> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U, V>>\n  private fillCallback: FillCallback<T, U, V>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U, V>\n    cache: Cache<Entry<U, V>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U, V>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter<V>()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U, V> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: V) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch((error: unknown) => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      (error: unknown) => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n"],"names":["schemeRegex","urlRegex","fileRegex","isAbsolutePath","input","startsWith","isRelative","test","parseAbsoluteUrl","match","exec","makeUrl","scheme","user","host","port","path","query","hash","type","parseUrl","isSchemeRelativeUrl","url","isFileUrl","parseFileUrl","isAbsoluteUrl","normalizePath","rel","pieces","split","pointer","positive","addTrailingSlash","i","length","piece","endsWith","base","inputType","baseUrl","baseType","index","lastIndexOf","slice","stripPathFilename","mergePaths","queryHash","constructor","classes","this","fields","cl","f","attributes","undefined","proto","isArrayAttr","attrIndices","attr","map","x","indexOf","toLowerCase","get","obj","lcattr","adhocIndex","makeSetter","val","set","makeGetter","makeFastGetter","indices","accessors","_accessors","_makeAccessors","field","field_accessors","call","tags","forEach","cdef","classnum","attrname","offset","c","Object","keys","async","readJSON","readFile","options","defaultContent","str","encoding","decoder","TextDecoder","JSON","parse","decode","error","code","status","message","includes","newURL","arg","resolve","LazyArray","urlTemplate","chunkSize","cacheSize","Error","chunkCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","getChunk","bind","callback","param","range","start","end","Math","max","min","firstChunk","floor","lastChunk","chunkreadFiles","chunk","push","elt","chunkNumber","chunkData","filterChunkData","replaceAll","queryStart","queryEnd","firstIndex","chunkStart","chunkEnd","NCList","topList","readChunkItems","importExisting","nclist","attrs","baseURL","lazyUrlTemplate","lazyClass","binarySearch","arr","item","getter","mid","low","high","chunkNum","iterateSublist","from","to","inc","searchGet","testGet","getSublist","pendingPromises","chunkItemsP","then","concat","sublist","p","iterate","histogram","numBins","result","Array","binWidth","feat","firstBin","lastBin","bin","idfunc","_uniqueID","parentfunc","_parent","childrenfunc","NCListStore","urlTemplates","root","dataRootCache","fetchDataRoot","makeNCList","GenericNCList","loadNCList","refData","trackInfo","listUrl","intervals","getDataRoot","refName","parseTrackInfo","stats","featureCount","ArrayRepr","histograms","meta","lazyArray","arrayParams","_histograms","key","entry","key2","String","Number","getRegionStats","ref","getRegionFeatureDensities","basesPerBin","data","TypeError","ceil","statEntry","find","histogramMeta","binRatio","abs","round","firstServerBin","bins","getFeatures","feature","decorated","uniqueID","join","decorateFeature","id","parent","children","jb2ToJb1","jb1ToJb2","seq_id","NCListFeature","ncFeature","uniqueId","parentHandle","jb2TagToJb1Tag","tag","jb1TagToJb2Tag","t","attrName","subfeature","toJSON","mappedTag","value","subfeatures","NCListAdapter","BaseFeatureDataAdapter","config","getSubAdapter","pluginManager","super","refNames","getConf","rootUrlTemplate","configRefNames","uri","RemoteFile","baseUri","URL","toString","region","opts","ObservableCreate","stopToken","checkStopToken","observer","next","wrapFeature","complete","hasDataForRefName","getRefNames","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","addSignal","signal","aborted","add","handleAborted","addEventListener","delete","size","abort","AggregateStatusReporter","callbacks","addCallback","currentMessage","fillCallback","isAbortException","exception","name","evict","statusCallback","aborter","statusReporter","newEntry","promise","settled","catch","console","checkSinglePromise","checkForSingleAbort","assign","has","AbortSignal","cacheEntry","cachedEntry","clear","keyIter","deleteCount","done"],"sourceRoot":""}