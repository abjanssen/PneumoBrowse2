"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[3750],{93750(e,t,r){function i(e,t){const r=e.indexOf(t);return[e.slice(0,r),e.slice(r+1)]}r.d(t,{A:()=>c,h:()=>h});const n={AA:{Number:1,Type:"String",Description:"Ancestral allele"},AC:{Number:"A",Type:"Integer",Description:"Allele count in genotypes, for each ALT allele, in the same order as listed"},AD:{Number:"R",Type:"Integer",Description:"Total read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},AF:{Number:"A",Type:"Float",Description:"Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)"},AN:{Number:1,Type:"Integer",Description:"Total number of alleles in called genotypes"},BQ:{Number:1,Type:"Float",Description:"RMS base quality"},CIGAR:{Number:1,Type:"Float",Description:"Cigar string describing how to align an alternate allele to the reference allele"},DB:{Number:0,Type:"Flag",Description:"dbSNP membership"},DP:{Number:1,Type:"Integer",Description:"combined depth across samples"},END:{Number:1,Type:"Integer",Description:"End position (for use with symbolic alleles)"},H2:{Number:0,Type:"Flag",Description:"HapMap2 membership"},H3:{Number:0,Type:"Flag",Description:"HapMap3 membership"},MQ:{Number:1,Type:null,Description:"RMS mapping quality"},MQ0:{Number:1,Type:"Integer",Description:"Number of MAPQ == 0 reads"},NS:{Number:1,Type:"Integer",Description:"Number of samples with data"},SB:{Number:4,Type:"Integer",Description:"Strand bias"},SOMATIC:{Number:0,Type:"Flag",Description:"Somatic mutation (for cancer genomics)"},VALIDATED:{Number:0,Type:"Flag",Description:"Validated by follow-up experiment"},"1000G":{Number:0,Type:"Flag",Description:"1000 Genomes membership"},IMPRECISE:{Number:0,Type:"Flag",Description:"Imprecise structural variation"},NOVEL:{Number:0,Type:"Flag",Description:"Indicates a novel structural variation"},SVTYPE:{Number:1,Type:"String",Description:"Type of structural variant"},SVLEN:{Number:null,Type:"Integer",Description:"Difference in length between REF and ALT alleles"},CIPOS:{Number:2,Type:"Integer",Description:"Confidence interval around POS for imprecise variants"},CIEND:{Number:2,Type:"Integer",Description:"Confidence interval around END for imprecise variants"},HOMLEN:{Type:"Integer",Description:"Length of base pair identical micro-homology at event breakpoints"},HOMSEQ:{Type:"String",Description:"Sequence of base pair identical micro-homology at event breakpoints"},BKPTID:{Type:"String",Description:"ID of the assembled alternate allele in the assembly file"},MEINFO:{Number:4,Type:"String",Description:"Mobile element info of the form NAME,START,END,POLARITY"},METRANS:{Number:4,Type:"String",Description:"Mobile element transduction info of the form CHR,START,END,POLARITY"},DGVID:{Number:1,Type:"String",Description:"ID of this element in Database of Genomic Variation"},DBVARID:{Number:1,Type:"String",Description:"ID of this element in DBVAR"},DBRIPID:{Number:1,Type:"String",Description:"ID of this element in DBRIP"},MATEID:{Number:null,Type:"String",Description:"ID of mate breakends"},PARID:{Number:1,Type:"String",Description:"ID of partner breakend"},EVENT:{Number:1,Type:"String",Description:"ID of event associated to breakend"},CILEN:{Number:2,Type:"Integer",Description:"Confidence interval around the inserted material between breakend"},DPADJ:{Type:"Integer",Description:"Read Depth of adjacency"},CN:{Number:1,Type:"Integer",Description:"Copy number of segment containing breakend"},CNADJ:{Number:null,Type:"Integer",Description:"Copy number of adjacency"},CICN:{Number:2,Type:"Integer",Description:"Confidence interval around copy number for the segment"},CICNADJ:{Number:null,Type:"Integer",Description:"Confidence interval around copy number for the adjacency"}},o={AD:{Number:"R",Type:"Integer",Description:"Read depth for each allele"},ADF:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the forward strand"},ADR:{Number:"R",Type:"Integer",Description:"Read depth for each allele on the reverse strand"},DP:{Number:1,Type:"Integer",Description:"Read depth"},EC:{Number:"A",Type:"Integer",Description:"Expected alternate allele counts"},FT:{Number:1,Type:"String",Description:'Filter indicating if this genotype was "called"'},GL:{Number:"G",Type:"Float",Description:"Genotype likelihoods"},GP:{Number:"G",Type:"Float",Description:"Genotype posterior probabilities"},GQ:{Number:1,Type:"Integer",Description:"Conditional genotype quality"},GT:{Number:1,Type:"String",Description:"Genotype"},HQ:{Number:2,Type:"Integer",Description:"Haplotype quality"},MQ:{Number:1,Type:"Integer",Description:"RMS mapping quality"},PL:{Number:"G",Type:"Integer",Description:"Phred-scaled genotype likelihoods rounded to the closest integer"},PQ:{Number:1,Type:"Integer",Description:"Phasing quality"},PS:{Number:1,Type:"Integer",Description:"Phase set"}},s={DEL:{Description:"Deletion relative to the reference"},INS:{Description:"Insertion of novel sequence relative to the reference"},DUP:{Description:"Region of elevated copy number relative to the reference"},INV:{Description:"Inversion of reference sequence"},CNV:{Description:"Copy number variable region (may be both deletion and duplication)"},"DUP:TANDEM":{Description:"Tandem duplication"},"DEL:ME":{Description:"Deletion of mobile element relative to the reference"},"INS:ME":{Description:"Insertion of a mobile element relative to the reference"},NON_REF:{Description:"Represents any possible alternative allele at this location"},"*":{Description:"Represents any possible alternative allele at this location"}},a={PASS:{Description:"Passed all filters"}};function l(e){try{return decodeURIComponent(e)}catch(t){return e}}class c{constructor({header:e="",strict:t=!0}){if(!e.length)throw new Error("empty header received");const r=e.split(/[\r\n]+/).filter(Boolean);if(!r.length)throw new Error("no non-empty header lines specified");let i;this.strict=t,this.metadata={INFO:{...n},FORMAT:{...o},ALT:{...s},FILTER:{...a}};for(let e=0;e<r.length;e++){const t=r[e];if(!t.startsWith("#"))throw new Error(`Bad line in header:\n${t}`);t.startsWith("##")?this.parseMetadata(t):i=t}if(!i)throw new Error("No format line found in header");const l=i.trim().split("\t"),c=l.slice(0,8),p=["#CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO"];if(l.length<8)throw new Error(`VCF header missing columns:\n${i}`);if(c.length!==p.length||!c.every((e,t)=>e===p[t]))throw new Error(`VCF column headers not correct:\n${i}`);this.samples=l.slice(9)}parseInfo(e){const t={},r=e.includes("%"),i=e.split(";"),n=this.metadata.INFO,o=i.length;for(let e=0;e<o;e++){const o=i[e],s=o.indexOf("="),a=-1===s?o:o.slice(0,s),c=-1===s?void 0:o.slice(s+1),p=n[a]?.Type;if("Flag"===p)t[a]=!0;else if(c){const e="Integer"===p||"Float"===p,i=c.split(","),n=i.length;if(r){const r=[];for(let t=0;t<n;t++){const n=i[t];if("."===n)r.push(void 0);else{const t=l(n);r.push(e?Number(t):t)}}t[a]=r}else{const r=[];for(let t=0;t<n;t++){const n=i[t];"."===n?r.push(void 0):r.push(e?Number(n):n)}t[a]=r}}else t[a]=!0}return t}parseSamples(e,t){const r={};if(e){const i=t.split("\t"),n=e.split(":"),o=this.metadata.FORMAT,s=[];for(let e=0;e<n.length;e++){const t=o[n[e]]?.Type;s.push("Integer"===t||"Float"===t)}const a=n.length,l=this.samples.length;for(let e=0;e<l;e++){const t=this.samples[e],o={},l=i[e],c=l.length;let p=0,u=0;for(let e=0;e<=c;e++)if(e===c||":"===l[e]){const t=l.slice(p,e);if(""===t||"."===t)o[n[u]]=void 0;else{const e=t.split(","),r=[];if(s[u])for(let t=0;t<e.length;t++){const i=e[t];r.push("."===i?void 0:+i)}else for(let t=0;t<e.length;t++){const i=e[t];r.push("."===i?void 0:i)}o[n[u]]=r}if(p=e+1,u+=1,u>=a)break}r[t]=o}}return r}parseMetadata(e){const t=/^##(.+?)=(.*)/.exec(e.trim());if(!t)throw new Error(`Line is not a valid metadata line: ${e}`);const[r,i]=t.slice(1,3),n=r;if(i?.startsWith("<")){n in this.metadata||(this.metadata[n]={});const[e,t]=this.parseStructuredMetaVal(i);e?this.metadata[n][e]=t:this.metadata[n]=t}else this.metadata[n]=i}parseStructuredMetaVal(e){const t=function(e){const t=function(e){const t=[],r=[];let i=!1,n=!1;const o=e.length;for(let s=0;s<o;s++){const o=e[s];'"'===o?(i=!i,r.push(o)):"["===o?(n=!0,r.push(o)):"]"===o?(n=!1,r.push(o)):","!==o||i||n?r.push(o):(t.push(r.join("").trim()),r.length=0)}return r.length>0&&t.push(r.join("").trim()),t}(e.slice(1,-1)),r=[];for(let e=0;e<t.length;e++){const n=t[e],[o,s]=i(n,"=");if(s&&s.startsWith("[")&&s.endsWith("]")){const e=s.slice(1,-1).split(",");for(let t=0;t<e.length;t++)e[t]=e[t].trim();r.push([o,e])}else s&&s.startsWith('"')&&s.endsWith('"')?r.push([o,s.slice(1,-1)]):r.push([o,s])}return Object.fromEntries(r)}(e),r=t.ID;return delete t.ID,"Number"in t&&(Number.isNaN(Number(t.Number))||(t.Number=Number(t.Number))),[r,t]}getMetadata(...e){let t=this.metadata;const r=e.length;for(let i=0;i<r;i++)if(t=t[e[i]],!t)return t;return t}parseLine(e){let t=0,r=0;for(;t<e.length&&r<9;)"\t"===e[t]&&(r+=1),t+=1;const i=9===r?t-1:t,n=e.slice(0,i).split("\t"),o=e.slice(i+1),[s,a,l,c,p,u,h]=n,m=s,d=+a,f="."===l?void 0:l.split(";"),D=c,b="."===p?void 0:p.split(","),g="."===u?void 0:+u,N="."===h?void 0:h.split(";"),y=n[8];if(this.strict&&!n[7])throw new Error("no INFO field specified, must contain at least a '.' (turn off strict mode to allow)");return{CHROM:m,POS:d,ALT:b,INFO:void 0===n[7]||"."===n[7]?{}:this.parseInfo(n[7]),REF:D,FILTER:1===N?.length&&"PASS"===N[0]?"PASS":N,ID:f,QUAL:g,FORMAT:y,SAMPLES:()=>this.parseSamples(n[8]??"",o),GENOTYPES:()=>function(e,t,r){const i=Object.create(null),n=r.length,o=t.length;let s=0;if("GT"===e){for(let e=0;e<n;e++){const n=s;for(;s<o&&9!==t.charCodeAt(s);)s++;i[r[e]]=t.slice(n,s),s++}return i}const a=e.indexOf("GT");if(-1===a)return i;if(0===a){for(let e=0;e<n;e++){const n=s;for(;s<o&&58!==t.charCodeAt(s)&&9!==t.charCodeAt(s);)s++;for(i[r[e]]=t.slice(n,s);s<o&&9!==t.charCodeAt(s);)s++;s++}return i}let l=0;for(let t=0;t<a;t++)58===e.charCodeAt(t)&&l++;for(let e=0;e<n;e++){const n=s;let a=s;for(;a<o&&9!==t.charCodeAt(a);)a++;let c=0,p=n;for(let o=n;o<=a;o++)if(o===a||58===t.charCodeAt(o)){if(c===l){i[r[e]]=t.slice(p,o);break}c++,p=o+1}s=a+1}return i}(n[8]??"",o,this.samples)}}}const p=/<(.*)>(.*)/,u=/(.*)<(.*)>/;function h(e){const t=e[0],r=e[e.length-1];if("["===t||"]"===t||"["===r||"]"===r){const t=e.split(/[[\]]/),r=e.includes("[")?"right":"left";let i,n,o;const s=t.length;for(let e=0;e<s;e++){const r=t[e];r&&(r.includes(":")?(o=r,i=n?"right":"left"):n=r)}if(!(o&&i&&n))throw new Error(`Invalid breakend: ${e}`);return{MatePosition:o,Join:i,Replacement:n,MateDirection:r}}if("."===t)return{Join:"left",SingleBreakend:!0,Replacement:e.slice(1)};if("."===r)return{Join:"right",SingleBreakend:!0,Replacement:e.slice(0,-1)};if("<"===t){const t=p.exec(e);if(!t)throw new Error(`failed to parse ${e}`);const r=t[2];return r?{Join:"left",Replacement:r,MateDirection:"right",MatePosition:`<${t[1]}>:1`}:void 0}if(e.includes("<")){const t=u.exec(e);if(!t)throw new Error(`failed to parse ${e}`);const r=t[1];return r?{Join:"right",Replacement:r,MateDirection:"right",MatePosition:`<${t[2]}>:1`}:void 0}}}}]);
//# sourceMappingURL=3750.3d4b811e.chunk.js.map