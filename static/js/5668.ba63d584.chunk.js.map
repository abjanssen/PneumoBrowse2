{"version":3,"file":"static/js/5668.ba63d584.chunk.js","mappings":"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","sources":["../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/util.ts","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/AlignmentConnections.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Breakends.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Translocations.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Overlay.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/svgcomponents/SVGBackground.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/svgcomponents/util.ts","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/svgcomponents/SVGBreakpointSplitView.tsx"],"sourcesContent":["import { Feature, notEmpty } from '@jbrowse/core/util'\n\nimport { parseBreakend } from '@gmod/vcf'\n\n// this finds candidate alignment features, aimed at plotting split reads from\n// BAM/CRAM files\nexport function getBadlyPairedAlignments(features: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  // this finds candidate features that share the same name\n  for (const feature of features.values()) {\n    const flags = feature.get('flags')\n    const id = feature.id()\n    const unmapped = flags & 4\n    const correctlyPaired = flags & 2\n\n    if (!alreadySeen.has(id) && !correctlyPaired && !unmapped) {\n      const n = feature.get('name')\n      let val = candidates.get(n)\n      if (!val) {\n        val = []\n        candidates.set(n, val)\n      }\n      val.push(feature)\n    }\n    alreadySeen.add(feature.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\nfunction getTag(f: Feature, tag: string) {\n  const tags = f.get('tags')\n  return tags ? tags[tag] : f.get(tag)\n}\n\n// this finds candidate alignment features, aimed at plotting split reads from\n// BAM/CRAM files\nexport function getMatchedAlignmentFeatures(features: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  // this finds candidate features that share the same name\n  for (const feature of features.values()) {\n    const id = feature.id()\n    const unmapped = feature.get('flags') & 4\n    const hasSA = !!getTag(feature, 'SA')\n    if (!alreadySeen.has(id) && !unmapped && hasSA) {\n      const n = feature.get('name')\n      let val = candidates.get(n)\n      if (!val) {\n        val = []\n        candidates.set(n, val)\n      }\n      val.push(feature)\n    }\n    alreadySeen.add(feature.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\nexport function hasPairedReads(features: Map<string, Feature>) {\n  for (const f of features.values()) {\n    if (f.get('flags') & 1) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function findMatchingAlt(feat1: Feature, feat2: Feature) {\n  const alts = feat1.get('ALT') as string[] | undefined\n  if (alts) {\n    return new Map(\n      alts\n        ?.map(alt => parseBreakend(alt))\n        .filter(notEmpty)\n        .map(bnd => [bnd.MatePosition, bnd]),\n    ).get(`${feat2.get('refName')}:${feat2.get('start') + 1}`)\n  }\n  return undefined\n}\n\n// Returns paired BND features across multiple views by inspecting the ALT\n// field to get exact coordinate matches\nexport function getMatchedBreakendFeatures(feats: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('type') === 'breakend') {\n      const alts = f.get('ALT') as string[] | undefined\n      alts?.forEach(a => {\n        const cur = `${f.get('refName')}:${f.get('start') + 1}`\n        const bnd = parseBreakend(a)\n        if (bnd) {\n          const val = candidates.get(cur)\n          if (!val) {\n            candidates.set(bnd.MatePosition || 'none', [f])\n          } else {\n            val.push(f)\n          }\n        }\n      })\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\n// Getting \"matched\" TRA means just return all TRA\nexport function getMatchedTranslocationFeatures(feats: Map<string, Feature>) {\n  const ret: Feature[][] = []\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('ALT')[0] === '<TRA>') {\n      ret.push([f])\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return ret\n}\n","import React, { useMemo, useState } from 'react'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\nimport { useTheme } from '@mui/material'\nimport { getSession } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\n\n// locals\nimport {\n  getBadlyPairedAlignments,\n  getMatchedAlignmentFeatures,\n  hasPairedReads,\n} from './util'\nimport { yPos, useNextFrame, getPxFromCoordinate } from '../util'\nimport { BreakpointViewModel } from '../model'\n\nconst [LEFT, , RIGHT] = [0, 1, 2, 3]\n\nconst AlignmentConnections = observer(function ({\n  model,\n  trackId,\n  parentRef,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { views, showIntraviewLinks } = model\n  const theme = useTheme()\n  const session = getSession(model)\n  const snap = getSnapshot(model)\n  const { assemblyManager } = session\n  const assembly = assemblyManager.get(views[0].assemblyNames[0])\n  useNextFrame(snap)\n  const allFeatures = model.getTrackFeatures(trackId)\n  const hasPaired = useMemo(() => hasPairedReads(allFeatures), [allFeatures])\n  const { r, g, b, a } = colord(theme.palette.text.disabled).rgba\n  const layoutMatches = useMemo(() => {\n    const layoutMatches = model.getMatchedFeaturesInLayout(\n      trackId,\n      hasPaired\n        ? getBadlyPairedAlignments(allFeatures)\n        : getMatchedAlignmentFeatures(allFeatures),\n    )\n    if (!hasPaired) {\n      layoutMatches.forEach(m => {\n        m.sort((a, b) => a.feature.get('clipPos') - b.feature.get('clipPos'))\n      })\n    }\n    return layoutMatches\n  }, [allFeatures, trackId, hasPaired, model])\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n\n  let yOffset = 0\n  if (parentRef.current) {\n    const rect = parentRef.current.getBoundingClientRect()\n    yOffset = rect.top\n  }\n\n  return assembly ? (\n    <g\n      fill=\"none\"\n      stroke={`rgb(${r},${g},${b})`}\n      strokeOpacity={a}\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        // we follow a path in the list of chunks, not from top to bottom, just in series\n        // following x1,y1 -> x2,y2\n        for (let i = 0; i < chunk.length - 1; i++) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]\n\n          if (!c1 || !c2) {\n            console.warn('received null layout for a overlay feature')\n            return null\n          }\n\n          // disable rendering connections in a single level\n          if (!showIntraviewLinks && level1 === level2) {\n            return null\n          }\n          const f1ref = assembly.getCanonicalRefName(f1.get('refName'))\n          const f2ref = assembly.getCanonicalRefName(f2.get('refName'))\n\n          if (!f1ref || !f2ref) {\n            throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n          }\n\n          const s1 = f1.get('strand')\n          const s2 = f2.get('strand')\n          const p1 = c1[s1 === -1 ? LEFT : RIGHT]\n          const sn1 = s2 === -1\n          const p2 = hasPaired ? c2[sn1 ? LEFT : RIGHT] : c2[sn1 ? RIGHT : LEFT]\n          const x1 = getPxFromCoordinate(views[level1], f1ref, p1)\n          const x2 = getPxFromCoordinate(views[level2], f2ref, p2)\n          const reversed1 = views[level1].pxToBp(x1).reversed\n          const reversed2 = views[level2].pxToBp(x2).reversed\n          const tracks = views.map(v => v.getTrack(trackId))\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yOffset\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yOffset\n\n          // possible todo: use totalCurveHeight to possibly make alternative\n          // squiggle if the S is too small\n          const path = [\n            'M',\n            x1,\n            y1,\n            'C',\n            x1 + 200 * f1.get('strand') * (reversed1 ? -1 : 1),\n            y1,\n            x2 -\n              200 *\n                f2.get('strand') *\n                (reversed2 ? -1 : 1) *\n                (hasPaired ? -1 : 1),\n            y2,\n            x2,\n            y2,\n          ].join(' ')\n          const id = `${f1.id()}-${f2.id()}`\n          ret.push(\n            <path\n              d={path}\n              key={id}\n              data-testid=\"r1\"\n              strokeWidth={mouseoverElt === id ? 5 : 1}\n              onClick={() => {\n                const featureWidget = session.addWidget?.(\n                  'BreakpointAlignmentsWidget',\n                  'breakpointAlignments',\n                  {\n                    featureData: {\n                      feature1: (\n                        allFeatures.get(f1.id()) || { toJSON: () => {} }\n                      ).toJSON(),\n                      feature2: (\n                        allFeatures.get(f2.id()) || { toJSON: () => {} }\n                      ).toJSON(),\n                    },\n                  },\n                )\n                session.showWidget?.(featureWidget)\n              }}\n              onMouseOver={() => setMouseoverElt(id)}\n              onMouseOut={() => setMouseoverElt(undefined)}\n            />,\n          )\n        }\n        return ret\n      })}\n    </g>\n  ) : null\n})\n\nexport default AlignmentConnections\n","import React, { useState, useMemo } from 'react'\nimport { getSession } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\n\n// locals\nimport { findMatchingAlt, getMatchedBreakendFeatures } from './util'\nimport { yPos, getPxFromCoordinate, useNextFrame } from '../util'\nimport { BreakpointViewModel } from '../model'\n\nconst [LEFT] = [0, 1, 2, 3]\n\nconst Breakends = observer(function ({\n  model,\n  trackId,\n  parentRef: ref,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const totalFeatures = model.getTrackFeatures(trackId)\n  const layoutMatches = useMemo(\n    () =>\n      model.getMatchedFeaturesInLayout(\n        trackId,\n        getMatchedBreakendFeatures(totalFeatures),\n      ),\n    [totalFeatures, trackId, model],\n  )\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const snap = getSnapshot(model)\n  useNextFrame(snap)\n  const assembly = assemblyManager.get(views[0].assemblyNames[0])\n\n  if (!assembly) {\n    return null\n  }\n\n  let yoff = 0\n  if (ref.current) {\n    const rect = ref.current.getBoundingClientRect()\n    yoff = rect.top\n  }\n\n  return (\n    <g\n      stroke=\"green\"\n      strokeWidth={5}\n      fill=\"none\"\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        // we follow a path in the list of chunks, not from top to bottom, just\n        // in series following x1,y1 -> x2,y2\n        for (let i = 0; i < chunk.length - 1; i += 1) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]\n          const id = f1.id()\n\n          const relevantAlt = findMatchingAlt(f1, f2)\n          if (!c1 || !c2) {\n            return null\n          }\n          const f1origref = f1.get('refName')\n          const f2origref = f2.get('refName')\n          const f1ref = assembly.getCanonicalRefName(f1origref)\n          const f2ref = assembly.getCanonicalRefName(f2origref)\n          if (!f1ref || !f2ref) {\n            throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n          }\n          const x1 = getPxFromCoordinate(views[level1], f1ref, c1[LEFT])\n          const x2 = getPxFromCoordinate(views[level2], f2ref, c2[LEFT])\n          const reversed1 = views[level1].pxToBp(x1).reversed\n          const reversed2 = views[level2].pxToBp(x2).reversed\n\n          const tracks = views.map(v => v.getTrack(trackId))\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yoff\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yoff\n          if (!relevantAlt) {\n            console.warn('the relevant ALT allele was not found, cannot render')\n          } else {\n            const path = [\n              'M', // move to\n              x1 -\n                20 *\n                  (relevantAlt.Join === 'left' ? -1 : 1) *\n                  (reversed1 ? -1 : 1),\n              y1,\n              'L', // line to\n              x1,\n              y1,\n              'L', // line to\n              x2,\n              y2,\n              'L', // line to\n              x2 -\n                20 *\n                  (relevantAlt.MateDirection === 'left' ? 1 : -1) *\n                  (reversed2 ? -1 : 1),\n              y2,\n            ].join(' ')\n            ret.push(\n              <path\n                d={path}\n                data-testid=\"r2\"\n                key={JSON.stringify(path)}\n                strokeWidth={id === mouseoverElt ? 10 : 5}\n                onClick={() => {\n                  const featureWidget = session.addWidget?.(\n                    'VariantFeatureWidget',\n                    'variantFeature',\n                    {\n                      featureData: totalFeatures.get(id)?.toJSON(),\n                    },\n                  )\n                  session.showWidget?.(featureWidget)\n                }}\n                onMouseOver={() => setMouseoverElt(id)}\n                onMouseOut={() => setMouseoverElt(undefined)}\n              />,\n            )\n          }\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default Breakends\n","import React, { useState, useMemo } from 'react'\nimport { getSession } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\n\n// locals\nimport { getMatchedTranslocationFeatures } from './util'\nimport { yPos, getPxFromCoordinate, useNextFrame } from '../util'\nimport { BreakpointViewModel, LayoutRecord } from '../model'\n\nconst [LEFT] = [0, 1, 2, 3]\n\nfunction str(s: string) {\n  if (s === '+') {\n    return 1\n  } else if (s === '-') {\n    return -1\n  } else {\n    return 0\n  }\n}\n\nconst Translocations = observer(function ({\n  model,\n  trackId,\n  parentRef: ref,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const totalFeatures = model.getTrackFeatures(trackId)\n  const layoutMatches = useMemo(\n    () =>\n      model.getMatchedFeaturesInLayout(\n        trackId,\n        getMatchedTranslocationFeatures(totalFeatures),\n      ),\n\n    [totalFeatures, trackId, model],\n  )\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const snap = getSnapshot(model)\n  useNextFrame(snap)\n\n  const assembly = assemblyManager.get(views[0].assemblyNames[0])\n  if (!assembly) {\n    return null\n  }\n\n  let yOffset = 0\n  if (ref.current) {\n    const rect = ref.current.getBoundingClientRect()\n    yOffset = rect.top\n  }\n\n  // we hardcode the TRA to go to the \"other view\" and if there is none, we\n  // just return null here note: would need to do processing of the INFO\n  // CHR2/END and see which view could contain those coordinates to really do\n  // it properly\n  if (views.length < 2) {\n    return null\n  }\n  return (\n    <g\n      fill=\"none\"\n      stroke=\"green\"\n      strokeWidth={5}\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        // we follow a path in the list of chunks, not from top to bottom,\n        // just in series following x1,y1 -> x2,y2\n        const ret = []\n        for (const { layout: c1, feature: f1, level: level1 } of chunk) {\n          const level2 = level1 === 0 ? 1 : 0\n          const id = f1.id()\n          if (!c1) {\n            return null\n          }\n\n          const info = f1.get('INFO')\n          const chr2 = info.CHR2[0]\n          const end2 = info.END[0]\n          const res = info.STRANDS?.[0]?.split('') // not all files have STRANDS\n          const [myDirection, mateDirection] = res ?? ['.', '.']\n\n          const r = getPxFromCoordinate(views[level2], chr2, end2)\n          if (r) {\n            const c2: LayoutRecord = [r, 0, r + 1, 0]\n            const x1 = getPxFromCoordinate(\n              views[level1],\n              f1.get('refName'),\n              c1[LEFT],\n            )\n            const x2 = r\n            const reversed1 = views[level1].pxToBp(x1).reversed\n            const reversed2 = views[level2].pxToBp(x2).reversed\n\n            const tracks = views.map(v => v.getTrack(trackId))\n            const y1 =\n              yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n              yOffset\n            const y2 =\n              yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n              yOffset\n\n            const path = [\n              'M', // move to\n              x1 - 20 * str(myDirection) * (reversed1 ? -1 : 1),\n              y1,\n              'L', // line to\n              x1,\n              y1,\n              'L', // line to\n              x2,\n              y2,\n              'L', // line to\n              x2 - 20 * str(mateDirection) * (reversed2 ? -1 : 1),\n              y2,\n            ].join(' ')\n            ret.push(\n              <path\n                d={path}\n                key={JSON.stringify(path)}\n                strokeWidth={id === mouseoverElt ? 10 : 5}\n                onClick={() => {\n                  const featureWidget = session.addWidget?.(\n                    'VariantFeatureWidget',\n                    'variantFeature',\n                    {\n                      featureData: (\n                        totalFeatures.get(id) || { toJSON: () => {} }\n                      ).toJSON(),\n                    },\n                  )\n                  session.showWidget?.(featureWidget)\n                }}\n                onMouseOver={() => setMouseoverElt(id)}\n                onMouseOut={() => setMouseoverElt(undefined)}\n              />,\n            )\n          }\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default Translocations\n","import React from 'react'\nimport { observer } from 'mobx-react'\n\n// locals\nimport { BreakpointViewModel } from '../model'\nimport AlignmentConnections from './AlignmentConnections'\nimport Breakends from './Breakends'\nimport Translocations from './Translocations'\n\nconst Overlay = observer(function (props: {\n  parentRef: React.RefObject<SVGSVGElement>\n  model: BreakpointViewModel\n  trackId: string\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { model, trackId } = props\n  const tracks = model.getMatchedTracks(trackId)\n  if (tracks[0]?.type === 'AlignmentsTrack') {\n    return <AlignmentConnections {...props} />\n  }\n  if (tracks[0]?.type === 'VariantTrack') {\n    return model.hasTranslocations(trackId) ? (\n      <Translocations {...props} />\n    ) : (\n      <Breakends {...props} />\n    )\n  }\n  return null\n})\n\nexport default Overlay\n","import React from 'react'\nimport { useTheme } from '@mui/material'\nimport { stripAlpha } from '@jbrowse/core/util'\n\nexport default function SVGBackground({\n  width,\n  height,\n  shift,\n}: {\n  width: number\n  height: number\n  shift: number\n}) {\n  const theme = useTheme()\n  return (\n    <rect\n      width={width + shift * 2}\n      height={height}\n      fill={stripAlpha(theme.palette.background.default)}\n    />\n  )\n}\n","import { AbstractSessionModel, max, measureText } from '@jbrowse/core/util'\n\n// locals\nimport { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\n// locals\nimport { getTrackName } from '@jbrowse/core/util/tracks'\n\nexport function getTrackNameMaxLen(\n  views: LinearGenomeViewModel[],\n  fontSize: number,\n  session: AbstractSessionModel,\n) {\n  return max(\n    views.flatMap(view =>\n      view.tracks.map(t =>\n        measureText(getTrackName(t.configuration, session), fontSize),\n      ),\n    ),\n    0,\n  )\n}\nexport function getTrackOffsets(\n  view: LinearGenomeViewModel,\n  textOffset: number,\n  extra = 0,\n) {\n  const offsets = {} as Record<string, number>\n  let curr = textOffset\n  for (const track of view.tracks) {\n    offsets[track.configuration.trackId] = curr + extra\n    curr += track.displays[0].height + textOffset\n  }\n  return offsets\n}\n","import React from 'react'\nimport { when } from 'mobx'\nimport { getSession, renderToStaticMarkup, sum } from '@jbrowse/core/util'\nimport { ThemeProvider } from '@mui/material'\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\nimport { getRoot } from 'mobx-state-tree'\nimport {\n  SVGTracks,\n  SVGRuler,\n  totalHeight,\n} from '@jbrowse/plugin-linear-genome-view'\n\n// locals\nimport SVGBackground from './SVGBackground'\nimport { ExportSvgOptions, BreakpointViewModel } from '../model'\nimport Overlay from '../components/Overlay'\nimport { getTrackNameMaxLen, getTrackOffsets } from './util'\n\ntype BSV = BreakpointViewModel\n\n// render LGV to SVG\nexport async function renderToSvg(model: BSV, opts: ExportSvgOptions) {\n  const {\n    textHeight = 18,\n    headerHeight = 30,\n    rulerHeight = 30,\n    fontSize = 13,\n    trackLabels = 'offset',\n    Wrapper = ({ children }) => children,\n    themeName = 'default',\n  } = opts\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const { createRootFn } = getRoot<any>(model)\n  const session = getSession(model)\n  const theme = session.allThemes?.()[themeName]\n  const { width, views } = model\n  const shift = 50\n  const offset = headerHeight + rulerHeight\n\n  const heights = views.map(\n    v => totalHeight(v.tracks, textHeight, trackLabels) + offset,\n  )\n  const totalHeightSvg = sum(heights) + 100\n  const displayResults = await Promise.all(\n    views.map(\n      async view =>\n        ({\n          view,\n          data: await Promise.all(\n            view.tracks.map(async track => {\n              const d = track.displays[0]\n              await when(() => (d.ready !== undefined ? d.ready : true))\n              return { track, result: await d.renderSvg({ ...opts, theme }) }\n            }),\n          ),\n        }) as const,\n    ),\n  )\n\n  const trackLabelMaxLen = getTrackNameMaxLen(views, fontSize, session) + 40\n  const trackLabelOffset = trackLabels === 'left' ? trackLabelMaxLen : 0\n  const textOffset = trackLabels === 'offset' ? textHeight : 0\n  const trackOffsets = [\n    getTrackOffsets(views[0], textOffset, fontSize + offset),\n    getTrackOffsets(views[1], textOffset, fontSize + heights[0] + offset),\n  ]\n  const w = width + trackLabelOffset\n  const t = createJBrowseTheme(theme)\n\n  // the xlink namespace is used for rendering <image> tag\n  return renderToStaticMarkup(\n    <ThemeProvider theme={t}>\n      <Wrapper>\n        <svg\n          width={width}\n          height={totalHeightSvg}\n          xmlns=\"http://www.w3.org/2000/svg\"\n          xmlnsXlink=\"http://www.w3.org/1999/xlink\"\n          viewBox={[0, 0, w + shift * 2, totalHeightSvg].toString()}\n        >\n          <SVGBackground width={w} height={totalHeightSvg} shift={shift} />\n          <g transform={`translate(${shift} ${fontSize})`}>\n            <g transform={`translate(${trackLabelOffset})`}>\n              <text x={0} fontSize={fontSize} fill={t.palette.text.primary}>\n                {views[0].assemblyNames.join(', ')}\n              </text>\n\n              <SVGRuler model={displayResults[0].view} fontSize={fontSize} />\n            </g>\n            <SVGTracks\n              textHeight={textHeight}\n              trackLabels={trackLabels}\n              fontSize={fontSize}\n              model={displayResults[0].view}\n              displayResults={displayResults[0].data}\n              offset={offset}\n              trackLabelOffset={trackLabelOffset}\n            />\n          </g>\n\n          <g transform={`translate(${shift} ${fontSize + heights[0]})`}>\n            <g transform={`translate(${trackLabelOffset})`}>\n              <text x={0} fontSize={fontSize} fill={t.palette.text.primary}>\n                {views[1].assemblyNames.join(', ')}\n              </text>\n              <SVGRuler model={displayResults[1].view} fontSize={fontSize} />\n            </g>\n            <SVGTracks\n              textHeight={textHeight}\n              trackLabels={trackLabels}\n              fontSize={fontSize}\n              model={displayResults[1].view}\n              displayResults={displayResults[1].data}\n              offset={offset}\n              trackLabelOffset={trackLabelOffset}\n            />\n          </g>\n\n          <defs>\n            <clipPath id=\"clip-bsv\">\n              <rect x={0} y={0} width={width} height={totalHeightSvg} />\n            </clipPath>\n          </defs>\n          <g\n            transform={`translate(${trackLabelOffset + shift})`}\n            clipPath=\"url(#clip-bsv)\"\n          >\n            {model.matchedTracks.map(track => (\n              <Overlay\n                parentRef={{ current: null }}\n                key={track.configuration.trackId}\n                model={model}\n                trackId={track.configuration.trackId}\n                getTrackYPosOverride={(id, level) => trackOffsets[level][id]}\n              />\n            ))}\n          </g>\n        </svg>\n      </Wrapper>\n    </ThemeProvider>,\n    createRootFn,\n  )\n}\n"],"names":["getTag","f","tag","tags","get","findMatchingAlt","feat1","feat2","alts","Map","map","alt","parseBreakend","filter","notEmpty","bnd","MatePosition","LEFT","RIGHT","observer","model","trackId","parentRef","getTrackYPosOverride","views","showIntraviewLinks","theme","useTheme","session","getSession","snap","getSnapshot","assemblyManager","assembly","assemblyNames","useNextFrame","allFeatures","getTrackFeatures","hasPaired","useMemo","features","values","hasPairedReads","r","g","a","colord","palette","text","disabled","rgba","layoutMatches","getMatchedFeaturesInLayout","candidates","alreadySeen","Set","feature","flags","id","unmapped","correctlyPaired","has","n","val","set","push","add","v","length","getBadlyPairedAlignments","hasSA","getMatchedAlignmentFeatures","forEach","m","sort","b","mouseoverElt","setMouseoverElt","useState","yOffset","current","rect","getBoundingClientRect","top","React","fill","stroke","strokeOpacity","chunk","ret","i","layout","c1","f1","level","level1","c2","f2","level2","console","warn","f1ref","getCanonicalRefName","f2ref","Error","s1","s2","p1","sn1","p2","x1","getPxFromCoordinate","x2","reversed1","pxToBp","reversed","reversed2","tracks","getTrack","y1","yPos","y2","path","join","d","key","strokeWidth","onClick","featureWidget","addWidget","featureData","feature1","toJSON","feature2","showWidget","onMouseOver","onMouseOut","undefined","ref","totalFeatures","feats","cur","getMatchedBreakendFeatures","yoff","relevantAlt","f1origref","f2origref","Join","MateDirection","JSON","stringify","str","s","getMatchedTranslocationFeatures","info","chr2","CHR2","end2","END","res","STRANDS","split","myDirection","mateDirection","props","getMatchedTracks","type","AlignmentConnections","hasTranslocations","Translocations","Breakends","SVGBackground","width","height","shift","stripAlpha","background","default","getTrackOffsets","view","textOffset","extra","offsets","curr","track","configuration","displays","async","renderToSvg","opts","textHeight","headerHeight","rulerHeight","fontSize","trackLabels","Wrapper","children","themeName","createRootFn","getRoot","allThemes","offset","heights","totalHeight","totalHeightSvg","sum","displayResults","Promise","all","data","when","ready","result","renderSvg","trackLabelMaxLen","max","flatMap","t","measureText","getTrackName","getTrackNameMaxLen","trackLabelOffset","trackOffsets","w","createJBrowseTheme","renderToStaticMarkup","ThemeProvider","xmlns","xmlnsXlink","viewBox","toString","transform","x","primary","SVGRuler","SVGTracks","y","clipPath","matchedTracks","Overlay"],"sourceRoot":""}