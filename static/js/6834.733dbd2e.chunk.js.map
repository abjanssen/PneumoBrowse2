{"version":3,"file":"static/js/6834.733dbd2e.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BigBedAdapter/BigBedAdapter.ts","../../../plugins/bed/src/generateRepeatMaskerFeature.ts","../../../plugins/bed/src/util.ts","../../../plugins/bed/src/generateBedMethylFeature.ts","../../../plugins/bed/src/generateUcscTranscript.ts"],"sourcesContent":["import { BigBed } from '@gmod/bbi'\nimport BED from '@gmod/bed'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  SimpleFeature,\n  doesIntersect2,\n  max,\n  min,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { firstValueFrom, toArray } from 'rxjs'\n\nimport { featureData2 } from '../util'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\nimport type { Region } from '@jbrowse/core/util/types'\nimport type { Observer } from 'rxjs'\n\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n  private cachedP?: Promise<{\n    bigbed: BigBed\n    header: Awaited<ReturnType<BigBed['getHeader']>>\n    parser: BED\n  }>\n\n  public async configurePre(opts?: BaseOptions) {\n    const pm = this.pluginManager\n    const bigbed = new BigBed({\n      filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n    })\n    const header = await bigbed.getHeader(opts)\n    const parser = new BED({\n      autoSql: header.autoSql,\n    })\n    return {\n      bigbed,\n      header,\n      parser,\n    }\n  }\n\n  public async configure(opts?: BaseOptions) {\n    if (!this.cachedP) {\n      this.cachedP = this.configurePre(opts).catch((e: unknown) => {\n        this.cachedP = undefined\n        throw e\n      })\n    }\n    return this.cachedP\n  }\n\n  public async getRefNames(opts?: BaseOptions) {\n    const { header } = await this.configure(opts)\n    return Object.keys(header.refsByName)\n  }\n\n  // allow using BigBedAdapter for aliases with chromAlias.bb file from UCSC\n  public async getRefNameAliases(opts?: BaseOptions) {\n    const { header } = await this.configure(opts)\n    const ret = await Promise.all(\n      Object.keys(header.refsByName).map(\n        async r =>\n          (\n            await firstValueFrom(\n              this.getFeatures({\n                assemblyName: '',\n                refName: r,\n                start: 0,\n                end: 1,\n              }).pipe(toArray()),\n            )\n          )[0]!,\n      ),\n    )\n    return ret\n      .map(r => r.toJSON())\n      .map(r => ({\n        refName: r.ucsc,\n        aliases: [r.ncbi, r.refseq, r.genbank],\n        override: true,\n      }))\n  }\n\n  public async getData() {\n    const refNames = await this.getRefNames()\n    const features = []\n    for (const refName of refNames) {\n      const f = await firstValueFrom(\n        this.getFeatures({\n          assemblyName: 'unknown',\n          refName,\n          start: 0,\n          end: Number.MAX_SAFE_INTEGER,\n        }).pipe(toArray()),\n      )\n      features.push(f)\n    }\n    return features.flat()\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { parser, header } = await this.configure(opts)\n    const { version, fileType } = header\n    const { fields, ...rest } = parser.autoSql\n    return {\n      version,\n      fileType,\n      autoSql: { ...rest },\n      fields: Object.fromEntries(\n        fields.map(({ name, comment }) => [name, comment]),\n      ),\n    }\n  }\n\n  public async getFeaturesHelper({\n    query,\n    opts,\n    observer,\n    allowRedispatch,\n    originalQuery = query,\n  }: {\n    query: Region\n    opts: BaseOptions\n    observer: Observer<Feature>\n    allowRedispatch: boolean\n    originalQuery?: Region\n  }) {\n    const { statusCallback = () => {} } = opts\n    const scoreColumn = this.getConf('scoreColumn')\n    const aggregateField = this.getConf('aggregateField')\n    const { parser, bigbed } = await updateStatus(\n      'Downloading header',\n      statusCallback,\n      () => this.configure(opts),\n    )\n    const feats = await updateStatus(\n      'Downloading features',\n      statusCallback,\n      () =>\n        bigbed.getFeatures(query.refName, query.start, query.end, {\n          basesPerSpan: query.end - query.start,\n        }),\n    )\n\n    if (allowRedispatch && feats.length) {\n      let minStart = Number.POSITIVE_INFINITY\n      let maxEnd = Number.NEGATIVE_INFINITY\n      let hasAnyAggregationField = false\n      for (const feat of feats) {\n        if (feat.start < minStart) {\n          minStart = feat.start\n        }\n        if (feat.end > maxEnd) {\n          maxEnd = feat.end\n        }\n        // @ts-expect-error\n        if (feat[aggregateField]) {\n          hasAnyAggregationField = true\n        }\n      }\n\n      if (\n        hasAnyAggregationField &&\n        (maxEnd > query.end || minStart < query.start)\n      ) {\n        await this.getFeaturesHelper({\n          query: {\n            ...query,\n            // re-query with 500kb added onto start and end, in order to catch\n            // gene subfeatures that may not overlap your view\n            start: minStart - 500_000,\n            end: maxEnd + 500_000,\n          },\n          opts,\n          observer,\n          allowRedispatch: false,\n          originalQuery: query,\n        })\n        return\n      }\n    }\n\n    const parentAggregation = {} as Record<string, SimpleFeatureSerialized[]>\n\n    if (feats.some(f => f.uniqueId === undefined)) {\n      throw new Error('found uniqueId undefined')\n    }\n    for (const feat of feats) {\n      const splitLine = [\n        query.refName,\n        `${feat.start}`,\n        `${feat.end}`,\n        ...(feat.rest?.split('\\t') || []),\n      ]\n      const data = parser.parseLine(splitLine, {\n        uniqueId: feat.uniqueId!,\n      })\n\n      const aggr = data[aggregateField]\n      if (!parentAggregation[aggr]) {\n        parentAggregation[aggr] = []\n      }\n      const {\n        uniqueId,\n        type,\n        chrom,\n        chromStart,\n        chromEnd,\n        description,\n        chromStarts: chromStarts2,\n        blockStarts: blockStarts2,\n        blockSizes: blockSizes2,\n        score: score2,\n        blockCount,\n        thickStart,\n        thickEnd,\n        strand,\n        ...rest\n      } = data\n\n      const f = featureData2({\n        ...rest,\n        scoreColumn,\n        splitLine,\n        parser,\n        uniqueId,\n        start: feat.start,\n        end: feat.end,\n        refName: query.refName,\n      })\n      if (aggr) {\n        parentAggregation[aggr].push(f)\n      } else {\n        if (\n          doesIntersect2(f.start, f.end, originalQuery.start, originalQuery.end)\n        ) {\n          observer.next(\n            new SimpleFeature({\n              id: `${this.id}-${uniqueId}`,\n              data: f,\n            }),\n          )\n        }\n      }\n    }\n\n    Object.entries(parentAggregation).map(([name, subfeatures]) => {\n      const s = min(subfeatures.map(f => f.start))\n      const e = max(subfeatures.map(f => f.end))\n      if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n        const subs = subfeatures.sort((a, b) =>\n          a.uniqueId.localeCompare(b.uniqueId),\n        )\n        observer.next(\n          new SimpleFeature({\n            id: `${this.id}-${subs[0]?.uniqueId}-parent`,\n            data: {\n              type: 'gene',\n              subfeatures: subs,\n              strand: subs[0]?.strand || 1,\n              name,\n              start: s,\n              end: e,\n              refName: query.refName,\n            },\n          }),\n        )\n      }\n    })\n    observer.complete()\n  }\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        await this.getFeaturesHelper({\n          query: {\n            ...query,\n            start: query.start,\n            end: query.end,\n          },\n          opts,\n          observer,\n          allowRedispatch: true,\n        })\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n\n  public freeResources(): void {}\n}\n","export function isRepeatMaskerDescriptionField(desc?: string): desc is string {\n  const ret = desc?.trim().split(' ')\n  return [0, 1, 2, 3, 5, 6].every(s =>\n    ret?.[s] !== undefined ? !Number.isNaN(+ret[s]) : false,\n  )\n}\n\nfunction makeRepeatTrackDescription(description?: string) {\n  if (isRepeatMaskerDescriptionField(description)) {\n    const [\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    ] = description.trim().split(' ')\n    return {\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    }\n  }\n  return { description }\n}\n\nexport function generateRepeatMaskerFeature({\n  uniqueId,\n  refName,\n  start,\n  end,\n  description,\n  ...rest\n}: {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  description: string\n  [key: string]: unknown\n}) {\n  const { subfeatures, ...rest2 } = rest\n  return {\n    ...rest2,\n    ...makeRepeatTrackDescription(description),\n    uniqueId,\n    refName,\n    start,\n    end,\n  }\n}\n","import {\n  generateBedMethylFeature,\n  isBedMethylFeature,\n} from './generateBedMethylFeature'\nimport {\n  generateRepeatMaskerFeature,\n  isRepeatMaskerDescriptionField,\n} from './generateRepeatMaskerFeature'\nimport {\n  generateUcscTranscript,\n  isUcscTranscript,\n} from './generateUcscTranscript'\n\nimport type BED from '@gmod/bed'\n\nfunction defaultParser(fields: string[], splitLine: string[]) {\n  let hasBlockCount = false\n  const r = [] as [string, string][]\n\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let i = 0; i < splitLine.length; i++) {\n    if (fields[i] === 'blockCount') {\n      hasBlockCount = true\n    }\n    r.push([fields[i]!, splitLine[i]!] as const)\n  }\n  // heuristically try to determine whether to follow 'slow path' as there can\n  // be many features in e.g. GWAS type data\n  const obj = Object.fromEntries(r)\n  // slow path\n  if (hasBlockCount) {\n    const {\n      blockStarts,\n      blockCount,\n      chromStarts,\n      thickEnd,\n      thickStart,\n      blockSizes,\n      ...rest\n    } = obj\n\n    return {\n      ...rest,\n      blockStarts: arrayify(blockStarts),\n      chromStarts: arrayify(chromStarts),\n      blockSizes: arrayify(blockSizes),\n      thickStart: thickStart ? +thickStart : undefined,\n      thickEnd: thickEnd ? +thickEnd : undefined,\n      blockCount: blockCount ? +blockCount : undefined,\n    } as Record<string, unknown>\n  }\n\n  // fast path\n  else {\n    return obj\n  }\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes?: number[]\n  blockStarts?: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts || blockStarts || []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] || 0) + start\n    const bsize = blockSizes?.[b]\n    if (bsize && bsize > 0) {\n      const bmax = bmin + bsize\n      subfeatures.push({\n        uniqueId: `${uniqueId}-${b}`,\n        start: bmin,\n        end: bmax,\n        refName,\n        type: 'block',\n      })\n    }\n  }\n  return subfeatures\n}\n\nexport function featureData({\n  line,\n  colRef,\n  colStart,\n  colEnd,\n  scoreColumn,\n  parser,\n  uniqueId,\n  names,\n}: {\n  line: string\n  colRef: number\n  colStart: number\n  colEnd: number\n  scoreColumn: string\n  parser: BED\n  uniqueId: string\n  names?: string[]\n}) {\n  const splitLine = line.split('\\t')\n  const refName = splitLine[colRef]!\n  const start = Number.parseInt(splitLine[colStart]!, 10)\n  const end =\n    Number.parseInt(splitLine[colEnd]!, 10) + (colStart === colEnd ? 1 : 0)\n\n  return featureData2({\n    splitLine,\n    refName,\n    start,\n    end,\n    parser,\n    uniqueId,\n    scoreColumn,\n    names,\n  })\n}\n\nexport function featureData2({\n  splitLine,\n  refName,\n  start,\n  end,\n  parser,\n  uniqueId,\n  scoreColumn,\n  names,\n}: {\n  splitLine: string[]\n  refName: string\n  start: number\n  end: number\n  parser: BED\n  uniqueId: string\n  scoreColumn: string\n  names?: string[]\n}) {\n  const data = names\n    ? defaultParser(names, splitLine)\n    : parser.parseLine(splitLine, { uniqueId })\n  const {\n    strand: strand2,\n    score: score2,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n\n  const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined\n  const strand =\n    typeof strand2 === 'string' ? (strand2 === '-' ? -1 : 1) : strand2\n\n  const subfeatures = rest.blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts: rest.chromStarts,\n        blockCount: rest.blockCount,\n        blockSizes: rest.blockSizes,\n        blockStarts: rest.blockStarts,\n      })\n    : undefined\n\n  if (isBedMethylFeature({ splitLine, start, end })) {\n    return generateBedMethylFeature({\n      splitLine,\n      uniqueId,\n      refName,\n      start,\n      end,\n    })\n  } else if (isRepeatMaskerDescriptionField(rest.description)) {\n    const {\n      chromStarts,\n      blockSizes,\n      blockStarts,\n      type,\n      blockCount,\n      thickStart,\n      thickEnd,\n      description,\n      ...rest2\n    } = rest\n    return generateRepeatMaskerFeature({\n      ...rest2,\n      uniqueId,\n      description,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    })\n  } else if (\n    subfeatures &&\n    isUcscTranscript({\n      strand,\n      blockCount: rest.blockCount,\n      thickStart: rest.thickStart,\n    })\n  ) {\n    const {\n      chromStarts,\n      blockSizes,\n      type,\n      blockCount,\n      thickStart,\n      thickEnd,\n      description,\n    } = rest\n    return generateUcscTranscript({\n      ...rest,\n      description,\n      chromStarts,\n      thickStart,\n      thickEnd,\n      blockSizes,\n      blockCount,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      uniqueId,\n      subfeatures,\n    })\n  } else {\n    return {\n      ...rest,\n      uniqueId,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    }\n  }\n}\n\nexport function arrayify(f?: string | number[]) {\n  return f !== undefined\n    ? typeof f === 'string'\n      ? f.split(',').map(f => +f)\n      : f\n    : undefined\n}\n","// this uses modkit bedMethyl. unclear how to reliably detect minimal 9+2 bedMethyl\nexport function isBedMethylFeature({\n  splitLine,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  start: number\n  end: number\n}) {\n  return (\n    +(splitLine[6] || 0) === start &&\n    +(splitLine[7] || 0) === end &&\n    [9, 10, 11, 12, 13, 14, 15, 16, 17].every(\n      r => splitLine[r] && !Number.isNaN(+splitLine[r]),\n    )\n  )\n}\n\nexport function generateBedMethylFeature({\n  splitLine,\n  uniqueId,\n  refName,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n}) {\n  // see\n  // https://github.com/nanoporetech/modkit?tab=readme-ov-file#description-of-bedmethyl-output\n  const [\n    ,\n    ,\n    ,\n    code,\n    ,\n    strand,\n    ,\n    ,\n    color,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  ] = splitLine\n\n  return {\n    uniqueId,\n    refName,\n    start,\n    end,\n    code,\n    score: +fraction_modified! || 0,\n    strand,\n    color,\n    source: code,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  }\n}\n","import type { MinimalFeature, TranscriptFeat } from './types'\n\nexport function isUcscTranscript({\n  thickStart,\n  blockCount,\n  strand,\n}: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return thickStart && blockCount && strand !== 0\n}\n\nexport function generateUcscTranscript(data: TranscriptFeat) {\n  const {\n    strand = 0,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    chromStarts,\n    blockStarts,\n    blockSizes,\n    uniqueId,\n    ...rest\n  } = data\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    refName,\n    ...rest2\n  } = rest\n\n  const subfeatures: MinimalFeature[] = []\n  const feats = oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n\n  for (const block of feats) {\n    const start = block.start\n    const end = block.end\n    if (thickStart >= end) {\n      // left-side UTR\n      subfeatures.push({\n        type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n        start,\n        end,\n        refName,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n      // UTR | CDS\n      subfeatures.push(\n        {\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end: thickStart,\n          refName,\n        },\n        {\n          type: 'CDS',\n          phase: 0,\n          start: thickStart,\n          end,\n          refName,\n        },\n      )\n    } else if (thickStart <= start && thickEnd >= end) {\n      // CDS\n      subfeatures.push({\n        type: 'CDS',\n        phase: 0,\n        start,\n        end,\n        refName,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd < end) {\n      // UTR | CDS | UTR\n      subfeatures.push(\n        {\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end: thickStart,\n          refName,\n        },\n        {\n          type: 'CDS',\n          phase: 0,\n          start: thickStart,\n          end: thickEnd,\n          refName,\n        },\n        {\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start: thickEnd,\n          end,\n          refName,\n        },\n      )\n    } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n      // CDS | UTR\n      subfeatures.push(\n        {\n          type: 'CDS',\n          phase: 0,\n          start,\n          end: thickEnd,\n          refName,\n        },\n        {\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start: thickEnd,\n          end,\n          refName,\n        },\n      )\n    } else if (thickEnd <= start) {\n      // right-side UTR\n      subfeatures.push({\n        type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n        start,\n        end,\n        refName,\n      })\n    }\n  }\n\n  return {\n    ...rest2,\n    uniqueId,\n    strand,\n    type: 'mRNA',\n    refName,\n    subfeatures,\n  }\n}\n"],"names":["BigBedAdapter","BaseFeatureDataAdapter","configurePre","opts","pm","this","pluginManager","bigbed","BigBed","filehandle","openLocation","getConf","header","getHeader","parser","BED","autoSql","configure","cachedP","catch","e","undefined","getRefNames","Object","keys","refsByName","getRefNameAliases","Promise","all","map","async","firstValueFrom","getFeatures","assemblyName","refName","r","start","end","pipe","toArray","toJSON","ucsc","aliases","ncbi","refseq","genbank","override","getData","refNames","features","f","Number","MAX_SAFE_INTEGER","push","flat","version","fileType","fields","rest","fromEntries","name","comment","getFeaturesHelper","query","observer","allowRedispatch","originalQuery","statusCallback","scoreColumn","aggregateField","updateStatus","feats","basesPerSpan","length","minStart","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","hasAnyAggregationField","feat","parentAggregation","some","uniqueId","Error","splitLine","split","data","parseLine","aggr","type","chrom","chromStart","chromEnd","description","chromStarts","chromStarts2","blockStarts","blockStarts2","blockSizes","blockSizes2","score","score2","blockCount","thickStart","thickEnd","strand","featureData2","doesIntersect2","next","SimpleFeature","id","entries","subfeatures","s","min","max","subs","sort","a","b","localeCompare","complete","ObservableCreate","error","stopToken","freeResources","isRepeatMaskerDescriptionField","desc","ret","trim","every","isNaN","makeRepeatTrackDescription","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","featureData","line","colRef","colStart","colEnd","names","parseInt","hasBlockCount","i","obj","arrayify","defaultParser","strand2","_1","_2","_3","starts","bmin","bsize","bmax","makeBlocks","isBedMethylFeature","code","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","source","generateBedMethylFeature","rest2","generateRepeatMaskerFeature","isUcscTranscript","oldSubfeatures","filter","child","block","phase","generateUcscTranscript"],"sourceRoot":""}