{"version":3,"file":"static/js/9409.7d2e575e.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/MCScanSimpleAnchorsAdapter/MCScanSimpleAnchorsAdapter.ts","../../../plugins/comparative-adapters/src/util.ts"],"sourcesContent":["import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { doesIntersect2 } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\n\nimport { parseBed, readFile } from '../util'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { Region } from '@jbrowse/core/util/types'\n\ninterface BareFeature {\n  refName: string\n  start: number\n  end: number\n  score: number\n  name: string\n}\n\ntype Row = [\n  BareFeature,\n  BareFeature,\n  BareFeature,\n  BareFeature,\n  number,\n  number,\n  number,\n]\n\nexport default class MCScanAnchorsAdapter extends BaseFeatureDataAdapter {\n  private setupP?: Promise<{\n    assemblyNames: string[]\n    feats: Row[]\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  async setup(opts: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n  async setupPre(opts: BaseOptions) {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    const pm = this.pluginManager\n    const bed1 = openLocation(this.getConf('bed1Location'), pm)\n    const bed2 = openLocation(this.getConf('bed2Location'), pm)\n    const mcscan = openLocation(this.getConf('mcscanSimpleAnchorsLocation'), pm)\n    const [bed1text, bed2text, mcscantext] = await Promise.all(\n      [bed1, bed2, mcscan].map(r => readFile(r, opts)),\n    )\n    const bed1Map = parseBed(bed1text!)\n    const bed2Map = parseBed(bed2text!)\n    const feats = mcscantext!\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f && f !== '###')\n      .map((line, index) => {\n        const [n11, n12, n21, n22, score, strand] = line.split('\\t')\n        const r11 = bed1Map.get(n11)\n        const r12 = bed1Map.get(n12)\n        const r21 = bed2Map.get(n21)\n        const r22 = bed2Map.get(n22)\n        if (!r11 || !r12 || !r21 || !r22) {\n          throw new Error(\n            `feature not found, ${n11} ${n12} ${n21} ${n22} ${r11} ${r12} ${r21} ${r22}`,\n          )\n        }\n        return [\n          r11,\n          r12,\n          r21,\n          r22,\n          +score!,\n          strand === '-' ? -1 : 1,\n          index,\n        ] as Row\n      })\n\n    return {\n      assemblyNames,\n      feats,\n    }\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures\n    // so is not really that important, and has to be true or else\n    // getFeatures is never called (BaseFeatureDataAdapter filters it out)\n    return true\n  }\n\n  getAssemblyNames() {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    return assemblyNames\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    // @ts-expect-error\n    const r1 = opts.regions?.[0].assemblyName\n    const { feats } = await this.setup(opts)\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    if (idx !== -1) {\n      const set = new Set<string>()\n      for (const feat of feats) {\n        if (idx === 0) {\n          set.add(feat[0].refName)\n          set.add(feat[1].refName)\n        } else {\n          set.add(feat[2].refName)\n          set.add(feat[3].refName)\n        }\n      }\n      return [...set]\n    }\n    console.warn('Unable to do ref renaming on adapter')\n    return []\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { assemblyNames, feats } = await this.setup(opts)\n\n      // The index of the assembly name in the region list corresponds to\n      // the adapter in the subadapters list\n      const index = assemblyNames.indexOf(region.assemblyName)\n      if (index !== -1) {\n        const flip = index === 0\n        feats.forEach(f => {\n          const [f11, f12, f21, f22, score, strand, rowNum] = f\n          let r1 = {\n            refName: f11.refName,\n            start: Math.min(f11.start, f12.start),\n            end: Math.max(f11.end, f12.end),\n          }\n          let r2 = {\n            refName: f21.refName,\n            start: Math.min(f21.start, f22.start),\n            end: Math.max(f21.end, f22.end),\n          }\n          if (!flip) {\n            ;[r2, r1] = [r1, r2]\n          }\n          if (\n            r1.refName === region.refName &&\n            doesIntersect2(r1.start, r1.end, region.start, region.end)\n          ) {\n            observer.next(\n              new SimpleFeature({\n                ...r1,\n                uniqueId: `${rowNum}`,\n                syntenyId: rowNum,\n                assemblyName: assemblyNames[+!flip],\n                score,\n                strand,\n                mate: {\n                  ...r2,\n                  assemblyName: assemblyNames[+flip],\n                },\n              }),\n            )\n          }\n        })\n      }\n\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n  freeResources(/* { region } */): void {}\n}\n","import { fetchAndMaybeUnzipText } from '@jbrowse/core/util'\n\nimport type { PAFRecord } from './PAFAdapter/util'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f || f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start!,\n            end: +end!,\n            score: +score!,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  return fetchAndMaybeUnzipText(file, opts)\n}\n\nexport function zip(a: number[], b: number[]) {\n  return a.map((e, i) => [e, b[i]] as [number, number])\n}\n\nexport function parseLineByLine<T>(\n  buffer: Uint8Array,\n  cb: (line: string) => T | undefined,\n  opts?: BaseOptions,\n): T[] {\n  const { statusCallback = () => {} } = opts || {}\n  let blockStart = 0\n  const entries: T[] = []\n  const decoder = new TextDecoder('utf8')\n\n  let i = 0\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    if (n === -1) {\n      break\n    }\n    const b = buffer.subarray(blockStart, n)\n    const line = decoder.decode(b).trim()\n    if (line) {\n      const entry = cb(line)\n      if (entry) {\n        entries.push(entry)\n      }\n    }\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${Math.floor(blockStart / 1_000_000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1_000_000).toLocaleString('en-US')} MB`,\n      )\n    }\n    blockStart = n + 1\n  }\n  return entries\n}\n\nexport function parsePAFLine(line: string) {\n  const parts = line.split('\\t')\n  const extraFields = parts.slice(12)\n  const extra: Record<string, string | number> = {\n    numMatches: +parts[9]!,\n    blockLen: +parts[10]!,\n    mappingQual: +parts[11]!,\n  }\n\n  // Process extra fields only if they exist\n  if (extraFields.length) {\n    for (const field of extraFields) {\n      const colonIndex = field.indexOf(':')\n      extra[field.slice(0, colonIndex)] = field.slice(colonIndex + 3)\n    }\n  }\n\n  return {\n    tname: parts[5],\n    tstart: +parts[7]!,\n    tend: +parts[8]!,\n    qname: parts[0],\n    qstart: +parts[2]!,\n    qend: +parts[3]!,\n    strand: parts[4] === '-' ? -1 : 1,\n    extra,\n  } as PAFRecord\n}\n\nexport function flipCigar(cigar: string[]) {\n  const arr = []\n  for (let i = cigar.length - 2; i >= 0; i -= 2) {\n    arr.push(cigar[i])\n    const op = cigar[i + 1]\n    if (op === 'D') {\n      arr.push('I')\n    } else if (op === 'I') {\n      arr.push('D')\n    } else {\n      arr.push(op)\n    }\n  }\n  return arr\n}\n\nexport function swapIndelCigar(cigar: string) {\n  return cigar.replaceAll('D', 'K').replaceAll('I', 'D').replaceAll('K', 'I')\n}\n"],"names":["MCScanAnchorsAdapter","BaseFeatureDataAdapter","setup","opts","this","setupP","setupPre","catch","e","undefined","assemblyNames","getConf","pm","pluginManager","bed1","openLocation","bed2","mcscan","bed1text","bed2text","mcscantext","Promise","all","map","r","readFile","bed1Map","parseBed","bed2Map","feats","split","filter","f","line","index","n11","n12","n21","n22","score","strand","r11","get","r12","r21","r22","Error","hasDataForRefName","getAssemblyNames","getRefNames","r1","regions","assemblyName","idx","indexOf","set","Set","feat","add","refName","console","warn","getFeatures","region","ObservableCreate","async","flip","forEach","f11","f12","f21","f22","rowNum","start","Math","min","end","max","r2","doesIntersect2","observer","next","SimpleFeature","uniqueId","syntenyId","mate","complete","freeResources","text","Map","startsWith","name","file","fetchAndMaybeUnzipText","zip","a","b","i","parseLineByLine","buffer","cb","statusCallback","blockStart","entries","decoder","TextDecoder","length","n","subarray","decode","trim","entry","push","floor","toLocaleString","parsePAFLine","parts","extraFields","slice","extra","numMatches","blockLen","mappingQual","field","colonIndex","tname","tstart","tend","qname","qstart","qend","flipCigar","cigar","arr","op","swapIndelCigar","replaceAll"],"sourceRoot":""}