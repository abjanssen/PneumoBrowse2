{"version":3,"file":"static/js/8701.2220c755.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/MultiLinearVariantMatrixRenderer/components/MultiLinearVariantMatrixRendering.tsx","../../../plugins/variants/src/VcfFeature/util.ts"],"sourcesContent":["import { useCallback, useRef } from 'react'\n\nimport { PrerenderedCanvas } from '@jbrowse/core/ui'\nimport { getBpDisplayStr } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\n\nimport { makeSimpleAltString } from '../../VcfFeature/util.ts'\n\nimport type { MultiVariantBaseModel } from '../../shared/MultiVariantBaseModel.ts'\n\ninterface FeatureData {\n  alt: string[]\n  ref: string\n  name: string\n  description: string\n  length: number\n}\n\ninterface SimplifiedFeature {\n  uniqueId: string\n}\n\ninterface RenderingProps {\n  onFeatureClick?: (event: React.MouseEvent, featureId: string) => void\n}\n\nconst MultiLinearVariantMatrixRendering = observer(\n  function MultiLinearVariantMatrixRendering(props: {\n    width: number\n    height: number\n    displayModel: MultiVariantBaseModel\n    arr: string[][]\n    featureData: FeatureData[]\n    rowHeight: number\n    origScrollTop: number\n    totalHeight: number\n    simplifiedFeatures?: SimplifiedFeature[]\n    renderingProps?: RenderingProps\n  }) {\n    const {\n      arr,\n      width,\n      displayModel,\n      featureData,\n      totalHeight,\n      origScrollTop,\n      rowHeight,\n      simplifiedFeatures,\n      renderingProps,\n    } = props\n    const ref = useRef<HTMLDivElement>(null)\n    const lastHoveredRef = useRef<string | undefined>(undefined)\n\n    const getFeatureUnderMouse = useCallback(\n      (eventClientX: number, eventClientY: number) => {\n        if (!ref.current) {\n          return\n        }\n        const r = ref.current.getBoundingClientRect()\n        const offsetX = eventClientX - r.left\n        const offsetY = eventClientY - r.top\n\n        const { sources } = displayModel\n\n        // Canvas is positioned at top=origScrollTop, so adjust mouse position\n        // relative to canvas top\n        const canvasOffsetY = offsetY - origScrollTop\n        // The first row in the canvas corresponds to source at index startRow\n        const startRow = Math.floor(origScrollTop / rowHeight)\n        const visibleRowIdx = Math.floor(canvasOffsetY / rowHeight)\n        const sourceIdx = startRow + visibleRowIdx\n        const name = sources?.[sourceIdx]?.name\n        const featureIdx = Math.floor((offsetX / width) * arr.length)\n        const genotype = arr[featureIdx]?.[visibleRowIdx]\n        const feature = featureData[featureIdx]\n\n        if (genotype && name && feature) {\n          const { ref, alt, name: featureName, description, length } = feature\n          const alleles = makeSimpleAltString(genotype, ref, alt)\n          return {\n            name,\n            genotype,\n            alleles,\n            featureName,\n            description: alt.length >= 3 ? 'multiple ALT alleles' : description,\n            length: getBpDisplayStr(length),\n          }\n        }\n        return undefined\n      },\n      [arr, width, displayModel, featureData, origScrollTop, rowHeight],\n    )\n\n    const handleMouseMove = useCallback(\n      (e: React.MouseEvent) => {\n        const result = getFeatureUnderMouse(e.clientX, e.clientY)\n        const key = result ? `${result.name}:${result.genotype}` : undefined\n        if (key !== lastHoveredRef.current) {\n          lastHoveredRef.current = key\n          displayModel.setHoveredGenotype(result)\n        }\n      },\n      [getFeatureUnderMouse, displayModel],\n    )\n\n    const handleMouseLeave = useCallback(() => {\n      if (lastHoveredRef.current !== undefined) {\n        lastHoveredRef.current = undefined\n        displayModel.setHoveredGenotype(undefined)\n      }\n    }, [displayModel])\n\n    const handleClick = useCallback(\n      (e: React.MouseEvent) => {\n        if (!ref.current || !simplifiedFeatures) {\n          return\n        }\n        const r = ref.current.getBoundingClientRect()\n        const offsetX = e.clientX - r.left\n        const featureIdx = Math.floor((offsetX / width) * arr.length)\n        const feature = simplifiedFeatures[featureIdx]\n        if (feature) {\n          renderingProps?.onFeatureClick?.(e, feature.uniqueId)\n        }\n      },\n      [arr.length, width, simplifiedFeatures, renderingProps],\n    )\n\n    return (\n      <div\n        ref={ref}\n        onMouseMove={handleMouseMove}\n        onMouseLeave={handleMouseLeave}\n        onMouseOut={handleMouseLeave}\n        onClick={handleClick}\n        style={{\n          overflow: 'visible',\n          position: 'relative',\n          height: totalHeight,\n        }}\n      >\n        <PrerenderedCanvas\n          {...props}\n          style={{\n            position: 'absolute',\n            left: 0,\n            top: origScrollTop,\n          }}\n        />\n      </div>\n    )\n  },\n)\n\nexport default MultiLinearVariantMatrixRendering\n","import { parseBreakend } from '@gmod/vcf'\nimport { getBpDisplayStr } from '@jbrowse/core/util'\n\nimport type VCF from '@gmod/vcf'\n\nconst genotypeDelimRegex = /[/|]/\n\nfunction isBreakend(alt: string) {\n  return (\n    alt.includes('[') ||\n    alt.includes(']') ||\n    alt.startsWith('.') ||\n    alt.endsWith('.')\n  )\n}\n\nfunction isSymbolic(alt: string) {\n  return alt.startsWith('<') || isBreakend(alt)\n}\n\nfunction isInversion(ref: string, alt: string) {\n  return ref.split('').reverse().join('') === alt\n}\n\nconst altTypeToSO: Record<string, string> = {\n  '<DEL>': 'deletion',\n  '<INS>': 'insertion',\n  '<DUP>': 'duplication',\n  '<INV>': 'inversion',\n  '<INVDUP>': 'inverted_duplication',\n  '<CNV>': 'copy_number_variation',\n  '<TRA>': 'translocation',\n  '<DUP:TANDEM>': 'tandem_duplication',\n  '<NON_REF>': 'sequence_variant',\n  '<*>': 'sequence_variant',\n}\n\nexport function getSOTermAndDescription(\n  ref: string,\n  alt: string[] | undefined,\n  parser: VCF,\n): string[] {\n  if (!alt || alt.length === 0) {\n    return ['remark', 'no alternative alleles']\n  }\n\n  const soTerms = alt.map(a => getSOTerm(a, ref, parser))\n  const uniqueSoTerms = [...new Set(soTerms)]\n  const description = formatGroupDescription(ref, alt)\n\n  return [uniqueSoTerms.join(','), description]\n}\n\nfunction getSOTerm(alt: string, ref: string, parser: VCF): string {\n  // Symbolic alleles\n  if (alt.startsWith('<')) {\n    return findSOTerm(alt, parser) ?? 'variant'\n  }\n\n  // Breakends\n  if (isBreakend(alt) && parseBreakend(alt)) {\n    return 'breakend'\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n\n  if (lenRef === 1 && lenAlt === 1) {\n    return 'SNV'\n  } else if (lenRef === lenAlt) {\n    return isInversion(ref, alt) ? 'inversion' : 'substitution'\n  } else {\n    return lenRef < lenAlt ? 'insertion' : 'deletion'\n  }\n}\n\nfunction formatGroupDescription(ref: string, alts: string[]): string {\n  if (alts.every(isSymbolic)) {\n    return alts.join(',')\n  }\n\n  const lenRef = ref.length\n\n  return `${ref.length > 10 ? getBpDisplayStr(lenRef) : ref} -> ${alts.map(a => (a.length > 10 ? getBpDisplayStr(a.length) : a)).join(',')}`\n}\n\nfunction findSOTerm(alt: string, parser: VCF): string | undefined {\n  if (altTypeToSO[alt]) {\n    return altTypeToSO[alt]\n  }\n  if (parser.getMetadata('ALT', alt)) {\n    return 'sequence_variant'\n  }\n  // Try parent term by stripping last component, e.g. '<INS:ME>' -> '<INS>'\n  const parts = alt.slice(1, -1).split(':')\n  return parts.length > 1\n    ? findSOTerm(`<${parts.slice(0, -1).join(':')}>`, parser)\n    : undefined\n}\n\nexport function getSOAndDescFromAltDefs(alt: string, parser: VCF): string[] {\n  if (!alt.startsWith('<')) {\n    return []\n  }\n\n  const soTerm = findSOTerm(alt, parser)\n  return [soTerm ?? 'variant', alt]\n}\n\nexport function getMinimalDesc(ref: string, alt: string) {\n  if (isSymbolic(alt) || (ref.length === 1 && alt.length === 1)) {\n    return alt\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n  const isLong = lenRef > 5 || lenAlt > 5\n\n  return isLong\n    ? `${getBpDisplayStr(lenRef)} -> ${getBpDisplayStr(lenAlt)}`\n    : `${ref} -> ${alt}`\n}\n\nexport function makeSimpleAltString(\n  genotype: string,\n  ref: string,\n  alt: string[],\n) {\n  return genotype\n    .split(genotypeDelimRegex)\n    .map(r =>\n      r === '.'\n        ? '.'\n        : +r === 0\n          ? `ref(${ref.length < 10 ? ref : getBpDisplayStr(ref.length)})`\n          : getMinimalDesc(ref, alt[+r - 1] || ''),\n    )\n    .join(genotype.includes('|') ? '|' : '/')\n}\n"],"names":["observer","props","arr","width","displayModel","featureData","totalHeight","origScrollTop","rowHeight","simplifiedFeatures","renderingProps","ref","useRef","lastHoveredRef","undefined","getFeatureUnderMouse","useCallback","eventClientX","eventClientY","current","r","getBoundingClientRect","offsetX","left","offsetY","top","sources","canvasOffsetY","startRow","Math","floor","visibleRowIdx","sourceIdx","name","featureIdx","length","genotype","feature","alt","featureName","description","alleles","makeSimpleAltString","getBpDisplayStr","handleMouseMove","e","result","clientX","clientY","key","setHoveredGenotype","handleMouseLeave","handleClick","onFeatureClick","uniqueId","_jsx","onMouseMove","onMouseLeave","onMouseOut","onClick","style","overflow","position","height","children","PrerenderedCanvas","genotypeDelimRegex","isBreakend","includes","startsWith","endsWith","isSymbolic","altTypeToSO","getSOTermAndDescription","parser","soTerms","map","a","findSOTerm","parseBreakend","lenRef","lenAlt","split","reverse","join","isInversion","getSOTerm","uniqueSoTerms","Set","alts","every","formatGroupDescription","getMetadata","parts","slice","getMinimalDesc"],"ignoreList":[],"sourceRoot":""}