{"version":3,"file":"static/js/9822.1da382f8.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","../../../plugins/alignments/src/CramAdapter/readFeaturesToCIGAR.ts","../../../plugins/alignments/src/CramAdapter/readFeaturesToMismatches.ts","../../../plugins/alignments/src/CramAdapter/CramAdapter.ts"],"sourcesContent":["import { readFeaturesToCIGAR } from './readFeaturesToCIGAR'\nimport { readFeaturesToMismatches } from './readFeaturesToMismatches'\nimport { cacheGetter } from '../shared/util'\n\nimport type CramAdapter from './CramAdapter'\nimport type { CramRecord } from '@gmod/cram'\nimport type { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(\n    private record: CramRecord,\n    private _store: CramAdapter,\n  ) {}\n\n  get name() {\n    return this.record.readName\n  }\n\n  get start() {\n    return this.record.alignmentStart - 1\n  }\n\n  get end() {\n    return this.start + (this.record.lengthOnRef ?? 1)\n  }\n\n  get score() {\n    return this.record.mappingQuality\n  }\n\n  get flags() {\n    return this.record.flags\n  }\n\n  get strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  get qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  get qualRaw() {\n    return this.record.qualityScores\n  }\n\n  get refName() {\n    return this._store.refIdToName(this.record.sequenceId)!\n  }\n\n  get pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  get template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  get next_ref() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  get next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  get is_paired() {\n    return !!this.record.mate\n  }\n\n  get next_pos() {\n    return this.record.mate?.alignmentStart\n  }\n\n  get tags() {\n    const RG = this._store.samHeader.readGroups?.[this.record.readGroupId]\n    return RG !== undefined ? { ...this.record.tags, RG } : this.record.tags\n  }\n\n  get seq() {\n    return this.record.getReadBases()\n  }\n\n  // generate a CIGAR, based on code from jkbonfield\n  get CIGAR() {\n    return readFeaturesToCIGAR(\n      this.record.readFeatures,\n      this.record.alignmentStart,\n      this.record.readLength,\n      this.record._refRegion,\n    )\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string): any {\n    return field === 'mismatches'\n      ? this.mismatches\n      : field === 'qual'\n        ? this.qual\n        : field === 'CIGAR'\n          ? this.CIGAR\n          : this.fields[field]\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  get mismatches() {\n    return readFeaturesToMismatches(\n      this.record.readFeatures,\n      this.start,\n      this.qualRaw,\n    )\n    // this commented code can try to resolve MD tags, xref https://github.com/galaxyproject/tools-iuc/issues/6523#issuecomment-2462927211 but put on hold\n    // return this.tags.MD && this.seq\n    //   ? mismatches.concat(\n    //       mdToMismatches(\n    //         this.tags.MD,\n    //         parseCigar(this.CIGAR),\n    //         mismatches,\n    //         this.seq,\n    //         this.qualRaw,\n    //       ),\n    //     )\n    //   : mismatches\n  }\n\n  get fields(): SimpleFeatureSerialized {\n    return {\n      start: this.start,\n      name: this.name,\n      end: this.end,\n      score: this.score,\n      strand: this.strand,\n      template_length: this.template_length,\n      flags: this.flags,\n      tags: this.tags,\n      refName: this.refName,\n      seq: this.seq,\n      type: 'match',\n      pair_orientation: this.pair_orientation,\n      next_ref: this.next_ref,\n      next_pos: this.next_pos,\n      next_segment_position: this.next_segment_position,\n      uniqueId: this.id(),\n    }\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...this.fields,\n      // lazy\n      CIGAR: this.CIGAR,\n      // lazy\n      qual: this.qual,\n    }\n  }\n}\n\ncacheGetter(CramSlightlyLazyFeature, 'fields')\ncacheGetter(CramSlightlyLazyFeature, 'CIGAR')\ncacheGetter(CramSlightlyLazyFeature, 'mismatches')\n","import type { Mismatch } from '../shared/types'\nimport type { CramRecord } from '@gmod/cram'\n\ntype ReadFeatures = CramRecord['readFeatures']\n\nexport function readFeaturesToMismatches(\n  readFeatures: ReadFeatures = [],\n  start: number,\n  qual?: number[] | null,\n) {\n  const mismatches: Mismatch[] = new Array(readFeatures.length)\n  let j = 0\n  let insLen = 0\n  let refPos = 0\n  let sublen = 0\n  let lastPos = start\n\n  for (const ret of readFeatures) {\n    const { refPos: p, code, pos, data, sub, ref } = ret\n    sublen = refPos - lastPos\n    lastPos = refPos\n\n    if (sublen && insLen > 0) {\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${insLen}`,\n        insertedBases: data,\n        length: 0,\n      }\n      insLen = 0\n    }\n    refPos = p - 1 - start\n\n    if (code === 'X') {\n      // substitution\n      mismatches[j++] = {\n        start: refPos,\n        length: 1,\n        base: sub!,\n        qual: qual?.[pos - 1],\n        altbase: ref?.toUpperCase(),\n        type: 'mismatch',\n      }\n    } else if (code === 'I') {\n      // insertion\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${data.length}`,\n        length: 0,\n      }\n    } else if (code === 'N') {\n      // reference skip\n      mismatches[j++] = {\n        type: 'skip',\n        length: data,\n        start: refPos,\n        base: 'N',\n      }\n    } else if (code === 'S') {\n      // soft clip\n      const len = data.length\n      mismatches[j++] = {\n        start: refPos,\n        type: 'softclip',\n        base: `S${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'P') {\n      // padding\n    } else if (code === 'H') {\n      // hard clip\n      const len = data\n      mismatches[j++] = {\n        start: refPos,\n        type: 'hardclip',\n        base: `H${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'D') {\n      // deletion\n      mismatches[j++] = {\n        type: 'deletion',\n        length: data,\n        start: refPos,\n        base: '*',\n      }\n    } else if (code === 'b') {\n      // stretch of bases\n    } else if (code === 'q') {\n      // stretch of qual scores\n    } else if (code === 'B') {\n      // a pair of [base, qual]\n    } else if (code === 'i') {\n      // single-base insertion, we collect these if there are multiple in a row\n      // into a single insertion entry\n      insLen++\n    } else if (code === 'Q') {\n      // single quality value\n    }\n  }\n\n  if (sublen && insLen > 0) {\n    mismatches[j++] = {\n      start: refPos,\n      type: 'insertion',\n      base: `${insLen}`,\n      length: 0,\n    }\n    insLen = 0\n  }\n\n  return mismatches.slice(0, j)\n}\n\nexport function readFeaturesToCIGAR(\n  readFeatures: ReadFeatures,\n  alignmentStart: number,\n  readLen: number,\n  refRegion?: { seq: string; start: number },\n) {\n  let seq = ''\n  let cigar = ''\n  let op = 'M'\n  let oplen = 0\n  if (!refRegion) {\n    return ''\n  }\n  const ref = refRegion.seq\n  const refStart = refRegion.start\n  let lastPos = alignmentStart\n  let sublen = 0\n  let insLen = 0\n  if (readFeatures !== undefined) {\n    for (const { code, refPos, sub, data } of readFeatures) {\n      sublen = refPos - lastPos\n      seq += ref.slice(lastPos - refStart, refPos - refStart)\n      lastPos = refPos\n\n      if (insLen > 0 && sublen) {\n        cigar += `${insLen}I`\n        insLen = 0\n      }\n      if (oplen && op !== 'M') {\n        cigar += `${oplen}${op}`\n        oplen = 0\n      }\n      if (sublen) {\n        op = 'M'\n        oplen += sublen\n      }\n\n      if (code === 'b') {\n        // An array of bases stored verbatim\n        const ret = data.split(',')\n        const added = String.fromCharCode(...ret)\n        seq += added\n        lastPos += added.length\n        oplen += added.length\n      } else if (code === 'B') {\n        // Single base (+ qual score)\n        seq += sub\n        lastPos++\n        oplen++\n      } else if (code === 'X') {\n        // Substitution\n        seq += sub\n        lastPos++\n        oplen++\n      } else if (code === 'D' || code === 'N') {\n        // Deletion or Ref Skip\n        lastPos += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += data + code\n        oplen = 0\n      } else if (code === 'I' || code === 'S') {\n        // Insertion or soft-clip\n        seq += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += data.length + code\n        oplen = 0\n      } else if (code === 'i') {\n        // Single base insertion\n        // seq += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        insLen++\n        seq += data\n        oplen = 0\n      } else if (code === 'P') {\n        // Padding\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += `${data}P`\n      } else if (code === 'H') {\n        // Hard clip\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += `${data}H`\n        oplen = 0\n      } // else q or Q\n    }\n  } else {\n    sublen = readLen - seq.length\n  }\n  if (seq.length !== readLen) {\n    sublen = readLen - seq.length\n    seq += ref.slice(lastPos - refStart, lastPos - refStart + sublen)\n\n    if (oplen && op !== 'M') {\n      cigar += `${oplen}${op}`\n      oplen = 0\n    }\n    op = 'M'\n    oplen += sublen\n  }\n  if (sublen && insLen > 0) {\n    cigar += `${insLen}I`\n  }\n  if (oplen) {\n    cigar += `${oplen}${op}`\n  }\n\n  return cigar\n}\n","import type { Mismatch } from '../shared/types'\nimport type { CramRecord } from '@gmod/cram'\n\ntype ReadFeatures = CramRecord['readFeatures']\n\nexport function readFeaturesToMismatches(\n  readFeatures: ReadFeatures = [],\n  start: number,\n  qual?: number[] | null,\n) {\n  const mismatches: Mismatch[] = new Array(readFeatures.length)\n  let j = 0\n  let refPos = 0\n  let sublen = 0\n  let lastPos = start\n  let insertedBases = ''\n\n  for (const ret of readFeatures) {\n    const { refPos: p, code, pos, data, sub, ref } = ret\n    sublen = refPos - lastPos\n    lastPos = refPos\n\n    if (sublen && insertedBases.length > 0) {\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${insertedBases.length}`,\n        insertedBases,\n        length: 0,\n      }\n      insertedBases = ''\n    }\n    refPos = p - 1 - start\n\n    if (code === 'X') {\n      // substitution\n      mismatches[j++] = {\n        start: refPos,\n        length: 1,\n        base: sub!,\n        qual: qual?.[pos - 1],\n        altbase: ref?.toUpperCase(),\n        type: 'mismatch',\n      }\n    } else if (code === 'I') {\n      // insertion\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${data.length}`,\n        insertedBases: data,\n        length: 0,\n      }\n    } else if (code === 'N') {\n      // reference skip\n      mismatches[j++] = {\n        type: 'skip',\n        length: data,\n        start: refPos,\n        base: 'N',\n      }\n    } else if (code === 'S') {\n      // soft clip\n      const len = data.length\n      mismatches[j++] = {\n        start: refPos,\n        type: 'softclip',\n        base: `S${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'P') {\n      // padding\n    } else if (code === 'H') {\n      // hard clip\n      const len = data\n      mismatches[j++] = {\n        start: refPos,\n        type: 'hardclip',\n        base: `H${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'D') {\n      // deletion\n      mismatches[j++] = {\n        type: 'deletion',\n        length: data,\n        start: refPos,\n        base: '*',\n      }\n    } else if (code === 'b') {\n      // stretch of bases\n    } else if (code === 'q') {\n      // stretch of qual scores\n    } else if (code === 'B') {\n      // a pair of [base, qual]\n    } else if (code === 'i') {\n      // single-base insertion, we collect these if there are multiple in a row\n      // into a single insertion entry\n      insertedBases += data\n    } else if (code === 'Q') {\n      // single quality value\n    }\n  }\n\n  if (sublen && insertedBases.length > 0) {\n    mismatches[j++] = {\n      start: refPos,\n      type: 'insertion',\n      base: `${insertedBases.length}`,\n      insertedBases,\n      length: 0,\n    }\n    insertedBases = ''\n  }\n\n  return mismatches.slice(0, j)\n}\n","import { CraiIndex, IndexedCramFile } from '@gmod/cram'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { toLocale, updateStatus } from '@jbrowse/core/util'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature'\nimport { filterReadFlag, filterTagValue } from '../shared/util'\n\nimport type { FilterBy } from '../shared/types'\nimport type { CramRecord } from '@gmod/cram'\nimport type {\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\ninterface Header {\n  idToName?: string[]\n  nameToId?: Record<string, number>\n  readGroups?: (string | undefined)[]\n}\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  samHeader: Header = {}\n\n  private setupP?: Promise<{\n    samHeader: Header\n    cram: IndexedCramFile\n    sequenceAdapter: BaseSequenceAdapter\n  }>\n\n  private configureP?: Promise<{\n    cram: IndexedCramFile\n    sequenceAdapter: BaseSequenceAdapter\n  }>\n\n  // used for avoiding re-creation new BamSlightlyLazyFeatures, keeping\n  // mismatches in cache. at an average of 100kb-300kb, keeping even just 500\n  // of these in memory is fairly intensive but can reduce recomputation on\n  // these objects\n  private ultraLongFeatureCache = new QuickLRU<string, Feature>({\n    maxSize: 500,\n  })\n\n  // maps a refname to an id\n  private seqIdToRefName: string[] | undefined\n\n  // maps a seqId to original refname, passed specially to render args, to a seqid\n  private seqIdToOriginalRefName: string[] = []\n\n  public async configurePre() {\n    const cramLocation = this.getConf('cramLocation')\n    const craiLocation = this.getConf('craiLocation')\n    const pm = this.pluginManager\n\n    const cram = new IndexedCramFile({\n      cramFilehandle: openLocation(cramLocation, pm),\n      index: new CraiIndex({\n        filehandle: openLocation(craiLocation, pm),\n      }),\n      seqFetch: (...args) => this.seqFetch(...args),\n      checkSequenceMD5: false,\n    })\n\n    if (!this.getSubAdapter) {\n      throw new Error('Error getting subadapter')\n    }\n\n    const seqConf = this.getConf('sequenceAdapter')\n    if (!seqConf) {\n      throw new Error('no sequenceAdapter supplied to CramAdapter config')\n    }\n    const subadapter = await this.getSubAdapter(seqConf)\n\n    return {\n      cram,\n      sequenceAdapter: subadapter.dataAdapter as BaseSequenceAdapter,\n    }\n  }\n\n  public async configure() {\n    if (!this.configureP) {\n      this.configureP = this.configurePre().catch((e: unknown) => {\n        this.configureP = undefined\n        throw e\n      })\n    }\n    return this.configureP\n  }\n\n  async getHeader(_opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    return cram.cram.getHeaderText()\n  }\n\n  private async seqFetch(\n    seqId: number,\n    start: number,\n    end: number,\n  ): Promise<string> {\n    start -= 1 // convert from 1-based closed to interbase\n\n    const { sequenceAdapter } = await this.configure()\n    const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n    if (!refName) {\n      throw new Error('unknown')\n    }\n\n    const seqChunks = await firstValueFrom(\n      sequenceAdapter\n        .getFeatures({\n          refName,\n          start,\n          end,\n          assemblyName: '',\n        })\n        .pipe(toArray()),\n    )\n\n    const sequence = seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .map(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        return chunkSeq.slice(trimStart, trimStart + trimLength)\n      })\n      .join('')\n\n    const qlen = end - start\n    if (sequence.length !== qlen) {\n      throw new Error(\n        `fetching ${refName}:${toLocale(\n          start - 1,\n        )}-${toLocale(end)} returned ${toLocale(sequence.length)} bases, should have returned ${toLocale(\n          qlen,\n        )}`,\n      )\n    }\n    return sequence\n  }\n\n  private async setupPre(_opts?: BaseOptions) {\n    const conf = await this.configure()\n    const { cram } = conf\n    const samHeader = await cram.cram.getSamHeader()\n\n    // use the @SQ lines in the header to figure out the mapping between ref\n    // ID numbers and names\n    const idToName: string[] = []\n    const nameToId: Record<string, number> = {}\n    for (const [refId, sqLine] of samHeader\n      .filter(l => l.tag === 'SQ')\n      .entries()) {\n      const SN = sqLine.data.find(item => item.tag === 'SN')\n      if (SN) {\n        const refName = SN.value\n        nameToId[refName] = refId\n        idToName[refId] = refName\n      }\n    }\n\n    const readGroups = samHeader\n      .filter(l => l.tag === 'RG')\n      .map(rgLine => rgLine.data.find(item => item.tag === 'ID')?.value)\n\n    const data = { idToName, nameToId, readGroups }\n    this.samHeader = data\n    return {\n      samHeader: data,\n      ...conf,\n    }\n  }\n\n  private async setupPre2(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async setup(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, () =>\n      this.setupPre2(opts),\n    )\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { samHeader } = await this.setup(opts)\n    if (!samHeader.idToName) {\n      throw new Error('CRAM file has no header lines')\n    }\n    return samHeader.idToName\n  }\n\n  // use info from the SAM header if possible, but fall back to using the ref\n  // seq order from when the browser's refseqs were loaded\n  refNameToId(refName: string) {\n    if (this.samHeader.nameToId) {\n      return this.samHeader.nameToId[refName]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName.indexOf(refName)\n    }\n    return undefined\n  }\n\n  // use info from the SAM header if possible, but fall back to using the ref\n  // seq order from when the browser's refseqs were loaded\n  refIdToName(refId: number) {\n    return this.samHeader.idToName?.[refId] || this.seqIdToRefName?.[refId]\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: FilterBy\n    },\n  ) {\n    const { stopToken, filterBy, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      const { cram, samHeader } = await this.setup(opts)\n\n      const refId = this.refNameToId(refName)\n      if (refId === undefined) {\n        console.warn('Unknown refName', refName)\n        observer.complete()\n        return\n      }\n\n      if (originalRefName) {\n        this.seqIdToOriginalRefName[refId] = originalRefName\n      }\n      const records = await updateStatus(\n        'Downloading alignments',\n        statusCallback,\n        () => cram.getRecordsForRange(refId, start, end),\n      )\n      checkStopToken(stopToken)\n      await updateStatus('Processing alignments', statusCallback, () => {\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n        } = filterBy || {}\n\n        for (const record of records) {\n          if (filterReadFlag(record.flags, flagInclude, flagExclude)) {\n            continue\n          }\n          if (\n            tagFilter &&\n            filterTagValue(\n              tagFilter.tag === 'RG'\n                ? samHeader.readGroups?.[record.readGroupId]\n                : record.tags[tagFilter.tag],\n              tagFilter.value,\n            )\n          ) {\n            continue\n          }\n\n          if (readName && record.readName !== readName) {\n            continue\n          }\n\n          const ret = this.ultraLongFeatureCache.get(`${record.uniqueId}`)\n          if (!ret) {\n            const elt = this.cramRecordToFeature(record)\n            this.ultraLongFeatureCache.set(`${record.uniqueId}`, elt)\n            observer.next(elt)\n          } else {\n            observer.next(ret)\n          }\n        }\n\n        observer.complete()\n      })\n    }, stopToken)\n  }\n\n  cramRecordToFeature(record: CramRecord) {\n    return new CramSlightlyLazyFeature(record, this)\n  }\n\n  // we return the configured fetchSizeLimit, and the bytes for the region\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const bytes = await this.bytesForRegions(regions, opts)\n    const fetchSizeLimit = this.getConf('fetchSizeLimit')\n    return {\n      bytes,\n      fetchSizeLimit,\n    }\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   *\n   * @param regions - list of query regions\n   */\n  private async bytesForRegions(regions: Region[], _opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region => {\n        const { refName, start, end } = region\n        const chrId = this.refNameToId(refName)\n        return chrId !== undefined\n          ? cram.index.getEntriesForRange(chrId, start, end)\n          : Promise.resolve([{ sliceBytes: 0 }])\n      }),\n    )\n\n    return blockResults.flat().reduce((a, b) => a + b.sliceBytes, 0)\n  }\n}\n"],"names":["CramSlightlyLazyFeature","constructor","record","_store","name","this","readName","start","alignmentStart","end","lengthOnRef","score","mappingQuality","flags","strand","isReverseComplemented","qual","qualityScores","join","qualRaw","refName","refIdToName","sequenceId","pair_orientation","isPaired","getPairOrientation","undefined","template_length","templateLength","templateSize","next_ref","mate","next_segment_position","is_paired","next_pos","tags","RG","samHeader","readGroups","readGroupId","seq","getReadBases","CIGAR","readFeatures","readLen","refRegion","cigar","op","oplen","ref","refStart","lastPos","sublen","insLen","code","refPos","sub","data","slice","ret","split","added","String","fromCharCode","length","readFeaturesToCIGAR","readLength","_refRegion","id","uniqueId","get","field","mismatches","fields","parent","children","Array","j","insertedBases","p","pos","type","base","altbase","toUpperCase","len","cliplen","readFeaturesToMismatches","toJSON","cacheGetter","CramAdapter","BaseFeatureDataAdapter","ultraLongFeatureCache","QuickLRU","maxSize","seqIdToOriginalRefName","configurePre","cramLocation","getConf","craiLocation","pm","pluginManager","cram","IndexedCramFile","cramFilehandle","openLocation","index","CraiIndex","filehandle","seqFetch","args","checkSequenceMD5","getSubAdapter","Error","seqConf","sequenceAdapter","dataAdapter","configure","configureP","catch","e","getHeader","_opts","getHeaderText","seqId","refIdToOriginalName","sequence","firstValueFrom","getFeatures","assemblyName","pipe","toArray","sort","a","b","map","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","qlen","toLocale","setupPre","conf","getSamHeader","idToName","nameToId","refId","sqLine","filter","l","tag","entries","SN","find","item","value","rgLine","setupPre2","opts","setupP","setup","statusCallback","updateStatus","getRefNames","refNameToId","seqIdToRefName","indexOf","region","stopToken","filterBy","originalRefName","ObservableCreate","async","console","warn","observer","complete","records","getRecordsForRange","checkStopToken","flagInclude","flagExclude","tagFilter","filterReadFlag","filterTagValue","next","elt","cramRecordToFeature","set","getMultiRegionFeatureDensityStats","regions","bytes","bytesForRegions","fetchSizeLimit","Promise","all","chrId","getEntriesForRange","resolve","sliceBytes","flat","reduce"],"sourceRoot":""}