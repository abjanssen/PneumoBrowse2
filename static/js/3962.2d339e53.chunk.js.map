{"version":3,"file":"static/js/3962.2d339e53.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/shared/canvasUtils.ts","../../../plugins/alignments/src/RenderLinearReadCloudDisplayRPC/drawChainsUtil.ts","../../../plugins/alignments/src/shared/chevron.ts","../../../plugins/alignments/src/shared/primaryStrand.ts","../../../plugins/alignments/src/RenderLinearReadCloudDisplayRPC/drawLongReadChains.ts","../../../plugins/alignments/src/RenderLinearReadCloudDisplayRPC/drawPairChains.ts","../../../plugins/alignments/src/RenderLinearReadCloudDisplayRPC/drawFeatsCommon.ts"],"sourcesContent":["export function strokeRectCtx(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  ctx: CanvasRenderingContext2D,\n  strokeColor?: string,\n) {\n  if (width < 0) {\n    x += width\n    width = -width\n  }\n  if (height < 0) {\n    y += height\n    height = -height\n  }\n\n  if (strokeColor) {\n    ctx.strokeStyle = strokeColor\n  }\n  ctx.strokeRect(x, y, width, height)\n}\n\nexport function lineToCtx(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  ctx: CanvasRenderingContext2D,\n  strokeColor?: string,\n) {\n  if (strokeColor) {\n    ctx.strokeStyle = strokeColor\n  }\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y2)\n  ctx.stroke()\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\n\nimport { getCigarOps } from '../PileupRenderer/renderers/cigarUtil.ts'\nimport { renderMismatchesCallback } from '../PileupRenderer/renderers/renderMismatchesCallback.ts'\nimport { renderModifications } from '../PileupRenderer/renderers/renderModifications.ts'\nimport { strokeRectCtx } from '../shared/canvasUtils.ts'\nimport { drawChevron } from '../shared/chevron.ts'\nimport { SAM_FLAG_PAIRED, SAM_FLAG_SUPPLEMENTARY } from '../shared/samFlags.ts'\nimport {\n  CHEVRON_WIDTH,\n  getCharWidthHeight,\n  getColorBaseMap,\n  getContrastBaseMap,\n  setAlignmentFont,\n  shouldDrawIndels,\n  shouldDrawSNPsMuted,\n} from '../shared/util.ts'\n\nimport type { FlatbushItem, LayoutFeature } from '../PileupRenderer/types.ts'\nimport type { ColorBy, ModificationTypeWithColor } from '../shared/types.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { BaseBlock } from '@jbrowse/core/util/blockTypes'\nimport type { ThemeOptions } from '@mui/material'\n\n// Get connecting line color based on theme mode\nexport function getConnectingLineColor(configTheme: ThemeOptions) {\n  const theme = createJBrowseTheme(configTheme)\n  return theme.palette.mode === 'dark' ? '#aaa8' : '#6665'\n}\nexport const MIN_FEATURE_WIDTH_PX = 3\nexport const CLIP_RECT_HEIGHT = 100000\n\nexport function renderFeatureShape({\n  ctx,\n  xPos,\n  yPos,\n  width,\n  height,\n  strand,\n  fillStyle,\n  strokeStyle,\n  renderChevrons,\n  showOutline = true,\n}: {\n  ctx: CanvasRenderingContext2D\n  xPos: number\n  yPos: number\n  width: number\n  height: number\n  strand: number\n  fillStyle: string\n  strokeStyle: string\n  renderChevrons: boolean\n  showOutline?: boolean\n}) {\n  if (renderChevrons) {\n    drawChevron(\n      ctx,\n      xPos,\n      yPos,\n      width,\n      height,\n      strand,\n      fillStyle,\n      CHEVRON_WIDTH,\n      showOutline ? strokeStyle : undefined,\n    )\n  } else {\n    // Handle negative dimensions for SVG exports\n    let drawX = xPos\n    let drawY = yPos\n    let drawWidth = width\n    if (drawWidth < 0) {\n      drawX += drawWidth\n      drawWidth = -drawWidth\n    }\n    if (height < 0) {\n      drawY += height\n    }\n\n    ctx.fillStyle = fillStyle\n    ctx.fillRect(drawX, drawY, drawWidth, height)\n    if (showOutline) {\n      strokeRectCtx(drawX, drawY, drawWidth, height, ctx, strokeStyle)\n    }\n  }\n}\n\nexport interface MismatchData {\n  coords: number[]\n  items: FlatbushItem[]\n}\n\nexport function getStrandColorKey(strand: number) {\n  return strand === -1 ? 'color_rev_strand' : 'color_fwd_strand'\n}\n\nexport function chainIsPairedEnd(chain: Feature[]) {\n  for (const element of chain) {\n    if (element.get('flags') & SAM_FLAG_PAIRED) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function collectNonSupplementary(chain: Feature[]) {\n  const result: Feature[] = []\n  for (const element of chain) {\n    if (!(element.get('flags') & SAM_FLAG_SUPPLEMENTARY)) {\n      result.push(element)\n    }\n  }\n  return result\n}\n\nexport interface MismatchRenderingConfig {\n  mismatchAlpha: boolean | undefined\n  minSubfeatureWidth: number\n  largeInsertionIndicatorScale: number\n  hideSmallIndels: boolean\n  hideMismatches: boolean\n  hideLargeIndels: boolean\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  charWidth: number\n  charHeight: number\n  drawSNPsMuted: boolean\n  drawIndels: boolean\n}\n\nexport function getMismatchRenderingConfig(\n  ctx: CanvasRenderingContext2D,\n  config: AnyConfigurationModel,\n  configTheme: ThemeOptions,\n  colorBy: ColorBy,\n  overrides?: {\n    hideSmallIndels?: boolean\n    hideMismatches?: boolean\n    hideLargeIndels?: boolean\n  },\n): MismatchRenderingConfig {\n  const mismatchAlpha = readConfObject(config, 'mismatchAlpha')\n  const minSubfeatureWidth = readConfObject(config, 'minSubfeatureWidth') ?? 1\n  const largeInsertionIndicatorScale = readConfObject(\n    config,\n    'largeInsertionIndicatorScale',\n  )\n  const hideSmallIndels =\n    overrides?.hideSmallIndels ??\n    (readConfObject(config, 'hideSmallIndels') as boolean)\n  const hideMismatches =\n    overrides?.hideMismatches ??\n    (readConfObject(config, 'hideMismatches') as boolean)\n  const hideLargeIndels =\n    overrides?.hideLargeIndels ??\n    (readConfObject(config, 'hideLargeIndels') as boolean | undefined) ??\n    false\n  const theme = createJBrowseTheme(configTheme)\n  const colorMap = getColorBaseMap(theme)\n  const colorContrastMap = getContrastBaseMap(theme)\n  setAlignmentFont(ctx)\n  const { charWidth, charHeight } = getCharWidthHeight()\n  const drawSNPsMuted = shouldDrawSNPsMuted(colorBy.type)\n  const drawIndels = shouldDrawIndels()\n\n  return {\n    mismatchAlpha,\n    minSubfeatureWidth,\n    largeInsertionIndicatorScale,\n    hideSmallIndels,\n    hideMismatches,\n    hideLargeIndels,\n    colorMap,\n    colorContrastMap,\n    charWidth,\n    charHeight,\n    drawSNPsMuted,\n    drawIndels,\n  }\n}\n\nexport function featureOverlapsRegion(\n  featRefName: string,\n  featStart: number,\n  featEnd: number,\n  region: BaseBlock,\n) {\n  return (\n    featRefName === region.refName &&\n    featStart < region.end &&\n    featEnd > region.start\n  )\n}\n\nexport function calculateFeaturePositionPx(\n  featStart: number,\n  featEnd: number,\n  regionStart: number,\n  regionEnd: number,\n  bpPerPx: number,\n) {\n  const clippedStart = Math.max(featStart, regionStart)\n  const clippedEnd = Math.min(featEnd, regionEnd)\n  const xPos = (clippedStart - regionStart) / bpPerPx\n  const width = Math.max(\n    (clippedEnd - clippedStart) / bpPerPx,\n    MIN_FEATURE_WIDTH_PX,\n  )\n  return { xPos, width }\n}\n\n/**\n * Find min start and max end coordinates across all features in a chain\n * that are on the specified reference. Returns undefined if no features match.\n */\nexport function getChainBoundsOnRef(chain: Feature[], refName: string) {\n  let minStart = Number.MAX_VALUE\n  let maxEnd = Number.MIN_VALUE\n\n  for (const element of chain) {\n    const f = element\n    if (f.get('refName') === refName) {\n      minStart = Math.min(minStart, f.get('start'))\n      maxEnd = Math.max(maxEnd, f.get('end'))\n    }\n  }\n\n  return minStart !== Number.MAX_VALUE ? { minStart, maxEnd } : undefined\n}\n\nfunction aggregateMismatchData(\n  ret: MismatchData,\n  regionStartPx: number,\n  allCoords: number[],\n  allItems: FlatbushItem[],\n) {\n  for (let i = 0; i < ret.coords.length; i += 4) {\n    allCoords.push(\n      ret.coords[i]! + regionStartPx,\n      ret.coords[i + 1]!,\n      ret.coords[i + 2]! + regionStartPx,\n      ret.coords[i + 3]!,\n    )\n  }\n  for (const item of ret.items) {\n    allItems.push(item)\n  }\n}\n\nexport function renderFeatureModifications({\n  ctx,\n  feat,\n  layoutFeat,\n  region,\n  regionStartPx,\n  bpPerPx,\n  colorBy,\n  visibleModifications,\n  allCoords,\n  allItems,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: Feature\n  layoutFeat: LayoutFeature\n  region: BaseBlock\n  regionStartPx: number\n  bpPerPx: number\n  colorBy: ColorBy\n  visibleModifications?: Record<string, ModificationTypeWithColor>\n  allCoords: number[]\n  allItems: FlatbushItem[]\n}) {\n  if (colorBy.type !== 'modifications' || !visibleModifications) {\n    return\n  }\n\n  const cigarOps = getCigarOps(feat.get('NUMERIC_CIGAR') || feat.get('CIGAR'))\n  const modRet = renderModifications({\n    ctx,\n    feat: layoutFeat,\n    region,\n    bpPerPx,\n    renderArgs: {\n      colorBy,\n      visibleModifications,\n    },\n    cigarOps,\n  })\n\n  aggregateMismatchData(modRet, regionStartPx, allCoords, allItems)\n}\n\nexport function renderFeatureMismatchesAndModifications({\n  ctx,\n  feat,\n  layoutFeat,\n  region,\n  regionStartPx,\n  bpPerPx,\n  canvasWidth,\n  colorBy,\n  visibleModifications,\n  mismatchConfig,\n  allCoords,\n  allItems,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: Feature\n  layoutFeat: LayoutFeature\n  region: BaseBlock\n  regionStartPx: number\n  bpPerPx: number\n  canvasWidth: number\n  colorBy: ColorBy\n  visibleModifications?: Record<string, ModificationTypeWithColor>\n  mismatchConfig: MismatchRenderingConfig\n  allCoords: number[]\n  allItems: FlatbushItem[]\n}) {\n  const ret = renderMismatchesCallback({\n    ctx,\n    feat: layoutFeat,\n    checkRef: true,\n    bpPerPx,\n    regions: [region],\n    canvasWidth,\n    ...mismatchConfig,\n  })\n  aggregateMismatchData(ret, regionStartPx, allCoords, allItems)\n\n  renderFeatureModifications({\n    ctx,\n    feat,\n    layoutFeat,\n    region,\n    regionStartPx,\n    bpPerPx,\n    colorBy,\n    visibleModifications,\n    allCoords,\n    allItems,\n  })\n}\n","/**\n * Draw a chevron shape (arrow-like) for directional features like reads\n * @param ctx - Canvas rendering context\n * @param x - X position\n * @param y - Y position\n * @param width - Width of the chevron\n * @param height - Height of the chevron\n * @param strand - Strand direction (-1 for reverse, 1 for forward)\n * @param color - Fill color\n * @param chevronWidth - Width of the chevron pointer in pixels\n * @param stroke - Optional stroke color (if not provided, no stroke is drawn)\n */\nexport function drawChevron(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  strand: number,\n  color: string,\n  chevronWidth: number,\n  stroke?: string,\n) {\n  ctx.fillStyle = color\n  ctx.beginPath()\n  if (strand === -1) {\n    ctx.moveTo(x - chevronWidth, y + height / 2)\n    ctx.lineTo(x, y + height)\n    ctx.lineTo(x + width, y + height)\n    ctx.lineTo(x + width, y)\n    ctx.lineTo(x, y)\n  } else {\n    ctx.moveTo(x, y)\n    ctx.lineTo(x, y + height)\n    ctx.lineTo(x + width, y + height)\n    ctx.lineTo(x + width + chevronWidth, y + height / 2)\n    ctx.lineTo(x + width, y)\n  }\n  ctx.closePath()\n  ctx.fill()\n  if (stroke) {\n    ctx.strokeStyle = stroke\n    ctx.stroke()\n  }\n}\n","import type { Feature } from '@jbrowse/core/util'\n\n/**\n * Gets the primary strand for a feature, handling both primary and supplementary alignments.\n *\n * For non-supplementary alignments (!(flags & 2048)), uses the feature's strand property.\n * For supplementary alignments, parses the SA tag to get the primary alignment's strand.\n *\n * @param feat - The feature to get the primary strand from\n * @returns The primary strand (-1 for reverse, 1 for forward, or undefined if SA tag is missing)\n */\nexport function getPrimaryStrand(feat: Feature) {\n  const flags = feat.get('flags')\n  // Check if this is not a supplementary alignment (flag 2048)\n  if (!(flags & 2048)) {\n    return feat.get('strand')\n  } else {\n    // Parse SA tag to get primary alignment strand\n    const SA = feat.get('tags')?.SA\n    const res = SA?.split(';')[0]?.split(',')[2]\n    return res === '-' ? -1 : 1\n  }\n}\n\n/**\n * Gets the primary strand for a feature by checking the reverse complement flag.\n *\n * For non-supplementary alignments (!(flags & 2048)), checks flag 16 (reverse complement).\n * For supplementary alignments, parses the SA tag to get the primary alignment's strand.\n *\n * @param feat - The feature to get the primary strand from\n * @returns The primary strand (-1 for reverse, 1 for forward, or undefined if SA tag is missing)\n */\nexport function getPrimaryStrandFromFlags(feat: Feature) {\n  const flags = feat.get('flags')\n  // Check if this is not a supplementary alignment (flag 2048)\n  if (!(flags & 2048)) {\n    return flags & 16 ? -1 : 1\n  } else {\n    // Parse SA tag to get primary alignment strand\n    const SA = feat.get('tags')?.SA\n    const res = SA?.split(';')[0]?.split(',')[2]\n    return res === '-' ? -1 : 1\n  }\n}\n","import { checkStopToken2 } from '@jbrowse/core/util/stopToken'\n\nimport {\n  calculateFeaturePositionPx,\n  featureOverlapsRegion,\n  getChainBoundsOnRef,\n  getConnectingLineColor,\n  getMismatchRenderingConfig,\n  getStrandColorKey,\n  renderFeatureMismatchesAndModifications,\n  renderFeatureShape,\n} from './drawChainsUtil.ts'\nimport { lineToCtx } from '../shared/canvasUtils.ts'\nimport { fillColor, getSingletonColor, strokeColor } from '../shared/color.ts'\nimport { getPrimaryStrandFromFlags } from '../shared/primaryStrand.ts'\n\nimport type { MismatchData } from './drawChainsUtil.ts'\nimport type { ComputedChain } from './drawFeatsCommon.ts'\nimport type {\n  ChainData,\n  ColorBy,\n  ModificationTypeWithColor,\n} from '../shared/types.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { LastStopTokenCheck } from '@jbrowse/core/util'\nimport type { BaseBlock } from '@jbrowse/core/util/blockTypes'\nimport type { ThemeOptions } from '@mui/material'\n\nexport function drawLongReadChains({\n  ctx,\n  chainData,\n  chainYOffsets,\n  renderChevrons,\n  featureHeight,\n  computedChains,\n  flipStrandLongReadChains,\n  config,\n  theme: configTheme,\n  region,\n  regionStartPx,\n  bpPerPx,\n  colorBy,\n  visibleModifications,\n  stopTokenCheck,\n  hideSmallIndels,\n  hideMismatches,\n  hideLargeIndels,\n  showOutline,\n}: {\n  ctx: CanvasRenderingContext2D\n  chainData: ChainData\n  chainYOffsets: Map<string, number>\n  renderChevrons: boolean\n  featureHeight: number\n  computedChains: ComputedChain[]\n  flipStrandLongReadChains: boolean\n  config: AnyConfigurationModel\n  theme: ThemeOptions\n  region: BaseBlock\n  regionStartPx: number\n  bpPerPx: number\n  colorBy: ColorBy\n  visibleModifications?: Record<string, ModificationTypeWithColor>\n  stopTokenCheck?: LastStopTokenCheck\n  hideSmallIndels?: boolean\n  hideMismatches?: boolean\n  hideLargeIndels?: boolean\n  showOutline?: boolean\n}): MismatchData {\n  const mismatchConfig = getMismatchRenderingConfig(\n    ctx,\n    config,\n    configTheme,\n    colorBy,\n    { hideSmallIndels, hideMismatches, hideLargeIndels },\n  )\n  const canvasWidth = region.widthPx\n  const regionStart = region.start\n\n  const allCoords: MismatchData['coords'] = []\n  const allItems: MismatchData['items'] = []\n\n  for (const computedChain of computedChains) {\n    checkStopToken2(stopTokenCheck)\n    const { id, chain, isPairedEnd, nonSupplementary } = computedChain\n\n    if (isPairedEnd) {\n      continue\n    }\n\n    const chainY = chainYOffsets.get(id)\n    if (chainY === undefined) {\n      continue\n    }\n\n    const isSingleton = chain.length === 1\n    const c1 = nonSupplementary[0] || chain[0]!\n    const primaryStrand = getPrimaryStrandFromFlags(c1)\n\n    // Draw connecting line for multi-segment long reads\n    if (!isSingleton) {\n      const bounds = getChainBoundsOnRef(chain, region.refName)\n      if (\n        bounds &&\n        bounds.minStart < region.end &&\n        bounds.maxEnd > region.start\n      ) {\n        const firstPx = (bounds.minStart - regionStart) / bpPerPx\n        const lastPx = (bounds.maxEnd - regionStart) / bpPerPx\n        const lineY = chainY + featureHeight / 2\n        lineToCtx(\n          firstPx,\n          lineY,\n          lastPx,\n          lineY,\n          ctx,\n          getConnectingLineColor(configTheme),\n        )\n      }\n    }\n\n    // First pass: draw all feature shapes\n    const layoutFeats: typeof chain = []\n    for (let i = 0, l = chain.length; i < l; i++) {\n      const feat = chain[i]!\n      const featRefName = feat.get('refName')\n      const featStart = feat.get('start')\n      const featEnd = feat.get('end')\n\n      if (!featureOverlapsRegion(featRefName, featStart, featEnd, region)) {\n        continue\n      }\n\n      const featStrand = feat.get('strand')\n      const effectiveStrand =\n        isSingleton || !flipStrandLongReadChains\n          ? featStrand\n          : featStrand * primaryStrand\n\n      const [featureFill, featureStroke] = isSingleton\n        ? getSingletonColor(\n            {\n              tlen: feat.get('template_length'),\n              pair_orientation: feat.get('pair_orientation'),\n              flags: feat.get('flags'),\n            },\n            chainData.stats,\n          )\n        : [\n            fillColor[getStrandColorKey(effectiveStrand)],\n            strokeColor[getStrandColorKey(effectiveStrand)],\n          ]\n\n      const { xPos, width } = calculateFeaturePositionPx(\n        featStart,\n        featEnd,\n        regionStart,\n        region.end,\n        bpPerPx,\n      )\n\n      layoutFeats.push(feat)\n\n      renderFeatureShape({\n        ctx,\n        xPos,\n        yPos: chainY,\n        width,\n        height: featureHeight,\n        strand: effectiveStrand,\n        fillStyle: featureFill,\n        strokeStyle: featureStroke,\n        renderChevrons,\n        showOutline,\n      })\n    }\n\n    // Second pass: draw all mismatches on top\n    for (const feat of layoutFeats) {\n      const layoutFeat = {\n        feature: feat,\n        heightPx: featureHeight,\n        topPx: chainY,\n      }\n\n      renderFeatureMismatchesAndModifications({\n        ctx,\n        feat,\n        layoutFeat,\n        region,\n        regionStartPx,\n        bpPerPx,\n        canvasWidth,\n        colorBy,\n        visibleModifications,\n        mismatchConfig,\n        allCoords,\n        allItems,\n      })\n    }\n  }\n\n  return {\n    coords: allCoords,\n    items: allItems,\n  }\n}\n","import { checkStopToken2 } from '@jbrowse/core/util/stopToken'\n\nimport {\n  calculateFeaturePositionPx,\n  featureOverlapsRegion,\n  getChainBoundsOnRef,\n  getConnectingLineColor,\n  getMismatchRenderingConfig,\n  renderFeatureMismatchesAndModifications,\n  renderFeatureShape,\n} from './drawChainsUtil.ts'\nimport { lineToCtx } from '../shared/canvasUtils.ts'\nimport { fillColor, getPairedColor, strokeColor } from '../shared/color.ts'\n\nimport type { MismatchData } from './drawChainsUtil.ts'\nimport type { ComputedChain } from './drawFeatsCommon.ts'\nimport type {\n  ChainData,\n  ColorBy,\n  ModificationTypeWithColor,\n} from '../shared/types.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { LastStopTokenCheck } from '@jbrowse/core/util'\nimport type { BaseBlock } from '@jbrowse/core/util/blockTypes'\nimport type { ThemeOptions } from '@mui/material'\n\nexport function drawPairChains({\n  ctx,\n  type,\n  chainData,\n  chainYOffsets,\n  renderChevrons,\n  featureHeight,\n  computedChains,\n  config,\n  theme: configTheme,\n  region,\n  regionStartPx,\n  bpPerPx,\n  colorBy,\n  visibleModifications,\n  stopTokenCheck,\n  hideSmallIndels,\n  hideMismatches,\n  hideLargeIndels,\n  showOutline,\n}: {\n  ctx: CanvasRenderingContext2D\n  type: string\n  chainData: ChainData\n  chainYOffsets: Map<string, number>\n  renderChevrons: boolean\n  featureHeight: number\n  computedChains: ComputedChain[]\n  config: AnyConfigurationModel\n  theme: ThemeOptions\n  region: BaseBlock\n  regionStartPx: number\n  bpPerPx: number\n  colorBy: ColorBy\n  visibleModifications?: Record<string, ModificationTypeWithColor>\n  stopTokenCheck?: LastStopTokenCheck\n  hideSmallIndels?: boolean\n  hideMismatches?: boolean\n  hideLargeIndels?: boolean\n  showOutline?: boolean\n}): MismatchData {\n  const mismatchConfig = getMismatchRenderingConfig(\n    ctx,\n    config,\n    configTheme,\n    colorBy,\n    { hideSmallIndels, hideMismatches, hideLargeIndels },\n  )\n  const canvasWidth = region.widthPx\n  const regionStart = region.start\n\n  const allCoords: MismatchData['coords'] = []\n  const allItems: MismatchData['items'] = []\n\n  for (const computedChain of computedChains) {\n    checkStopToken2(stopTokenCheck)\n    const { id, chain, isPairedEnd, nonSupplementary } = computedChain\n\n    if (!isPairedEnd) {\n      continue\n    }\n\n    const chainY = chainYOffsets.get(id)\n    if (chainY === undefined) {\n      continue\n    }\n\n    const hasBothMates = nonSupplementary.length === 2\n\n    // Get colors for this read pair/singleton\n    const feat = nonSupplementary[0] || chain[0]!\n    const [pairedFill, pairedStroke] = getPairedColor({\n      type,\n      v0: feat,\n      stats: chainData.stats,\n    }) || ['lightgrey', '#888']\n\n    const lineY = chainY + featureHeight / 2\n\n    // Check if chain has supplementary alignments\n    const hasSupplementary = chain.length > nonSupplementary.length\n\n    // Draw connecting line spanning all features in chain (including supplementary)\n    if (hasBothMates) {\n      const bounds = getChainBoundsOnRef(chain, region.refName)\n      if (\n        bounds &&\n        bounds.minStart < region.end &&\n        bounds.maxEnd > region.start\n      ) {\n        const r1s = (bounds.minStart - regionStart) / bpPerPx\n        const r2s = (bounds.maxEnd - regionStart) / bpPerPx\n        // Use orange for chains with supplementary alignments\n        const lineColor = hasSupplementary\n          ? fillColor.color_supplementary\n          : getConnectingLineColor(configTheme)\n        lineToCtx(r1s, lineY, r2s, lineY, ctx, lineColor)\n      }\n    }\n\n    // First pass: draw all feature shapes\n    const layoutFeats: typeof chain = []\n    for (let i = 0, l = chain.length; i < l; i++) {\n      const feat = chain[i]!\n      const featRefName = feat.get('refName')\n      const featStart = feat.get('start')\n      const featEnd = feat.get('end')\n\n      if (!featureOverlapsRegion(featRefName, featStart, featEnd, region)) {\n        continue\n      }\n\n      const { xPos, width } = calculateFeaturePositionPx(\n        featStart,\n        featEnd,\n        regionStart,\n        region.end,\n        bpPerPx,\n      )\n\n      layoutFeats.push(feat)\n\n      // Use supplementary color for entire chain if it has supplementary alignments\n      const [featFill, featStroke] = hasSupplementary\n        ? [fillColor.color_supplementary, strokeColor.color_supplementary]\n        : [pairedFill, pairedStroke]\n\n      renderFeatureShape({\n        ctx,\n        xPos,\n        yPos: chainY,\n        width,\n        height: featureHeight,\n        strand: feat.get('strand'),\n        fillStyle: featFill,\n        strokeStyle: featStroke,\n        renderChevrons,\n        showOutline,\n      })\n    }\n\n    // Second pass: draw all mismatches on top\n    for (const feat of layoutFeats) {\n      const layoutFeat = {\n        feature: feat,\n        heightPx: featureHeight,\n        topPx: chainY,\n      }\n\n      renderFeatureMismatchesAndModifications({\n        ctx,\n        feat,\n        layoutFeat,\n        region,\n        regionStartPx,\n        bpPerPx,\n        canvasWidth,\n        colorBy,\n        visibleModifications,\n        mismatchConfig,\n        allCoords,\n        allItems,\n      })\n    }\n    checkStopToken2(stopTokenCheck)\n  }\n\n  return { coords: allCoords, items: allItems }\n}\n","import Flatbush from '@jbrowse/core/util/flatbush'\n\nimport {\n  CLIP_RECT_HEIGHT,\n  chainIsPairedEnd,\n  collectNonSupplementary,\n} from './drawChainsUtil.ts'\nimport { drawLongReadChains } from './drawLongReadChains.ts'\nimport { drawPairChains } from './drawPairChains.ts'\nimport { PairType, getPairedType } from '../shared/color.ts'\nimport { SAM_FLAG_PAIRED, SAM_FLAG_SUPPLEMENTARY } from '../shared/samFlags.ts'\nimport { shouldRenderChevrons } from '../shared/util.ts'\n\nimport type { LinearReadCloudDisplayModel } from '../LinearReadCloudDisplay/model.ts'\nimport type { FlatbushItem } from '../PileupRenderer/types.ts'\nimport type { FlatbushEntry } from '../shared/flatbushType.ts'\nimport type {\n  ChainData,\n  ColorBy,\n  ModificationTypeWithColor,\n} from '../shared/types.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, LastStopTokenCheck } from '@jbrowse/core/util'\nimport type { BaseBlock } from '@jbrowse/core/util/blockTypes'\nimport type { ThemeOptions } from '@mui/material'\n\ninterface ViewForDrawing {\n  bpPerPx: number\n  offsetPx: number\n  bpToPx: (arg: {\n    refName: string\n    coord: number\n  }) => { offsetPx: number } | undefined\n}\n\n// If TLEN is more than this factor larger than the visible bp span,\n// it's likely from a distant mate (e.g., SV) and shouldn't affect scaling\nconst TLEN_CONSISTENCY_FACTOR = 100\n\nexport interface ComputedChain {\n  distance: number\n  minX: number\n  maxX: number\n  chain: Feature[]\n  id: string\n  // Pre-computed to avoid repeated iteration in drawing code\n  isPairedEnd: boolean\n  nonSupplementary: Feature[]\n}\n\n/**\n * Filter chains based on singleton and proper pair settings\n */\nexport function filterChains(\n  chains: Feature[][],\n  drawSingletons: boolean,\n  drawProperPairs: boolean,\n  type: string,\n  chainData: ChainData,\n) {\n  const filtered: Feature[][] = []\n\n  for (const chain of chains) {\n    // Filter out singletons if drawSingletons is false\n    if (!drawSingletons && chain.length === 1) {\n      continue\n    }\n\n    // Filter out proper pairs if drawProperPairs is false\n    const isPairedEnd = chainIsPairedEnd(chain)\n\n    if (!drawProperPairs && isPairedEnd) {\n      const nonSupplementary = collectNonSupplementary(chain)\n      if (nonSupplementary.length === 2) {\n        const v0 = nonSupplementary[0]!\n        const pairType = getPairedType({\n          type,\n          f: {\n            refName: v0.get('refName'),\n            next_ref: v0.get('next_ref'),\n            pair_orientation: v0.get('pair_orientation'),\n            tlen: v0.get('template_length'),\n            flags: v0.get('flags'),\n          },\n          stats: chainData.stats,\n        })\n        // Filter out proper pairs\n        if (pairType === PairType.PROPER_PAIR) {\n          continue\n        }\n      }\n    }\n\n    filtered.push(chain)\n  }\n\n  return filtered\n}\n\n/**\n * Compute pixel bounds for each chain\n */\nexport function computeChainBounds(chains: Feature[][], view: ViewForDrawing) {\n  const computedChains: ComputedChain[] = []\n  const { bpPerPx } = view\n\n  for (const chain of chains) {\n    let minX = Number.MAX_VALUE\n    let maxX = Number.MIN_VALUE\n    let chainId = ''\n    let tlenDistance = 0\n    let isPairedEnd = false\n    const nonSupplementary: Feature[] = []\n    const chainLength = chain.length\n\n    for (let j = 0; j < chainLength; j++) {\n      const elt = chain[j]!\n      const start = elt.get('start')\n      const end = elt.get('end')\n      const flags = elt.get('flags')\n\n      // Pre-compute isPairedEnd and nonSupplementary in single pass\n      if (flags & SAM_FLAG_PAIRED) {\n        isPairedEnd = true\n      }\n      if (!(flags & SAM_FLAG_SUPPLEMENTARY)) {\n        nonSupplementary.push(elt)\n      }\n\n      // Only call bpToPx once per feature, calculate end from start + length\n      const rs = view.bpToPx({\n        refName: elt.get('refName'),\n        coord: start,\n      })?.offsetPx\n      if (rs !== undefined) {\n        const re = rs + (end - start) / bpPerPx\n        minX = Math.min(minX, rs)\n        maxX = Math.max(maxX, re)\n      }\n      if (!chainId) {\n        chainId = elt.id()\n      }\n      // Use TLEN from the first feature that has it\n      const tlen = elt.get('template_length')\n      if (tlenDistance === 0 && tlen) {\n        tlenDistance = Math.abs(tlen)\n      }\n    }\n\n    // Skip chains with no valid pixel positions\n    if (minX === Number.MAX_VALUE || maxX === Number.MIN_VALUE) {\n      continue\n    }\n\n    // Use TLEN for distance (template length in bp).\n    // Long reads without TLEN will have distance=0 and appear at y=0.\n    // Filter out chains where TLEN is wildly inconsistent with the\n    // visible bp span (e.g., distant mate from SV)\n    let distance = 0\n    if (tlenDistance > 0) {\n      const bpSpan = (maxX - minX) * bpPerPx\n      if (tlenDistance <= bpSpan * TLEN_CONSISTENCY_FACTOR) {\n        distance = tlenDistance\n      }\n    }\n\n    computedChains.push({\n      distance,\n      minX,\n      maxX,\n      chain,\n      id: chainId,\n      isPairedEnd,\n      nonSupplementary,\n    })\n  }\n\n  return computedChains\n}\n\n/**\n * Sort chains: singletons first, then by width within each group\n */\nexport function sortComputedChains(computedChains: ComputedChain[]) {\n  computedChains.sort((a, b) => {\n    const aIsSingleton = a.chain.length === 1 ? 1 : 0\n    const bIsSingleton = b.chain.length === 1 ? 1 : 0\n\n    // Sort singletons first (higher value = earlier in sort)\n    if (bIsSingleton !== aIsSingleton) {\n      return bIsSingleton - aIsSingleton\n    }\n\n    // Within each group, sort by width (smaller first)\n    return a.distance - b.distance\n  })\n}\n\n/**\n * Build Flatbush index for mouseover detection\n */\nexport function buildFlatbushIndex(\n  featuresForFlatbush: FlatbushEntry[],\n  self: LinearReadCloudDisplayModel,\n) {\n  const finalFlatbush = new Flatbush(Math.max(featuresForFlatbush.length, 1))\n  const length = featuresForFlatbush.length\n  if (length) {\n    for (let i = 0; i < length; i++) {\n      const { x1, y1, x2, y2 } = featuresForFlatbush[i]!\n      finalFlatbush.add(x1, y1, x2, y2)\n    }\n  } else {\n    // flatbush does not like 0 items\n    finalFlatbush.add(0, 0)\n  }\n  finalFlatbush.finish()\n  self.setFeatureLayout(finalFlatbush)\n  self.setFeaturesForFlatbush(featuresForFlatbush)\n}\n\n/**\n * Add full-width rectangles for each chain to enable mouseover on connecting lines\n */\nexport function addChainMouseoverRects(\n  computedChains: ComputedChain[],\n  chainYOffsets: Map<string, number>,\n  featureHeight: number,\n  view: ViewForDrawing,\n  featuresForFlatbush: FlatbushEntry[],\n) {\n  for (const computedChain of computedChains) {\n    const { id, chain, minX, maxX, nonSupplementary } = computedChain\n    const chainY = chainYOffsets.get(id)\n    if (chainY === undefined) {\n      continue\n    }\n\n    const chainMinXPx = minX - view.offsetPx\n    const chainMaxXPx = maxX - view.offsetPx\n    if (chain.length > 0) {\n      // Use pre-computed nonSupplementary from computeChainBounds\n      const primaryFeat = nonSupplementary[0] || chain[0]!\n      const hasSupplementary = nonSupplementary.length < chain.length\n      featuresForFlatbush.push({\n        x1: chainMinXPx,\n        y1: chainY,\n        x2: chainMaxXPx,\n        y2: chainY + featureHeight,\n        data: {\n          name: primaryFeat.get('name'),\n          refName: primaryFeat.get('refName'),\n          start: primaryFeat.get('start'),\n          end: primaryFeat.get('end'),\n          strand: primaryFeat.get('strand'),\n          flags: primaryFeat.get('flags'),\n          id: primaryFeat.id(),\n          tlen: primaryFeat.get('template_length') || 0,\n          pair_orientation: primaryFeat.get('pair_orientation') || '',\n          clipLengthAtStartOfRead:\n            primaryFeat.get('clipLengthAtStartOfRead') || 0,\n          next_ref: primaryFeat.get('next_ref'),\n        },\n        chainId: id,\n        chainMinX: chainMinXPx,\n        chainMaxX: chainMaxXPx,\n        hasSupplementary,\n        chain: chain.map(f => ({\n          name: f.get('name'),\n          refName: f.get('refName'),\n          start: f.get('start'),\n          end: f.get('end'),\n          strand: f.get('strand'),\n          flags: f.get('flags'),\n          id: f.id(),\n          tlen: f.get('template_length') || 0,\n          pair_orientation: f.get('pair_orientation') || '',\n          clipLengthAtStartOfRead: f.get('clipLengthAtStartOfRead') || 0,\n          next_ref: f.get('next_ref'),\n        })),\n      })\n    }\n  }\n}\n\nexport interface DrawFeatsParams {\n  chainData: ChainData\n  featureHeight: number\n  colorBy: ColorBy\n  drawSingletons: boolean\n  drawProperPairs: boolean\n  flipStrandLongReadChains: boolean\n  noSpacing?: boolean\n  trackMaxHeight?: number\n  config: AnyConfigurationModel\n  theme: ThemeOptions\n  regions: BaseBlock[]\n  bpPerPx: number\n  canvasWidth: number\n  stopTokenCheck?: LastStopTokenCheck\n  visibleModifications?: Record<string, ModificationTypeWithColor>\n  hideSmallIndels?: boolean\n  hideMismatches?: boolean\n  hideLargeIndels?: boolean\n  showOutline?: boolean\n}\n\nexport interface DrawFeatsResult {\n  featuresForFlatbush: FlatbushEntry[]\n  layoutHeight?: number\n  cloudMaxDistance?: number\n  mismatchFlatbush: ArrayBufferLike\n  mismatchItems: FlatbushItem[]\n}\n\nexport function drawFeatsCore({\n  ctx,\n  params,\n  view,\n  calculateYOffsets,\n}: {\n  ctx: CanvasRenderingContext2D\n  params: DrawFeatsParams\n  view: any\n  calculateYOffsets: (computedChains: ComputedChain[]) => {\n    chainYOffsets: Map<string, number>\n    layoutHeight?: number\n    cloudMaxDistance?: number\n  }\n}): DrawFeatsResult {\n  const {\n    chainData,\n    featureHeight,\n    colorBy,\n    drawSingletons,\n    drawProperPairs,\n    flipStrandLongReadChains,\n    stopTokenCheck,\n  } = params\n\n  const type = colorBy.type || 'insertSizeAndOrientation'\n  const { chains } = chainData\n\n  // Filter chains based on settings\n  const filteredChains = filterChains(\n    chains,\n    drawSingletons,\n    drawProperPairs,\n    type,\n    chainData,\n  )\n\n  // Compute pixel bounds for each chain\n  const computedChains = computeChainBounds(filteredChains, view)\n\n  // Sort chains: singletons first, then by width within each group\n  sortComputedChains(computedChains)\n\n  // Calculate Y-offsets using the provided strategy\n  const { chainYOffsets, layoutHeight, cloudMaxDistance } =\n    calculateYOffsets(computedChains)\n\n  // Initialize array for Flatbush mouseover data\n  const featuresForFlatbush: FlatbushEntry[] = []\n\n  const renderChevrons = shouldRenderChevrons(view.bpPerPx, featureHeight)\n\n  const viewOffsetPx = view.offsetPx\n\n  // Collect mismatch data for flatbush tooltips\n  const mismatchCoords: number[] = []\n  const mismatchItems: FlatbushItem[] = []\n\n  // Render each region independently with clipping to prevent bleeding between regions\n  for (const region of params.regions) {\n    ctx.save()\n\n    // Set up clipping rect for this region\n    const regionStartPx = region.offsetPx - viewOffsetPx\n    ctx.beginPath()\n    ctx.rect(regionStartPx, 0, region.widthPx, CLIP_RECT_HEIGHT)\n    ctx.clip()\n\n    // Translate coordinate system for this region\n    ctx.translate(regionStartPx, 0)\n\n    // Delegate rendering to specialized functions for paired and long-read chains\n    const pairMismatches = drawPairChains({\n      ctx,\n      type,\n      chainData,\n      chainYOffsets,\n      renderChevrons,\n      featureHeight,\n      computedChains,\n      config: params.config,\n      theme: params.theme,\n      region,\n      regionStartPx,\n      bpPerPx: params.bpPerPx,\n      colorBy: params.colorBy,\n      visibleModifications: params.visibleModifications,\n      stopTokenCheck,\n      hideSmallIndels: params.hideSmallIndels,\n      hideMismatches: params.hideMismatches,\n      hideLargeIndels: params.hideLargeIndels,\n      showOutline: params.showOutline,\n    })\n\n    const longReadMismatches = drawLongReadChains({\n      ctx,\n      chainData,\n      chainYOffsets,\n      renderChevrons,\n      featureHeight,\n      computedChains,\n      flipStrandLongReadChains,\n      config: params.config,\n      theme: params.theme,\n      region,\n      regionStartPx,\n      bpPerPx: params.bpPerPx,\n      colorBy: params.colorBy,\n      visibleModifications: params.visibleModifications,\n      stopTokenCheck,\n      hideSmallIndels: params.hideSmallIndels,\n      hideMismatches: params.hideMismatches,\n      hideLargeIndels: params.hideLargeIndels,\n      showOutline: params.showOutline,\n    })\n\n    // Aggregate mismatch data (avoid push(...list) which can cause stack overflow)\n    for (const coord of pairMismatches.coords) {\n      mismatchCoords.push(coord)\n    }\n    for (const coord of longReadMismatches.coords) {\n      mismatchCoords.push(coord)\n    }\n    for (const item of pairMismatches.items) {\n      mismatchItems.push(item)\n    }\n    for (const item of longReadMismatches.items) {\n      mismatchItems.push(item)\n    }\n\n    ctx.restore()\n  }\n\n  // Add full-width rectangles for each chain to enable mouseover on connecting lines\n  addChainMouseoverRects(\n    computedChains,\n    chainYOffsets,\n    featureHeight,\n    view,\n    featuresForFlatbush,\n  )\n\n  // Build flatbush index for mismatch tooltips\n  const mismatchFlatbush = new Flatbush(Math.max(mismatchItems.length, 1))\n  if (mismatchCoords.length) {\n    for (let i = 0; i < mismatchCoords.length; i += 4) {\n      mismatchFlatbush.add(\n        mismatchCoords[i]!,\n        mismatchCoords[i + 1]!,\n        mismatchCoords[i + 2],\n        mismatchCoords[i + 3],\n      )\n    }\n  } else {\n    mismatchFlatbush.add(0, 0, 0, 0)\n  }\n  mismatchFlatbush.finish()\n\n  return {\n    featuresForFlatbush,\n    layoutHeight,\n    cloudMaxDistance,\n    mismatchFlatbush: mismatchFlatbush.data,\n    mismatchItems,\n  }\n}\n\n/**\n * Build Flatbush index for mismatch mouseover detection\n */\nexport function buildMismatchFlatbushIndex(\n  mismatchFlatbushData: ArrayBuffer,\n  mismatchItems: FlatbushItem[],\n  self: LinearReadCloudDisplayModel,\n) {\n  const mismatchFlatbush = Flatbush.from(mismatchFlatbushData)\n  self.setMismatchLayout(mismatchFlatbush)\n  self.setMismatchItems(mismatchItems)\n}\n"],"names":["lineToCtx","x1","y1","x2","y2","ctx","strokeColor","strokeStyle","beginPath","moveTo","lineTo","stroke","getConnectingLineColor","configTheme","createJBrowseTheme","palette","mode","renderFeatureShape","xPos","yPos","width","height","strand","fillStyle","renderChevrons","showOutline","x","y","color","chevronWidth","closePath","fill","drawChevron","CHEVRON_WIDTH","undefined","drawX","drawY","drawWidth","fillRect","strokeRect","strokeRectCtx","getStrandColorKey","chainIsPairedEnd","chain","element","get","SAM_FLAG_PAIRED","collectNonSupplementary","result","SAM_FLAG_SUPPLEMENTARY","push","getMismatchRenderingConfig","config","colorBy","overrides","mismatchAlpha","readConfObject","minSubfeatureWidth","largeInsertionIndicatorScale","hideSmallIndels","hideMismatches","hideLargeIndels","theme","colorMap","getColorBaseMap","colorContrastMap","getContrastBaseMap","setAlignmentFont","charWidth","charHeight","getCharWidthHeight","drawSNPsMuted","shouldDrawSNPsMuted","type","drawIndels","shouldDrawIndels","featureOverlapsRegion","featRefName","featStart","featEnd","region","refName","end","start","calculateFeaturePositionPx","regionStart","regionEnd","bpPerPx","clippedStart","Math","max","clippedEnd","min","getChainBoundsOnRef","minStart","Number","MAX_VALUE","maxEnd","MIN_VALUE","f","aggregateMismatchData","ret","regionStartPx","allCoords","allItems","i","coords","length","item","items","renderFeatureMismatchesAndModifications","feat","layoutFeat","canvasWidth","visibleModifications","mismatchConfig","renderMismatchesCallback","checkRef","regions","cigarOps","getCigarOps","renderModifications","renderArgs","renderFeatureModifications","getPrimaryStrandFromFlags","flags","SA","res","split","drawLongReadChains","chainData","chainYOffsets","featureHeight","computedChains","flipStrandLongReadChains","stopTokenCheck","widthPx","computedChain","checkStopToken2","id","isPairedEnd","nonSupplementary","chainY","isSingleton","primaryStrand","bounds","lineY","layoutFeats","l","featStrand","effectiveStrand","featureFill","featureStroke","getSingletonColor","tlen","pair_orientation","stats","fillColor","feature","heightPx","topPx","drawPairChains","hasBothMates","pairedFill","pairedStroke","getPairedColor","v0","hasSupplementary","color_supplementary","featFill","featStroke","filterChains","chains","drawSingletons","drawProperPairs","filtered","getPairedType","next_ref","PairType","PROPER_PAIR","computeChainBounds","view","minX","maxX","chainId","tlenDistance","chainLength","j","elt","rs","bpToPx","coord","offsetPx","re","abs","distance","sortComputedChains","sort","a","b","aIsSingleton","bIsSingleton","buildFlatbushIndex","featuresForFlatbush","self","finalFlatbush","Flatbush","add","finish","setFeatureLayout","setFeaturesForFlatbush","drawFeatsCore","params","calculateYOffsets","layoutHeight","cloudMaxDistance","shouldRenderChevrons","viewOffsetPx","mismatchCoords","mismatchItems","save","rect","clip","translate","pairMismatches","longReadMismatches","restore","chainMinXPx","chainMaxXPx","primaryFeat","data","name","clipLengthAtStartOfRead","chainMinX","chainMaxX","map","addChainMouseoverRects","mismatchFlatbush","buildMismatchFlatbushIndex","mismatchFlatbushData","from","setMismatchLayout","setMismatchItems"],"ignoreList":[],"sourceRoot":""}