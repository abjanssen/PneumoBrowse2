{"version":3,"file":"static/js/2812.3eb59f98.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/ModificationParser/getModPositions.ts","../../../plugins/alignments/src/shared/color.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts","../../../plugins/alignments/src/ModificationParser/getModProbabilities.ts","../../../plugins/alignments/src/ModificationParser/getMethBins.ts","../../../plugins/alignments/src/PileupRenderer/renderers/getAlignmentShapeColor.ts","../../../plugins/alignments/src/PileupRenderer/colorBy.ts","../../../plugins/alignments/src/PileupRenderer/util.ts","../../../plugins/alignments/src/PileupRenderer/makeImageData.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderAlignment.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderAlignmentShape.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderPerBaseQuality.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderPerBaseLettering.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderModifications.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderMethylation.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderMismatches.ts","../../../plugins/alignments/src/PileupRenderer/renderers/renderSoftClipping.ts"],"sourcesContent":["import { revcom } from '@jbrowse/core/util'\n\nimport { modificationRegex } from './consts'\n\n/**\n * Parse MM tag to extract modification positions on the read sequence.\n *\n *\n * @param mm - MM tag string (e.g., \"C+m,2,2,1;A+a,0,3\")\n * @param fseq - Read sequence\n * @param fstrand - Read strand (-1, 0, or 1)\n * @returns Array of modification objects with positions\n */\nexport function getModPositions(mm: string, fseq: string, fstrand: number) {\n  const seq = fstrand === -1 ? revcom(fseq) : fseq\n  const seqLength = seq.length\n  const mods = mm.split(';')\n  const result = []\n\n  for (const mod of mods) {\n    // Empty string\n    if (mod === '') {\n      continue\n    }\n\n    const split = mod.split(',')\n    const basemod = split[0]!\n    const matches = modificationRegex.exec(basemod)\n    if (!matches) {\n      throw new Error(`bad format for MM tag: \"${mod}\"`)\n    }\n    const [, base, strand, typestr] = matches\n\n    // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so split,\n    // and they can also be chemical codes (ChEBI) e.g. C+16061\n    const types = typestr!.split(/(\\d+|.)/)\n\n    // Note: Negative strand modifications (e.g., T-a) are now supported\n    // They are processed the same way as positive strand modifications\n    // The strand information is preserved for simplex/duplex detection\n\n    // this logic based on parse_mm.pl from hts-specs\n    for (const type of types) {\n      if (type === '') {\n        continue\n      }\n\n      const splitLength = split.length\n      let currPos = 0\n\n      // For reverse strand, pre-allocate array and fill backwards to avoid reverse()\n      // This is worthwhile because we avoid an O(n) reverse() operation\n      const positions = fstrand === -1 ? new Array(splitLength - 1) : []\n      let writeIndex = fstrand === -1 ? splitLength - 2 : 0\n\n      for (let i = 1; i < splitLength; i++) {\n        let delta = +split[i]!\n        do {\n          if (base === 'N' || base === seq[currPos]) {\n            delta--\n          }\n          currPos++\n        } while (delta >= 0 && currPos < seqLength)\n\n        // Calculate and store position\n        if (fstrand === -1) {\n          const pos = seqLength - currPos\n          if (pos >= 0) {\n            // avoid negative-number-positions in array, seen in #4629 cause\n            // unknown, could warrant some further investigation\n            positions[writeIndex--] = pos\n          } else {\n            // Position is negative (edge case from #4629)\n            // Don't write anything, don't decrement writeIndex\n            // This leaves a gap at the beginning of the array that we'll slice off\n          }\n        } else {\n          positions[writeIndex++] = currPos - 1\n        }\n      }\n\n      // For reverse strand, slice off any unfilled slots at the beginning\n      // (happens when some positions were negative and skipped)\n      const validPositions =\n        fstrand === -1 ? positions.slice(writeIndex + 1) : positions\n\n      result.push({\n        type,\n        base: base!,\n        strand: strand!,\n        positions: validPositions,\n      })\n    }\n  }\n\n  return result\n}\n","import { orientationTypes, pairMap } from '../util'\n\nimport type { ChainStats, ReducedFeature } from './fetchChains'\n\n/**\n * Numeric codes for pair types\n * Used to classify paired-end reads without relying on color string comparisons\n */\nexport const PairType = {\n  /** Proper pair: correct orientation (LR) and normal insert size */\n  PROPER_PAIR: 0,\n  /** Long insert: same chromosome but insert size exceeds upper threshold */\n  LONG_INSERT: 1,\n  /** Short insert: same chromosome but insert size below lower threshold */\n  SHORT_INSERT: 2,\n  /** Inter-chromosome: mates on different chromosomes */\n  INTER_CHROM: 3,\n  /** Abnormal orientation: RR, RL, LL, etc. (not LR) */\n  ABNORMAL_ORIENTATION: 4,\n  /** Unmapped mate: mate is unmapped */\n  UNMAPPED_MATE: 5,\n} as const\n\nexport type PairTypeValue = (typeof PairType)[keyof typeof PairType]\n\nexport const fillColor = {\n  color_fwd_strand_not_proper: '#ECC8C8',\n  color_rev_strand_not_proper: '#BEBED8',\n  color_fwd_strand: '#EC8B8B',\n  color_rev_strand: '#8F8FD8',\n  color_fwd_missing_mate: '#D11919',\n  color_rev_missing_mate: '#1919D1',\n  color_fwd_diff_chr: '#000',\n  color_rev_diff_chr: '#969696',\n  color_pair_lr: '#c8c8c8',\n  color_pair_rr: '#3a3a9d',\n  color_pair_rl: 'teal',\n  color_pair_ll: 'green',\n  color_nostrand: '#c8c8c8',\n  color_interchrom: 'purple',\n  color_longinsert: 'red',\n  color_shortinsert: 'pink',\n  color_unmapped_mate: '#8B008B',\n  color_unknown: 'grey',\n}\n\n// manually calculated by running\n// const color = require('color')\n// Object.fromEntries(Object.entries(fillColor).map(([key,val])=>{\n//   return [key, color(val).darken('0.3').hex()]\n// }))\n// this avoids (expensive) use of Color module at runtime\nexport const strokeColor = {\n  color_fwd_strand_not_proper: '#CA6767',\n  color_rev_strand_not_proper: '#7272AA',\n  color_fwd_strand: '#DC2A2A',\n  color_rev_strand: '#4141BA',\n  color_fwd_missing_mate: '#921111',\n  color_rev_missing_mate: '#111192',\n  color_fwd_diff_chr: '#000000',\n  color_rev_diff_chr: '#696969',\n  color_pair_lr: '#8C8C8C',\n  color_pair_rr: '#00002A',\n  color_pair_rl: '#005A5A',\n  color_pair_ll: '#005A00',\n  color_nostrand: '#8C8C8C',\n  color_interchrom: '#5A005A',\n  color_longinsert: '#B30000',\n  color_shortinsert: '#FF3A5C',\n  color_unmapped_mate: '#5A005A',\n  color_unknown: '#444',\n}\n\nconst defaultColor = [\n  fillColor.color_pair_lr,\n  strokeColor.color_pair_lr,\n] as const\n\n/**\n * Get the pair type classification for a paired-end read\n * Used internally by color functions and externally for filtering logic\n *\n * @param type - Color scheme type (insertSizeAndOrientation, orientation, insertSize)\n * @param f1 - First read in the pair\n * @param f2 - Second read in the pair\n * @param stats - Optional statistics for insert size thresholds\n * @returns Numeric code representing the pair type\n */\nexport function getPairedType({\n  type,\n  f1,\n  f2,\n  stats,\n}: {\n  type: string\n  f1: {\n    refName: string\n    pair_orientation?: string\n    tlen?: number\n    flags?: number\n  }\n  f2: { refName: string }\n  stats?: ChainStats\n}): PairTypeValue {\n  // Check for unmapped mate first (highest priority)\n  if (f1.flags !== undefined && f1.flags & 8) {\n    return PairType.UNMAPPED_MATE\n  }\n\n  // Check orientation first (if applicable)\n  if (type === 'insertSizeAndOrientation' || type === 'orientation') {\n    const orientationType = orientationTypes.fr\n    const r = orientationType[f1.pair_orientation || ''] as\n      | keyof typeof pairMap\n      | undefined\n    // If orientation is not LR (proper), it's abnormal\n    if (r && r !== 'LR') {\n      return PairType.ABNORMAL_ORIENTATION\n    }\n  }\n\n  // Check insert size (if applicable)\n  if (type === 'insertSizeAndOrientation' || type === 'insertSize') {\n    const sameRef = f1.refName === f2.refName\n    const tlen = Math.abs(f1.tlen || 0)\n\n    if (!sameRef) {\n      return PairType.INTER_CHROM\n    }\n\n    if (stats) {\n      if (tlen > stats.upper) {\n        return PairType.LONG_INSERT\n      }\n      if (tlen < stats.lower) {\n        return PairType.SHORT_INSERT\n      }\n    }\n  }\n\n  // If all checks pass, it's a proper pair\n  return PairType.PROPER_PAIR\n}\n\n/**\n * Get color for a paired-end read based on insert size only\n * Uses getPairedType() internally to determine classification\n */\nexport function getPairedInsertSizeColor(\n  f1: { refName: string; tlen?: number; flags?: number },\n  f2: { refName: string },\n  stats?: ChainStats,\n) {\n  const pairType = getPairedType({ type: 'insertSize', f1, f2, stats })\n\n  switch (pairType) {\n    case PairType.UNMAPPED_MATE:\n      return [\n        fillColor.color_unmapped_mate,\n        strokeColor.color_unmapped_mate,\n      ] as const\n    case PairType.LONG_INSERT:\n      return [fillColor.color_longinsert, strokeColor.color_longinsert] as const\n    case PairType.SHORT_INSERT:\n      return [\n        fillColor.color_shortinsert,\n        strokeColor.color_shortinsert,\n      ] as const\n    case PairType.INTER_CHROM:\n      return [fillColor.color_interchrom, strokeColor.color_interchrom] as const\n    case PairType.PROPER_PAIR:\n      return undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n * Get color for a paired-end read based on orientation only\n * Returns undefined for proper pairs (LR orientation)\n */\nexport function getPairedOrientationColorOrDefault(f: {\n  pair_orientation?: string\n  flags?: number\n}) {\n  // Check for unmapped mate first\n  if (f.flags !== undefined && f.flags & 8) {\n    return [\n      fillColor.color_unmapped_mate,\n      strokeColor.color_unmapped_mate,\n    ] as const\n  }\n\n  const type = orientationTypes.fr\n  const r = type[f.pair_orientation || ''] as keyof typeof pairMap\n  const type2 = pairMap[r] as keyof typeof fillColor\n  return r === 'LR'\n    ? undefined\n    : ([fillColor[type2], strokeColor[type2]] as const)\n}\n\n/**\n * Get color for a paired-end read based on orientation only\n * Returns default color for proper pairs\n */\nexport function getPairedOrientationColor(f: {\n  pair_orientation?: string\n  flags?: number\n}) {\n  return getPairedOrientationColorOrDefault(f) || defaultColor\n}\n\n/**\n * Get color for a paired-end read based on both insert size and orientation\n * Prioritizes orientation coloring over insert size coloring\n * Uses getPairedType() internally to determine classification\n */\nexport function getPairedInsertSizeAndOrientationColor(\n  f1: {\n    refName: string\n    pair_orientation?: string\n    tlen?: number\n    flags?: number\n  },\n  f2: { refName: string },\n  stats?: ChainStats,\n) {\n  return (\n    getPairedOrientationColorOrDefault(f1) ||\n    getPairedInsertSizeColor(f1, f2, stats) ||\n    defaultColor\n  )\n}\n\nexport function getSingletonColor(f: { tlen?: number }, stats?: ChainStats) {\n  const tlen = Math.abs(f.tlen || 0)\n  // If TLEN is abnormally large, color it dark red\n  if (stats && tlen > stats.upper) {\n    return [\n      fillColor.color_fwd_missing_mate,\n      strokeColor.color_fwd_missing_mate,\n    ] as const\n  }\n  // Otherwise use properly paired coloring for normal-looking singletons\n  return defaultColor // [fillColor.color_pair_lr, strokeColor.color_pair_lr] as const\n}\n\nexport function getPairedColor({\n  type,\n  v0,\n  v1,\n  stats,\n}: {\n  type: string\n  v0: ReducedFeature\n  v1: ReducedFeature\n  stats?: ChainStats\n}) {\n  if (type === 'insertSizeAndOrientation') {\n    return getPairedInsertSizeAndOrientationColor(v0, v1, stats)\n  }\n  if (type === 'orientation') {\n    return getPairedOrientationColor(v0)\n  }\n  if (type === 'insertSize') {\n    return getPairedInsertSizeColor(v0, v1, stats)\n  }\n  return undefined\n}\n","import { getNextRefPos, parseCigar } from '../MismatchParser'\nimport { getModPositions } from '../ModificationParser/getModPositions'\nimport { getModProbabilities } from '../ModificationParser/getModProbabilities'\nimport { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  cigarOps?: string[],\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const ops = cigarOps || parseCigar(feature.get('CIGAR'))\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n","import { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getModProbabilities(feature: Feature) {\n  // ML stores probabilities as array of numerics and MP is scaled phred scores\n  // https://github.com/samtools/hts-specs/pull/418/files#diff-e765c6479316309f56b636f88189cdde8c40b854c7bdcce9ee7fe87a4e76febcR596\n  //\n  // - if we have ML or Ml, it is an 8bit probability, divide by 255\n  //\n  // - if we have MP or Mp it is phred scaled ASCII, which can go up to 90 but\n  // has very high likelihood basecalls at that point, we really only care about\n  // low qual calls <20 approx\n  const m = (getTagAlt(feature, 'ML', 'Ml') as number[] | string) || []\n  if (m) {\n    const result = []\n    if (typeof m === 'string') {\n      const parts = m.split(',')\n      for (let i = 0, l = parts.length; i < l; i++) {\n        result.push(+parts[i]! / 255)\n      }\n    } else {\n      for (let i = 0, l = m.length; i < l; i++) {\n        result.push(m[i]! / 255)\n      }\n    }\n    return result\n  } else {\n    const mp = getTagAlt(feature, 'MP', 'Mp') as string | undefined\n    if (mp) {\n      const result = []\n      for (let i = 0, l = mp.length; i < l; i++) {\n        const phred = mp.charCodeAt(i) - 33\n        result.push(Math.min(1, phred / 50))\n      }\n      return result\n    }\n    return undefined\n  }\n}\n","import { getNextRefPos } from '../MismatchParser'\nimport { getModPositions } from './getModPositions'\nimport { getModProbabilities } from './getModProbabilities'\nimport { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getMethBins(feature: Feature, cigarOps: string[]) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const flen = fend - fstart\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string | undefined) || ''\n  const methBins = []\n  const hydroxyMethBins = []\n  const methProbs = []\n  const hydroxyMethProbs = []\n  const seq = feature.get('seq') as string | undefined\n  if (seq) {\n    const probabilities = getModProbabilities(feature)\n    const modifications = getModPositions(mm, seq, fstrand)\n    let probIndex = 0\n\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n        // Skip positions outside the feature bounds\n        if (ref < 0 || ref >= flen) {\n          continue\n        }\n\n        // Calculate probability index based on strand\n        const isReverseStrand = fstrand === -1\n        const idx2 =\n          probIndex + (isReverseStrand ? positions.length - 1 - idx : idx)\n        const prob = probabilities?.[idx2] || 0\n\n        // Store modification data in appropriate bins\n        if (type === 'm') {\n          methBins[ref] = 1\n          methProbs[ref] = prob\n        } else if (type === 'h') {\n          hydroxyMethBins[ref] = 1\n          hydroxyMethProbs[ref] = prob\n        }\n      }\n      probIndex += positions.length\n    }\n  }\n  return {\n    methBins,\n    hydroxyMethBins,\n    methProbs,\n    hydroxyMethProbs,\n  }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\n\nimport { fillColor } from '../../shared/color'\nimport {\n  colorByInsertSize,\n  colorByMappingQuality,\n  colorByOrientation,\n  colorByStrand,\n  colorByStrandedRnaSeq,\n} from '../colorBy'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getAlignmentShapeColor({\n  colorType,\n  tag,\n  feature,\n  config,\n  defaultColor,\n  colorTagMap,\n}: {\n  colorType: string\n  tag: string\n  feature: Feature\n  defaultColor: boolean\n  config: AnyConfigurationModel\n  colorTagMap: Record<string, string>\n}) {\n  // first pass for simple color changes that change the color of the\n  // alignment\n  switch (colorType) {\n    case 'insertSize':\n      return colorByInsertSize(feature)\n    case 'strand':\n      return colorByStrand(feature)\n    case 'mappingQuality':\n      return colorByMappingQuality(feature)\n    case 'pairOrientation':\n      return colorByOrientation(feature, config)\n    case 'stranded':\n      return colorByStrandedRnaSeq(feature)\n    case 'xs':\n    case 'tag': {\n      const tags = feature.get('tags')\n      const val = tags ? tags[tag] : feature.get(tag)\n\n      if (tag === 'XS' || tag === 'TS') {\n        if (val === '-') {\n          return fillColor.color_rev_strand\n        } else if (val === '+') {\n          return fillColor.color_fwd_strand\n        } else {\n          return fillColor.color_nostrand\n        }\n      }\n      if (tag === 'ts') {\n        if (val === '-') {\n          return feature.get('strand') === -1\n            ? fillColor.color_fwd_strand\n            : fillColor.color_rev_strand\n        } else if (val === '+') {\n          return feature.get('strand') === -1\n            ? fillColor.color_rev_strand\n            : fillColor.color_fwd_strand\n        } else {\n          return fillColor.color_nostrand\n        }\n      }\n      return colorTagMap[val] || fillColor.color_nostrand\n    }\n    case 'insertSizeAndPairOrientation':\n      break\n\n    case 'modifications':\n    case 'methylation':\n      // this coloring is similar to igv.js, and is helpful to color negative\n      // strand reads differently because their c-g will be flipped (e.g. g-c\n      // read right to left)\n      return feature.get('flags') & 16 ? '#c8dcc8' : '#c8c8c8'\n\n    default:\n      return defaultColor\n        ? 'lightgrey'\n        : readConfObject(config, 'color', { feature })\n  }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\n\nimport { fillColor } from '../shared/color'\nimport { orientationTypes } from '../util'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function colorByInsertSize(feature: Feature) {\n  return feature.get('is_paired') &&\n    feature.get('refName') !== feature.get('next_ref')\n    ? '#555'\n    : `hsl(${Math.abs(feature.get('template_length')) / 10},50%,50%)`\n}\n\nexport function colorByMappingQuality(feature: Feature) {\n  return `hsl(${feature.get('score')},50%,50%)`\n}\n\nfunction getOrientation(feature: Feature, config: AnyConfigurationModel) {\n  const orientationType = readConfObject(config, 'orientationType') as\n    | 'fr'\n    | 'ff'\n    | 'rf'\n  const type = orientationTypes[orientationType]\n  const orientation = type[feature.get('pair_orientation') as string]!\n  return {\n    LR: 'color_pair_lr' as const,\n    RR: 'color_pair_rr' as const,\n    RL: 'color_pair_rl' as const,\n    LL: 'color_pair_ll' as const,\n  }[orientation]\n}\n\nexport function colorByStrand(feature: Feature) {\n  return feature.get('strand') === -1 ? '#8F8FD8' : '#EC8B8B'\n}\n\nexport function colorByOrientation(\n  feature: Feature,\n  config: AnyConfigurationModel,\n) {\n  return fillColor[getOrientation(feature, config) || 'color_nostrand']\n}\nfunction getStranded(feature: Feature) {\n  const flags = feature.get('flags')\n  const strand = feature.get('strand')\n\n  // is paired\n  if (flags & 1) {\n    // first-of-pair?\n    const flipper = flags & 64 ? -1 : 1\n\n    // proper pairing\n    if (flags & 2) {\n      return strand * flipper === 1 ? 'color_rev_strand' : 'color_fwd_strand'\n    }\n    // mate missing, separate color\n    if (flags & 8) {\n      return strand * flipper === 1\n        ? 'color_rev_missing_mate'\n        : 'color_fwd_missing_mate'\n    }\n    // same chrom without proper pairing gets separate color\n    if (feature.get('refName') === feature.get('next_ref')) {\n      return strand * flipper === 1\n        ? 'color_rev_strand_not_proper'\n        : 'color_fwd_strand_not_proper'\n    }\n    // abberant chrom\n\n    return strand === 1 ? 'color_fwd_diff_chr' : 'color_rev_diff_chr'\n  }\n  return 'color_unknown'\n}\n\nexport function colorByStrandedRnaSeq(feature: Feature) {\n  return fillColor[getStranded(feature)]\n}\n","import { measureText } from '@jbrowse/core/util'\n\nimport type { Feature } from '@jbrowse/core/util'\nimport type { Theme } from '@mui/material'\n\nexport function fillRect(\n  ctx: CanvasRenderingContext2D,\n  l: number,\n  t: number,\n  w: number,\n  h: number,\n  cw: number,\n  color?: string,\n) {\n  if (l + w < 0 || l > cw) {\n    return\n  }\n  if (color) {\n    ctx.fillStyle = color\n  }\n  ctx.fillRect(l, t, w, h)\n}\n\nexport function getColorBaseMap(theme: Theme) {\n  const { skip, deletion, insertion, hardclip, softclip, bases } = theme.palette\n  return {\n    A: bases.A.main,\n    C: bases.C.main,\n    G: bases.G.main,\n    T: bases.T.main,\n    deletion,\n    insertion,\n    hardclip,\n    softclip,\n    skip,\n  }\n}\n\nexport function getContrastBaseMap(theme: Theme) {\n  return Object.fromEntries(\n    Object.entries(getColorBaseMap(theme)).map(([key, value]) => [\n      key,\n      theme.palette.getContrastText(value),\n    ]),\n  )\n}\n\nexport function shouldDrawSNPsMuted(type?: string) {\n  return ['methylation', 'modifications'].includes(type || '')\n}\n\nexport function shouldDrawIndels() {\n  return true\n}\n\nexport interface LayoutFeature {\n  heightPx: number\n  topPx: number\n  feature: Feature\n}\n\n// get width and height of chars the height is an approximation: width letter M\n// is approximately the height\nexport function getCharWidthHeight() {\n  const charWidth = measureText('A')\n  const charHeight = measureText('M') - 2\n  return { charWidth, charHeight }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\nimport { forEachWithStopTokenCheck } from '@jbrowse/core/util'\nimport Flatbush from '@jbrowse/core/util/flatbush'\n\nimport { renderAlignment } from './renderers/renderAlignment'\nimport { renderMismatches } from './renderers/renderMismatches'\nimport { renderSoftClipping } from './renderers/renderSoftClipping'\nimport {\n  getCharWidthHeight,\n  getColorBaseMap,\n  getContrastBaseMap,\n  shouldDrawIndels,\n  shouldDrawSNPsMuted,\n} from './util'\n\nimport type { FlatbushItem, ProcessedRenderArgs } from './types'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface LayoutFeature {\n  heightPx: number\n  topPx: number\n  feature: Feature\n}\n\nexport function makeImageData({\n  ctx,\n  layoutRecords,\n  canvasWidth,\n  renderArgs,\n}: {\n  ctx: CanvasRenderingContext2D\n  canvasWidth: number\n  layoutRecords: LayoutFeature[]\n  renderArgs: ProcessedRenderArgs\n}) {\n  const {\n    stopToken,\n    config,\n    showSoftClip,\n    colorBy,\n    theme: configTheme,\n  } = renderArgs\n  const mismatchAlpha = readConfObject(config, 'mismatchAlpha')\n  const minSubfeatureWidth = readConfObject(config, 'minSubfeatureWidth')\n  const largeInsertionIndicatorScale = readConfObject(\n    config,\n    'largeInsertionIndicatorScale',\n  )\n  const hideSmallIndels = readConfObject(config, 'hideSmallIndels') as boolean\n  const defaultColor = readConfObject(config, 'color') === '#f0f'\n  const theme = createJBrowseTheme(configTheme)\n  const colorMap = getColorBaseMap(theme)\n  const colorContrastMap = getContrastBaseMap(theme)\n  ctx.font = 'bold 10px Courier New,monospace'\n\n  const { charWidth, charHeight } = getCharWidthHeight()\n  const drawSNPsMuted = shouldDrawSNPsMuted(colorBy?.type)\n  const drawIndels = shouldDrawIndels()\n  const coords = [] as number[]\n  const items = [] as FlatbushItem[]\n  forEachWithStopTokenCheck(layoutRecords, stopToken, feat => {\n    const alignmentRet = renderAlignment({\n      ctx,\n      feat,\n      renderArgs,\n      defaultColor,\n      colorMap,\n      colorContrastMap,\n      charWidth,\n      charHeight,\n      canvasWidth,\n    })\n    for (let i = 0, l = alignmentRet.coords.length; i < l; i++) {\n      coords.push(alignmentRet.coords[i]!)\n    }\n    for (let i = 0, l = alignmentRet.items.length; i < l; i++) {\n      items.push(alignmentRet.items[i]!)\n    }\n    const ret = renderMismatches({\n      ctx,\n      feat,\n      renderArgs,\n      hideSmallIndels,\n      mismatchAlpha,\n      drawSNPsMuted,\n      drawIndels,\n      largeInsertionIndicatorScale,\n      minSubfeatureWidth,\n      charWidth,\n      charHeight,\n      colorMap,\n      colorContrastMap,\n      canvasWidth,\n    })\n    for (let i = 0, l = ret.coords.length; i < l; i++) {\n      coords.push(ret.coords[i]!)\n    }\n    for (let i = 0, l = ret.items.length; i < l; i++) {\n      items.push(ret.items[i]!)\n    }\n    if (showSoftClip) {\n      renderSoftClipping({\n        ctx,\n        feat,\n        renderArgs,\n        colorMap,\n        config,\n        theme,\n        canvasWidth,\n      })\n    }\n  })\n  const flatbush = new Flatbush(Math.max(items.length, 1))\n  if (coords.length) {\n    for (let i = 0; i < coords.length; i += 4) {\n      flatbush.add(coords[i]!, coords[i + 1]!, coords[i + 2], coords[i + 3])\n    }\n  } else {\n    flatbush.add(0, 0)\n  }\n  flatbush.finish()\n  return {\n    flatbush: flatbush.data,\n    items,\n  }\n}\n","import { getAlignmentShapeColor } from './getAlignmentShapeColor'\nimport { renderAlignmentShape } from './renderAlignmentShape'\nimport { renderMethylation } from './renderMethylation'\nimport { renderModifications } from './renderModifications'\nimport { renderPerBaseLettering } from './renderPerBaseLettering'\nimport { renderPerBaseQuality } from './renderPerBaseQuality'\nimport { parseCigar } from '../../MismatchParser'\n\nimport type { FlatbushItem, ProcessedRenderArgs } from '../types'\nimport type { LayoutFeature } from '../util'\n\nexport function renderAlignment({\n  ctx,\n  feat,\n  renderArgs,\n  colorMap,\n  colorContrastMap,\n  charWidth,\n  charHeight,\n  defaultColor,\n  canvasWidth,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  renderArgs: ProcessedRenderArgs\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  charWidth: number\n  charHeight: number\n  defaultColor: boolean\n  canvasWidth: number\n}) {\n  const items = [] as FlatbushItem[]\n  const coords = [] as number[]\n  const { config, bpPerPx, regions, colorBy, colorTagMap = {} } = renderArgs\n  const { tag = '', type: colorType = '' } = colorBy || {}\n  const { feature } = feat\n  const region = regions[0]!\n\n  ctx.fillStyle = getAlignmentShapeColor({\n    feature,\n    config,\n    tag,\n    defaultColor,\n    colorType,\n    colorTagMap,\n  })\n\n  renderAlignmentShape({ ctx, feat, renderArgs })\n\n  // second pass for color types that render per-base things that go over the\n  // existing drawing\n  switch (colorType) {\n    case 'perBaseQuality': {\n      const cigarOps = parseCigar(feature.get('CIGAR'))\n      renderPerBaseQuality({\n        ctx,\n        feat,\n        region,\n        bpPerPx,\n        canvasWidth,\n        cigarOps,\n      })\n      break\n    }\n\n    case 'perBaseLettering': {\n      const cigarOps = parseCigar(feature.get('CIGAR'))\n      renderPerBaseLettering({\n        ctx,\n        feat,\n        region,\n        bpPerPx,\n        colorMap,\n        colorContrastMap,\n        charWidth,\n        charHeight,\n        canvasWidth,\n        cigarOps,\n      })\n      break\n    }\n\n    case 'modifications': {\n      const cigarOps = parseCigar(feature.get('CIGAR'))\n      const ret = renderModifications({\n        ctx,\n        feat,\n        region,\n        bpPerPx,\n        renderArgs,\n        canvasWidth,\n        cigarOps,\n      })\n      for (let i = 0, l = ret.coords.length; i < l; i++) {\n        coords.push(ret.coords[i]!)\n      }\n      for (let i = 0, l = ret.items.length; i < l; i++) {\n        items.push(ret.items[i]!)\n      }\n      break\n    }\n\n    case 'methylation': {\n      const cigarOps = parseCigar(feature.get('CIGAR'))\n      renderMethylation({\n        ctx,\n        feat,\n        region,\n        bpPerPx,\n        renderArgs,\n        canvasWidth,\n        cigarOps,\n      })\n      break\n    }\n  }\n\n  return { coords, items }\n}\n","import { bpSpanPx } from '@jbrowse/core/util'\n\nimport { parseCigar } from '../../MismatchParser'\n\nimport type { ProcessedRenderArgs } from '../types'\nimport type { LayoutFeature } from '../util'\n\nexport function renderAlignmentShape({\n  ctx,\n  feat,\n  renderArgs,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  renderArgs: ProcessedRenderArgs\n}) {\n  const { regions, bpPerPx } = renderArgs\n  const { heightPx, topPx, feature } = feat\n  const region = regions[0]!\n  const s = feature.get('start')\n  const e = feature.get('end')\n  const CIGAR = feature.get('CIGAR') as string | undefined\n  const flip = region.reversed ? -1 : 1\n  const strand = feature.get('strand') * flip\n  const renderChevrons = bpPerPx < 10 && heightPx > 5\n  if (CIGAR?.includes('N')) {\n    const cigarOps = parseCigar(CIGAR)\n    if (strand === 1) {\n      let drawLen = 0\n      let drawStart = s\n      for (let i = 0; i < cigarOps.length; i += 2) {\n        const opLen = +cigarOps[i]!\n        const op = cigarOps[i + 1]!\n        if (op === 'M' || op === 'X' || op === '=' || op === 'D') {\n          drawLen += opLen\n        } else if (op === 'N') {\n          if (drawStart !== drawLen) {\n            const [leftPx, rightPx] = bpSpanPx(\n              drawStart,\n              drawStart + drawLen,\n              region,\n              bpPerPx,\n            )\n            const w = rightPx - leftPx\n            ctx.fillRect(leftPx, topPx, w, heightPx)\n          }\n          drawStart += drawLen + opLen\n          drawLen = 0\n        }\n      }\n\n      if (drawStart !== drawLen) {\n        const [leftPx, rightPx] = bpSpanPx(\n          drawStart,\n          drawStart + drawLen,\n          region,\n          bpPerPx,\n        )\n        const w = rightPx - leftPx\n\n        if (renderChevrons) {\n          ctx.beginPath()\n          ctx.moveTo(leftPx, topPx)\n          ctx.lineTo(leftPx, topPx + heightPx)\n          ctx.lineTo(rightPx, topPx + heightPx)\n          ctx.lineTo(rightPx + 5, topPx + heightPx / 2)\n          ctx.lineTo(rightPx, topPx)\n          ctx.closePath()\n          ctx.fill()\n        } else {\n          ctx.fillRect(leftPx, topPx, w, heightPx)\n        }\n      }\n    } else if (strand === -1) {\n      let drawLen = 0\n      let drawStart = e\n      for (let i = cigarOps.length - 2; i >= 0; i -= 2) {\n        const opLen = +cigarOps[i]!\n        const op = cigarOps[i + 1]!\n        if (op === 'M' || op === 'X' || op === '=' || op === 'D') {\n          drawLen += opLen\n        } else if (op === 'N') {\n          if (drawLen !== 0) {\n            const [leftPx, rightPx] = bpSpanPx(\n              drawStart - drawLen,\n              drawStart,\n              region,\n              bpPerPx,\n            )\n            ctx.fillRect(leftPx, topPx, rightPx - leftPx, heightPx)\n          }\n          drawStart -= drawLen + opLen\n          drawLen = 0\n        }\n      }\n\n      if (drawLen !== 0) {\n        const [leftPx, rightPx] = bpSpanPx(\n          drawStart - drawLen,\n          drawStart,\n          region,\n          bpPerPx,\n        )\n        const w = rightPx - leftPx\n\n        if (renderChevrons) {\n          ctx.beginPath()\n          ctx.moveTo(leftPx - 5, topPx + heightPx / 2)\n          ctx.lineTo(leftPx, topPx + heightPx)\n          ctx.lineTo(rightPx, topPx + heightPx)\n          ctx.lineTo(rightPx, topPx)\n          ctx.lineTo(leftPx, topPx)\n          ctx.closePath()\n          ctx.fill()\n        } else {\n          ctx.fillRect(leftPx, topPx, w, heightPx)\n        }\n      }\n    }\n  } else {\n    const [leftPx, rightPx] = bpSpanPx(s, e, region, bpPerPx)\n    if (bpPerPx < 10 && heightPx > 5) {\n      if (strand === -1) {\n        ctx.beginPath()\n        ctx.moveTo(leftPx - 5, topPx + heightPx / 2)\n        ctx.lineTo(leftPx, topPx + heightPx)\n        ctx.lineTo(rightPx, topPx + heightPx)\n        ctx.lineTo(rightPx, topPx)\n        ctx.lineTo(leftPx, topPx)\n        ctx.closePath()\n        ctx.fill()\n      } else {\n        ctx.beginPath()\n        ctx.moveTo(leftPx, topPx)\n        ctx.lineTo(leftPx, topPx + heightPx)\n        ctx.lineTo(rightPx, topPx + heightPx)\n        ctx.lineTo(rightPx + 5, topPx + heightPx / 2)\n        ctx.lineTo(rightPx, topPx)\n        ctx.closePath()\n        ctx.fill()\n      }\n    } else {\n      ctx.fillRect(leftPx, topPx, rightPx - leftPx, heightPx)\n    }\n  }\n}\n","import { bpSpanPx } from '@jbrowse/core/util'\n\nimport { fillRect } from '../util'\n\nimport type { LayoutFeature } from '../util'\nimport type { Region } from '@jbrowse/core/util'\n\nexport function renderPerBaseQuality({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  canvasWidth,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  canvasWidth: number\n  cigarOps: string[]\n}) {\n  const { feature, topPx, heightPx } = feat\n  const qual: string = feature.get('qual') || ''\n  const scores = qual.split(' ').map(val => +val)\n  const w = 1 / bpPerPx\n  const start = feature.get('start')\n  let soffset = 0 // sequence offset\n  let roffset = 0 // reference offset\n\n  for (let i = 0; i < cigarOps.length; i += 2) {\n    const len = +cigarOps[i]!\n    const op = cigarOps[i + 1]!\n    if (op === 'S' || op === 'I') {\n      soffset += len\n    } else if (op === 'D' || op === 'N') {\n      roffset += len\n    } else if (op === 'M' || op === 'X' || op === '=') {\n      for (let m = 0; m < len; m++) {\n        const score = scores[soffset + m]!\n        const start0 = start + roffset + m\n        const leftPx = bpSpanPx(start0, start0 + 1, region, bpPerPx)[0]\n        const c = `hsl(${score === 255 ? 150 : score * 1.5},55%,50%)`\n        fillRect(ctx, leftPx, topPx, w + 0.5, heightPx, canvasWidth, c)\n      }\n      soffset += len\n      roffset += len\n    }\n  }\n}\n","import { bpSpanPx } from '@jbrowse/core/util'\n\nimport { fillRect } from '../util'\n\nimport type { LayoutFeature } from '../util'\nimport type { Region } from '@jbrowse/core/util'\n\nexport function renderPerBaseLettering({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  colorMap,\n  colorContrastMap,\n  charWidth,\n  charHeight,\n  canvasWidth,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  charWidth: number\n  charHeight: number\n  canvasWidth: number\n  cigarOps: string[]\n}) {\n  const heightLim = charHeight - 2\n  const { feature, topPx, heightPx } = feat\n  const seq = feature.get('seq') as string | undefined\n  const w = 1 / bpPerPx\n  const start = feature.get('start')\n  let soffset = 0\n  let roffset = 0\n\n  if (!seq) {\n    return\n  }\n  for (let i = 0; i < cigarOps.length; i += 2) {\n    const len = +cigarOps[i]!\n    const op = cigarOps[i + 1]!\n    if (op === 'S' || op === 'I') {\n      soffset += len\n    } else if (op === 'D' || op === 'N') {\n      roffset += len\n    } else if (op === 'M' || op === 'X' || op === '=') {\n      for (let m = 0; m < len; m++) {\n        const letter = seq[soffset + m]!\n        const r = start + roffset + m\n        const [leftPx] = bpSpanPx(r, r + 1, region, bpPerPx)\n        const c = colorMap[letter]\n        fillRect(ctx, leftPx, topPx, w + 0.5, heightPx, canvasWidth, c)\n\n        if (w >= charWidth && heightPx >= heightLim) {\n          // normal SNP coloring\n          ctx.fillStyle = colorContrastMap[letter]!\n          ctx.fillText(\n            letter,\n            leftPx + (w - charWidth) / 2 + 1,\n            topPx + heightPx,\n          )\n        }\n      }\n      soffset += len\n      roffset += len\n    }\n  }\n}\n","import { bpSpanPx, max, sum } from '@jbrowse/core/util'\n\nimport { getNextRefPos } from '../../MismatchParser'\nimport { getModPositions } from '../../ModificationParser/getModPositions'\nimport { getModProbabilities } from '../../ModificationParser/getModProbabilities'\nimport { getMaxProbModAtEachPosition } from '../../shared/getMaximumModificationAtEachPosition'\nimport { getModificationName } from '../../shared/modificationData'\nimport { alphaColor } from '../../shared/util'\nimport { getTagAlt } from '../../util'\nimport { fillRect } from '../util'\n\nimport type { FlatbushItem, ProcessedRenderArgs } from '../types'\nimport type { LayoutFeature } from '../util'\nimport type { Region } from '@jbrowse/core/util'\n\n// render modifications stored in MM tag in BAM\nexport function renderModifications({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  renderArgs,\n  canvasWidth,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  renderArgs: ProcessedRenderArgs\n  canvasWidth: number\n  cigarOps: string[]\n}) {\n  const items = [] as FlatbushItem[]\n  const coords = [] as number[]\n  const { feature, topPx, heightPx } = feat\n  const { colorBy, visibleModifications = {} } = renderArgs\n\n  const seq = feature.get('seq') as string | undefined\n\n  if (!seq) {\n    return { coords, items }\n  }\n  const start = feature.get('start')\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  const twoColor = colorBy?.modifications?.twoColor\n  const modificationThreshold = colorBy?.modifications?.threshold ?? 10\n  const thresholdFraction = modificationThreshold / 100\n\n  // Get all modifications with strand info for tooltip\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const modifications = getModPositions(mm, seq, fstrand)\n  const probabilities = getModProbabilities(feature)\n\n  // Build a map of position -> list of modifications with strand info\n  const modsByPosition = new Map<\n    number,\n    { type: string; base: string; strand: string; prob: number }[]\n  >()\n\n  let probIndex = 0\n  for (const { type, base, strand, positions } of modifications) {\n    for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n      const prob =\n        probabilities?.[\n          probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n        ] || 0\n\n      if (!modsByPosition.has(ref)) {\n        modsByPosition.set(ref, [])\n      }\n      modsByPosition.get(ref)!.push({ type, base, strand, prob })\n    }\n    probIndex += positions.length\n  }\n\n  // this is a hole-y array, does not work with normal for loop\n  // eslint-disable-next-line unicorn/no-array-for-each\n  getMaxProbModAtEachPosition(feature, cigarOps)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      const r = start + pos\n      const [leftPx, rightPx] = bpSpanPx(r, r + 1, region, bpPerPx)\n      const mod = visibleModifications[type]\n      if (!mod) {\n        console.warn(`${type} not known yet`)\n        return\n      }\n      if (isolatedModification && mod.type !== isolatedModification) {\n        return\n      }\n\n      // Check if modification probability exceeds threshold\n      if (prob < thresholdFraction) {\n        return\n      }\n\n      const col = mod.color || 'black'\n      const s = 1 - sum(allProbs)\n      if (twoColor && s > max(allProbs)) {\n        const c = alphaColor('blue', s)\n        const w = rightPx - leftPx + 0.5\n        fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c)\n      } else {\n        const c = alphaColor(col, prob)\n        const w = rightPx - leftPx + 0.5\n        fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c)\n      }\n\n      // Add to flatbush for mouseover with strand-specific info showing all modifications\n      const modsAtPos = modsByPosition.get(pos) || []\n      const strandInfo = modsAtPos\n        .map(\n          m =>\n            `${m.base}${m.strand}${m.type} ${getModificationName(m.type)} (${(m.prob * 100).toFixed(1)}%)`,\n        )\n        .join('<br/>')\n\n      items.push({\n        type: 'modification',\n        seq: strandInfo || mod.base,\n        modType: type,\n        probability: prob,\n      })\n      coords.push(leftPx, topPx, rightPx, topPx + heightPx)\n\n      pos++\n    },\n  )\n\n  return { coords, items }\n}\n","import { bpSpanPx } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\n\nimport { getMethBins } from '../../ModificationParser/getMethBins'\nimport { fillRect } from '../util'\n\nimport type { ProcessedRenderArgs } from '../types'\nimport type { LayoutFeature } from '../util'\nimport type { Region } from '@jbrowse/core/util'\n\n// Color by methylation is slightly modified version of color by modifications\n// at reference CpG sites, with non-methylated CpG colored (looking only at the\n// MM tag can not tell you where reference CpG sites are)\nexport function renderMethylation({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  renderArgs,\n  canvasWidth,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  renderArgs: ProcessedRenderArgs\n  canvasWidth: number\n  cigarOps: string[]\n}) {\n  const { regionSequence } = renderArgs\n  const { feature, topPx, heightPx } = feat\n  if (!regionSequence) {\n    throw new Error('region sequence required for methylation')\n  }\n\n  const seq = feature.get('seq') as string | undefined\n  if (!seq) {\n    return\n  }\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const { methBins, methProbs, hydroxyMethBins, hydroxyMethProbs } =\n    getMethBins(feature, cigarOps)\n\n  function getCol(k: number) {\n    if (methBins[k]) {\n      const p = methProbs[k] || 0\n      return (\n        p > 0.5\n          ? colord('red').alpha((p - 0.5) * 2)\n          : colord('blue').alpha(1 - p * 2)\n      ).toHslString()\n    }\n    if (hydroxyMethBins[k]) {\n      const p = hydroxyMethProbs[k] || 0\n      return (\n        p > 0.5\n          ? colord('pink').alpha((p - 0.5) * 2)\n          : colord('purple').alpha(1 - p * 2)\n      ).toHslString()\n    }\n    return undefined\n  }\n  const r = regionSequence.toLowerCase()\n  for (let i = 0; i < fend - fstart; i++) {\n    const j = i + fstart\n\n    const l1 = r[j - region.start + 1]\n    const l2 = r[j - region.start + 2]\n\n    if (l1 === 'c' && l2 === 'g') {\n      if (bpPerPx > 2) {\n        const [leftPx, rightPx] = bpSpanPx(j, j + 2, region, bpPerPx)\n        const w = rightPx - leftPx + 0.5\n        const c = getCol(i) || getCol(i + 1) || 'blue'\n        fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c)\n      } else {\n        const [leftPx, rightPx] = bpSpanPx(j, j + 1, region, bpPerPx)\n        const w = rightPx - leftPx + 0.5\n        const c = getCol(i) || 'blue'\n        fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c)\n        const [leftPx2, rightPx2] = bpSpanPx(j + 1, j + 2, region, bpPerPx)\n        const w2 = rightPx2 - leftPx2 + 0.5\n        const c2 = getCol(i + 1) || 'blue'\n        fillRect(ctx, leftPx2, topPx, w2, heightPx, canvasWidth, c2)\n      }\n    }\n  }\n}\n","import { bpSpanPx, measureText } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\n\nimport { fillRect } from '../util'\n\nimport type { Mismatch } from '../../shared/types'\nimport type { FlatbushItem, ProcessedRenderArgs } from '../types'\nimport type { LayoutFeature } from '../util'\n\nexport function renderMismatches({\n  ctx,\n  feat,\n  renderArgs,\n  minSubfeatureWidth,\n  largeInsertionIndicatorScale,\n  mismatchAlpha,\n  charWidth,\n  charHeight,\n  colorMap,\n  colorContrastMap,\n  hideSmallIndels,\n  canvasWidth,\n  drawSNPsMuted,\n  drawIndels = true,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  renderArgs: ProcessedRenderArgs\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  mismatchAlpha?: boolean\n  drawIndels?: boolean\n  drawSNPsMuted?: boolean\n  minSubfeatureWidth: number\n  largeInsertionIndicatorScale: number\n  hideSmallIndels: boolean\n  charWidth: number\n  charHeight: number\n  canvasWidth: number\n}) {\n  const items = [] as FlatbushItem[]\n  const coords = [] as number[]\n  const { bpPerPx, regions } = renderArgs\n  const { heightPx, topPx, feature } = feat\n  const region = regions[0]!\n  const start = feature.get('start')\n\n  const pxPerBp = Math.min(1 / bpPerPx, 2)\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n  const heightLim = charHeight - 2\n\n  // extraHorizontallyFlippedOffset is used to draw interbase items, which are\n  // located to the left when forward and right when reversed\n  const extraHorizontallyFlippedOffset = region.reversed ? 1 / bpPerPx + 1 : -1\n\n  // two pass rendering: first pass, draw all the mismatches except wide\n  // insertion markers\n  for (const mismatch of mismatches) {\n    const mstart = start + mismatch.start\n    const mlen = mismatch.length\n    const mbase = mismatch.base\n    const [leftPx, rightPx] = bpSpanPx(mstart, mstart + mlen, region, bpPerPx)\n    const widthPx = Math.max(minSubfeatureWidth, rightPx - leftPx)\n    if (mismatch.type === 'mismatch') {\n      items.push({\n        type: 'mismatch',\n        seq: mismatch.base,\n      })\n      coords.push(leftPx, topPx, rightPx, topPx + heightPx)\n\n      if (!drawSNPsMuted) {\n        const baseColor = colorMap[mismatch.base] || '#888'\n        const c =\n          mismatchAlpha && mismatch.qual !== undefined\n            ? colord(baseColor)\n                .alpha(Math.min(1, mismatch.qual / 50))\n                .toHslString()\n            : baseColor\n\n        fillRect(\n          ctx,\n          Math.round(leftPx),\n          topPx,\n          widthPx,\n          heightPx,\n          canvasWidth,\n          c,\n        )\n      }\n\n      if (widthPx >= charWidth && heightPx >= heightLim) {\n        // normal SNP coloring\n        const contrastColor = drawSNPsMuted\n          ? 'black'\n          : colorContrastMap[mismatch.base] || 'black'\n        ctx.fillStyle =\n          mismatchAlpha && mismatch.qual !== undefined\n            ? colord(contrastColor)\n                .alpha(Math.min(1, mismatch.qual / 50))\n                .toHslString()\n            : contrastColor\n        ctx.fillText(\n          mbase,\n          leftPx + (widthPx - charWidth) / 2 + 1,\n          topPx + heightPx,\n        )\n      }\n    } else if (mismatch.type === 'deletion' && drawIndels) {\n      const len = mismatch.length\n      if (!hideSmallIndels || len >= 10) {\n        fillRect(\n          ctx,\n          leftPx,\n          topPx,\n          Math.abs(leftPx - rightPx),\n          heightPx,\n          canvasWidth,\n          colorMap.deletion,\n        )\n        items.push({\n          type: 'deletion',\n          seq: `${mismatch.length}`,\n        })\n        coords.push(leftPx, topPx, rightPx, topPx + heightPx)\n        const txt = `${mismatch.length}`\n        const rwidth = measureText(txt, 10)\n        if (widthPx >= rwidth && heightPx >= heightLim) {\n          ctx.fillStyle = colorContrastMap.deletion!\n          ctx.fillText(\n            txt,\n            (leftPx + rightPx) / 2 - rwidth / 2,\n            topPx + heightPx,\n          )\n        }\n      }\n    } else if (mismatch.type === 'insertion' && drawIndels) {\n      const pos = leftPx + extraHorizontallyFlippedOffset\n      const len = +mismatch.base || mismatch.length\n      const insW = Math.max(0, Math.min(1.2, 1 / bpPerPx))\n      if (len < 10) {\n        if (!hideSmallIndels) {\n          fillRect(\n            ctx,\n            pos,\n            topPx,\n            insW,\n            heightPx,\n            canvasWidth,\n            colorMap.insertion,\n          )\n          if (1 / bpPerPx >= charWidth && heightPx >= heightLim) {\n            items.push({\n              type: 'insertion',\n              seq: mismatch.insertedBases || 'unknown',\n            })\n            coords.push(leftPx - 2, topPx, leftPx + insW + 2, topPx + heightPx)\n\n            const l = Math.round(pos - insW)\n            fillRect(ctx, l, topPx, insW * 3, 1, canvasWidth)\n            fillRect(ctx, l, topPx + heightPx - 1, insW * 3, 1, canvasWidth)\n            ctx.fillText(`(${mismatch.base})`, pos + 3, topPx + heightPx)\n          }\n        }\n      }\n    } else if (mismatch.type === 'hardclip' || mismatch.type === 'softclip') {\n      const pos = leftPx + extraHorizontallyFlippedOffset\n      const c = colorMap[mismatch.type]\n      const clipW = Math.max(minSubfeatureWidth, pxPerBp)\n      fillRect(ctx, pos, topPx, clipW, heightPx, canvasWidth, c)\n      if (1 / bpPerPx >= charWidth && heightPx >= heightLim) {\n        const l = pos - clipW\n        fillRect(ctx, l, topPx, clipW * 3, 1, canvasWidth)\n        fillRect(ctx, l, topPx + heightPx - 1, clipW * 3, 1, canvasWidth)\n        ctx.fillText(`(${mismatch.base})`, pos + 3, topPx + heightPx)\n      }\n    } else if (mismatch.type === 'skip') {\n      // fix to avoid bad rendering note that this was also related to chrome\n      // bug https://bugs.chromium.org/p/chromium/issues/detail?id=1131528\n      //\n      // also affected firefox ref #1236 #2750\n      if (leftPx + widthPx > 0) {\n        // make small exons more visible when zoomed far out\n        const adjustPx = widthPx - (bpPerPx > 10 ? 1.5 : 0)\n        const l = Math.max(0, leftPx)\n        const t = topPx + heightPx / 2 - 1\n        const w = adjustPx + Math.min(leftPx, 0)\n        const h = 1\n        fillRect(ctx, l, t, w, h, canvasWidth, colorMap.skip)\n      }\n    }\n  }\n\n  // second pass, draw wide insertion markers on top\n  if (drawIndels) {\n    for (const mismatch of mismatches) {\n      const mstart = start + mismatch.start\n      const mlen = mismatch.length\n      const len = +mismatch.base || mismatch.length\n      if (mismatch.type === 'insertion' && len >= 10) {\n        const [leftPx] = bpSpanPx(mstart, mstart + mlen, region, bpPerPx)\n        const txt = `${len}`\n        items.push({\n          type: 'insertion',\n          seq: mismatch.insertedBases || 'unknown',\n        })\n        coords.push(leftPx - 3, topPx, leftPx + 4, topPx + heightPx)\n        if (bpPerPx > largeInsertionIndicatorScale) {\n          fillRect(\n            ctx,\n            leftPx - 1,\n            topPx,\n            2,\n            heightPx,\n            canvasWidth,\n            colorMap.insertion,\n          )\n        } else if (heightPx > charHeight) {\n          const rwidth = measureText(txt)\n          const padding = 5\n          fillRect(\n            ctx,\n            leftPx - rwidth / 2 - padding,\n            topPx,\n            rwidth + 2 * padding,\n            heightPx,\n            canvasWidth,\n            'purple',\n          )\n          ctx.fillStyle = colorContrastMap.insertion!\n          ctx.fillText(txt, leftPx - rwidth / 2, topPx + heightPx)\n        } else {\n          const padding = 2\n          fillRect(\n            ctx,\n            leftPx - padding,\n            topPx,\n            2 * padding,\n            heightPx,\n            canvasWidth,\n            colorMap.insertion,\n          )\n        }\n      }\n    }\n  }\n  return {\n    coords,\n    items,\n  }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { bpSpanPx } from '@jbrowse/core/util'\n\nimport { parseCigar } from '../../MismatchParser'\nimport { fillRect, getCharWidthHeight } from '../util'\n\nimport type { Mismatch } from '../../shared/types'\nimport type { ProcessedRenderArgs } from '../types'\nimport type { LayoutFeature } from '../util'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Theme } from '@mui/material'\n\nexport function renderSoftClipping({\n  ctx,\n  feat,\n  renderArgs,\n  config,\n  theme,\n  colorMap,\n  canvasWidth,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  renderArgs: ProcessedRenderArgs\n  config: AnyConfigurationModel\n  colorMap: Record<string, string>\n  theme: Theme\n  canvasWidth: number\n}) {\n  const { feature, topPx, heightPx } = feat\n  const { regions, bpPerPx } = renderArgs\n  const region = regions[0]!\n  const minFeatWidth = readConfObject(config, 'minSubfeatureWidth')\n  const mismatches = feature.get('mismatches') as Mismatch[] | undefined\n  const seq = feature.get('seq') as string | undefined\n  const { charWidth, charHeight } = getCharWidthHeight()\n\n  // Display all bases softclipped off in lightened colors\n  if (!(seq && mismatches)) {\n    return\n  }\n\n  const heightLim = charHeight - 2\n  let seqOffset = 0\n  let refOffset = 0\n  const CIGAR = feature.get('CIGAR')\n  const cigarOps = parseCigar(CIGAR)\n  for (let i = 0; i < cigarOps.length; i += 2) {\n    const op = cigarOps[i + 1]!\n    const len = +cigarOps[i]!\n    if (op === 'S') {\n      for (let k = 0; k < len; k++) {\n        const base = seq[seqOffset + k]!\n        const s0 = feature.get('start') - (i === 0 ? len : 0) + refOffset + k\n        const [leftPx, rightPx] = bpSpanPx(s0, s0 + 1, region, bpPerPx)\n        const widthPx = Math.max(minFeatWidth, rightPx - leftPx)\n\n        // Black accounts for IUPAC ambiguity code bases such as N that\n        // show in soft clipping\n        const baseColor = colorMap[base] || '#000000'\n        ctx.fillStyle = baseColor\n        fillRect(ctx, leftPx, topPx, widthPx, heightPx, canvasWidth)\n\n        if (widthPx >= charWidth && heightPx >= heightLim) {\n          ctx.fillStyle = theme.palette.getContrastText(baseColor)\n          ctx.fillText(\n            base,\n            leftPx + (widthPx - charWidth) / 2 + 1,\n            topPx + heightPx,\n          )\n        }\n      }\n      seqOffset += len\n    }\n    if (op === 'N') {\n      refOffset += len\n    }\n    if (op === 'M' || op === '=' || op === 'X') {\n      refOffset += len\n      seqOffset += len\n    }\n    if (op === 'H') {\n      // do nothing\n    }\n    if (op === 'D') {\n      refOffset += len\n    }\n    if (op === 'I') {\n      seqOffset += len\n    }\n  }\n}\n"],"names":["getModPositions","mm","fseq","fstrand","seq","revcom","seqLength","length","mods","split","result","mod","basemod","matches","modificationRegex","exec","Error","base","strand","typestr","types","type","splitLength","currPos","positions","Array","writeIndex","i","delta","pos","validPositions","slice","push","PairType","PROPER_PAIR","LONG_INSERT","SHORT_INSERT","INTER_CHROM","ABNORMAL_ORIENTATION","UNMAPPED_MATE","fillColor","color_fwd_strand_not_proper","color_rev_strand_not_proper","color_fwd_strand","color_rev_strand","color_fwd_missing_mate","color_rev_missing_mate","color_fwd_diff_chr","color_rev_diff_chr","color_pair_lr","color_pair_rr","color_pair_rl","color_pair_ll","color_nostrand","color_interchrom","color_longinsert","color_shortinsert","color_unmapped_mate","color_unknown","strokeColor","defaultColor","getPairedType","f1","f2","stats","undefined","flags","r","orientationTypes","fr","pair_orientation","sameRef","refName","tlen","Math","abs","upper","lower","getPairedInsertSizeColor","getPairedOrientationColorOrDefault","f","type2","pairMap","getPairedOrientationColor","getPairedInsertSizeAndOrientationColor","getSingletonColor","getPairedColor","v0","v1","getMaxProbModAtEachPosition","feature","cigarOps","get","getTagAlt","ops","parseCigar","modifications","probabilities","getModProbabilities","maxProbModForPosition","probIndex","ref","idx","getNextRefPos","prob","old","allProbs","max","m","parts","l","mp","phred","charCodeAt","min","getMethBins","fstart","fend","flen","methBins","hydroxyMethBins","methProbs","hydroxyMethProbs","idx2","getAlignmentShapeColor","colorType","tag","config","colorTagMap","colorByInsertSize","colorByStrand","colorByMappingQuality","orientationType","readConfObject","LR","RR","RL","LL","getOrientation","colorByOrientation","flipper","getStranded","colorByStrandedRnaSeq","tags","val","fillRect","ctx","t","w","h","cw","color","fillStyle","getColorBaseMap","theme","skip","deletion","insertion","hardclip","softclip","bases","palette","A","main","C","G","T","getCharWidthHeight","charWidth","measureText","charHeight","makeImageData","layoutRecords","canvasWidth","renderArgs","stopToken","showSoftClip","colorBy","configTheme","mismatchAlpha","minSubfeatureWidth","largeInsertionIndicatorScale","hideSmallIndels","createJBrowseTheme","colorMap","colorContrastMap","Object","fromEntries","entries","map","key","value","getContrastText","getContrastBaseMap","font","drawSNPsMuted","includes","coords","items","forEachWithStopTokenCheck","feat","alignmentRet","bpPerPx","regions","region","heightPx","topPx","s","e","CIGAR","flip","reversed","renderChevrons","drawLen","drawStart","opLen","op","leftPx","rightPx","bpSpanPx","beginPath","moveTo","lineTo","closePath","fill","renderAlignmentShape","scores","start","soffset","roffset","len","score","start0","renderPerBaseQuality","heightLim","letter","fillText","renderPerBaseLettering","ret","visibleModifications","isolatedModification","twoColor","thresholdFraction","threshold","modsByPosition","Map","has","set","forEach","console","warn","col","sum","c","alphaColor","strandInfo","getModificationName","toFixed","join","modType","probability","renderModifications","regionSequence","getCol","k","p","colord","alpha","toHslString","toLowerCase","j","l1","l2","leftPx2","rightPx2","renderMethylation","renderAlignment","drawIndels","pxPerBp","mismatches","extraHorizontallyFlippedOffset","mismatch","mstart","mlen","mbase","widthPx","baseColor","qual","round","contrastColor","txt","rwidth","insW","insertedBases","clipW","adjustPx","padding","renderMismatches","minFeatWidth","seqOffset","refOffset","s0","renderSoftClipping","flatbush","Flatbush","add","finish","data"],"sourceRoot":""}