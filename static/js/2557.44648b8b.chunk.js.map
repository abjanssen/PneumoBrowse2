{"version":3,"file":"static/js/2557.44648b8b.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/SyntenyFeature/index.ts","../../../plugins/comparative-adapters/src/BlastTabularAdapter/BlastTabularAdapter.ts","../../../packages/core/src/util/parseLineByLine.ts"],"sourcesContent":["import { SimpleFeature } from '@jbrowse/core/util'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\n\nconst { getMismatches } = MismatchParser\n\nexport default class SyntenyFeature extends SimpleFeature {\n  get(arg: string): any {\n    return arg === 'mismatches'\n      ? getMismatches(this.get('CIGAR'))\n      : super.get(arg)\n  }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { doesIntersect2, fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport SyntenyFeature from '../SyntenyFeature/index.ts'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\n// Blast output column names/descriptions taken from\n// https://www.ncbi.nlm.nih.gov/books/NBK279684/#_appendices_Options_for_the_commandline_a_\ninterface BlastColumns {\n  /** Query Seq-id */\n  qseqid?: string\n  /** Query GI */\n  qgi?: string\n  /** Query accesion */\n  qacc?: string\n  /** Subject Seq-id */\n  sseqid?: string\n  /** All subject Seq-id(s), separated by a ';' */\n  sallseqid?: string\n  /** Subject GI */\n  sgi?: string\n  /** All subject GIs */\n  sallgi?: string\n  /** Subject accession */\n  sacc?: string\n  /** All subject accessions */\n  sallacc?: string\n  /** Start of alignment in query */\n  qstart?: number\n  /** End of alignment in query */\n  qend?: number\n  /** Start of alignment in subject */\n  sstart?: number\n  /** End of alignment in subject */\n  send?: number\n  /** Aligned part of query sequence */\n  qseq?: string\n  /** Aligned part of subject sequence */\n  sseq?: string\n  /** Expect value */\n  evalue?: string\n  /** Bit score */\n  bitscore?: string\n  /** Raw score */\n  score?: string\n  /** Alignment length */\n  length?: string\n  /** Percentage of identical matches */\n  pident?: string\n  /** Number of identical matches */\n  nident?: string\n  /** Number of mismatches */\n  mismatch?: string\n  /** Number of positive-scoring matches */\n  positive?: string\n  /** Number of gap openings */\n  gapopen?: string\n  /** Total number of gap */\n  gaps?: string\n  /** Percentage of positive-scoring matches */\n  ppos?: string\n  /** Query and subject frames separated by a '/' */\n  frames?: string\n  /** Query frame */\n  qframe?: string\n  /** Subject frame */\n  sframe?: string\n  /** Blast traceback operations (BTOP) */\n  btop?: string\n  /** Unique Subject Taxonomy ID(s), separated by a ';'(in numerical order) */\n  staxids?: string\n  /** Unique Subject Scientific Name(s), separated by a ';' */\n  sscinames?: string\n  /** Unique Subject Common Name(s), separated by a ';' */\n  scomnames?: string\n  /**\n   * Unique Subject Blast Name(s), separated by a ';' (in alphabetical order)\n   */\n  sblastnames?: string\n  /**\n   * Unique Subject Super Kingdom(s), separated by a ';' (in alphabetical order)\n   */\n  sskingdoms?: string\n  /** Subject Title */\n  stitle?: string\n  /** All Subject Title(s), separated by a '<>' */\n  salltitles?: string\n  /** Subject Strand */\n  sstrand?: string\n  /** Query Coverage Per Subject (for all HSPs) */\n  qcovs?: string\n  /** Query Coverage Per HSP */\n  qcovhsp?: string\n  /**\n   * A measure of Query Coverage that counts a position in a subject sequence\n   * for this measure only once. The second time the position is aligned to the\n   * query is not counted towards this measure.\n   */\n  qcovus?: string\n}\n\n// Blast output column names/descriptions taken from\n// https://www.ncbi.nlm.nih.gov/books/NBK279684/#_appendices_Options_for_the_commandline_a_\ninterface BlastRecord extends BlastColumns {\n  /** Query Seq-id */\n  qseqid: string\n  /** Subject Seq-id */\n  sseqid: string\n  /** Start of alignment in query */\n  qstart: number\n  /** End of alignment in query */\n  qend: number\n  /** Start of alignment in subject */\n  sstart: number\n  /** End of alignment in subject */\n  send: number\n}\n\nfunction createBlastLineParser(columns: string) {\n  const columnNames = columns.trim().split(' ') as (keyof BlastRecord)[]\n  const qseqidIndex = columnNames.indexOf('qseqid')\n  if (qseqidIndex === -1) {\n    throw new Error('Missing required column \"qseqid\"')\n  }\n  const sseqidIndex = columnNames.indexOf('sseqid')\n  if (sseqidIndex === -1) {\n    throw new Error('Missing required column \"sseqid\"')\n  }\n  const qstartIndex = columnNames.indexOf('qstart')\n  if (qstartIndex === -1) {\n    throw new Error('Missing required column \"qstart\"')\n  }\n  const qendIndex = columnNames.indexOf('qend')\n  if (qendIndex === -1) {\n    throw new Error('Missing required column \"qend\"')\n  }\n  const sstartIndex = columnNames.indexOf('sstart')\n  if (sstartIndex === -1) {\n    throw new Error('Missing required column \"sstart\"')\n  }\n  const sendIndex = columnNames.indexOf('send')\n  if (sendIndex === -1) {\n    throw new Error('Missing required column \"send\"')\n  }\n  const columnNameSet = new Map<string, number>(\n    columnNames\n      .map((c, idx) => [c, idx] as const)\n      .filter(\n        f =>\n          !['qseqid', 'sseqid', 'qstart', 'qend', 'sstart', 'send'].includes(\n            f[0],\n          ),\n      ),\n  )\n  return (line: string): BlastRecord | undefined => {\n    if (line.startsWith('#')) {\n      return\n    }\n    const row = line.split('\\t')\n    const qseqid = row[qseqidIndex]\n    const sseqid = row[sseqidIndex]\n    const qstart = row[qstartIndex]\n    const qend = row[qendIndex]\n    const sstart = row[sstartIndex]\n    const send = row[sendIndex]\n    if (!(qseqid && sseqid && qstart && qend && sstart && send)) {\n      console.warn('Invalid BLAST line')\n      console.warn(line)\n      return\n    }\n    const record: BlastRecord = {\n      qseqid,\n      sseqid,\n      qstart: Number.parseInt(qstart),\n      qend: Number.parseInt(qend),\n      sstart: Number.parseInt(sstart),\n      send: Number.parseInt(send),\n    }\n    for (const [columnName, idx] of columnNameSet.entries()) {\n      const value = row[idx]\n      if (!value) {\n        continue\n      }\n      // @ts-expect-error\n      record[columnName] = value\n    }\n    return record\n  }\n}\n\nexport default class BlastTabularAdapter extends BaseFeatureDataAdapter {\n  private data: Promise<BlastRecord[]> | undefined\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  getData(opts?: BaseOptions): Promise<BlastRecord[]> {\n    if (!this.data) {\n      this.data = this.setup(opts).catch((e: unknown) => {\n        this.data = undefined\n        throw e\n      })\n    }\n    return this.data\n  }\n\n  async setup(opts?: BaseOptions): Promise<BlastRecord[]> {\n    const columns: string = readConfObject(this.config, 'columns')\n    const lines = [] as NonNullable<\n      ReturnType<ReturnType<typeof createBlastLineParser>>\n    >[]\n\n    const cb = createBlastLineParser(columns)\n    parseLineByLine(\n      await fetchAndMaybeUnzip(\n        openLocation(\n          readConfObject(this.config, 'blastTableLocation'),\n          this.pluginManager,\n        ),\n        opts,\n      ),\n      line => {\n        const res = cb(line)\n        if (res) {\n          lines.push(res)\n        }\n        return true\n      },\n      opts?.statusCallback,\n    )\n    return lines\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures\n    // so is not really that important, and has to be true or else\n    // getFeatures is never called (BaseAdapter filters it out)\n    return true\n  }\n\n  getAssemblyNames() {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    if (assemblyNames.length === 0) {\n      const query = this.getConf('queryAssembly') as string\n      const target = this.getConf('targetAssembly') as string\n      return [query, target]\n    }\n    return assemblyNames\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    // @ts-expect-error\n    const r1 = opts.regions?.[0].assemblyName\n    const feats = await this.getData(opts)\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    if (idx !== -1) {\n      const set = new Set<string>()\n      for (const feat of feats) {\n        set.add(idx === 0 ? feat.qseqid : feat.sseqid)\n      }\n      return [...set]\n    }\n    console.warn('Unable to do ref renaming on adapter')\n    return []\n  }\n\n  getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const blastRecords = await this.getData(opts)\n      const [queryAssembly, targetAssembly] = this.getAssemblyNames()\n\n      // The index of the assembly name in the query list corresponds to the\n      // adapter in the subadapters list\n      const {\n        refName: queryRefName,\n        assemblyName: queryAssemblyName,\n        start: queryStart,\n        end: queryEnd,\n      } = query\n      if (\n        queryAssemblyName !== targetAssembly &&\n        queryAssemblyName !== queryAssembly\n      ) {\n        console.warn(`${queryAssemblyName} not found in this adapter`)\n        observer.complete()\n        return\n      }\n\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let i = 0; i < blastRecords.length; i++) {\n        const r = blastRecords[i]!\n        let start: number\n        let end: number\n        let refName: string\n        let assemblyName: string | undefined\n        let mateStart: number\n        let mateEnd: number\n        let mateRefName: string\n        let mateAssemblyName: string | undefined\n\n        const { qseqid, sseqid, qstart, qend, sstart, send, ...rest } = r\n        if (queryAssemblyName === queryAssembly) {\n          start = qstart\n          end = qend\n          refName = qseqid\n          assemblyName = queryAssembly\n          mateStart = sstart\n          mateEnd = send\n          mateRefName = sseqid\n          mateAssemblyName = targetAssembly\n        } else {\n          start = sstart\n          end = send\n          refName = sseqid\n          assemblyName = targetAssembly\n          mateStart = qstart\n          mateEnd = qend\n          mateRefName = qseqid\n          mateAssemblyName = queryAssembly\n        }\n        let strand = 1\n        let mateStrand = 1\n        if (start > end) {\n          ;[start, end] = [end, start]\n          strand = -1\n        }\n        if (mateStart > mateEnd) {\n          ;[mateStart, mateEnd] = [mateEnd, mateStart]\n          mateStrand = -1\n        }\n        // Convert from BLAST 1-based to JBrowse 0-based coordinates\n        start -= 1\n        mateStart -= 1\n        if (\n          refName === queryRefName &&\n          doesIntersect2(queryStart, queryEnd, start, end)\n        ) {\n          observer.next(\n            new SyntenyFeature({\n              uniqueId: i + queryAssemblyName,\n              assemblyName,\n              start,\n              end,\n              type: 'match',\n              refName,\n              strand: strand * mateStrand,\n              syntenyId: i,\n              ...rest,\n              mate: {\n                start: mateStart,\n                end: mateEnd,\n                refName: mateRefName,\n                assemblyName: mateAssemblyName,\n              },\n            }),\n          )\n        }\n      }\n\n      observer.complete()\n    })\n  }\n}\n","import { getProgressDisplayStr } from './index.ts'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n"],"names":["getMismatches","MismatchParser","SyntenyFeature","SimpleFeature","get","arg","this","super","BlastTabularAdapter","BaseFeatureDataAdapter","getData","opts","data","setup","catch","e","undefined","columns","readConfObject","config","lines","cb","columnNames","trim","split","qseqidIndex","indexOf","Error","sseqidIndex","qstartIndex","qendIndex","sstartIndex","sendIndex","columnNameSet","Map","map","c","idx","filter","f","includes","line","startsWith","row","qseqid","sseqid","qstart","qend","sstart","send","console","warn","record","Number","parseInt","columnName","entries","value","createBlastLineParser","parseLineByLine","fetchAndMaybeUnzip","openLocation","pluginManager","res","push","statusCallback","hasDataForRefName","getAssemblyNames","assemblyNames","getConf","length","getRefNames","r1","regions","assemblyName","feats","set","Set","feat","add","getFeatures","query","ObservableCreate","async","blastRecords","queryAssembly","targetAssembly","refName","queryRefName","queryAssemblyName","start","queryStart","end","queryEnd","observer","complete","i","r","mateStart","mateEnd","mateRefName","mateAssemblyName","rest","strand","mateStrand","doesIntersect2","next","uniqueId","type","syntenyId","mate","buffer","lineCallback","decoder","TextDecoder","blockStart","n","lineEnd","b","subarray","decode","getProgressDisplayStr"],"ignoreList":[],"sourceRoot":""}