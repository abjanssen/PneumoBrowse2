{"version":3,"file":"static/js/7489.5da809f3.chunk.js","mappings":"uNAGO,SAASA,EAAeC,GAC7B,OAAO,IAAIC,YAAY,OAAQ,CAAEC,OAAO,IAAQC,OAAOH,EACzD,CAEAI,eAAeC,EAAUL,EAAgBM,EAAU,CAAC,GAElD,aADkB,qCAAoBC,MAAKC,GAAUA,EAAOC,WACjD,CAAEC,UAAU,EAAMC,OAAQ,SAAUL,IAAWM,WACxDb,EAAeC,GAEnB,CAgCA,SAASa,EACPC,EACAC,EACAC,GAEA,MAAMC,EAAOH,EAAOI,KAAK,GAAIC,MAAMJ,GAAeE,MAAQ,GAE1D,IAEIG,EAFAC,EAAc,OAGlB,IACED,GAAYE,EAAAA,EAAAA,gBAAeL,EAAMD,EACnC,CAAE,MAAOO,GACP,CAWF,OATIH,GAAWI,SAAsC,iBAApBJ,EAAUK,MACzCJ,EAAc,YACL,gBAAgBK,KAAKT,KAC9BI,EAAc,UAMTA,CACT,CAEA,SAASM,EACPT,EACAZ,EAAwB,CAAC,GAEzB,MAAM,kBACJsB,GAAoB,EAAK,qBACzBC,EAAuB,EAAC,eACxBb,EAAiBA,KAAM,EAAK,qBAC5Bc,GACExB,EAGJ,IAAIyB,EAAU,EACd,MAAMjB,EAAiB,CACrBkB,UAAU,EACVd,KAAMA,EAAKe,KAAI,CAACC,EAAKC,KACnB,MAAMC,EAAKD,GAAaP,EAAoB,EAAI,GAIhD,OAHIM,EAAIG,OAASN,IACfA,EAAUG,EAAIG,QAET,CACLD,GAAIE,OAAOF,GACXjB,MAAOe,EAAID,KAAI,CAAChB,EAAMF,KACb,CAAEA,eAAcE,WAE1B,KAKCsB,EAAsC,CAAC,EAE7C,GAAIX,QAA8CY,IAAzBX,EAAoC,CAC3D,MAAOY,GAAe3B,EAAOI,KAAKwB,OAAOb,EAAuB,EAAG,GAE/DY,GACFA,EAAYtB,MAAMwB,SAAQ,CAACC,EAAM7B,KAC/BwB,EAAYxB,GAAgB6B,EAAK3B,MAAQ,EAAE,GAGjD,CAGA,MAAM4B,EAAoB,GACpBC,EAAqB,GAC3B,IAAK,IAAI/B,EAAe,EAAGA,EAAegB,EAAShB,GAAgB,EAAG,CACpE+B,EAAmBC,KAAKhC,GACxB,MAAMM,EAAcR,EAAgBC,EAAQC,EAAcC,GAG1D,GAAoB,cAAhBK,EACF,IAAK,MAAMa,KAAOpB,EAAOI,KAAM,CAC7B,MAAM0B,EAAOV,EAAIf,MAAMJ,GACvB6B,EAAKI,cAAe1B,EAAAA,EAAAA,gBAAesB,EAAK3B,KAAMD,EAChD,CAGF6B,EAAQ9B,GAAgB,CACtBkC,KAAMV,EAAYxB,GAClBmC,SAAU,CACRC,KAAM9B,GAGZ,CAEA,MAAO,CACLP,SACAgC,qBACAM,iBAAkBxB,EAClBiB,UACAQ,aAAcvB,EAElB,CAEO1B,eAAekD,EAAetD,EAAgBM,GAEnD,OAAOqB,QADYtB,EAAUL,GACUM,EACzC,CAEOF,eAAemD,EAAevD,EAAgBM,GAEnD,OAAOqB,QADYtB,EAAUL,EAAQ,CAAEwD,UAAW,OACXlD,EACzC,C","sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts"],"sourcesContent":["import { ParsedLocString, parseLocString } from '@jbrowse/core/util'\nimport type { Buffer } from 'buffer'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf8', { fatal: true }).decode(buffer)\n}\n\nasync function parseWith(buffer: Buffer, options = {}) {\n  const csv = await import('csvtojson').then(module => module.default)\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n\n  extendedData?: any\n  cells: {\n    text: string\n\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName?: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0]!.cells[columnNumber]!.text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc: ParsedLocString | undefined\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc?.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {},\n) {\n  const {\n    hasColumnNameLine = false,\n    columnNameLineNumber = 1,\n    isValidRefName = () => false,\n    selectedAssemblyName,\n  } = options\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) {\n        maxCols = row.length\n      }\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (hasColumnNameLine && columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(columnNameLineNumber - 1, 1)\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(rowSet, columnNumber, isValidRefName)\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      for (const row of rowSet.rows) {\n        const cell = row.cells[columnNumber]!\n        cell.extendedData = parseLocString(cell.text, isValidRefName)\n      }\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber]!,\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!hasColumnNameLine,\n    columns,\n    assemblyName: selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(buffer: Buffer, options?: ParseOptions) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(buffer: Buffer, options?: ParseOptions) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n"],"names":["bufferToString","buffer","TextDecoder","fatal","decode","async","parseWith","options","then","module","default","noheader","output","fromString","guessColumnType","rowSet","columnNumber","isValidRefName","text","rows","cells","parsedLoc","guessedType","parseLocString","error","refName","start","test","dataToSpreadsheetSnapshot","hasColumnNameLine","columnNameLineNumber","selectedAssemblyName","maxCols","isLoaded","map","row","rowNumber","id","length","String","columnNames","undefined","colNamesRow","splice","forEach","cell","columns","columnDisplayOrder","push","extendedData","name","dataType","type","hasColumnNames","assemblyName","parseCsvBuffer","parseTsvBuffer","delimiter"],"sourceRoot":""}