{"version":3,"file":"static/js/555.42849243.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/alignments/src/MismatchParser/getNextRefPos.ts","webpack://@jbrowse/web/../../plugins/alignments/src/ModificationParser/getModPositions.ts","webpack://@jbrowse/web/../../plugins/alignments/src/ModificationParser/getModProbabilities.ts","webpack://@jbrowse/web/../../plugins/alignments/src/PileupRenderer/renderers/cigarUtil.ts","webpack://@jbrowse/web/../../plugins/alignments/src/PileupRenderer/util.ts","webpack://@jbrowse/web/../../plugins/alignments/src/PileupRenderer/renderers/renderMismatchesCallback.ts","webpack://@jbrowse/web/../../plugins/alignments/src/PileupRenderer/renderers/renderModifications.ts","webpack://@jbrowse/web/../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts"],"sourcesContent":["// get relative reference sequence positions for positions given relative to\n// the read sequence\n\nimport {\n  CIGAR_D,\n  CIGAR_EQ,\n  CIGAR_I,\n  CIGAR_M,\n  CIGAR_N,\n  CIGAR_S,\n  CIGAR_X,\n} from '../PileupRenderer/renderers/cigarUtil.ts'\n\n// Handles both packed Uint32Array and unpacked number[] formats\nexport function getNextRefPos(\n  cigarOps: ArrayLike<number>,\n  positions: number[],\n) {\n  let readPos = 0\n  let refPos = 0\n  let currPos = 0\n  const ret = []\n\n  for (\n    let i = 0, l = cigarOps.length, l2 = positions.length;\n    i < l && currPos < l2;\n    i++\n  ) {\n    const packed = cigarOps[i]!\n    const len = packed >> 4\n    const op = packed & 0xf\n    if (op === CIGAR_S || op === CIGAR_I) {\n      for (let j = 0; j < len && currPos < l2; j++) {\n        if (positions[currPos] === readPos + j) {\n          currPos++\n        }\n      }\n      readPos += len\n    } else if (op === CIGAR_D || op === CIGAR_N) {\n      refPos += len\n    } else if (op === CIGAR_M || op === CIGAR_X || op === CIGAR_EQ) {\n      for (let j = 0; j < len && currPos < l2; j++) {\n        if (positions[currPos] === readPos + j) {\n          ret.push({\n            ref: refPos + j,\n            idx: currPos,\n          })\n          currPos++\n        }\n      }\n      readPos += len\n      refPos += len\n    }\n  }\n\n  return ret\n}\n","import { revcom } from '@jbrowse/core/util'\n\nimport { modificationRegex } from './consts.ts'\n\n/**\n * Parse MM tag to extract modification positions on the read sequence.\n *\n *\n * @param mm - MM tag string (e.g., \"C+m,2,2,1;A+a,0,3\")\n * @param fseq - Read sequence\n * @param fstrand - Read strand (-1, 0, or 1)\n * @returns Array of modification objects with positions\n */\nexport function getModPositions(mm: string, fseq: string, fstrand: number) {\n  const seq = fstrand === -1 ? revcom(fseq) : fseq\n  const seqLength = seq.length\n  const mods = mm.split(';')\n  const result = []\n\n  for (const mod of mods) {\n    // Empty string\n    if (mod === '') {\n      continue\n    }\n\n    const split = mod.split(',')\n    const basemod = split[0]!\n    const matches = modificationRegex.exec(basemod)\n    if (!matches) {\n      throw new Error(`bad format for MM tag: \"${mod}\"`)\n    }\n    const [, base, strand, typestr] = matches\n\n    // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so split,\n    // and they can also be chemical codes (ChEBI) e.g. C+16061\n    const types = typestr!.split(/(\\d+|.)/)\n\n    // Note: Negative strand modifications (e.g., T-a) are now supported\n    // They are processed the same way as positive strand modifications\n    // The strand information is preserved for simplex/duplex detection\n\n    // this logic based on parse_mm.pl from hts-specs\n    for (const type of types) {\n      if (type === '') {\n        continue\n      }\n\n      const splitLength = split.length\n      let currPos = 0\n\n      // For reverse strand, pre-allocate array and fill backwards to avoid reverse()\n      // This is worthwhile because we avoid an O(n) reverse() operation\n      const positions = fstrand === -1 ? new Array(splitLength - 1) : []\n      let writeIndex = fstrand === -1 ? splitLength - 2 : 0\n\n      for (let i = 1; i < splitLength; i++) {\n        let delta = +split[i]!\n        do {\n          if (base === 'N' || base === seq[currPos]) {\n            delta--\n          }\n          currPos++\n        } while (delta >= 0 && currPos < seqLength)\n\n        // Calculate and store position\n        if (fstrand === -1) {\n          const pos = seqLength - currPos\n          if (pos >= 0) {\n            // avoid negative-number-positions in array, seen in #4629 cause\n            // unknown, could warrant some further investigation\n            positions[writeIndex--] = pos\n          } else {\n            // Position is negative (edge case from #4629)\n            // Don't write anything, don't decrement writeIndex\n            // This leaves a gap at the beginning of the array that we'll slice off\n          }\n        } else {\n          positions[writeIndex++] = currPos - 1\n        }\n      }\n\n      // For reverse strand, slice off any unfilled slots at the beginning\n      // (happens when some positions were negative and skipped)\n      const validPositions =\n        fstrand === -1 ? positions.slice(writeIndex + 1) : positions\n\n      result.push({\n        type,\n        base: base!,\n        strand: strand!,\n        positions: validPositions,\n      })\n    }\n  }\n\n  return result\n}\n","import { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getModProbabilities(feature: Feature) {\n  // ML stores probabilities as array of numerics and MP is scaled phred scores\n  // https://github.com/samtools/hts-specs/pull/418/files#diff-e765c6479316309f56b636f88189cdde8c40b854c7bdcce9ee7fe87a4e76febcR596\n  //\n  // - if we have ML or Ml, it is an 8bit probability, divide by 255\n  //\n  // - if we have MP or Mp it is phred scaled ASCII, which can go up to 90 but\n  // has very high likelihood basecalls at that point, we really only care about\n  // low qual calls <20 approx\n  const m = (getTagAlt(feature, 'ML', 'Ml') as number[] | string) || []\n  if (m) {\n    const result = []\n    if (typeof m === 'string') {\n      const parts = m.split(',')\n      for (let i = 0, l = parts.length; i < l; i++) {\n        result.push(+parts[i]! / 255)\n      }\n    } else {\n      for (let i = 0, l = m.length; i < l; i++) {\n        result.push(m[i]! / 255)\n      }\n    }\n    return result\n  } else {\n    const mp = getTagAlt(feature, 'MP', 'Mp') as string | undefined\n    if (mp) {\n      const result = []\n      for (let i = 0, l = mp.length; i < l; i++) {\n        const phred = mp.charCodeAt(i) - 33\n        result.push(Math.min(1, phred / 50))\n      }\n      return result\n    }\n    return undefined\n  }\n}\n","import { parseCigar2 } from '../../MismatchParser/index.ts'\n\n// CIGAR operation indices (from BAM spec) - used in packed Uint32Array format\nexport const CIGAR_M = 0\nexport const CIGAR_I = 1\nexport const CIGAR_D = 2\nexport const CIGAR_N = 3\nexport const CIGAR_S = 4\nexport const CIGAR_H = 5\nexport const CIGAR_P = 6\nexport const CIGAR_EQ = 7\nexport const CIGAR_X = 8\n\n// Bitmasks for CIGAR operation categories (use with: (1 << op) & MASK)\n// Alignment match ops (M=0, ==7) - may contain mismatches, need MD tag\nexport const CIGAR_M_EQ_MASK = 0b10000001 // (1<<0)|(1<<7) = 129\n// Match/mismatch ops that consume both ref and seq (M=0, ==7, X=8)\nexport const CIGAR_MATCH_MASK = 0b110000001 // (1<<0)|(1<<7)|(1<<8) = 385\n// Seq-only ops (S=4, I=1)\nexport const CIGAR_SEQ_ONLY_MASK = 0b10010 // (1<<1)|(1<<4) = 18\n// Ref-skip ops (D=2, N=3)\nexport const CIGAR_REF_SKIP_MASK = 0b1100 // (1<<2)|(1<<3) = 12\n// Ref-consuming ops (M=0, D=2, ==7, X=8)\nexport const CIGAR_REF_CONSUMING_MASK = 0b110000101 // (1<<0)|(1<<2)|(1<<7)|(1<<8) = 389\n\n// BAM 4-bit encoded sequence lookup table\nexport const SEQRET = '=ACMGRSVTWYHKDBN'\n\n// Numeric decoder - returns char codes directly (lowercase for case-insensitive comparison)\n// '=' = 61, 'a' = 97, 'c' = 99, 'm' = 109, 'g' = 103, 'r' = 114, 's' = 115, 'v' = 118,\n// 't' = 116, 'w' = 119, 'y' = 121, 'h' = 104, 'k' = 107, 'd' = 100, 'b' = 98, 'n' = 110\nexport const SEQRET_NUMERIC_DECODER = new Uint8Array([\n  61, 97, 99, 109, 103, 114, 115, 118, 116, 119, 121, 104, 107, 100, 98, 110,\n])\n\n// Pre-computed char lookup for ASCII codes (avoids String.fromCharCode in hot loops)\nexport const CHAR_FROM_CODE: string[] = Array.from({ length: 128 }, (_, i) =>\n  String.fromCharCode(i),\n)\n\n// Helper to ensure we have Uint32Array (packed format)\nexport function getCigarOps(\n  cigar: Uint32Array | string | undefined,\n): ArrayLike<number> {\n  return typeof cigar === 'string' ? parseCigar2(cigar) : cigar || []\n}\n","import { measureText } from '@jbrowse/core/util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport interface LayoutFeature {\n  heightPx: number\n  topPx: number\n  feature: Feature\n}\n\n// Cache measureText results for small numbers (0-99)\n// Most deletions are small, so this avoids calling measureText in hot loops\nconst smallNumberWidthCache10 = new Map<number, number>()\nconst smallNumberWidthCache = new Map<number, number>()\n\nexport function measureTextSmallNumber(n: number, fontSize?: number) {\n  const cache =\n    fontSize === 10 ? smallNumberWidthCache10 : smallNumberWidthCache\n  if (n >= 0 && n < 100) {\n    let width = cache.get(n)\n    if (width === undefined) {\n      width = measureText(String(n), fontSize)\n      cache.set(n, width)\n    }\n    return width\n  }\n  return measureText(String(n), fontSize)\n}\n","import { colord } from '@jbrowse/core/util/colord'\n\nimport {\n  DELETION_TYPE,\n  HARDCLIP_TYPE,\n  INSERTION_TYPE,\n  INTERBASE_MASK,\n  MISMATCH_REV_MAP,\n  MISMATCH_TYPE,\n  SKIP_TYPE,\n  SOFTCLIP_TYPE,\n} from '../../shared/forEachMismatchTypes.ts'\nimport { measureTextSmallNumber } from '../util.ts'\n\nimport type {\n  FeatureWithMismatchIterator,\n  Mismatch,\n} from '../../shared/types.ts'\nimport type { FlatbushItem } from '../types.ts'\nimport type { LayoutFeature } from '../util.ts'\nimport type { Region } from '@jbrowse/core/util'\n\nconst alphaColorCache = new Map<string, string>()\nfunction applyQualAlpha(baseColor: string, qual: number) {\n  const key = `${baseColor},${qual}`\n  const hit = alphaColorCache.get(key)\n  if (hit) {\n    return hit\n  }\n  const result =\n    qual >= 0\n      ? colord(baseColor)\n          .alpha(Math.min(1, qual / 50))\n          .toHslString()\n      : baseColor\n  alphaColorCache.set(key, result)\n  return result\n}\n\nexport function renderMismatchesCallback({\n  ctx,\n  feat,\n  bpPerPx,\n  regions,\n  minSubfeatureWidth,\n  largeInsertionIndicatorScale,\n  mismatchAlpha,\n  charWidth,\n  charHeight,\n  colorMap,\n  colorContrastMap,\n  hideSmallIndels,\n  hideMismatches,\n  hideLargeIndels,\n  canvasWidth,\n  drawSNPsMuted,\n  checkRef,\n  drawIndels = true,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  bpPerPx: number\n  regions: Region[]\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  mismatchAlpha?: boolean\n  drawIndels?: boolean\n  drawSNPsMuted?: boolean\n  minSubfeatureWidth: number\n  largeInsertionIndicatorScale: number\n  hideSmallIndels: boolean\n  hideMismatches?: boolean\n  hideLargeIndels?: boolean\n  checkRef?: boolean\n  charWidth: number\n  charHeight: number\n  canvasWidth: number\n}) {\n  const items = [] as FlatbushItem[]\n  const coords = [] as number[]\n  const { heightPx, topPx, feature } = feat\n  const bottomPx = topPx + heightPx\n  const featStart = feature.get('start')\n  const region = checkRef\n    ? (regions.find(r => {\n        const rn = feature.get('refName')\n        const end = feature.get('end')\n        return r.refName === rn && r.start <= featStart && end <= r.end\n      }) ?? regions[0]!)\n    : regions[0]!\n\n  const invBpPerPx = 1 / bpPerPx\n  const pxPerBp = Math.min(invBpPerPx, 2)\n  const canRenderText = heightPx >= charHeight - 2\n  const useAlpha = mismatchAlpha === true\n  const regionStart = region.start\n  const regionEnd = region.end\n  const reversed = region.reversed\n\n  // extraHorizontallyFlippedOffset is used to draw interbase items\n  const extraHorizontallyFlippedOffset = reversed ? invBpPerPx + 1 : -1\n\n  // Accumulate insertions/clips for second pass\n  const secondPassItems: {\n    type: number\n    start: number\n    base: string\n    cliplen: number\n  }[] = []\n\n  // Counters for optimization stats\n  let mismatchDrawn = 0\n  let mismatchSkipped = 0\n  let deletionDrawn = 0\n  let deletionSkipped = 0\n\n  // Track last drawn X to avoid redundant draws at same pixel\n  let lastMismatchX = Number.NEGATIVE_INFINITY\n\n  // Check if feature has forEachMismatch method (BAM/CRAM adapters)\n  const featureWithIterator = feature as unknown as FeatureWithMismatchIterator\n  const mismatchHandler = (\n    type: number,\n    start: number,\n    length: number,\n    base: string,\n    qualVal: number | undefined,\n    _altbase: number | undefined,\n    cliplen: number | undefined,\n  ) => {\n    const mismatchStart = featStart + start\n    const mismatchEnd = mismatchStart + length\n\n    // Handle insertions/clips in second pass (interbase events)\n    if ((1 << type) & INTERBASE_MASK) {\n      if (mismatchStart >= regionStart && mismatchStart < regionEnd) {\n        secondPassItems.push({\n          type,\n          start,\n          base,\n          cliplen: cliplen!,\n        })\n      }\n      return\n    }\n\n    // Skip items entirely outside visible region\n    if (mismatchEnd <= regionStart || mismatchStart >= regionEnd) {\n      return\n    }\n\n    const leftPx = reversed\n      ? (regionEnd - mismatchEnd) * invBpPerPx\n      : (mismatchStart - regionStart) * invBpPerPx\n    const rightPx = reversed\n      ? (regionEnd - mismatchStart) * invBpPerPx\n      : (mismatchEnd - regionStart) * invBpPerPx\n\n    // if the mismatch is off-screen, don't render it\n    if (rightPx < 0 || leftPx > canvasWidth) {\n      return\n    }\n\n    const widthPx = Math.max(minSubfeatureWidth, rightPx - leftPx)\n\n    if (type === MISMATCH_TYPE) {\n      if (!hideMismatches) {\n        if (rightPx - leftPx >= 0.2) {\n          items.push({\n            type: 'mismatch',\n            base,\n            start: mismatchStart,\n          })\n          coords.push(leftPx, topPx, rightPx, bottomPx)\n        }\n\n        if (!drawSNPsMuted) {\n          const baseColor = colorMap[base] || '#888'\n          const c =\n            useAlpha && qualVal ? applyQualAlpha(baseColor, qualVal) : baseColor\n          const l = Math.round(leftPx)\n          const w = widthPx\n          // Skip drawing at same X coordinate as previous mismatch\n          if (l === lastMismatchX) {\n            mismatchSkipped++\n          } else if (l + w > 0 && l < canvasWidth) {\n            ctx.fillStyle = c\n            ctx.fillRect(l, topPx, w, heightPx)\n            mismatchDrawn++\n            lastMismatchX = l\n          }\n        }\n\n        if (widthPx >= charWidth && canRenderText) {\n          const contrastColor = drawSNPsMuted\n            ? 'black'\n            : colorContrastMap[base] || 'black'\n          const textColor =\n            useAlpha && qualVal\n              ? applyQualAlpha(contrastColor, qualVal)\n              : contrastColor\n          const x = leftPx + (widthPx - charWidth) / 2 + 1\n          if (x > 0 && x < canvasWidth && textColor) {\n            ctx.fillStyle = textColor\n            ctx.fillText(base, x, bottomPx)\n          }\n        }\n      }\n    } else if (type === DELETION_TYPE && drawIndels) {\n      const shouldHide =\n        (length < 10 && hideSmallIndels) || (length >= 10 && hideLargeIndels)\n      if (!shouldHide) {\n        const w = Math.abs(leftPx - rightPx)\n        // Skip drawing sub-pixel width deletions (< 0.3px)\n        if (w >= 0.3 && leftPx + w > 0 && leftPx < canvasWidth) {\n          ctx.fillStyle = colorMap.deletion!\n          ctx.fillRect(leftPx, topPx, w, heightPx)\n          deletionDrawn++\n          // Add deletion items for mouseover tooltip when visible\n          items.push({\n            type: 'deletion',\n            length,\n            start: mismatchStart,\n          })\n          coords.push(leftPx, topPx, rightPx, bottomPx)\n        } else if (w < 0.3) {\n          deletionSkipped++\n        }\n        const txt = String(length)\n        const rwidth = measureTextSmallNumber(length, 10)\n        if (widthPx >= rwidth && canRenderText) {\n          const x = (leftPx + rightPx) / 2 - rwidth / 2\n          if (x > 0 && x < canvasWidth) {\n            ctx.fillStyle = colorContrastMap.deletion!\n            ctx.fillText(txt, x, bottomPx)\n          }\n        }\n      }\n    } else if (type === SKIP_TYPE) {\n      const w = Math.max(widthPx, 1.5)\n      if (leftPx + w > 0 && leftPx < canvasWidth) {\n        ctx.fillStyle = colorMap.skip!\n        ctx.fillRect(leftPx, topPx + heightPx / 2 - 1, w, 1)\n      }\n    }\n  }\n\n  // First pass: draw mismatches, deletions, skips - accumulate insertions/clips\n  if ('forEachMismatch' in feature) {\n    featureWithIterator.forEachMismatch(mismatchHandler)\n  } else {\n    const mismatches = feature.get('mismatches') as Mismatch[] | undefined\n    if (mismatches) {\n      for (let i = 0, l = mismatches.length; i < l; i++) {\n        const m = mismatches[i]!\n        let base: string\n        let cliplen: number | undefined\n        if (m.type === 'mismatch') {\n          base = m.base\n        } else if (m.type === 'insertion') {\n          base = m.insertedBases ?? ''\n          cliplen = m.insertlen\n        } else if (m.type === 'softclip' || m.type === 'hardclip') {\n          base = ''\n          cliplen = m.cliplen\n        } else {\n          base = ''\n        }\n        mismatchHandler(\n          MISMATCH_REV_MAP[m.type],\n          m.start,\n          m.length,\n          base,\n          m.type === 'mismatch' ? m.qual : undefined,\n          m.type === 'mismatch' ? m.altbase?.charCodeAt(0) : undefined,\n          cliplen,\n        )\n      }\n    }\n  }\n\n  // Second pass: draw insertions and clips on top\n  for (const item of secondPassItems) {\n    const { type, start, base, cliplen } = item\n    const mstart = featStart + start\n\n    const leftPx = reversed\n      ? (regionEnd - mstart - 1) * invBpPerPx\n      : (mstart - regionStart) * invBpPerPx\n    const pos = leftPx + extraHorizontallyFlippedOffset\n\n    // if the mismatch is off-screen, don't render it. give 20px buffer\n    if (pos < -20 || pos > canvasWidth + 20) {\n      continue\n    }\n\n    if (type === INSERTION_TYPE && drawIndels) {\n      const len = cliplen\n      const insW = Math.max(0, Math.min(1.2, invBpPerPx))\n\n      if (len < 10) {\n        if (!hideSmallIndels) {\n          const c = colorMap.insertion!\n          if (pos + insW > 0 && pos < canvasWidth) {\n            ctx.fillStyle = c\n            ctx.fillRect(pos, topPx, insW, heightPx)\n          }\n          if (invBpPerPx >= charWidth && canRenderText) {\n            const l = Math.round(pos - insW)\n            const insW3 = insW * 3\n            if (l + insW3 > 0 && l < canvasWidth) {\n              ctx.fillRect(l, topPx, insW3, 1)\n              ctx.fillRect(l, bottomPx - 1, insW3, 1)\n            }\n            const x = pos + 3\n            if (x > 0 && x < canvasWidth) {\n              ctx.fillText(`(${len})`, x, bottomPx)\n            }\n          }\n          if (bpPerPx < 3) {\n            items.push({\n              type: 'insertion',\n              length: len,\n              ...(base ? { sequence: base } : {}),\n              start: mstart,\n            })\n            coords.push(leftPx - 2, topPx, leftPx + insW + 2, bottomPx)\n          }\n        }\n      } else if (!hideLargeIndels) {\n        items.push({\n          type: 'insertion',\n          length: len,\n          ...(base ? { sequence: base } : {}),\n          start: mstart,\n        })\n        const txt = `${len}`\n        if (bpPerPx > largeInsertionIndicatorScale) {\n          coords.push(leftPx - 1, topPx, leftPx + 1, bottomPx)\n          const l = leftPx - 1\n          const w = 2\n          if (l + w > 0 && l < canvasWidth) {\n            ctx.fillStyle = colorMap.insertion!\n            ctx.fillRect(l, topPx, w, heightPx)\n          }\n        } else if (heightPx > charHeight) {\n          const rwidth = measureTextSmallNumber(len)\n          const padding = 5\n          coords.push(\n            leftPx - rwidth / 2 - padding,\n            topPx,\n            leftPx + rwidth / 2 + padding,\n            bottomPx,\n          )\n          const l = leftPx - rwidth / 2 - padding\n          const w = rwidth + 2 * padding\n          if (l + w > 0 && l < canvasWidth) {\n            ctx.fillStyle = colorMap.insertion!\n            ctx.fillRect(l, topPx, w, heightPx)\n          }\n          const x = leftPx - rwidth / 2\n          if (x > 0 && x < canvasWidth) {\n            ctx.fillStyle = colorContrastMap.insertion!\n            ctx.fillText(txt, x, bottomPx)\n          }\n        } else {\n          const padding = 2\n          coords.push(leftPx - padding, topPx, leftPx + padding, bottomPx)\n          const l = leftPx - padding\n          const w = 2 * padding\n          if (l + w > 0 && l < canvasWidth) {\n            ctx.fillStyle = colorMap.insertion!\n            ctx.fillRect(l, topPx, w, heightPx)\n          }\n        }\n      }\n    } else if (\n      (type === SOFTCLIP_TYPE || type === HARDCLIP_TYPE) &&\n      !hideLargeIndels\n    ) {\n      const typeName = type === SOFTCLIP_TYPE ? 'softclip' : 'hardclip'\n      const c = colorMap[typeName]!\n      const clipW = Math.max(minSubfeatureWidth, pxPerBp)\n      if (pos + clipW > 0 && pos < canvasWidth) {\n        ctx.fillStyle = c\n        ctx.fillRect(pos, topPx, clipW, heightPx)\n      }\n      items.push({ type: typeName, length: cliplen, start: mstart })\n      coords.push(pos - clipW, topPx, pos + clipW * 2, bottomPx)\n      if (invBpPerPx >= charWidth && canRenderText) {\n        const l = pos - clipW\n        const clipW3 = clipW * 3\n        if (l + clipW3 > 0 && l < canvasWidth) {\n          ctx.fillStyle = c\n          ctx.fillRect(l, topPx, clipW3, 1)\n          ctx.fillRect(l, bottomPx - 1, clipW3, 1)\n        }\n        const x = pos + 3\n        if (x > 0 && x < canvasWidth) {\n          ctx.fillStyle = c\n          ctx.fillText(`(${base})`, x, bottomPx)\n        }\n      }\n    }\n  }\n\n  return {\n    coords,\n    items,\n    // Return optimization stats for aggregation at higher level\n    stats: {\n      mismatchDrawn,\n      mismatchSkipped,\n      deletionDrawn,\n      deletionSkipped,\n    },\n  }\n}\n","import { colord } from '@jbrowse/core/util/colord'\n\nimport { getNextRefPos } from '../../MismatchParser/index.ts'\nimport { getModPositions } from '../../ModificationParser/getModPositions.ts'\nimport { getModProbabilities } from '../../ModificationParser/getModProbabilities.ts'\nimport { getMaxProbModAtEachPosition } from '../../shared/getMaximumModificationAtEachPosition.ts'\nimport { getModificationName } from '../../shared/modificationData.ts'\nimport { alphaColor, buildMismatchMap } from '../../shared/util.ts'\nimport { getTagAlt } from '../../util.ts'\n\nimport type { ColorBy, ModificationTypeWithColor } from '../../shared/types.ts'\nimport type { FlatbushItem } from '../types.ts'\nimport type { LayoutFeature } from '../util.ts'\nimport type { Region } from '@jbrowse/core/util'\n\nexport interface RenderModificationsArgs {\n  colorBy?: ColorBy\n  visibleModifications?: Record<string, ModificationTypeWithColor>\n  regionSequence?: string\n}\n\n// Pre-compute colord object for blue color (used in two-color mode)\nconst BLUE_COLORD = colord('blue')\n\n// render modifications stored in MM tag in BAM\nexport function renderModifications({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  renderArgs,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  renderArgs: RenderModificationsArgs\n  cigarOps: ArrayLike<number>\n}) {\n  const items = [] as FlatbushItem[]\n  const coords = [] as number[]\n  const { feature, topPx, heightPx } = feat\n  const { colorBy, visibleModifications = {} } = renderArgs\n\n  const seq = feature.get('seq') as string | undefined\n\n  if (!seq) {\n    return { coords, items }\n  }\n  const start = feature.get('start')\n  const mismatchMap = buildMismatchMap(feature, start)\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  const twoColor = colorBy?.modifications?.twoColor\n  const modificationThreshold = colorBy?.modifications?.threshold ?? 10\n  const thresholdFraction = modificationThreshold / 100\n  const bottomPx = topPx + heightPx\n\n  // Get all modifications with strand info for tooltip\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const modifications = getModPositions(mm, seq, fstrand)\n  const probabilities = getModProbabilities(feature)\n\n  // Build a map of position -> list of modifications with strand info\n  const modsByPosition = new Map<\n    number,\n    { type: string; base: string; strand: string; prob: number }[]\n  >()\n\n  let probIndex = 0\n  for (const { type, base, strand, positions } of modifications) {\n    for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n      const prob =\n        probabilities?.[\n          probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n        ] || 0\n\n      if (!modsByPosition.has(ref)) {\n        modsByPosition.set(ref, [])\n      }\n      modsByPosition.get(ref)!.push({ type, base, strand, prob })\n    }\n    probIndex += positions.length\n  }\n\n  const regionStart = region.start\n  const regionEnd = region.end\n  const reversed = region.reversed\n  const invBpPerPx = 1 / bpPerPx\n\n  // this is a hole-y array, does not work with normal for loop\n  // eslint-disable-next-line unicorn/no-array-for-each\n  getMaxProbModAtEachPosition(feature, cigarOps)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      const r = start + pos\n\n      // Skip positions outside visible region\n      if (r < regionStart || r >= regionEnd) {\n        return\n      }\n\n      const mod = visibleModifications[type]\n      if (!mod || (isolatedModification && mod.type !== isolatedModification)) {\n        return\n      }\n\n      // Check if modification probability exceeds threshold\n      if (prob < thresholdFraction) {\n        return\n      }\n\n      const leftPx = reversed\n        ? (regionEnd - r - 1) * invBpPerPx\n        : (r - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - r) * invBpPerPx\n        : (r + 1 - regionStart) * invBpPerPx\n      const widthPx = rightPx - leftPx + 0.5\n      const col = mod.color || 'black'\n\n      // Compute sum and max in a single pass instead of two utility calls\n      let sumProbs = 0\n      let maxProb = 0\n      for (let i = 0, l = allProbs.length; i < l; i++) {\n        const p = allProbs[i]!\n        sumProbs += p\n        if (p > maxProb) {\n          maxProb = p\n        }\n      }\n      const s = 1 - sumProbs\n\n      ctx.fillStyle =\n        twoColor && s > maxProb\n          ? BLUE_COLORD.alpha(s).toHslString()\n          : alphaColor(col, prob)\n      ctx.fillRect(leftPx, topPx, widthPx, heightPx)\n\n      // Add to flatbush for mouseover with strand-specific info showing all modifications\n      const modsAtPos = modsByPosition.get(pos)\n      if (rightPx - leftPx >= 0.2 && modsAtPos) {\n        const mismatchBase = mismatchMap.get(r)\n        items.push({\n          type: 'modification',\n          info: modsAtPos\n            .map(\n              m =>\n                `${m.base}${m.strand}${m.type} ${getModificationName(m.type)} (${(m.prob * 100).toFixed(1)}%)`,\n            )\n            .join('\\n'),\n          modType: type,\n          probability: prob,\n          start: r,\n          mismatch: mismatchBase,\n        })\n        coords.push(leftPx, topPx, rightPx, bottomPx)\n      }\n\n      pos++\n    },\n  )\n\n  return { coords, items }\n}\n","import { getNextRefPos } from '../MismatchParser/index.ts'\nimport { getModPositions } from '../ModificationParser/getModPositions.ts'\nimport { getModProbabilities } from '../ModificationParser/getModProbabilities.ts'\nimport { getTagAlt } from '../util.ts'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  ops: ArrayLike<number>,\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n"],"names":["getNextRefPos","cigarOps","positions","readPos","refPos","currPos","ret","i","l","length","l2","packed","len","op","CIGAR_S","CIGAR_I","j","CIGAR_D","CIGAR_N","CIGAR_M","CIGAR_X","CIGAR_EQ","push","ref","idx","getModPositions","mm","fseq","fstrand","seq","revcom","seqLength","mods","split","result","mod","basemod","matches","modificationRegex","exec","Error","base","strand","typestr","types","type","splitLength","Array","writeIndex","delta","pos","validPositions","slice","getModProbabilities","feature","m","getTagAlt","parts","mp","phred","charCodeAt","Math","min","CIGAR_H","CIGAR_M_EQ_MASK","CIGAR_REF_CONSUMING_MASK","SEQRET","SEQRET_NUMERIC_DECODER","Uint8Array","CHAR_FROM_CODE","from","_","String","fromCharCode","getCigarOps","cigar","parseCigar2","smallNumberWidthCache10","Map","smallNumberWidthCache","measureTextSmallNumber","n","fontSize","cache","width","get","undefined","measureText","set","alphaColorCache","applyQualAlpha","baseColor","qual","key","hit","colord","alpha","toHslString","renderMismatchesCallback","ctx","feat","bpPerPx","regions","minSubfeatureWidth","largeInsertionIndicatorScale","mismatchAlpha","charWidth","charHeight","colorMap","colorContrastMap","hideSmallIndels","hideMismatches","hideLargeIndels","canvasWidth","drawSNPsMuted","checkRef","drawIndels","items","coords","heightPx","topPx","bottomPx","featStart","region","find","r","rn","end","refName","start","invBpPerPx","pxPerBp","canRenderText","useAlpha","regionStart","regionEnd","reversed","extraHorizontallyFlippedOffset","secondPassItems","mismatchDrawn","mismatchSkipped","deletionDrawn","deletionSkipped","lastMismatchX","Number","NEGATIVE_INFINITY","mismatchHandler","qualVal","_altbase","cliplen","mismatchStart","mismatchEnd","INTERBASE_MASK","leftPx","rightPx","widthPx","max","MISMATCH_TYPE","c","round","w","fillStyle","fillRect","contrastColor","textColor","x","fillText","DELETION_TYPE","abs","deletion","txt","rwidth","SKIP_TYPE","skip","forEachMismatch","mismatches","insertedBases","insertlen","MISMATCH_REV_MAP","altbase","item","mstart","INSERTION_TYPE","insW","insertion","insW3","sequence","padding","SOFTCLIP_TYPE","HARDCLIP_TYPE","typeName","clipW","clipW3","stats","BLUE_COLORD","renderModifications","renderArgs","colorBy","visibleModifications","mismatchMap","buildMismatchMap","isolatedModification","modifications","twoColor","thresholdFraction","threshold","probabilities","modsByPosition","probIndex","prob","has","getMaxProbModAtEachPosition","forEach","allProbs","col","color","sumProbs","maxProb","p","s","alphaColor","modsAtPos","mismatchBase","info","map","getModificationName","toFixed","join","modType","probability","mismatch","ops","maxProbModForPosition","old"],"sourceRoot":""}