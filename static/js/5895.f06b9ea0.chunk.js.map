{"version":3,"file":"static/js/5895.f06b9ea0.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts","../../../plugins/gff3/src/Gff3Adapter/gffParser.ts","../../../node_modules/.pnpm/gff-nostream@3.0.2/node_modules/gff-nostream/src/util.ts","../../../node_modules/.pnpm/gff-nostream@3.0.2/node_modules/gff-nostream/src/api.ts","../../../packages/core/src/util/parseLineByLine.ts"],"sourcesContent":["import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { IntervalTree, fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { parseStringSyncJBrowse } from 'gff-nostream'\n\nimport { parseGffBuffer } from './gffParser.ts'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { NoAssemblyRegion } from '@jbrowse/core/util/types'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree<Feature>> = {}\n\n  gffFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<\n      string,\n      (sc?: StatusCallback) => IntervalTree<Feature>\n    >\n  }>\n\n  private async loadDataP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const buffer = await fetchAndMaybeUnzip(\n      openLocation(this.getConf('gffLocation'), this.pluginManager),\n      opts,\n    )\n\n    const { header, featureMap } = parseGffBuffer(buffer, statusCallback)\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing GFF data')\n            const intervalTree = new IntervalTree<Feature>()\n            const features = parseStringSyncJBrowse(lines)\n            for (let i = 0, l = features.length; i < l; i++) {\n              const f = features[i]!\n              const obj = new SimpleFeature({\n                data: f as unknown as Record<string, unknown>,\n                id: `${this.id}-${refName}-${i}`,\n              })\n              intervalTree.insert([f.start, f.end], obj)\n            }\n\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header,\n      intervalTreeMap,\n    }\n  }\n\n  private async loadData(opts: BaseOptions) {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.loadData(opts)\n    return Object.keys(intervalTreeMap)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTreeMap } = await this.loadData(opts)\n        for (const f of intervalTreeMap[refName]?.(opts.statusCallback).search([\n          start,\n          end,\n        ]) || []) {\n          observer.next(f)\n        }\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n}\n","import { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\n\nimport type { StatusCallback } from '@jbrowse/core/util/parseLineByLine'\n\ninterface GffParseResult {\n  header: string\n  featureMap: Record<string, string>\n}\n\n/**\n * Parse GFF3 buffer into header lines and feature map organized by reference name\n * @param buffer - The GFF3 file buffer\n * @param statusCallback - Optional callback for progress updates\n * @returns Object containing header lines and feature map\n */\nexport function parseGffBuffer(\n  buffer: Uint8Array,\n  statusCallback: StatusCallback = () => {},\n): GffParseResult {\n  const headerLines: string[] = []\n  const featureMap: Record<string, string> = {}\n\n  parseLineByLine(\n    buffer,\n    line => {\n      if (line.startsWith('#')) {\n        headerLines.push(line)\n      } else if (line.startsWith('>')) {\n        return false // Stop parsing at FASTA section\n      } else {\n        const ret = line.indexOf('\\t')\n        const refName = line.slice(0, ret)\n        if (!featureMap[refName]) {\n          featureMap[refName] = ''\n        }\n        featureMap[refName] += `${line}\\n`\n      }\n      return true\n    },\n    statusCallback,\n  )\n\n  return {\n    header: headerLines.join('\\n'),\n    featureMap,\n  }\n}\n","// Fast, low-level functions for parsing and formatting GFF3.\n// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n\nconst escapeRegex = /%([0-9A-Fa-f]{2})/g\nconst directiveRegex = /^\\s*##\\s*(\\S+)\\s*(.*)/\nconst lineEndRegex = /\\r?\\n$/\nconst whitespaceRegex = /\\s+/\nconst nonDigitRegex = /\\D/g\n// eslint-disable-next-line no-control-regex\nconst attrEscapeRegex = /[\\n;\\r\\t=%&,\\u0000-\\u001f\\u007f-\\u00ff]/g\n// eslint-disable-next-line no-control-regex\nconst columnEscapeRegex = /[\\n\\r\\t%\\u0000-\\u001f\\u007f-\\u00ff]/g\n\nconst HEX_LOOKUP: Record<string, string> = {}\nfor (let i = 0; i < 256; i++) {\n  const hex = i.toString(16).toUpperCase().padStart(2, '0')\n  HEX_LOOKUP[hex] = String.fromCharCode(i)\n  HEX_LOOKUP[hex.toLowerCase()] = String.fromCharCode(i)\n}\n\n/**\n * Unescape a string value used in a GFF3 attribute.\n *\n * @param stringVal - Escaped GFF3 string value\n * @returns An unescaped string value\n */\n\nexport function unescape(stringVal: string) {\n  const idx = stringVal.indexOf('%')\n  if (idx === -1) {\n    return stringVal\n  }\n\n  let result = ''\n  let lastIdx = 0\n  let i = idx\n\n  while (i < stringVal.length) {\n    if (stringVal[i] === '%' && i + 2 < stringVal.length) {\n      result += stringVal.slice(lastIdx, i)\n      const hex = stringVal.slice(i + 1, i + 3)\n      const char = HEX_LOOKUP[hex]\n      if (char !== undefined) {\n        result += char\n      } else {\n        result += stringVal.slice(i, i + 3)\n      }\n      i += 3\n      lastIdx = i\n    } else {\n      i++\n    }\n  }\n\n  return result + stringVal.slice(lastIdx)\n}\n\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributes(attrString: string): GFF3Attributes {\n  if (attrString.length === 0 || attrString === '.') {\n    return {}\n  }\n\n  const attrs: GFF3Attributes = {}\n  let len = attrString.length\n\n  if (attrString[len - 1] === '\\n') {\n    len = attrString[len - 2] === '\\r' ? len - 2 : len - 1\n    attrString = attrString.slice(0, len)\n  }\n\n  let start = 0\n  while (start < len) {\n    let semiIdx = attrString.indexOf(';', start)\n    if (semiIdx === -1) {\n      semiIdx = len\n    }\n\n    if (semiIdx > start) {\n      const eqIdx = attrString.indexOf('=', start)\n      if (eqIdx !== -1 && eqIdx < semiIdx && eqIdx + 1 < semiIdx) {\n        const tag = attrString.slice(start, eqIdx)\n        let arec = attrs[tag]\n        if (!arec) {\n          arec = []\n          attrs[tag] = arec\n        }\n\n        let valStart = eqIdx + 1\n        while (valStart < semiIdx) {\n          let commaIdx = attrString.indexOf(',', valStart)\n          if (commaIdx === -1 || commaIdx > semiIdx) {\n            commaIdx = semiIdx\n          }\n          if (commaIdx > valStart) {\n            const val = attrString.slice(valStart, commaIdx)\n            arec.push(unescape(val))\n          }\n          valStart = commaIdx + 1\n        }\n      }\n    }\n    start = semiIdx + 1\n  }\n  return attrs\n}\n\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line without unescaping.\n * Fast path for data known to contain no escaped characters.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributesNoUnescape(attrString: string): GFF3Attributes {\n  if (attrString.length === 0 || attrString === '.') {\n    return {}\n  }\n\n  const attrs: GFF3Attributes = {}\n  let len = attrString.length\n\n  if (attrString[len - 1] === '\\n') {\n    len = attrString[len - 2] === '\\r' ? len - 2 : len - 1\n    attrString = attrString.slice(0, len)\n  }\n\n  let start = 0\n  while (start < len) {\n    let semiIdx = attrString.indexOf(';', start)\n    if (semiIdx === -1) {\n      semiIdx = len\n    }\n\n    if (semiIdx > start) {\n      const eqIdx = attrString.indexOf('=', start)\n      if (eqIdx !== -1 && eqIdx < semiIdx && eqIdx + 1 < semiIdx) {\n        const tag = attrString.slice(start, eqIdx)\n        let arec = attrs[tag]\n        if (!arec) {\n          arec = []\n          attrs[tag] = arec\n        }\n\n        let valStart = eqIdx + 1\n        while (valStart < semiIdx) {\n          let commaIdx = attrString.indexOf(',', valStart)\n          if (commaIdx === -1 || commaIdx > semiIdx) {\n            commaIdx = semiIdx\n          }\n          if (commaIdx > valStart) {\n            arec.push(attrString.slice(valStart, commaIdx))\n          }\n          valStart = commaIdx + 1\n        }\n      }\n    }\n    start = semiIdx + 1\n  }\n  return attrs\n}\n\nfunction normUnescape(s: string) {\n  return s.length === 0 || s === '.' ? null : unescape(s)\n}\n\nfunction norm(s: string) {\n  return s.length === 0 || s === '.' ? null : s\n}\n\n/**\n * Parse a GFF3 feature line\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeature(line: string): GFF3FeatureLine {\n  const f = line.split('\\t')\n  const seq_id = f[0]!\n  const source = f[1]!\n  const type = f[2]!\n  const startStr = f[3]!\n  const endStr = f[4]!\n  const scoreStr = f[5]!\n  const strand = f[6]!\n  const phase = f[7]!\n  const attrString = f[8]!\n\n  return {\n    seq_id: normUnescape(seq_id),\n    source: normUnescape(source),\n    type: normUnescape(type),\n    start: startStr.length === 0 || startStr === '.' ? null : +startStr,\n    end: endStr.length === 0 || endStr === '.' ? null : +endStr,\n    score: scoreStr.length === 0 || scoreStr === '.' ? null : +scoreStr,\n    strand: norm(strand),\n    phase: norm(phase),\n    attributes: attrString.length === 0 || attrString === '.' ? null : parseAttributes(attrString),\n  }\n}\n\n/**\n * Parse a GFF3 feature line without unescaping.\n * Fast path for data known to contain no escaped characters.\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeatureNoUnescape(line: string): GFF3FeatureLine {\n  const f = line.split('\\t')\n  const seq_id = f[0]!\n  const source = f[1]!\n  const type = f[2]!\n  const startStr = f[3]!\n  const endStr = f[4]!\n  const scoreStr = f[5]!\n  const strand = f[6]!\n  const phase = f[7]!\n  const attrString = f[8]!\n\n  return {\n    seq_id: norm(seq_id),\n    source: norm(source),\n    type: norm(type),\n    start: startStr.length === 0 || startStr === '.' ? null : +startStr,\n    end: endStr.length === 0 || endStr === '.' ? null : +endStr,\n    score: scoreStr.length === 0 || scoreStr === '.' ? null : +scoreStr,\n    strand: norm(strand),\n    phase: norm(phase),\n    attributes: attrString.length === 0 || attrString === '.' ? null : parseAttributesNoUnescape(attrString),\n  }\n}\n\n/**\n * Parse a GFF3 feature from a pre-split fields array\n *\n * @param f - Array of 9 GFF3 column values (use null or '.' for empty values)\n * @returns The parsed feature\n */\nexport function parseFieldsArray(\n  f: (string | null | undefined)[],\n): GFF3FeatureLine {\n  const seq_id = f[0]\n  const source = f[1]\n  const type = f[2]\n  const startStr = f[3]\n  const endStr = f[4]\n  const scoreStr = f[5]\n  const strand = f[6]\n  const phase = f[7]\n  const attrString = f[8]\n\n  return {\n    seq_id: seq_id ? normUnescape(seq_id) : null,\n    source: source ? normUnescape(source) : null,\n    type: type ? normUnescape(type) : null,\n    start: !startStr || startStr === '.' ? null : +startStr,\n    end: !endStr || endStr === '.' ? null : +endStr,\n    score: !scoreStr || scoreStr === '.' ? null : +scoreStr,\n    strand: strand && strand !== '.' ? strand : null,\n    phase: phase && phase !== '.' ? phase : null,\n    attributes: !attrString || attrString === '.' ? null : parseAttributes(attrString),\n  }\n}\n\n/**\n * Parse a GFF3 feature from a pre-split fields array without unescaping.\n * Fast path for data known to contain no escaped characters.\n *\n * @param f - Array of 9 GFF3 column values (use null or '.' for empty values)\n * @returns The parsed feature\n */\nexport function parseFieldsArrayNoUnescape(\n  f: (string | null | undefined)[],\n): GFF3FeatureLine {\n  const seq_id = f[0]\n  const source = f[1]\n  const type = f[2]\n  const startStr = f[3]\n  const endStr = f[4]\n  const scoreStr = f[5]\n  const strand = f[6]\n  const phase = f[7]\n  const attrString = f[8]\n\n  return {\n    seq_id: seq_id && seq_id !== '.' ? seq_id : null,\n    source: source && source !== '.' ? source : null,\n    type: type && type !== '.' ? type : null,\n    start: !startStr || startStr === '.' ? null : +startStr,\n    end: !endStr || endStr === '.' ? null : +endStr,\n    score: !scoreStr || scoreStr === '.' ? null : +scoreStr,\n    strand: strand && strand !== '.' ? strand : null,\n    phase: phase && phase !== '.' ? phase : null,\n    attributes: !attrString || attrString === '.' ? null : parseAttributesNoUnescape(attrString),\n  }\n}\n\n/**\n * Parse a GFF3 directive line.\n *\n * @param line - GFF3 directive line\n * @returns The parsed directive\n */\nexport function parseDirective(\n  line: string,\n):\n  | GFF3Directive\n  | GFF3SequenceRegionDirective\n  | GFF3GenomeBuildDirective\n  | null {\n  const match = directiveRegex.exec(line)\n  if (!match) {\n    return null\n  }\n\n  const [, name] = match\n  let [, , contents] = match\n\n  const parsed: GFF3Directive = { directive: name }\n  if (contents!.length) {\n    contents = contents!.replace(lineEndRegex, '')\n    parsed.value = contents\n  }\n\n  // do a little additional parsing for sequence-region and genome-build directives\n  if (name === 'sequence-region') {\n    const c = contents!.split(whitespaceRegex, 3)\n    return {\n      ...parsed,\n      seq_id: c[0],\n      start: c[1]?.replaceAll(nonDigitRegex, ''),\n      end: c[2]?.replaceAll(nonDigitRegex, ''),\n    } as GFF3SequenceRegionDirective\n  } else if (name === 'genome-build') {\n    const [source, buildName] = contents!.split(whitespaceRegex, 2)\n    return {\n      ...parsed,\n      source,\n      buildName,\n    } as GFF3GenomeBuildDirective\n  }\n\n  return parsed\n}\n\n/** A record of GFF3 attribute identifiers and the values of those identifiers */\nexport type GFF3Attributes = Record<string, string[] | undefined>\n\n/** A representation of a single line of a GFF3 file */\nexport interface GFF3FeatureLine {\n  /** The ID of the landmark used to establish the coordinate system for the current feature */\n  seq_id: string | null\n  /** A free text qualifier intended to describe the algorithm or operating procedure that generated this feature */\n  source: string | null\n  /** The type of the feature */\n  type: string | null\n  /** The start coordinates of the feature */\n  start: number | null\n  /** The end coordinates of the feature */\n  end: number | null\n  /** The score of the feature */\n  score: number | null\n  /** The strand of the feature */\n  strand: string | null\n  /** For features of type \"CDS\", the phase indicates where the next codon begins relative to the 5' end of the current CDS feature */\n  phase: string | null\n  /** Feature attributes */\n  attributes: GFF3Attributes | null\n}\n\n/**\n * A GFF3 Feature line that includes references to other features defined in\n * their \"Parent\" or \"Derives_from\" attributes\n */\nexport interface GFF3FeatureLineWithRefs extends GFF3FeatureLine {\n  /** An array of child features */\n  child_features: GFF3Feature[]\n  /** An array of features derived from this feature */\n  derived_features: GFF3Feature[]\n}\n\n/**\n * A GFF3 feature, which may include multiple individual feature lines\n */\nexport type GFF3Feature = GFF3FeatureLineWithRefs[]\n\n/** A GFF3 directive */\nexport interface GFF3Directive {\n  /** The name of the directive */\n  directive: string\n  /** The string value of the directive */\n  value?: string\n}\n\n/** A GFF3 sequence-region directive */\nexport interface GFF3SequenceRegionDirective extends GFF3Directive {\n  /** The string value of the directive */\n  value: string\n  /** The sequence ID parsed from the directive */\n  seq_id: string\n  /** The sequence start parsed from the directive */\n  start: string\n  /** The sequence end parsed from the directive */\n  end: string\n}\n\n/** A GFF3 genome-build directive */\nexport interface GFF3GenomeBuildDirective extends GFF3Directive {\n  /** The string value of the directive */\n  value: string\n  /** The genome build source parsed from the directive */\n  source: string\n  /** The genome build name parsed from the directive */\n  buildName: string\n}\n\n/** A GFF3 comment */\nexport interface GFF3Comment {\n  /** The text of the comment */\n  comment: string\n}\n\n/** A GFF3 FASTA single sequence */\nexport interface GFF3Sequence {\n  /** The ID of the sequence */\n  id: string\n  /** The description of the sequence */\n  description?: string\n  /** The sequence */\n  sequence: string\n}\n\nexport type GFF3Item = GFF3Feature | GFF3Directive | GFF3Comment | GFF3Sequence\n\n// JBrowse format types and parsing functions\n\nconst JBROWSE_DEFAULT_FIELDS = new Set([\n  'start',\n  'end',\n  'seq_id',\n  'score',\n  'type',\n  'source',\n  'phase',\n  'strand',\n])\n\nexport interface JBrowseFeature {\n  start: number\n  end: number\n  strand?: number\n  type: string | null\n  source: string | null\n  refName: string\n  phase?: number\n  score?: number\n  subfeatures: JBrowseFeature[]\n  [key: string]: unknown\n}\n\nfunction parseStrand(s: string) {\n  if (s === '+') {\n    return 1\n  }\n  if (s === '-') {\n    return -1\n  }\n  if (s === '.') {\n    return 0\n  }\n  return undefined\n}\n\nexport function parseAttributesJBrowse(\n  attrString: string,\n  result: Record<string, unknown>,\n) {\n  if (attrString.length === 0 || attrString === '.') {\n    return\n  }\n\n  let len = attrString.length\n  if (attrString[len - 1] === '\\n') {\n    len = attrString[len - 2] === '\\r' ? len - 2 : len - 1\n    attrString = attrString.slice(0, len)\n  }\n\n  let start = 0\n  while (start < len) {\n    let semiIdx = attrString.indexOf(';', start)\n    if (semiIdx === -1) {\n      semiIdx = len\n    }\n\n    if (semiIdx > start) {\n      const eqIdx = attrString.indexOf('=', start)\n      if (eqIdx !== -1 && eqIdx < semiIdx && eqIdx + 1 < semiIdx) {\n        const tag = attrString.slice(start, eqIdx)\n        if (tag === '_lineHash') {\n          start = semiIdx + 1\n          continue\n        }\n\n        let key = tag.toLowerCase()\n        if (JBROWSE_DEFAULT_FIELDS.has(key)) {\n          key += '2'\n        }\n\n        const values: string[] = []\n        let valStart = eqIdx + 1\n        while (valStart < semiIdx) {\n          let commaIdx = attrString.indexOf(',', valStart)\n          if (commaIdx === -1 || commaIdx > semiIdx) {\n            commaIdx = semiIdx\n          }\n          if (commaIdx > valStart) {\n            const val = attrString.slice(valStart, commaIdx)\n            values.push(unescape(val))\n          }\n          valStart = commaIdx + 1\n        }\n\n        result[key] = values.length === 1 ? values[0] : values\n      }\n    }\n    start = semiIdx + 1\n  }\n}\n\nexport function parseAttributesJBrowseNoUnescape(\n  attrString: string,\n  result: Record<string, unknown>,\n) {\n  if (attrString.length === 0 || attrString === '.') {\n    return\n  }\n\n  let len = attrString.length\n  if (attrString[len - 1] === '\\n') {\n    len = attrString[len - 2] === '\\r' ? len - 2 : len - 1\n    attrString = attrString.slice(0, len)\n  }\n\n  let start = 0\n  while (start < len) {\n    let semiIdx = attrString.indexOf(';', start)\n    if (semiIdx === -1) {\n      semiIdx = len\n    }\n\n    if (semiIdx > start) {\n      const eqIdx = attrString.indexOf('=', start)\n      if (eqIdx !== -1 && eqIdx < semiIdx && eqIdx + 1 < semiIdx) {\n        const tag = attrString.slice(start, eqIdx)\n        if (tag === '_lineHash') {\n          start = semiIdx + 1\n          continue\n        }\n\n        let key = tag.toLowerCase()\n        if (JBROWSE_DEFAULT_FIELDS.has(key)) {\n          key += '2'\n        }\n\n        const values: string[] = []\n        let valStart = eqIdx + 1\n        while (valStart < semiIdx) {\n          let commaIdx = attrString.indexOf(',', valStart)\n          if (commaIdx === -1 || commaIdx > semiIdx) {\n            commaIdx = semiIdx\n          }\n          if (commaIdx > valStart) {\n            values.push(attrString.slice(valStart, commaIdx))\n          }\n          valStart = commaIdx + 1\n        }\n\n        result[key] = values.length === 1 ? values[0] : values\n      }\n    }\n    start = semiIdx + 1\n  }\n}\n\nexport function parseFeatureJBrowse(line: string): JBrowseFeature {\n  const f = line.split('\\t')\n  const seq_id = f[0]!\n  const source = f[1]!\n  const type = f[2]!\n  const startStr = f[3]!\n  const endStr = f[4]!\n  const scoreStr = f[5]!\n  const strand = f[6]!\n  const phase = f[7]!\n  const attrString = f[8]!\n\n  const result: JBrowseFeature = {\n    refName: seq_id.length === 0 || seq_id === '.' ? '' : unescape(seq_id),\n    source: source.length === 0 || source === '.' ? null : unescape(source),\n    type: type.length === 0 || type === '.' ? null : unescape(type),\n    start: startStr.length === 0 || startStr === '.' ? 0 : +startStr - 1,\n    end: endStr.length === 0 || endStr === '.' ? 0 : +endStr,\n    score: scoreStr.length === 0 || scoreStr === '.' ? undefined : +scoreStr,\n    strand: parseStrand(strand),\n    phase: phase.length === 0 || phase === '.' ? undefined : +phase,\n    subfeatures: [],\n  }\n\n  parseAttributesJBrowse(attrString, result)\n  return result\n}\n\nexport function parseFeatureJBrowseNoUnescape(line: string): JBrowseFeature {\n  const f = line.split('\\t')\n  const seq_id = f[0]!\n  const source = f[1]!\n  const type = f[2]!\n  const startStr = f[3]!\n  const endStr = f[4]!\n  const scoreStr = f[5]!\n  const strand = f[6]!\n  const phase = f[7]!\n  const attrString = f[8]!\n\n  const result: JBrowseFeature = {\n    refName: seq_id.length === 0 || seq_id === '.' ? '' : seq_id,\n    source: source.length === 0 || source === '.' ? null : source,\n    type: type.length === 0 || type === '.' ? null : type,\n    start: startStr.length === 0 || startStr === '.' ? 0 : +startStr - 1,\n    end: endStr.length === 0 || endStr === '.' ? 0 : +endStr,\n    score: scoreStr.length === 0 || scoreStr === '.' ? undefined : +scoreStr,\n    strand: parseStrand(strand),\n    phase: phase.length === 0 || phase === '.' ? undefined : +phase,\n    subfeatures: [],\n  }\n\n  parseAttributesJBrowseNoUnescape(attrString, result)\n  return result\n}\n","import {\n  parseFeature,\n  parseFeatureJBrowse,\n  parseFeatureJBrowseNoUnescape,\n  parseFeatureNoUnescape,\n} from './util.ts'\n\nimport type {\n  GFF3Feature,\n  GFF3FeatureLineWithRefs,\n  JBrowseFeature,\n} from './util.ts'\n\nexport interface LineRecord {\n  line: string\n  lineHash?: string | number\n  start: number\n  end: number\n  hasEscapes: boolean\n}\n\n/**\n * Synchronously parse a string containing GFF3 and return an array of the\n * parsed items.\n *\n * @param str - GFF3 string\n * @returns array of parsed features\n */\nexport function parseStringSync(str: string): GFF3Feature[] {\n  return parseRecords(stringToRecords(str))\n}\n\n/**\n * Synchronously parse a string containing GFF3 directly into JBrowse format.\n *\n * @param str - GFF3 string\n * @returns array of JBrowse-format features\n */\nexport function parseStringSyncJBrowse(str: string): JBrowseFeature[] {\n  return parseRecordsJBrowse(stringToRecords(str))\n}\n\nfunction stringToRecords(str: string) {\n  const lines = str.split(/\\r?\\n/)\n  const records: LineRecord[] = []\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!\n    if (line.length === 0 || line[0] === '#') {\n      if (line.startsWith('##FASTA')) {\n        break\n      }\n      continue\n    }\n    if (line[0] === '>') {\n      break\n    }\n    records.push({\n      line,\n      start: 0,\n      end: 0,\n      hasEscapes: line.includes('%'),\n    })\n  }\n  return records\n}\n\n/**\n * Parse an array of LineRecord objects containing raw GFF3 lines.\n * Supports parent/child relationships.\n *\n * @param records - Array of LineRecord objects with raw line and metadata\n * @returns array of parsed features\n */\nexport function parseRecords(records: LineRecord[]): GFF3Feature[] {\n  const items: GFF3Feature[] = []\n  const byId = new Map<string, GFF3Feature>()\n  const orphans = new Map<string, GFF3Feature[]>()\n\n  for (let i = 0; i < records.length; i++) {\n    const record = records[i]!\n    const featureLine = (\n      record.hasEscapes\n        ? parseFeature(record.line)\n        : parseFeatureNoUnescape(record.line)\n    ) as GFF3FeatureLineWithRefs\n    featureLine.child_features = []\n    featureLine.derived_features = []\n\n    if (record.lineHash !== undefined) {\n      if (!featureLine.attributes) {\n        featureLine.attributes = {}\n      }\n      featureLine.attributes._lineHash = [String(record.lineHash)]\n    }\n\n    const attrs = featureLine.attributes\n    const ids = attrs?.ID\n    const parents = attrs?.Parent\n\n    if (!ids && !parents) {\n      items.push([featureLine])\n      continue\n    }\n\n    let feature: GFF3Feature\n    if (ids) {\n      const id = ids[0]!\n      const existing = byId.get(id)\n      if (existing) {\n        existing.push(featureLine)\n        feature = existing\n      } else {\n        feature = [featureLine]\n        if (!parents) {\n          items.push(feature)\n        }\n        byId.set(id, feature)\n        const waiting = orphans.get(id)\n        if (waiting) {\n          for (let j = 0; j < waiting.length; j++) {\n            featureLine.child_features.push(waiting[j]!)\n          }\n          orphans.delete(id)\n        }\n      }\n    } else {\n      feature = [featureLine]\n    }\n\n    if (parents) {\n      for (let j = 0; j < parents.length; j++) {\n        const parentId = parents[j]!\n        const parent = byId.get(parentId)\n        if (parent) {\n          for (let k = 0; k < parent.length; k++) {\n            parent[k]!.child_features.push(feature)\n          }\n        } else {\n          let arr = orphans.get(parentId)\n          if (!arr) {\n            arr = []\n            orphans.set(parentId, arr)\n          }\n          arr.push(feature)\n        }\n      }\n    }\n  }\n\n  return items\n}\n\n/**\n * Parse an array of LineRecord objects directly into JBrowse feature format.\n * Supports parent/child relationships via subfeatures.\n *\n * @param records - Array of LineRecord objects with raw line and metadata\n * @returns array of JBrowse-format features\n */\nexport function parseRecordsJBrowse(records: LineRecord[]): JBrowseFeature[] {\n  const items: JBrowseFeature[] = []\n  const byId = new Map<string, JBrowseFeature>()\n  const orphans = new Map<string, JBrowseFeature[]>()\n\n  for (let i = 0; i < records.length; i++) {\n    const record = records[i]!\n    const feature = record.hasEscapes\n      ? parseFeatureJBrowse(record.line)\n      : parseFeatureJBrowseNoUnescape(record.line)\n\n    if (record.lineHash !== undefined) {\n      feature._lineHash = String(record.lineHash)\n    }\n\n    const id = feature.id as string | undefined\n    const parent = feature.parent as string | string[] | undefined\n\n    if (!id && !parent) {\n      items.push(feature)\n      continue\n    }\n\n    if (id) {\n      const existing = byId.get(id)\n      if (!existing) {\n        if (!parent) {\n          items.push(feature)\n        }\n        byId.set(id, feature)\n        const waiting = orphans.get(id)\n        if (waiting) {\n          for (let j = 0; j < waiting.length; j++) {\n            feature.subfeatures.push(waiting[j]!)\n          }\n          orphans.delete(id)\n        }\n      }\n    }\n\n    if (parent) {\n      const parents = Array.isArray(parent) ? parent : [parent]\n      for (let j = 0; j < parents.length; j++) {\n        const parentId = parents[j]!\n        const parentFeature = byId.get(parentId)\n        if (parentFeature) {\n          parentFeature.subfeatures.push(feature)\n        } else {\n          let arr = orphans.get(parentId)\n          if (!arr) {\n            arr = []\n            orphans.set(parentId, arr)\n          }\n          arr.push(feature)\n        }\n      }\n    }\n  }\n\n  return items\n}\n\nexport type {\n  GFF3Comment,\n  GFF3Directive,\n  GFF3Feature,\n  GFF3FeatureLine,\n  GFF3FeatureLineWithRefs,\n  GFF3Item,\n  GFF3Sequence,\n  JBrowseFeature,\n} from './util.ts'\n","import { getProgressDisplayStr } from './index.ts'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n"],"names":["Gff3Adapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","loadDataP","opts","statusCallback","buffer","fetchAndMaybeUnzip","openLocation","this","getConf","pluginManager","header","featureMap","headerLines","parseLineByLine","line","startsWith","push","ret","indexOf","refName","slice","join","parseGffBuffer","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","intervalTree","IntervalTree","features","parseStringSyncJBrowse","i","l","length","f","obj","SimpleFeature","data","id","insert","start","end","loadData","gffFeatures","catch","e","undefined","getRefNames","keys","getHeader","getFeatures","query","ObservableCreate","async","search","observer","next","complete","error","stopToken","HEX_LOOKUP","hex","toString","toUpperCase","padStart","String","fromCharCode","toLowerCase","unescape","stringVal","idx","result","lastIdx","char","JBROWSE_DEFAULT_FIELDS","Set","parseStrand","s","parseFeatureJBrowse","split","seq_id","source","type","startStr","endStr","scoreStr","strand","phase","attrString","score","subfeatures","len","semiIdx","eqIdx","tag","key","has","values","valStart","commaIdx","val","parseAttributesJBrowse","parseFeatureJBrowseNoUnescape","parseAttributesJBrowseNoUnescape","str","parseRecordsJBrowse","records","hasEscapes","includes","stringToRecords","items","byId","Map","orphans","record","feature","lineHash","_lineHash","parent","get","set","waiting","j","delete","parents","Array","isArray","parentId","parentFeature","arr","lineCallback","decoder","TextDecoder","blockStart","n","lineEnd","b","subarray","decode","trim","getProgressDisplayStr"],"ignoreList":[],"sourceRoot":""}