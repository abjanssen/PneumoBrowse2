{"version":3,"file":"static/js/7722.3615b374.chunk.js","mappings":"iPAaO,SAASA,EAA4BC,IAW1CC,EAAAA,EAAAA,aACED,GACAE,EAAAA,EAAAA,UACEC,UACE,IACE,GAAIH,EAAKI,uBAAwB,CAC/B,MAAMC,GAAOC,EAAAA,EAAAA,mBAAkBN,GACzBO,GAAYC,EAAAA,EAAAA,MAClBR,EAAKS,gBAAgBF,GACrB,MAAMG,EAAcC,KAAKC,UAAUP,EAAKQ,eAClCC,QCvBXX,eACLH,EAMAe,GAOA,MAAM,WAAEC,IAAeC,EAAAA,EAAAA,YAAWjB,GAC5BkB,GAAYC,EAAAA,EAAAA,SAAQnB,EAAM,cAAgB,GAC1C,cAAEoB,EAAa,cAAEC,GAAkBrB,EACnCsB,GAAYC,EAAAA,EAAAA,iBAAgBvB,IAC5B,iBAAEwB,GAAqBT,EACvBU,EAAS,CACbH,YACAF,gBACAM,eAAiBC,KACXC,EAAAA,EAAAA,SAAQ5B,IACVA,EAAK6B,WAAWF,EAClB,KAECZ,GAGL,GAAsB,WAAlBM,GAAgD,aAAlBA,EAA8B,CAC9D,MAAMS,QAAiBd,EAAWe,KAChCT,EACA,mCACAG,IAEI,SAAEO,EAAQ,UAAEC,EAAS,YAAEC,GAAgBJ,EAK7C,MAAyB,aAAlBT,EACH,IACKS,EACHE,SAAUA,GAAY,EAAI,EAAIC,EAAYf,EAAYgB,EACtDC,SAAUF,EAAYf,EAAYgB,EAClCV,oBAEF,IACKM,EACHN,mBAER,CACA,GAAsB,UAAlBH,GAA+C,YAAlBA,EAA6B,CAC5D,MAAM,cAAER,EAAa,QAAEuB,IAAY9B,EAAAA,EAAAA,mBAAkBN,GAC/C8B,QAAiBd,EAAWe,KAChCT,EACA,wCACA,IACKG,EACHY,QAASxB,EAAcyB,cAAcC,KAAIC,IACvC,MAAM,MAAEC,EAAK,IAAEC,GAAQF,EACvB,MAAO,IACF7B,KAAKgC,MAAMhC,KAAKC,UAAU4B,IAC7BC,MAAOG,KAAKC,MAAMJ,GAClBC,IAAKE,KAAKE,KAAKJ,GAChB,IAEHN,aAGE,SAAEJ,EAAQ,UAAEC,EAAS,YAAEC,GAAgBJ,EAI7C,MAAyB,YAAlBT,EACH,IACKS,EACHE,SAAUA,GAAY,EAAI,EAAIC,EAAYf,EAAYgB,EACtDC,SAAUF,EAAYf,EAAYgB,EAClCV,oBAEF,IACKM,EACHN,mBAER,CACA,GAAsB,WAAlBH,EACF,OAAOL,EAAWe,KAChBT,EACA,mCACAG,GAGJ,MAAM,IAAIsB,MAAM,0BAA0B1B,KAC5C,CDxEsC2B,CAAqBhD,EAAM,CACnDO,YACA0C,QAAS,GACTzB,iBAAkBnB,EAAK+B,WACpBpC,EAAKkD,kBAGNtB,EAAAA,EAAAA,SAAQ5B,IACVA,EAAKmD,wBAAwBrC,EAAaJ,EAE9C,CACF,CAAE,MAAO0C,IACHxB,EAAAA,EAAAA,SAAQ5B,MAAUqD,EAAAA,EAAAA,kBAAiBD,KACrCE,QAAQC,MAAMH,GACdpD,EAAKwD,SAASJ,GAElB,IAEF,CAAEK,MAAO,MAGf,C","sources":["../../../plugins/wiggle/src/getQuantitativeStatsAutorun.ts","../../../plugins/wiggle/src/getQuantitativeStats.ts"],"sourcesContent":["import { getContainingView, isAbortException } from '@jbrowse/core/util'\nimport { createStopToken } from '@jbrowse/core/util/stopToken'\nimport { autorun } from 'mobx'\nimport { addDisposer, isAlive } from 'mobx-state-tree'\n\nimport { getQuantitativeStats } from './getQuantitativeStats'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { QuantitativeStats } from '@jbrowse/core/util/stats'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport function getQuantitativeStatsAutorun(self: {\n  quantitativeStatsReady: boolean\n  configuration: AnyConfigurationModel\n  adapterConfig: AnyConfigurationModel\n  autoscaleType: string\n  adapterProps: () => Record<string, unknown>\n  setStatsLoading: (token: string) => void\n  setError: (error: unknown) => void\n  setMessage: (str: string) => void\n  updateQuantitativeStats: (stats: QuantitativeStats, region: string) => void\n}) {\n  addDisposer(\n    self,\n    autorun(\n      async () => {\n        try {\n          if (self.quantitativeStatsReady) {\n            const view = getContainingView(self) as LGV\n            const stopToken = createStopToken()\n            self.setStatsLoading(stopToken)\n            const statsRegion = JSON.stringify(view.dynamicBlocks)\n            const wiggleStats = await getQuantitativeStats(self, {\n              stopToken,\n              filters: [],\n              currStatsBpPerPx: view.bpPerPx,\n              ...self.adapterProps(),\n            })\n\n            if (isAlive(self)) {\n              self.updateQuantitativeStats(wiggleStats, statsRegion)\n            }\n          }\n        } catch (e) {\n          if (isAlive(self) && !isAbortException(e)) {\n            console.error(e)\n            self.setError(e)\n          }\n        }\n      },\n      { delay: 1000 },\n    ),\n  )\n}\n","import { getConf } from '@jbrowse/core/configuration'\nimport { getContainingView, getSession } from '@jbrowse/core/util'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\nimport { isAlive } from 'mobx-state-tree'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { QuantitativeStats } from '@jbrowse/core/util/stats'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport async function getQuantitativeStats(\n  self: {\n    adapterConfig: AnyConfigurationModel\n    configuration: AnyConfigurationModel\n    autoscaleType: string\n    setMessage: (str: string) => void\n  },\n  opts: {\n    headers?: Record<string, string>\n    stopToken?: string\n    filters: string[]\n    currStatsBpPerPx: number\n  },\n): Promise<QuantitativeStats> {\n  const { rpcManager } = getSession(self)\n  const numStdDev = getConf(self, 'numStdDev') || 3\n  const { adapterConfig, autoscaleType } = self\n  const sessionId = getRpcSessionId(self)\n  const { currStatsBpPerPx } = opts\n  const params = {\n    sessionId,\n    adapterConfig,\n    statusCallback: (message: string) => {\n      if (isAlive(self)) {\n        self.setMessage(message)\n      }\n    },\n    ...opts,\n  }\n\n  if (autoscaleType === 'global' || autoscaleType === 'globalsd') {\n    const results = (await rpcManager.call(\n      sessionId,\n      'WiggleGetGlobalQuantitativeStats',\n      params,\n    )) as QuantitativeStats\n    const { scoreMin, scoreMean, scoreStdDev } = results\n    // globalsd uses heuristic to avoid unnecessary scoreMin<0\n    //\n    // if the scoreMin is never less than 0 helps with most coverage bigwigs\n    // just being >0\n    return autoscaleType === 'globalsd'\n      ? {\n          ...results,\n          scoreMin: scoreMin >= 0 ? 0 : scoreMean - numStdDev * scoreStdDev,\n          scoreMax: scoreMean + numStdDev * scoreStdDev,\n          currStatsBpPerPx,\n        }\n      : {\n          ...results,\n          currStatsBpPerPx,\n        }\n  }\n  if (autoscaleType === 'local' || autoscaleType === 'localsd') {\n    const { dynamicBlocks, bpPerPx } = getContainingView(self) as LGV\n    const results = (await rpcManager.call(\n      sessionId,\n      'WiggleGetMultiRegionQuantitativeStats',\n      {\n        ...params,\n        regions: dynamicBlocks.contentBlocks.map(region => {\n          const { start, end } = region\n          return {\n            ...JSON.parse(JSON.stringify(region)),\n            start: Math.floor(start),\n            end: Math.ceil(end),\n          }\n        }),\n        bpPerPx,\n      },\n    )) as QuantitativeStats\n    const { scoreMin, scoreMean, scoreStdDev } = results\n\n    // uses heuristic to avoid unnecessary scoreMin<0 if the scoreMin is never\n    // less than 0 helps with most coverage bigwigs just being >0\n    return autoscaleType === 'localsd'\n      ? {\n          ...results,\n          scoreMin: scoreMin >= 0 ? 0 : scoreMean - numStdDev * scoreStdDev,\n          scoreMax: scoreMean + numStdDev * scoreStdDev,\n          currStatsBpPerPx,\n        }\n      : {\n          ...results,\n          currStatsBpPerPx,\n        }\n  }\n  if (autoscaleType === 'zscale') {\n    return rpcManager.call(\n      sessionId,\n      'WiggleGetGlobalQuantitativeStats',\n      params,\n    ) as Promise<QuantitativeStats>\n  }\n  throw new Error(`invalid autoscaleType '${autoscaleType}'`)\n}\n"],"names":["getQuantitativeStatsAutorun","self","addDisposer","autorun","async","quantitativeStatsReady","view","getContainingView","stopToken","createStopToken","setStatsLoading","statsRegion","JSON","stringify","dynamicBlocks","wiggleStats","opts","rpcManager","getSession","numStdDev","getConf","adapterConfig","autoscaleType","sessionId","getRpcSessionId","currStatsBpPerPx","params","statusCallback","message","isAlive","setMessage","results","call","scoreMin","scoreMean","scoreStdDev","scoreMax","bpPerPx","regions","contentBlocks","map","region","start","end","parse","Math","floor","ceil","Error","getQuantitativeStats","filters","adapterProps","updateQuantitativeStats","e","isAbortException","console","error","setError","delay"],"sourceRoot":""}