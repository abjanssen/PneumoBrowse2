{"version":3,"file":"static/js/9776.ade4fb82.chunk.js","mappings":"wPAcO,SAASA,EAA4BC,IAY1CC,EAAAA,EAAAA,aACED,GACAE,EAAAA,EAAAA,SACEC,UACE,IACE,GAAIH,EAAKI,YACP,OAEF,GAAIJ,EAAKK,uBAAwB,CAC/B,MAAMC,GAAOC,EAAAA,EAAAA,mBAAkBP,GACzBQ,GAAYC,EAAAA,EAAAA,MAClBT,EAAKU,gBAAgBF,GACrB,MAAMG,EAAcC,KAAKC,UAAUP,EAAKQ,eAClCC,QCvBXZ,eACLH,EAOAgB,GAOA,MAAM,WAAEC,IAAeC,EAAAA,EAAAA,YAAWlB,GAC5BmB,GAAYC,EAAAA,EAAAA,IAAQpB,EAAM,cAAgB,GAC1C,cAAEqB,EAAa,cAAEC,EAAa,uBAAEC,GAA2BvB,EAC3DwB,GAAYC,EAAAA,EAAAA,iBAAgBzB,GAC5B0B,GAAkBC,EAAAA,EAAAA,oBAAmB3B,GAAM4B,IAC3C,iBAAEC,GAAqBb,EACvBc,EAAS,CACbN,YACAE,kBACAL,gBACAU,cAAeR,EACfS,eAAiBC,KACXC,EAAAA,EAAAA,SAAQlC,IACVA,EAAKmC,iBAAiBF,OAGvBjB,GAGL,GAAsB,WAAlBM,GAAgD,aAAlBA,EAA8B,CAC9D,MAAMc,QAAiBnB,EAAWoB,KAChCb,EACA,mCACAM,IAEI,SAAEQ,EAAQ,UAAEC,EAAS,YAAEC,GAAgBJ,EAK7C,MAAyB,aAAlBd,EACH,IACKc,EACHE,SAAUA,GAAY,EAAI,EAAIC,EAAYpB,EAAYqB,EACtDC,SAAUF,EAAYpB,EAAYqB,EAClCX,oBAEF,IACKO,EACHP,mBAER,CAAO,GAAsB,UAAlBP,GAA+C,YAAlBA,EAA6B,CACnE,MAAM,cAAER,EAAa,aAAE4B,EAAY,QAAEC,IAAYpC,EAAAA,EAAAA,mBAC/CP,GAEIoC,QAAiBnB,EAAWoB,KAChCb,EACA,wCACA,IACKM,EACHc,QAAS9B,EAAc+B,cAAcC,IAAIC,IACvC,MAAM,MAAEC,EAAK,IAAEC,GAAQF,EACvB,MAAO,IACFnC,KAAKsC,MAAMtC,KAAKC,UAAUkC,IAC7BC,MAAOG,KAAKC,MAAMJ,GAClBC,IAAKE,KAAKE,KAAKJ,MAGnBP,aAAcA,EAAaG,cAAcC,IAAIC,IAC3C,MAAM,MAAEC,EAAK,IAAEC,GAAQF,EACvB,MAAO,IACFnC,KAAKsC,MAAMtC,KAAKC,UAAUkC,IAC7BC,MAAOG,KAAKC,MAAMJ,GAClBC,IAAKE,KAAKE,KAAKJ,MAGnBN,aAGE,SAAEL,EAAQ,UAAEC,EAAS,YAAEC,GAAgBJ,EAI7C,MAAyB,YAAlBd,EACH,IACKc,EACHE,SAAUA,GAAY,EAAI,EAAIC,EAAYpB,EAAYqB,EACtDC,SAAUF,EAAYpB,EAAYqB,EAClCX,oBAEF,IACKO,EACHP,mBAER,CAAO,GAAsB,WAAlBP,EACT,OAAOL,EAAWoB,KAChBb,EACA,mCACAM,GAGJ,MAAM,IAAIwB,MAAM,0BAA0BhC,KAC5C,CDpFsCiC,CAAqBvD,EAAM,CACnDQ,YACAgD,QAAS,GACT3B,iBAAkBvB,EAAKqC,WACpB3C,EAAKyD,kBAGNvB,EAAAA,EAAAA,SAAQlC,IACVA,EAAK0D,wBAAwB3C,EAAaJ,EAE9C,CACF,CAAE,MAAOgD,IACHzB,EAAAA,EAAAA,SAAQlC,MAAU4D,EAAAA,EAAAA,IAAiBD,KACrCE,QAAQC,MAAMH,GACd3D,EAAK+D,SAASJ,GAElB,GAEF,CAAEK,MAAO,MAGf,C","sources":["../../../plugins/wiggle/src/getQuantitativeStatsAutorun.ts","../../../plugins/wiggle/src/getQuantitativeStats.ts"],"sourcesContent":["import { getContainingView, isAbortException } from '@jbrowse/core/util'\nimport { createStopToken } from '@jbrowse/core/util/stopToken'\nimport { addDisposer, isAlive } from '@jbrowse/mobx-state-tree'\nimport { autorun } from 'mobx'\n\nimport { getQuantitativeStats } from './getQuantitativeStats.ts'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { QuantitativeStats } from '@jbrowse/core/util/stats'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport function getQuantitativeStatsAutorun(self: {\n  quantitativeStatsReady: boolean\n  configuration: AnyConfigurationModel\n  adapterConfig: AnyConfigurationModel\n  autoscaleType: string\n  isMinimized: boolean\n  adapterProps: () => Record<string, unknown>\n  setStatsLoading: (token: StopToken) => void\n  setError: (error: unknown) => void\n  setStatusMessage: (str: string) => void\n  updateQuantitativeStats: (stats: QuantitativeStats, region: string) => void\n}) {\n  addDisposer(\n    self,\n    autorun(\n      async () => {\n        try {\n          if (self.isMinimized) {\n            return\n          }\n          if (self.quantitativeStatsReady) {\n            const view = getContainingView(self) as LGV\n            const stopToken = createStopToken()\n            self.setStatsLoading(stopToken)\n            const statsRegion = JSON.stringify(view.dynamicBlocks)\n            const wiggleStats = await getQuantitativeStats(self, {\n              stopToken,\n              filters: [],\n              currStatsBpPerPx: view.bpPerPx,\n              ...self.adapterProps(),\n            })\n\n            if (isAlive(self)) {\n              self.updateQuantitativeStats(wiggleStats, statsRegion)\n            }\n          }\n        } catch (e) {\n          if (isAlive(self) && !isAbortException(e)) {\n            console.error(e)\n            self.setError(e)\n          }\n        }\n      },\n      { delay: 500 },\n    ),\n  )\n}\n","import { getConf } from '@jbrowse/core/configuration'\nimport {\n  getContainingTrack,\n  getContainingView,\n  getSession,\n} from '@jbrowse/core/util'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\nimport { isAlive } from '@jbrowse/mobx-state-tree'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { QuantitativeStats } from '@jbrowse/core/util/stats'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport async function getQuantitativeStats(\n  self: {\n    adapterConfig: AnyConfigurationModel\n    configuration: AnyConfigurationModel\n    autoscaleType: string\n    setStatusMessage: (str: string) => void\n    effectiveRpcDriverName?: string\n  },\n  opts: {\n    headers?: Record<string, string>\n    stopToken?: StopToken\n    filters: string[]\n    currStatsBpPerPx: number\n  },\n): Promise<QuantitativeStats> {\n  const { rpcManager } = getSession(self)\n  const numStdDev = getConf(self, 'numStdDev') || 3\n  const { adapterConfig, autoscaleType, effectiveRpcDriverName } = self\n  const sessionId = getRpcSessionId(self)\n  const trackInstanceId = getContainingTrack(self).id\n  const { currStatsBpPerPx } = opts\n  const params = {\n    sessionId,\n    trackInstanceId,\n    adapterConfig,\n    rpcDriverName: effectiveRpcDriverName,\n    statusCallback: (message: string) => {\n      if (isAlive(self)) {\n        self.setStatusMessage(message)\n      }\n    },\n    ...opts,\n  }\n\n  if (autoscaleType === 'global' || autoscaleType === 'globalsd') {\n    const results = (await rpcManager.call(\n      sessionId,\n      'WiggleGetGlobalQuantitativeStats',\n      params,\n    )) as QuantitativeStats\n    const { scoreMin, scoreMean, scoreStdDev } = results\n    // globalsd uses heuristic to avoid unnecessary scoreMin<0\n    //\n    // if the scoreMin is never less than 0 helps with most coverage bigwigs\n    // just being >0\n    return autoscaleType === 'globalsd'\n      ? {\n          ...results,\n          scoreMin: scoreMin >= 0 ? 0 : scoreMean - numStdDev * scoreStdDev,\n          scoreMax: scoreMean + numStdDev * scoreStdDev,\n          currStatsBpPerPx,\n        }\n      : {\n          ...results,\n          currStatsBpPerPx,\n        }\n  } else if (autoscaleType === 'local' || autoscaleType === 'localsd') {\n    const { dynamicBlocks, staticBlocks, bpPerPx } = getContainingView(\n      self,\n    ) as LGV\n    const results = (await rpcManager.call(\n      sessionId,\n      'WiggleGetMultiRegionQuantitativeStats',\n      {\n        ...params,\n        regions: dynamicBlocks.contentBlocks.map(region => {\n          const { start, end } = region\n          return {\n            ...JSON.parse(JSON.stringify(region)),\n            start: Math.floor(start),\n            end: Math.ceil(end),\n          }\n        }),\n        staticBlocks: staticBlocks.contentBlocks.map(region => {\n          const { start, end } = region\n          return {\n            ...JSON.parse(JSON.stringify(region)),\n            start: Math.floor(start),\n            end: Math.ceil(end),\n          }\n        }),\n        bpPerPx,\n      },\n    )) as QuantitativeStats\n    const { scoreMin, scoreMean, scoreStdDev } = results\n\n    // uses heuristic to avoid unnecessary scoreMin<0 if the scoreMin is never\n    // less than 0 helps with most coverage bigwigs just being >0\n    return autoscaleType === 'localsd'\n      ? {\n          ...results,\n          scoreMin: scoreMin >= 0 ? 0 : scoreMean - numStdDev * scoreStdDev,\n          scoreMax: scoreMean + numStdDev * scoreStdDev,\n          currStatsBpPerPx,\n        }\n      : {\n          ...results,\n          currStatsBpPerPx,\n        }\n  } else if (autoscaleType === 'zscale') {\n    return rpcManager.call(\n      sessionId,\n      'WiggleGetGlobalQuantitativeStats',\n      params,\n    ) as Promise<QuantitativeStats>\n  }\n  throw new Error(`invalid autoscaleType '${autoscaleType}'`)\n}\n"],"names":["getQuantitativeStatsAutorun","self","addDisposer","autorun","async","isMinimized","quantitativeStatsReady","view","getContainingView","stopToken","createStopToken","setStatsLoading","statsRegion","JSON","stringify","dynamicBlocks","wiggleStats","opts","rpcManager","getSession","numStdDev","getConf","adapterConfig","autoscaleType","effectiveRpcDriverName","sessionId","getRpcSessionId","trackInstanceId","getContainingTrack","id","currStatsBpPerPx","params","rpcDriverName","statusCallback","message","isAlive","setStatusMessage","results","call","scoreMin","scoreMean","scoreStdDev","scoreMax","staticBlocks","bpPerPx","regions","contentBlocks","map","region","start","end","parse","Math","floor","ceil","Error","getQuantitativeStats","filters","adapterProps","updateQuantitativeStats","e","isAbortException","console","error","setError","delay"],"ignoreList":[],"sourceRoot":""}