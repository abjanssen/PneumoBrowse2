{"version":3,"file":"static/js/6214.ac6a34fc.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedTabixAdapter/BedTabixAdapter.ts","../../../plugins/bed/src/generateRepeatMaskerFeature.ts","../../../plugins/bed/src/util.ts","../../../plugins/bed/src/generateBedMethylFeature.ts","../../../plugins/bed/src/generateUcscTranscript.ts"],"sourcesContent":["import BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport {\n  FileLocation,\n  Region,\n  Feature,\n  SimpleFeature,\n} from '@jbrowse/core/util'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\n\n// locals\nimport { featureData } from '../util'\n\nexport default class BedTabixAdapter extends BaseFeatureDataAdapter {\n  private parser: BED\n\n  protected bed: TabixIndexedFile\n\n  protected columnNames: string[]\n\n  protected scoreColumn: string\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  public constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const bedGzLoc = this.getConf('bedGzLocation') as FileLocation\n    const type = this.getConf(['index', 'indexType'])\n    const loc = this.getConf(['index', 'location'])\n    const autoSql = this.getConf('autoSql')\n    const pm = this.pluginManager\n\n    this.bed = new TabixIndexedFile({\n      filehandle: openLocation(bedGzLoc, pm),\n      csiFilehandle: type === 'CSI' ? openLocation(loc, pm) : undefined,\n      tbiFilehandle: type !== 'CSI' ? openLocation(loc, pm) : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n    this.columnNames = this.getConf('columnNames')\n    this.scoreColumn = this.getConf('scoreColumn')\n    this.parser = new BED({ autoSql })\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    return this.bed.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader() {\n    return this.bed.getHeader()\n  }\n\n  async getNames() {\n    if (this.columnNames.length) {\n      return this.columnNames\n    }\n    const header = await this.bed.getHeader()\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(f => f.trim())\n      : undefined\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const meta = await this.bed.getMetadata()\n      const { columnNumbers } = meta\n      const colRef = columnNumbers.ref - 1\n      const colStart = columnNumbers.start - 1\n      const colEnd = columnNumbers.end - 1\n      const names = await this.getNames()\n      await this.bed.getLines(query.refName, query.start, query.end, {\n        lineCallback: (line, fileOffset) => {\n          observer.next(\n            new SimpleFeature(\n              featureData({\n                line,\n                colRef,\n                colStart,\n                colEnd,\n                scoreColumn: this.scoreColumn,\n                parser: this.parser,\n                uniqueId: `${this.id}-${fileOffset}`,\n                names,\n              }),\n            ),\n          )\n        },\n        signal: opts.signal,\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","export function isRepeatMaskerDescriptionField(desc?: string): desc is string {\n  const ret = desc?.trim().split(' ')\n  return [0, 1, 2, 3, 5, 6].every(s =>\n    ret?.[s] !== undefined ? !Number.isNaN(+ret[s]) : false,\n  )\n}\n\nfunction makeRepeatTrackDescription(description?: string) {\n  if (isRepeatMaskerDescriptionField(description)) {\n    const [\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    ] = description.trim().split(' ')\n    return {\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    }\n  }\n  return { description }\n}\n\nexport function generateRepeatMaskerFeature({\n  uniqueId,\n  refName,\n  start,\n  end,\n  description,\n  ...rest\n}: {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  description: string\n  [key: string]: unknown\n}) {\n  return {\n    ...rest,\n    ...makeRepeatTrackDescription(description),\n    uniqueId,\n    refName,\n    start,\n    end,\n  }\n}\n","import BED from '@gmod/bed'\nimport { SimpleFeatureSerialized } from '@jbrowse/core/util'\nimport {\n  generateBedMethylFeature,\n  isBedMethylFeature,\n} from './generateBedMethylFeature'\nimport {\n  generateUcscTranscript,\n  isUcscTranscript,\n} from './generateUcscTranscript'\nimport {\n  generateRepeatMaskerFeature,\n  isRepeatMaskerDescriptionField,\n} from './generateRepeatMaskerFeature'\n\nfunction stringToStrand(f: string) {\n  if (f === '-1') {\n    return -1\n  } else if (f === '+') {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  const obj = Object.fromEntries(\n    line.split('\\t').map((f, i) => [fields[i]!, f] as const),\n  )\n  const {\n    blockStarts,\n    blockCount,\n    chromStarts,\n    thickEnd,\n    thickStart,\n    blockSizes,\n    ...rest\n  } = obj\n\n  return {\n    ...rest,\n    blockStarts: arrayify(blockStarts),\n    chromStarts: arrayify(chromStarts),\n    blockSizes: arrayify(blockSizes),\n    thickStart: thickStart ? +thickStart : undefined,\n    thickEnd: thickEnd ? +thickEnd : undefined,\n    blockCount: blockCount ? +blockCount : undefined,\n  } as Record<string, unknown>\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes?: number[]\n  blockStarts?: number[]\n}) {\n  if (blockCount) {\n    const subfeatures = []\n    const starts = chromStarts || blockStarts || []\n    for (let b = 0; b < blockCount; b++) {\n      const bmin = (starts[b] || 0) + start\n      const bsize = blockSizes?.[b]\n      if (bsize && bsize > 0) {\n        const bmax = bmin + bsize\n        subfeatures.push({\n          uniqueId: `${uniqueId}-${b}`,\n          start: bmin,\n          end: bmax,\n          refName,\n          type: 'block',\n        })\n      }\n    }\n    return subfeatures\n  }\n  return []\n}\n\nexport function featureData({\n  line,\n  colRef,\n  colStart,\n  colEnd,\n  scoreColumn,\n  parser,\n  uniqueId,\n  names,\n}: {\n  line: string\n  colRef: number\n  colStart: number\n  colEnd: number\n  scoreColumn: string\n  parser: BED\n  uniqueId: string\n  names?: string[]\n}) {\n  const splitLine = line.split('\\t')\n  const refName = splitLine[colRef]!\n  const start = +splitLine[colStart]!\n  const end = +splitLine[colEnd]! + (colStart === colEnd ? 1 : 0)\n\n  return featureData2({\n    line,\n    refName,\n    start,\n    end,\n    parser,\n    uniqueId,\n    scoreColumn,\n    names,\n  })\n}\n\nexport function featureData2({\n  line,\n  refName,\n  start,\n  end,\n  parser,\n  uniqueId,\n  scoreColumn,\n  names,\n}: {\n  line: string\n  refName: string\n  start: number\n  end: number\n  parser: BED\n  uniqueId: string\n  scoreColumn: string\n  names?: string[]\n}): SimpleFeatureSerialized {\n  const splitLine = line.split('\\t')\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n  const {\n    strand: strand2,\n    score: score2,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n\n  const {\n    chromStarts,\n    blockSizes,\n    blockStarts,\n    type,\n    blockCount,\n    thickStart,\n    thickEnd,\n    description,\n    ...rest2\n  } = rest\n  const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined\n  const strand = typeof strand2 === 'string' ? stringToStrand(strand2) : strand2\n\n  const subfeatures = makeBlocks({\n    start,\n    uniqueId,\n    refName,\n    chromStarts,\n    blockCount,\n    blockSizes,\n    blockStarts,\n  })\n\n  if (isBedMethylFeature({ splitLine, start, end })) {\n    return generateBedMethylFeature({\n      line,\n      uniqueId,\n      refName,\n      start,\n      end,\n    })\n  } else if (isRepeatMaskerDescriptionField(description)) {\n    return generateRepeatMaskerFeature({\n      ...rest2,\n      uniqueId,\n      description,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    })\n  } else if (isUcscTranscript({ strand, blockCount, thickStart })) {\n    return generateUcscTranscript({\n      ...rest,\n      description,\n      chromStarts,\n      thickStart,\n      thickEnd,\n      blockSizes,\n      blockCount,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      uniqueId,\n      subfeatures,\n    })\n  } else {\n    return {\n      ...rest,\n      uniqueId,\n      description,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    }\n  }\n}\n\nexport function arrayify(f?: string | number[]) {\n  return f !== undefined\n    ? typeof f === 'string'\n      ? f.split(',').map(f => +f)\n      : f\n    : undefined\n}\n","export function isBedMethylFeature({\n  splitLine,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  start: number\n  end: number\n}) {\n  return +(splitLine[6] || 0) === start && +(splitLine[7] || 0) === end\n}\nexport function generateBedMethylFeature({\n  line,\n  uniqueId,\n  refName,\n  start,\n  end,\n}: {\n  line: string\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n}) {\n  // see\n  // https://github.com/nanoporetech/modkit?tab=readme-ov-file#description-of-bedmethyl-output\n  const [\n    ,\n    ,\n    ,\n    code,\n    ,\n    strand,\n    ,\n    ,\n    color,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  ] = line.split('\\t')\n  return {\n    uniqueId,\n    refName,\n    start,\n    end,\n    code,\n    score: fraction_modified,\n    strand,\n    color,\n    source: code,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  }\n}\n","import { MinimalFeature, TranscriptFeat } from './types'\n\nexport function isUcscTranscript({\n  thickStart,\n  blockCount,\n  strand,\n}: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return thickStart && blockCount && strand !== 0\n}\n\nexport function generateUcscTranscript(data: TranscriptFeat) {\n  const {\n    strand = 0,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    chromStarts,\n    blockStarts,\n    blockSizes,\n    uniqueId,\n    ...rest\n  } = data\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    refName,\n    ...rest2\n  } = rest\n\n  const subfeatures: MinimalFeature[] = []\n  const feats = oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n\n  for (const block of feats) {\n    const start = block.start\n    const end = block.end\n    if (thickStart >= end) {\n      // left-side UTR\n      subfeatures.push({\n        type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n        start,\n        end,\n        refName,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n      // UTR | CDS\n      subfeatures.push(\n        {\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end: thickStart,\n          refName,\n        },\n        {\n          type: 'CDS',\n          start: thickStart,\n          end,\n          refName,\n        },\n      )\n    } else if (thickStart <= start && thickEnd >= end) {\n      // CDS\n      subfeatures.push({\n        type: 'CDS',\n        start,\n        end,\n        refName,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd < end) {\n      // UTR | CDS | UTR\n      subfeatures.push(\n        {\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end: thickStart,\n          refName,\n        },\n        {\n          type: 'CDS',\n          start: thickStart,\n          end: thickEnd,\n          refName,\n        },\n        {\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start: thickEnd,\n          end,\n          refName,\n        },\n      )\n    } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n      // CDS | UTR\n      subfeatures.push(\n        {\n          type: 'CDS',\n          start,\n          end: thickEnd,\n          refName,\n        },\n        {\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start: thickEnd,\n          end,\n          refName,\n        },\n      )\n    } else if (thickEnd <= start) {\n      // right-side UTR\n      subfeatures.push({\n        type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n        start,\n        end,\n        refName,\n      })\n    }\n  }\n\n  return {\n    ...rest2,\n    uniqueId,\n    strand,\n    type: 'mRNA',\n    refName,\n    subfeatures,\n  }\n}\n"],"names":["BedTabixAdapter","BaseFeatureDataAdapter","constructor","config","getSubAdapter","pluginManager","super","bedGzLoc","this","getConf","type","loc","autoSql","pm","bed","TabixIndexedFile","filehandle","openLocation","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","columnNames","scoreColumn","parser","BED","getRefNames","opts","getReferenceSequenceNames","getHeader","getNames","length","defline","split","filter","f","at","includes","slice","map","trim","getFeatures","query","ObservableCreate","async","meta","getMetadata","columnNumbers","colRef","ref","colStart","start","colEnd","end","names","getLines","refName","lineCallback","line","fileOffset","observer","next","SimpleFeature","featureData","uniqueId","id","signal","complete","freeResources","isRepeatMaskerDescriptionField","desc","ret","every","s","Number","isNaN","makeRepeatTrackDescription","description","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","splitLine","featureData2","data","fields","obj","Object","fromEntries","i","blockStarts","blockCount","chromStarts","thickEnd","thickStart","blockSizes","rest","arrayify","defaultParser","parseLine","strand","strand2","score","score2","chrom","_1","chromStart","_2","chromEnd","_3","rest2","subfeatures","starts","b","bmin","bsize","bmax","push","makeBlocks","isBedMethylFeature","code","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","source","generateBedMethylFeature","generateRepeatMaskerFeature","isUcscTranscript","oldSubfeatures","feats","child","sort","a","block","generateUcscTranscript"],"sourceRoot":""}