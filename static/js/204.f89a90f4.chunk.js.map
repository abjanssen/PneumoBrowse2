{"version":3,"file":"static/js/204.f89a90f4.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/wiggle/src/MultiDensityRenderer/renderMultiDensity.ts","webpack://@jbrowse/web/../../plugins/wiggle/src/drawDensity.ts"],"sourcesContent":["import {\n  groupBy,\n  renderToAbstractCanvas,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\nimport { createStopTokenChecker } from '@jbrowse/core/util/stopToken'\n\nimport { drawDensity } from '../drawDensity.ts'\nimport { serializeWiggleFeature } from '../util.ts'\n\nimport type { MultiRenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderMultiDensity(\n  renderProps: MultiRenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    sources,\n    height,\n    regions,\n    bpPerPx,\n    stopToken,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const rowHeight = height / sources.length\n  const lastCheck = createStopTokenChecker(stopToken)\n\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx => {\n        const groups = groupBy(features, f => f.get('source'))\n        let feats: Feature[] = []\n        ctx.save()\n        for (const source of sources) {\n          const { reducedFeatures } = drawDensity(ctx, {\n            ...renderProps,\n            features: groups[source.name] || [],\n            height: rowHeight,\n            lastCheck,\n          })\n          ctx.translate(0, rowHeight)\n          feats = feats.concat(reducedFeatures)\n        }\n        ctx.restore()\n        return { reducedFeatures: feats }\n      }),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { fillRectCtx, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, Region } from '@jbrowse/core/util'\nimport type {\n  LastStopTokenCheck,\n  StopToken,\n} from '@jbrowse/core/util/stopToken'\n\nconst fudgeFactor = 0.3\nconst clipHeight = 2\n\nexport function drawDensity(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    regions: Region[]\n    bpPerPx: number\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    displayCrossHatches: boolean\n    config: AnyConfigurationModel\n    stopToken?: StopToken\n    lastCheck?: LastStopTokenCheck\n  },\n) {\n  const {\n    features,\n    regions,\n    bpPerPx,\n    scaleOpts,\n    height,\n    config,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionReversed = region.reversed\n  const inverseBpPerPx = 1 / bpPerPx\n\n  const pivot = readConfObject(config, 'bicolorPivot')\n  const pivotValue = readConfObject(config, 'bicolorPivotValue')\n  const negColor = readConfObject(config, 'negColor')\n  const posColor = readConfObject(config, 'posColor')\n  const color = readConfObject(config, 'color')\n  const clipColor = readConfObject(config, 'clipColor')\n  const crossing = pivot !== 'none' && scaleOpts.scaleType !== 'log'\n  const scale = getScale({\n    ...scaleOpts,\n    pivotValue: crossing ? pivotValue : undefined,\n    range: crossing ? [negColor, '#eee', posColor] : ['#eee', posColor],\n  })\n\n  const scale2 = getScale({ ...scaleOpts, range: [0, height] })\n  const cb =\n    color === '#f0f'\n      ? (_: Feature, score: number) => scale(score)\n      : (feature: Feature, score: number) =>\n          readConfObject(config, 'color', { feature, score })\n  const domain = scale2.domain()\n  const niceMin = domain[0]!\n  const niceMax = domain[1]!\n\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  let hasClipping = false\n  const reducedFeatures = []\n  for (const feature of features.values()) {\n    checkStopToken2(lastCheck)\n    const fStart = feature.get('start')\n    const fEnd = feature.get('end')\n    const leftPx = regionReversed\n      ? (regionEnd - fEnd) * inverseBpPerPx\n      : (fStart - regionStart) * inverseBpPerPx\n    const rightPx = regionReversed\n      ? (regionEnd - fStart) * inverseBpPerPx\n      : (fEnd - regionStart) * inverseBpPerPx\n\n    // create reduced features, avoiding multiple features per px\n    if (Math.floor(leftPx) !== Math.floor(prevLeftPx) || rightPx - leftPx > 1) {\n      reducedFeatures.push(feature)\n      prevLeftPx = leftPx\n    }\n    const score = feature.get('score')\n    hasClipping = hasClipping || score > niceMax || score < niceMin\n    const w = rightPx - leftPx + fudgeFactor\n    if (score >= scaleOpts.domain[0]!) {\n      ctx.fillStyle = cb(feature, score)\n      ctx.fillRect(leftPx, 0, w, height)\n    } else {\n      ctx.fillStyle = '#eee'\n      ctx.fillRect(leftPx, 0, w, height)\n    }\n  }\n\n  // second pass: draw clipping\n  // avoid persisting the red fillstyle with save/restore\n  ctx.save()\n  if (hasClipping) {\n    ctx.fillStyle = clipColor\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const w = rightPx - leftPx + fudgeFactor\n      const score = feature.get('score')\n      if (score > niceMax) {\n        fillRectCtx(leftPx, 0, w, clipHeight, ctx)\n      } else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n        fillRectCtx(leftPx, 0, w, clipHeight, ctx)\n      }\n    }\n  }\n  ctx.restore()\n\n  return {\n    reducedFeatures,\n  }\n}\n"],"names":["async","renderMultiDensity","renderProps","features","sources","height","regions","bpPerPx","stopToken","statusCallback","region","width","end","start","rowHeight","length","lastCheck","createStopTokenChecker","reducedFeatures","rest","updateStatus","renderToAbstractCanvas","ctx","groups","groupBy","f","get","feats","save","source","drawDensity","name","translate","concat","restore","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables","props","scaleOpts","config","regionStart","regionEnd","regionReversed","reversed","inverseBpPerPx","pivot","readConfObject","pivotValue","negColor","posColor","color","clipColor","crossing","scaleType","scale","getScale","undefined","range","cb","_","score","feature","domain","niceMin","niceMax","prevLeftPx","Number","NEGATIVE_INFINITY","hasClipping","values","checkStopToken2","fStart","fEnd","leftPx","rightPx","Math","floor","push","w","fillStyle","fillRect","fillRectCtx"],"sourceRoot":""}