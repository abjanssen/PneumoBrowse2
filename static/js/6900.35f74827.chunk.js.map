{"version":3,"file":"static/js/6900.35f74827.chunk.js","mappings":"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","sources":["../../../node_modules/.pnpm/is-plain-object@2.0.4/node_modules/is-plain-object/index.js","../../../node_modules/.pnpm/set-value@4.1.0/node_modules/set-value/index.js","../../../node_modules/.pnpm/is-primitive@3.0.1/node_modules/is-primitive/index.js","../../../node_modules/.pnpm/isobject@3.0.1/node_modules/isobject/index.js","../../../plugins/legacy-jbrowse/src/JBrowse1Connection/get-value.ts","../../../plugins/legacy-jbrowse/src/JBrowse1Connection/util.ts","../../../plugins/legacy-jbrowse/src/JBrowse1Connection/jb1ConfigParse.ts","../../../plugins/legacy-jbrowse/src/JBrowse1Connection/jb1ConfigLoad.ts"],"sourcesContent":["/*!\n * is-plain-object <https://github.com/jonschlinkert/is-plain-object>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nvar isObject = require('isobject');\n\nfunction isObjectObject(o) {\n  return isObject(o) === true\n    && Object.prototype.toString.call(o) === '[object Object]';\n}\n\nmodule.exports = function isPlainObject(o) {\n  var ctor,prot;\n\n  if (isObjectObject(o) === false) return false;\n\n  // If has modified constructor\n  ctor = o.constructor;\n  if (typeof ctor !== 'function') return false;\n\n  // If has modified prototype\n  prot = ctor.prototype;\n  if (isObjectObject(prot) === false) return false;\n\n  // If constructor does not have an Object-specific method\n  if (prot.hasOwnProperty('isPrototypeOf') === false) {\n    return false;\n  }\n\n  // Most likely a plain Object\n  return true;\n};\n","/*!\n * set-value <https://github.com/jonschlinkert/set-value>\n *\n * Copyright (c) Jon Schlinkert (https://github.com/jonschlinkert).\n * Released under the MIT License.\n */\n\n'use strict';\n\nconst { deleteProperty } = Reflect;\nconst isPrimitive = require('is-primitive');\nconst isPlainObject = require('is-plain-object');\n\nconst isObject = value => {\n  return (typeof value === 'object' && value !== null) || typeof value === 'function';\n};\n\nconst isUnsafeKey = key => {\n  return key === '__proto__' || key === 'constructor' || key === 'prototype';\n};\n\nconst validateKey = key => {\n  if (!isPrimitive(key)) {\n    throw new TypeError('Object keys must be strings or symbols');\n  }\n\n  if (isUnsafeKey(key)) {\n    throw new Error(`Cannot set unsafe key: \"${key}\"`);\n  }\n};\n\nconst toStringKey = input => {\n  return Array.isArray(input) ? input.flat().map(String).join(',') : input;\n};\n\nconst createMemoKey = (input, options) => {\n  if (typeof input !== 'string' || !options) return input;\n  let key = input + ';';\n  if (options.arrays !== undefined) key += `arrays=${options.arrays};`;\n  if (options.separator !== undefined) key += `separator=${options.separator};`;\n  if (options.split !== undefined) key += `split=${options.split};`;\n  if (options.merge !== undefined) key += `merge=${options.merge};`;\n  if (options.preservePaths !== undefined) key += `preservePaths=${options.preservePaths};`;\n  return key;\n};\n\nconst memoize = (input, options, fn) => {\n  const key = toStringKey(options ? createMemoKey(input, options) : input);\n  validateKey(key);\n\n  const value = setValue.cache.get(key) || fn();\n  setValue.cache.set(key, value);\n  return value;\n};\n\nconst splitString = (input, options = {}) => {\n  const sep = options.separator || '.';\n  const preserve = sep === '/' ? false : options.preservePaths;\n\n  if (typeof input === 'string' && preserve !== false && /\\//.test(input)) {\n    return [input];\n  }\n\n  const parts = [];\n  let part = '';\n\n  const push = part => {\n    let number;\n    if (part.trim() !== '' && Number.isInteger((number = Number(part)))) {\n      parts.push(number);\n    } else {\n      parts.push(part);\n    }\n  };\n\n  for (let i = 0; i < input.length; i++) {\n    const value = input[i];\n\n    if (value === '\\\\') {\n      part += input[++i];\n      continue;\n    }\n\n    if (value === sep) {\n      push(part);\n      part = '';\n      continue;\n    }\n\n    part += value;\n  }\n\n  if (part) {\n    push(part);\n  }\n\n  return parts;\n};\n\nconst split = (input, options) => {\n  if (options && typeof options.split === 'function') return options.split(input);\n  if (typeof input === 'symbol') return [input];\n  if (Array.isArray(input)) return input;\n  return memoize(input, options, () => splitString(input, options));\n};\n\nconst assignProp = (obj, prop, value, options) => {\n  validateKey(prop);\n\n  // Delete property when \"value\" is undefined\n  if (value === undefined) {\n    deleteProperty(obj, prop);\n\n  } else if (options && options.merge) {\n    const merge = options.merge === 'function' ? options.merge : Object.assign;\n\n    // Only merge plain objects\n    if (merge && isPlainObject(obj[prop]) && isPlainObject(value)) {\n      obj[prop] = merge(obj[prop], value);\n    } else {\n      obj[prop] = value;\n    }\n\n  } else {\n    obj[prop] = value;\n  }\n\n  return obj;\n};\n\nconst setValue = (target, path, value, options) => {\n  if (!path || !isObject(target)) return target;\n\n  const keys = split(path, options);\n  let obj = target;\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    const next = keys[i + 1];\n\n    validateKey(key);\n\n    if (next === undefined) {\n      assignProp(obj, key, value, options);\n      break;\n    }\n\n    if (typeof next === 'number' && !Array.isArray(obj[key])) {\n      obj = obj[key] = [];\n      continue;\n    }\n\n    if (!isObject(obj[key])) {\n      obj[key] = {};\n    }\n\n    obj = obj[key];\n  }\n\n  return target;\n};\n\nsetValue.split = split;\nsetValue.cache = new Map();\nsetValue.clear = () => {\n  setValue.cache = new Map();\n};\n\nmodule.exports = setValue;\n","/*!\n * is-primitive <https://github.com/jonschlinkert/is-primitive>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isPrimitive(val) {\n  if (typeof val === 'object') {\n    return val === null;\n  }\n  return typeof val !== 'function';\n};\n","/*!\n * isobject <https://github.com/jonschlinkert/isobject>\n *\n * Copyright (c) 2014-2017, Jon Schlinkert.\n * Released under the MIT License.\n */\n\n'use strict';\n\nmodule.exports = function isObject(val) {\n  return val != null && typeof val === 'object' && Array.isArray(val) === false;\n};\n","/* !\n * get-value <https://github.com/jonschlinkert/get-value>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport interface Options {\n  default?: unknown\n  separator?: string\n  joinChar?: string\n  join?: (segs: string[]) => string\n  split?: (path: string) => string[]\n  isValid?: (key: string, target: {}) => boolean // eslint-disable-line\n}\n// @ts-expect-error\nconst isObject = v => v !== null && typeof v === 'object'\n\nconst join = (segs: string[], joinChar: string, options: unknown): string => {\n  // @ts-expect-error\n  if (typeof options.join === 'function') {\n    // @ts-expect-error\n    return options.join(segs)\n  }\n  return segs[0] + joinChar + segs[1]\n}\n\nconst split = (path: string, splitChar: string, options: unknown): string[] => {\n  // @ts-expect-error\n  if (typeof options.split === 'function') {\n    // @ts-expect-error\n    return options.split(path)\n  }\n\n  return path.split(splitChar)\n}\n\nconst isValid = (\n  key: string,\n  target: unknown = {},\n  options: unknown,\n): boolean => {\n  // @ts-expect-error\n  if (typeof options?.isValid === 'function') {\n    // @ts-expect-error\n    return options.isValid(key, target)\n  }\n\n  return true\n}\n\nconst isValidObject = (v: unknown): boolean => {\n  return isObject(v) || typeof v === 'function'\n}\n\nconst getValue = (\n  target: unknown,\n  path: string | number | string[],\n  options: Options = {},\n): unknown => {\n  if (!isObject(options)) {\n    options = { default: options }\n  }\n\n  if (!isValidObject(target)) {\n    return options.default !== undefined ? options.default : target\n  }\n\n  if (typeof path === 'number') {\n    path = String(path)\n  }\n\n  const pathIsArray = Array.isArray(path)\n  const pathIsString = typeof path === 'string'\n  const splitChar = options.separator || '.'\n  const joinChar =\n    options.joinChar || (typeof splitChar === 'string' ? splitChar : '.')\n\n  if (!pathIsString && !pathIsArray) {\n    return target\n  }\n\n  // @ts-expect-error\n  if (target[path] !== undefined) {\n    // @ts-expect-error\n    return isValid(path, target, options) ? target[path] : options.default\n  }\n\n  // @ts-expect-error\n  const segs = pathIsArray ? path : split(path, splitChar, options)\n  const len = segs.length\n  let idx = 0\n\n  do {\n    let prop = segs[idx]\n    if (typeof prop !== 'string') {\n      prop = String(prop)\n    }\n\n    while (prop.endsWith('\\\\')) {\n      prop = join([prop.slice(0, -1), segs[++idx] || ''], joinChar, options)\n    }\n\n    // @ts-expect-error\n    if (target[prop] !== undefined) {\n      if (!isValid(prop, target, options)) {\n        return options.default\n      }\n\n      // @ts-expect-error\n      target = target[prop]\n    } else {\n      let hasProp = false\n      let n = idx + 1\n\n      while (n < len) {\n        // @ts-expect-error\n        prop = join([prop, segs[n++]], joinChar, options)\n\n        // @ts-expect-error\n        if ((hasProp = target[prop] !== undefined)) {\n          if (!isValid(prop, target, options)) {\n            return options.default\n          }\n\n          // @ts-expect-error\n          target = target[prop]\n          idx = n - 1\n          break\n        }\n      }\n\n      if (!hasProp) {\n        return options.default\n      }\n    }\n  } while (++idx < len && isValidObject(target))\n\n  if (idx === len) {\n    return target\n  }\n\n  return options.default\n}\n\nexport default getValue\n","import getValue from './get-value.ts'\n\nimport type { Source, Track } from './types.ts'\n\nexport function isTrack(arg: any): arg is Track {\n  return arg?.label && typeof arg.label === 'string'\n}\n\nexport function isSource(arg: any): arg is Source {\n  return arg?.url && typeof arg.url === 'string'\n}\n\n/**\n * updates a with values from b, recursively\n */\n\ntype Obj = Record<string, any>\nexport function deepUpdate(a: Obj, b: Obj): Obj {\n  for (const prop of Object.keys(b)) {\n    if (\n      prop === '__proto__' ||\n      prop === 'constructor' ||\n      prop === 'prototype'\n    ) {\n      continue\n    }\n    if (\n      prop in a &&\n      typeof b[prop] === 'object' &&\n      typeof a[prop] === 'object'\n    ) {\n      deepUpdate(a[prop], b[prop])\n    } else if (a[prop] === undefined || b[prop] !== undefined) {\n      a[prop] = b[prop]\n    }\n  }\n  return a\n}\n\n/**\n * replace variables in a template string with values\n *\n * @param template - String with variable names in curly brackets\n * e.g., `http://foo/{bar}?arg={baz.foo}`\n * @param fillWith - object with attribute-value mappings\n * e.g., `{ 'bar': 'someurl', 'baz': { 'foo': 42 } }`\n * @returns the template string with variables in fillWith replaced\n * e.g., 'htp://foo/someurl?arg=valueforbaz'\n */\nexport function fillTemplate(template: string, fillWith: Obj): string {\n  return template.replaceAll(/{([\\s\\w.]+)}/g, (match, varName) => {\n    varName = varName.replaceAll(/\\s+/g, '')\n    const fill = getValue(fillWith, varName)\n    if (fill !== undefined) {\n      return typeof fill === 'function' ? fill(varName) : fill\n    }\n    if (fillWith.callback) {\n      // @ts-expect-error\n      const v = fillWith.callback.call(this, varName)\n      if (v !== undefined) {\n        return v\n      }\n    }\n    return match\n  })\n}\n\n/**\n * Clones objects (including DOM nodes) and all children.\n * Warning: do not clone cyclic structures\n * (Lifted from dojo https://github.com/dojo/dojo/blob/master/_base/lang.js)\n * @param src - The object to clone\n */\n\nexport function structuredClone(src: any): any {\n  if (\n    !src ||\n    typeof src !== 'object' ||\n    Object.prototype.toString.call(src) === '[object Function]'\n  ) {\n    // null, undefined, any non-object, or function\n    return src // anything\n  }\n  if (src.nodeType && 'cloneNode' in src) {\n    // DOM Node\n    return src.cloneNode(true) // Node\n  }\n  if (src instanceof Date) {\n    // Date\n    return new Date(src) // Date\n  }\n  if (src instanceof RegExp) {\n    // RegExp\n    return new RegExp(src) // RegExp\n  }\n  let r: unknown[]\n  if (Array.isArray(src)) {\n    // array\n    r = []\n    for (let i = 0, l = src.length; i < l; ++i) {\n      if (i in src) {\n        r[i] = structuredClone(src[i])\n      }\n    }\n    // we don't clone functions for performance reasons\n    //    }else if(d.isFunction(src)){\n    //      // function\n    //      r = function(){ return src.apply(this, arguments); };\n  } else {\n    // generic objects\n    r = src.constructor ? new src.constructor() : {}\n  }\n  return mixin(r, src, a => structuredClone(a))\n}\n\n/**\n * Copies/adds all properties of source to dest; returns dest.\n * (Lifted from dojo https://github.com/dojo/dojo/blob/master/_base/lang.js)\n *\n * All properties, including functions (sometimes termed \"methods\"), excluding\n * any non-standard extensions found in Object.prototype, are copied/added to\n * dest. Copying/adding each particular property is delegated to copyFunc\n * (if any); copyFunc defaults to the Javascript assignment operator if not\n * provided. Notice that by default, mixin executes a so-called \"shallow copy\"\n * and aggregate types are copied/added by reference.\n * @param dest - The object to which to copy/add all properties contained in\n * source.\n * @param source - The object from which to draw all properties to copy into dest.\n * @param copyFunc - The process used to copy/add a property in source; defaults\n * to the Javascript assignment operator.\n * @returns dest, as modified\n */\nfunction mixin(\n  dest: Obj,\n  source: Obj,\n  copyFunc?: (arg: unknown) => unknown,\n): Obj {\n  const empty = {}\n  for (const name in source) {\n    if (\n      name === '__proto__' ||\n      name === 'constructor' ||\n      name === 'prototype'\n    ) {\n      continue\n    }\n    // the (!(name in empty) || empty[name] !== s) condition avoids copying\n    // properties in \"source\" inherited from Object.prototype.\t For example,\n    // if dest has a custom toString() method, don't overwrite it with the\n    // toString() method that source inherited from Object.prototype\n    const s = source[name]\n    if (\n      !(name in dest) ||\n      // @ts-expect-error\n      (dest[name] !== s && (!(name in empty) || empty[name] !== s))\n    ) {\n      dest[name] = copyFunc ? copyFunc(s) : s\n    }\n  }\n\n  return dest // Object\n}\n","/* eslint no-cond-assign: [\"error\", \"except-parens\"] */\nimport { objectHash } from '@jbrowse/core/util'\nimport setValue from 'set-value'\n\nimport getValue from './get-value.ts'\nimport { isSource, isTrack } from './util.ts'\n\nimport type { Config, Names, Source, Store, Track } from './types.ts'\n\nexport function parseJB1Json(config: Config | string, url: string): Config {\n  if (typeof config === 'string') {\n    let parsedConf: Config\n    try {\n      parsedConf = JSON.parse(config)\n    } catch (error) {\n      throw new Error(`${error} when parsing configuration.`)\n    }\n    return regularizeConf(parsedConf, url)\n  }\n  return regularizeConf(config, url)\n}\n\nexport function parseJB1Conf(config: string, url: string): Config {\n  let parsedConf: Config\n  try {\n    parsedConf = parse(config, url)\n  } catch (error) {\n    throw new Error(`${error} when parsing configuration.`)\n  }\n  return regularizeConf(parsedConf, url)\n}\n\nfunction isAlwaysArray(varName: string): boolean {\n  if (varName === 'include') {\n    return true\n  }\n  return false\n}\n\nfunction parse(text: string, url: string): Config {\n  let section: string[] = []\n  let keyPath: string[] | undefined\n  let operation: string\n  let value: string | undefined\n  const data: Config = { tracks: {} }\n  let lineNumber: number\n\n  function recordVal(): void {\n    if (value !== undefined) {\n      let parsedValue:\n        | string\n        | number\n        | boolean\n        | string[]\n        | number[]\n        | boolean[]\n      try {\n        // parse json\n        const match = /^json:(.+)/i.exec(value)\n        if (match) {\n          parsedValue = JSON.parse(match[1]!)\n        }\n        // parse numbers if it looks numeric\n        else if (/^[+-]?[\\d.,]+([eE][-+]?\\d+)?$/.test(value)) {\n          parsedValue = Number.parseFloat(value.replaceAll(',', ''))\n        } else {\n          parsedValue = value\n        }\n\n        if (!keyPath) {\n          throw new Error(`Error parsing in section ${section.join(' - ')}`)\n        }\n        const path = [...section, ...keyPath].join('.')\n        if (operation === '+=') {\n          let existing = getValue(data, path)\n          if (existing) {\n            if (!Array.isArray(existing)) {\n              existing = [existing]\n            }\n          } else {\n            existing = []\n          }\n\n          // @ts-expect-error\n          existing.push(parsedValue)\n          // @ts-expect-error\n          parsedValue = existing\n        }\n        if (parsedValue === 'true') {\n          parsedValue = true\n        }\n        if (parsedValue === 'false') {\n          parsedValue = false\n        }\n        setValue(data, path, parsedValue)\n      } catch (e) {\n        throw new Error(\n          `syntax error${url ? ` in ${url}` : ''}${\n            lineNumber ? ` at line ${lineNumber - 1}` : ''\n          }`,\n        )\n      }\n    }\n  }\n\n  for (const [i, textLine] of text.split(/\\n|\\r\\n|\\r/).entries()) {\n    lineNumber = i + 1\n    const line = textLine.replace(/^\\s*#.+/, '')\n\n    // new section\n    let match: RegExpMatchArray | null\n    if ((match = /^\\s*\\[([^\\]]+)/.exec(line))) {\n      // new section\n      recordVal()\n      keyPath = undefined\n      value = undefined\n      section = match[1]!.trim().split(/\\s*\\.\\s*/)\n      if (section.length === 1 && section[0]!.toLowerCase() === 'general') {\n        section = []\n      }\n    }\n    // new value\n    else if (\n      (match = line.match(\n        value === undefined ? /^([^+=]+)(\\+?=)(.*)/ : /^(\\S[^+=]+)(\\+?=)(.*)/,\n      ))\n    ) {\n      recordVal()\n      keyPath = match[1]!.trim().split(/\\s*\\.\\s*/)\n      // @ts-expect-error\n      ;[, , operation] = match\n      if (isAlwaysArray([...section, ...keyPath].join('.'))) {\n        operation = '+='\n      }\n      value = match[3]!.trim()\n    }\n    // add to existing array value\n    else if (\n      keyPath !== undefined &&\n      (match = /^\\s{0,4}\\+\\s*(.+)/.exec(line))\n    ) {\n      recordVal()\n      operation = '+='\n      value = match[1]!.trim()\n    }\n    // add to existing value\n    else if (value !== undefined && (match = /^\\s+(\\S.*)/.exec(line))) {\n      const m = match[1]!\n      value += value.length ? ` ${m.trim()}` : m.trim()\n    }\n    // done with last value\n    else {\n      recordVal()\n      keyPath = undefined\n      value = undefined\n    }\n  }\n\n  recordVal()\n\n  return data\n}\n\n/**\n * Applies defaults and any other necessary tweaks to the loaded configuration.\n * @param conf - the object containing the configuration, which it modifies\n * in-place\n * @param url - URL of the config file\n * @returns the same object it was passed\n */\nexport function regularizeConf(conf: Config, url: string): Config {\n  // if tracks is not an array, convert it to one\n  if (conf.tracks && !Array.isArray(conf.tracks)) {\n    // if it's a single track config, wrap it in an arrayref\n    if (isTrack(conf.tracks)) {\n      conf.tracks = [conf.tracks]\n    }\n    // otherwise, coerce it to an array\n    else {\n      const tracks: Track[] = []\n      for (const label of Object.keys(conf.tracks)) {\n        const track = conf.tracks[label]\n        if (isTrack(track)) {\n          tracks.push(track)\n        } else {\n          tracks.push({ label, ...track })\n        }\n      }\n      conf.tracks = tracks\n    }\n  }\n\n  // regularize trackMetadata.sources\n  const meta = conf.trackMetadata\n  if (meta?.sources) {\n    // if it's a single source config, wrap it in an arrayref\n    if (typeof meta.sources === 'string') {\n      meta.sources = [meta.sources]\n    }\n    if (isSource(meta.sources)) {\n      meta.sources = [meta.sources]\n    }\n\n    if (!Array.isArray(meta.sources)) {\n      const sources: Source[] = []\n      for (const name of Object.keys(meta.sources)) {\n        const source = meta.sources[name]!\n        if (!('name' in source)) {\n          source.name = name\n        }\n        sources.push(source)\n      }\n      meta.sources = sources\n    }\n\n    // coerce any string source defs to be URLs, and try to detect their types\n    meta.sources = meta.sources.map((sourceDef: string | Source): Source => {\n      if (typeof sourceDef === 'string') {\n        const newSourceDef: Source = { url: sourceDef }\n        const typeMatch = /\\.(\\w+)$/.exec(sourceDef)\n        if (typeMatch) {\n          newSourceDef.type = typeMatch[1]!.toLowerCase()\n        }\n        return newSourceDef\n      }\n      return sourceDef\n    })\n  }\n\n  conf.sourceUrl = conf.sourceUrl || url\n  if (conf.sourceUrl.startsWith('/')) {\n    conf.sourceUrl = new URL(conf.sourceUrl, window.location.href).href\n  }\n  conf.baseUrl = conf.baseUrl || new URL('.', conf.sourceUrl).href\n  if (conf.baseUrl.length && !conf.baseUrl.endsWith('/')) {\n    conf.baseUrl += '/'\n  }\n\n  if (conf.sourceUrl) {\n    // set a default baseUrl in each of the track and store confs, and the names\n    // conf, if needed\n    const addBase: (Track | Store | Names)[] = []\n    if (conf.tracks) {\n      for (const track of conf.tracks) {\n        addBase.push(track)\n      }\n    }\n    if (conf.stores) {\n      for (const store of Object.values(conf.stores)) {\n        addBase.push(store)\n      }\n    }\n    if (conf.names) {\n      addBase.push(conf.names)\n    }\n\n    for (const t of addBase) {\n      if (!t.baseUrl) {\n        t.baseUrl = conf.baseUrl || '/'\n      }\n    }\n\n    // resolve the refSeqs and nameUrl if present\n    if (conf.refSeqs && typeof conf.refSeqs === 'string') {\n      conf.refSeqs = new URL(conf.refSeqs, conf.sourceUrl).href\n    }\n    if (conf.nameUrl) {\n      conf.nameUrl = new URL(conf.nameUrl, conf.sourceUrl).href\n    }\n  }\n\n  conf.stores = conf.stores || {}\n  for (let trackConfig of conf.tracks || []) {\n    // if there is a `config` subpart, just copy its keys in to the top-level\n    // config\n    if (trackConfig.config) {\n      const c = trackConfig.config\n      trackConfig.config = undefined\n      trackConfig = { ...c, ...trackConfig }\n    }\n\n    // skip if it's a new-style track def\n    if (trackConfig.store) {\n      continue\n    }\n\n    let trackClassName: string\n    if (trackConfig.type === 'FeatureTrack') {\n      trackClassName = 'JBrowse/View/Track/HTMLFeatures'\n    } else if (trackConfig.type === 'ImageTrack') {\n      trackClassName = 'JBrowse/View/Track/FixedImage'\n    } else if (trackConfig.type === 'ImageTrack.Wiggle') {\n      trackClassName = 'JBrowse/View/Track/FixedImage/Wiggle'\n    } else if (trackConfig.type === 'SequenceTrack') {\n      trackClassName = 'JBrowse/View/Track/Sequence'\n    } else {\n      trackClassName = regularizeClass('JBrowse/View/Track', trackConfig.type)\n    }\n\n    trackConfig.type = trackClassName\n\n    synthesizeTrackStoreConfig(conf, trackConfig)\n\n    if (trackConfig.histograms) {\n      if (!trackConfig.histograms.baseUrl) {\n        trackConfig.histograms.baseUrl = trackConfig.baseUrl\n      }\n      synthesizeTrackStoreConfig(conf, trackConfig.histograms)\n    }\n  }\n\n  return conf\n}\n\n/**\n * prefix class name with `root` if it contains no slashes\n * @param root - Prefix root\n * @param className - class name\n */\nfunction regularizeClass(root: string, className: string | undefined): string {\n  if (!className) {\n    return ''\n  }\n  if (!className.includes('/')) {\n    className = `${root}/${className}`\n  }\n  className = className.replace(/^\\//, '')\n  return className\n}\n\nfunction guessStoreClass(\n  trackConfig: Track | undefined,\n  urlTemplate: string,\n): string {\n  if (!trackConfig) {\n    return ''\n  }\n  if (trackConfig.type?.includes('/FixedImage')) {\n    return `JBrowse/Store/TiledImage/Fixed${\n      trackConfig.backendVersion === 0 ? '_v0' : ''\n    }`\n  }\n  if (/\\.jsonz?$/i.test(urlTemplate)) {\n    return `JBrowse/Store/SeqFeature/NCList${\n      trackConfig.backendVersion === 0 ? '_v0' : ''\n    }`\n  }\n  if (/\\.bam$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/BAM'\n  }\n  if (/\\.cram$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/CRAM'\n  }\n  if (/\\.gff3?$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/GFF3'\n  }\n  if (/\\.bed$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/BED'\n  }\n  if (/\\.vcf.b?gz$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/VCFTabix'\n  }\n  if (/\\.gff3?.b?gz$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/GFF3Tabix'\n  }\n  if (/\\.bed.b?gz$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/BEDTabix'\n  }\n  if (/\\.(bw|bigwig)$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/BigWig'\n  }\n  if (/\\.(bb|bigbed)$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/BigBed'\n  }\n  if (/\\.(fa|fasta)$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/IndexedFasta'\n  }\n  if (/\\.(fa|fasta)\\.b?gz$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/BgzipIndexedFasta'\n  }\n  if (/\\.2bit$/i.test(urlTemplate)) {\n    return 'JBrowse/Store/SeqFeature/TwoBit'\n  }\n  if (trackConfig.type?.endsWith('/Sequence')) {\n    return 'JBrowse/Store/Sequence/StaticChunked'\n  }\n  return ''\n}\n\nfunction synthesizeTrackStoreConfig(\n  mainConf: Config,\n  trackConfig: Track,\n): void {\n  // figure out what data store class to use with the track, applying some\n  // defaults if it is not explicit in the configuration\n  const { urlTemplate = '' } = trackConfig\n\n  const storeClass = trackConfig.storeClass\n    ? regularizeClass('JBrowse/Store', trackConfig.storeClass)\n    : guessStoreClass(trackConfig, urlTemplate)\n\n  if (!storeClass) {\n    console.warn(\n      `Unable to determine an appropriate data store to use with track '${trackConfig.label}', please explicitly specify a storeClass in the configuration.`,\n    )\n    return\n  }\n\n  // synthesize a separate store conf\n  const storeConf: Store = { ...trackConfig, type: storeClass }\n\n  // if this is the first sequence store we see, and we have no refseqs store\n  // defined explicitly, make this the refseqs store.\n  storeConf.name =\n    (storeClass === 'JBrowse/Store/Sequence/StaticChunked' ||\n      storeClass === 'JBrowse/Store/Sequence/IndexedFasta' ||\n      storeClass === 'JBrowse/Store/SeqFeature/IndexedFasta' ||\n      storeClass === 'JBrowse/Store/SeqFeature/BgzipIndexedFasta' ||\n      storeClass === 'JBrowse/Store/SeqFeature/TwoBit' ||\n      storeClass === 'JBrowse/Store/Sequence/TwoBit' ||\n      trackConfig.useAsRefSeqStore) &&\n    !mainConf.stores?.refseqs\n      ? 'refseqs'\n      : `store${objectHash(storeConf)}`\n  // record it\n  if (!mainConf.stores) {\n    mainConf.stores = {}\n  }\n  mainConf.stores[storeConf.name] = storeConf\n\n  // connect it to the track conf\n  trackConfig.store = storeConf.name\n}\n","import { openLocation } from '@jbrowse/core/util/io'\n\nimport { parseJB1Conf, parseJB1Json, regularizeConf } from './jb1ConfigParse.ts'\nimport { deepUpdate, fillTemplate } from './util.ts'\n\nimport type {\n  Config,\n  Include,\n  JBLocation,\n  LocalPathLocation,\n  Track,\n  UriLocation,\n} from './types.ts'\n\nfunction isUriLocation(location: JBLocation): location is UriLocation {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return (location as UriLocation).uri !== undefined\n}\n\nfunction isLocalPathLocation(\n  location: JBLocation,\n): location is LocalPathLocation {\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  return (location as LocalPathLocation).localPath !== undefined\n}\n\nexport async function fetchJb1(\n  // eslint-disable-next-line unicorn/no-object-as-default-parameter\n  dataRoot: JBLocation = { uri: '', locationType: 'UriLocation' },\n  // eslint-disable-next-line unicorn/no-object-as-default-parameter\n  baseConfig: Config = {\n    include: ['{dataRoot}/trackList.json', '{dataRoot}/tracks.conf'],\n  },\n  // eslint-disable-next-line unicorn/no-object-as-default-parameter\n  baseConfigRoot: JBLocation = { uri: '', locationType: 'UriLocation' },\n): Promise<Config> {\n  const protocol = 'uri' in dataRoot ? 'uri' : 'localPath'\n  const dataRootReg = JSON.parse(JSON.stringify(dataRoot))\n  let dataRootLocation = ''\n  if (isUriLocation(dataRoot)) {\n    dataRootLocation = dataRoot.uri\n  }\n  if (isLocalPathLocation(dataRoot)) {\n    dataRootLocation = dataRoot.localPath\n  }\n  if (dataRootLocation.endsWith('/')) {\n    dataRootReg[protocol] = dataRootLocation.slice(0, -1)\n  }\n  if (\n    (isUriLocation(baseConfigRoot) && baseConfigRoot.uri) ||\n    (isLocalPathLocation(baseConfigRoot) && baseConfigRoot.localPath)\n  ) {\n    const baseProtocol = 'uri' in baseConfigRoot ? 'uri' : 'localPath'\n    let baseConfigLocation = ''\n    if (isUriLocation(baseConfigRoot)) {\n      baseConfigLocation = baseConfigRoot.uri\n    }\n    if (isLocalPathLocation(baseConfigRoot)) {\n      baseConfigLocation = baseConfigRoot.localPath\n    }\n    if (baseConfigLocation.endsWith('/')) {\n      baseConfigLocation = baseConfigLocation.slice(0, -1)\n    }\n    let newConfig: Config = {}\n    for (const conf of ['jbrowse.conf', 'jbrowse_conf.json']) {\n      let fetchedConfig = null\n      try {\n        // @ts-expect-error\n        fetchedConfig = await fetchConfigFile({\n          [baseProtocol]: `${baseConfigLocation}/${conf}`,\n        })\n      } catch (error) {\n        console.error(\n          `tried to access ${baseConfigLocation}/${conf}, but failed`,\n        )\n      }\n      newConfig = mergeConfigs(newConfig, fetchedConfig) || {}\n    }\n    if (dataRootReg[protocol]) {\n      newConfig.dataRoot = dataRootReg[protocol]\n    }\n    return createFinalConfig(newConfig)\n  }\n  const newConfig = regularizeConf(baseConfig, window.location.href)\n  if (dataRootReg[protocol]) {\n    newConfig.dataRoot = dataRootReg[protocol]\n  }\n  return createFinalConfig(newConfig)\n}\n\nexport async function createFinalConfig(\n  baseConfig: Config,\n  defaults = configDefaults,\n): Promise<Config> {\n  const configWithDefaults = deepUpdate(structuredClone(defaults), baseConfig)\n  let finalConfig = await loadIncludes(configWithDefaults)\n  finalConfig = mergeConfigs(finalConfig, baseConfig) || finalConfig\n  fillTemplates(finalConfig, finalConfig)\n  validateConfig(finalConfig)\n  return finalConfig\n}\n\nexport async function fetchConfigFile(location: JBLocation): Promise<Config> {\n  const result = await openLocation(location).readFile('utf8')\n  if (isUriLocation(location)) {\n    return parseJb1(result, location.uri)\n  }\n  if (isLocalPathLocation(location)) {\n    return parseJb1(result, location.localPath)\n  }\n  return parseJb1(result)\n}\n\nexport function parseJb1(config: string, url = ''): Config {\n  if (config.trim().startsWith('{')) {\n    return parseJB1Json(config, url)\n  }\n  return parseJB1Conf(config, url)\n}\n\n/**\n * Merges config object b into a. Properties in b override those in a.\n */\nfunction mergeConfigs(a: Config | null, b: Config | null): Config | null {\n  if (b === null) {\n    return null\n  }\n\n  if (a === null) {\n    a = {}\n  }\n\n  for (const prop of Object.keys(b)) {\n    if (prop === 'tracks' && prop in a) {\n      const aTracks = a[prop] || []\n      const bTracks = b[prop] || []\n\n      if (Array.isArray(aTracks) && Array.isArray(bTracks)) {\n        a[prop] = mergeTrackConfigs(aTracks, bTracks)\n      } else {\n        throw new Error(\n          `Track config has not been properly regularized: ${aTracks} ${bTracks}`,\n        )\n      }\n    } else if (\n      !noRecursiveMerge(prop) &&\n      prop in a &&\n      // @ts-expect-error\n      typeof b[prop] === 'object' &&\n      // @ts-expect-error\n      typeof a[prop] === 'object'\n    ) {\n      // @ts-expect-error\n      a[prop] = deepUpdate(a[prop], b[prop])\n    } else if (prop === 'dataRoot') {\n      if (\n        a[prop] === undefined ||\n        (a[prop] === 'data' && b[prop] !== undefined)\n      ) {\n        a[prop] = b[prop]\n      }\n      // @ts-expect-error\n    } else if (a[prop] === undefined || b[prop] !== undefined) {\n      // @ts-expect-error\n      a[prop] = b[prop]\n    }\n  }\n  return a\n}\n\n/**\n * Special-case merging of two `tracks` configuration arrays.\n */\nfunction mergeTrackConfigs(a: Track[], b: Track[]): Track[] {\n  if (!b.length) {\n    return a\n  }\n\n  // index the tracks in `a` by track label\n  const aTracks: Record<string, Track> = {}\n  for (const [i, t] of a.entries()) {\n    t.index = i\n    aTracks[t.label] = t\n  }\n\n  for (const bT of b) {\n    const aT = aTracks[bT.label]\n    if (aT) {\n      mergeConfigs(aT, bT)\n    } else {\n      a.push(bT)\n    }\n  }\n\n  return a\n}\n\n/**\n * Recursively fetch, parse, and merge all the includes in the given config\n * object.  Calls the callback with the resulting configuration when finished.\n * @param inputConfig - Config to load includes into\n */\nasync function loadIncludes(inputConfig: Config): Promise<Config> {\n  inputConfig = structuredClone(inputConfig)\n\n  async function loadRecur(\n    config: Config,\n    upstreamConf: Config,\n  ): Promise<Config> {\n    const sourceUrl = config.sourceUrl || config.baseUrl\n    if (!sourceUrl) {\n      throw new Error(\n        `Could not determine source URL: ${JSON.stringify(config)}`,\n      )\n    }\n    const newUpstreamConf = mergeConfigs(structuredClone(upstreamConf), config)\n    if (!newUpstreamConf) {\n      throw new Error('Problem merging configs')\n    }\n    const includes = fillTemplates(\n      regularizeIncludes(config.include || []),\n      newUpstreamConf,\n    )\n    config.include = undefined\n\n    const loads = includes.map(async (include): Promise<Config> => {\n      include.cacheBuster = inputConfig.cacheBuster\n      const includedData = await fetchConfigFile({\n        uri: new URL(include.url, sourceUrl).href,\n        locationType: 'UriLocation',\n      })\n      return loadRecur(includedData, newUpstreamConf)\n    })\n    const includedDataObjects = await Promise.all(loads)\n    for (const includedData of includedDataObjects) {\n      config = mergeConfigs(config, includedData) || config\n    }\n    return config\n  }\n\n  return loadRecur(inputConfig, {})\n}\n\nfunction regularizeIncludes(\n  includes: Include | string | (Include | string)[] | null,\n): Include[] {\n  if (!includes) {\n    return []\n  }\n\n  // coerce include to an array\n  if (!Array.isArray(includes)) {\n    includes = [includes]\n  }\n\n  return includes.map((include): Include => {\n    // coerce bare strings in the includes to URLs\n    if (typeof include === 'string') {\n      include = { url: include }\n    }\n\n    // set defaults for format and version\n    if (!('format' in include)) {\n      include.format = include.url.endsWith('.conf') ? 'conf' : 'JB_json'\n    }\n    if (include.format === 'JB_json' && !('version' in include)) {\n      include.version = 1\n    }\n    return include\n  })\n}\n\nfunction fillTemplates<T>(subconfig: T, config: Config): T {\n  if (!subconfig) {\n    return subconfig\n  }\n  if (Array.isArray(subconfig)) {\n    for (let i = 0; i < subconfig.length; i += 1) {\n      subconfig[i] = fillTemplates(subconfig[i], config)\n    }\n  } else if (typeof subconfig === 'object') {\n    const sub = subconfig as Record<string, any>\n    for (const name of Object.keys(sub)) {\n      sub[name] = fillTemplates(sub[name], config)\n    }\n  } else if (typeof subconfig === 'string') {\n    // @ts-expect-error\n    return fillTemplate(subconfig, config)\n  }\n\n  return subconfig\n}\n\n/**\n * list of config properties that should not be recursively merged\n * @param propName - name of config property\n */\nfunction noRecursiveMerge(propName: string): boolean {\n  return propName === 'datasets'\n}\n\nconst configDefaults = {\n  tracks: [],\n\n  containerID: 'GenomeBrowser',\n  dataRoot: 'data',\n  show_tracklist: true,\n  show_nav: true,\n  show_menu: true,\n  show_overview: true,\n  show_fullviewlink: true,\n  update_browser_title: true,\n  updateBrowserURL: true,\n\n  refSeqs: '{dataRoot}/seq/refSeqs.json',\n  include: ['jbrowse.conf', 'jbrowse_conf.json'],\n  nameUrl: '{dataRoot}/names/root.json',\n\n  datasets: {\n    _DEFAULT_EXAMPLES: true,\n    volvox: { url: '?data=sample_data/json/volvox', name: 'Volvox Example' },\n    modencode: {\n      url: '?data=sample_data/json/modencode',\n      name: 'MODEncode Example',\n    },\n    yeast: { url: '?data=sample_data/json/yeast', name: 'Yeast Example' },\n  },\n\n  highlightSearchedRegions: false,\n  highResolutionMode: 'auto',\n}\n\n/**\n * Examine the loaded and merged configuration for errors.  Throws\n * exceptions if it finds anything amiss.\n * @returns nothing meaningful\n */\nfunction validateConfig(config: Config): void {\n  if (!config.tracks) {\n    config.tracks = []\n  }\n  if (!config.baseUrl) {\n    throw new Error('Must provide a `baseUrl` in configuration')\n  }\n}\n"],"names":["isObject","require","isObjectObject","o","Object","prototype","toString","call","module","exports","ctor","prot","constructor","hasOwnProperty","deleteProperty","Reflect","isPrimitive","isPlainObject","value","validateKey","key","TypeError","isUnsafeKey","Error","split","input","options","Array","isArray","memoize","fn","flat","map","String","join","toStringKey","createMemoKey","undefined","arrays","separator","merge","preservePaths","setValue","cache","get","set","splitString","sep","preserve","test","parts","part","push","number","trim","Number","isInteger","i","length","assignProp","obj","prop","assign","target","path","keys","next","Map","clear","val","v","segs","joinChar","isValid","isValidObject","getValue","default","pathIsArray","pathIsString","splitChar","len","idx","endsWith","slice","hasProp","n","isTrack","arg","label","deepUpdate","a","b","isAlwaysArray","varName","regularizeConf","conf","url","tracks","track","meta","trackMetadata","sources","name","source","sourceDef","newSourceDef","typeMatch","exec","type","toLowerCase","sourceUrl","startsWith","URL","window","location","href","baseUrl","addBase","stores","store","values","names","t","refSeqs","nameUrl","trackConfig","config","c","trackClassName","regularizeClass","synthesizeTrackStoreConfig","histograms","root","className","includes","replace","mainConf","urlTemplate","storeClass","backendVersion","guessStoreClass","console","warn","storeConf","useAsRefSeqStore","refseqs","objectHash","isUriLocation","uri","isLocalPathLocation","localPath","async","fetchJb1","dataRoot","locationType","baseConfig","include","baseConfigRoot","protocol","dataRootReg","JSON","parse","stringify","dataRootLocation","baseProtocol","baseConfigLocation","newConfig","fetchedConfig","fetchConfigFile","error","mergeConfigs","createFinalConfig","defaults","configDefaults","configWithDefaults","structuredClone","finalConfig","inputConfig","loadRecur","upstreamConf","newUpstreamConf","fillTemplates","format","version","regularizeIncludes","loads","cacheBuster","includedDataObjects","Promise","all","includedData","loadIncludes","validateConfig","result","openLocation","readFile","parseJb1","parsedConf","parseJB1Json","text","keyPath","operation","section","data","lineNumber","recordVal","parsedValue","match","parseFloat","replaceAll","existing","e","textLine","entries","line","m","parseJB1Conf","aTracks","bTracks","mergeTrackConfigs","noRecursiveMerge","index","bT","aT","subconfig","sub","template","fillWith","fill","callback","this","fillTemplate","propName","containerID","show_tracklist","show_nav","show_menu","show_overview","show_fullviewlink","update_browser_title","updateBrowserURL","datasets","_DEFAULT_EXAMPLES","volvox","modencode","yeast","highlightSearchedRegions","highResolutionMode"],"ignoreList":[],"sourceRoot":""}