{"version":3,"file":"static/js/6621.4bc65f20.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/VcfTabixAdapter/VcfTabixAdapter.ts"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix'\nimport VcfParser from '@gmod/vcf'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  fetchAndMaybeUnzipText,\n  shorten2,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport VcfFeature from '../VcfFeature'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { NoAssemblyRegion } from '@jbrowse/core/util/types'\n\nexport default class VcfTabixAdapter extends BaseFeatureDataAdapter {\n  private configured?: Promise<{\n    vcf: TabixIndexedFile\n    parser: VcfParser\n  }>\n\n  private async configurePre(_opts?: BaseOptions) {\n    const vcfGzLocation = this.getConf('vcfGzLocation')\n    const location = this.getConf(['index', 'location'])\n    const indexType = this.getConf(['index', 'indexType'])\n\n    const filehandle = openLocation(vcfGzLocation, this.pluginManager)\n    const isCSI = indexType === 'CSI'\n    const vcf = new TabixIndexedFile({\n      filehandle,\n      csiFilehandle: isCSI\n        ? openLocation(location, this.pluginManager)\n        : undefined,\n      tbiFilehandle: !isCSI\n        ? openLocation(location, this.pluginManager)\n        : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n\n    return {\n      vcf,\n      parser: new VcfParser({\n        header: await vcf.getHeader(),\n      }),\n    }\n  }\n\n  protected async configurePre2() {\n    if (!this.configured) {\n      this.configured = this.configurePre().catch((e: unknown) => {\n        this.configured = undefined\n        throw e\n      })\n    }\n    return this.configured\n  }\n\n  async configure(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, () =>\n      this.configurePre2(),\n    )\n  }\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { vcf } = await this.configure(opts)\n    return vcf.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { vcf } = await this.configure(opts)\n    return vcf.getHeader()\n  }\n\n  async getMetadata(opts?: BaseOptions) {\n    const { parser } = await this.configure(opts)\n    return parser.getMetadata()\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { refName, start, end } = query\n      const { statusCallback = () => {} } = opts\n      const { vcf, parser } = await this.configure(opts)\n\n      await updateStatus('Downloading variants', statusCallback, () =>\n        vcf.getLines(refName, start, end, {\n          lineCallback: (line, fileOffset) => {\n            observer.next(\n              new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-vcf-${fileOffset}`,\n              }),\n            )\n          },\n          ...opts,\n        }),\n      )\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  async getSources() {\n    const conf = this.getConf('samplesTsvLocation')\n    if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n      const { parser } = await this.configure()\n      return parser.samples.map(name => ({\n        name,\n      }))\n    } else {\n      const txt = await fetchAndMaybeUnzipText(\n        openLocation(conf, this.pluginManager),\n      )\n      const lines = txt.split(/\\n|\\r\\n|\\r/)\n      const header = lines[0]!.split('\\t')\n      const { parser } = await this.configure()\n      const metadataLines = lines\n        .slice(1)\n        .filter(f => !!f)\n        .map(line => {\n          const [name, ...rest] = line.split('\\t')\n          return {\n            ...Object.fromEntries(\n              // force col 0 to be called name\n              header.slice(1).map((c, idx) => [c, rest[idx] || ''] as const),\n            ),\n            name: name!,\n          }\n        })\n      const vcfSampleSet = new Set(parser.samples)\n      const metadataSet = new Set(metadataLines.map(r => r.name))\n      const metadataNotInVcfSamples = [...metadataSet].filter(\n        f => !vcfSampleSet.has(f),\n      )\n      const vcfSamplesNotInMetadata = [...vcfSampleSet].filter(\n        f => !metadataSet.has(f),\n      )\n      if (metadataNotInVcfSamples.length) {\n        console.warn(\n          `There are ${metadataNotInVcfSamples.length} samples in metadata file (${metadataLines.length} lines) not in VCF (${parser.samples.length} samples):`,\n          shorten2(metadataNotInVcfSamples.join(',')),\n        )\n      }\n      if (vcfSamplesNotInMetadata.length) {\n        console.warn(\n          `There are ${vcfSamplesNotInMetadata.length} samples in VCF file (${parser.samples.length} samples) not in metadata file (${metadataLines.length} lines):`,\n          shorten2(vcfSamplesNotInMetadata.map(m => m).join(',')),\n        )\n      }\n      return metadataLines.filter(f => vcfSampleSet.has(f.name))\n    }\n  }\n}\n"],"names":["VcfTabixAdapter","BaseFeatureDataAdapter","configurePre","_opts","vcfGzLocation","this","getConf","location","indexType","filehandle","openLocation","pluginManager","isCSI","vcf","TabixIndexedFile","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","parser","VcfParser","header","getHeader","configurePre2","configured","catch","e","configure","opts","statusCallback","updateStatus","getRefNames","getReferenceSequenceNames","getMetadata","getFeatures","query","ObservableCreate","async","refName","start","end","getLines","lineCallback","line","fileOffset","observer","next","VcfFeature","variant","parseLine","id","complete","stopToken","getSources","conf","uri","samples","map","name","lines","fetchAndMaybeUnzipText","split","metadataLines","slice","filter","f","rest","Object","fromEntries","c","idx","vcfSampleSet","Set","metadataSet","r","metadataNotInVcfSamples","has","vcfSamplesNotInMetadata","length","console","warn","shorten2","join","m"],"sourceRoot":""}