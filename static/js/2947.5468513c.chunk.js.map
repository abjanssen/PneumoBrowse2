{"version":3,"file":"static/js/2947.5468513c.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/SNPCoverageAdapter/processDepth.ts","../../../plugins/alignments/src/SNPCoverageAdapter/util.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processMismatches.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processModifications.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processReferenceCpGs.ts","../../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts","../../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBins.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts"],"sourcesContent":["import type { PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion } from '@jbrowse/core/util/types'\n\nexport function processDepth({\n  feature,\n  bins,\n  region,\n}: {\n  feature: Feature\n  bins: PreBaseCoverageBin[]\n  region: AugmentedRegion\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const regionLength = region.end - region.start\n  for (let j = fstart; j < fend + 1; j++) {\n    const i = j - region.start\n    if (i >= 0 && i < regionLength) {\n      if (bins[i] === undefined) {\n        bins[i] = {\n          depth: 0,\n          readsCounted: 0,\n          ref: {\n            probabilities: [],\n            entryDepth: 0,\n            '-1': 0,\n            0: 0,\n            1: 0,\n          },\n          snps: {},\n          mods: {},\n          nonmods: {},\n          delskips: {},\n          noncov: {},\n        }\n      }\n      if (j !== fend) {\n        bins[i].depth++\n        bins[i].readsCounted++\n        bins[i].ref.entryDepth++\n        bins[i].ref[fstrand]++\n      }\n    }\n  }\n}\n","import type {\n  ColorBy,\n  Mismatch,\n  PreBaseCoverageBin,\n  PreBaseCoverageBinSubtypes,\n} from '../shared/types'\n\nexport interface Opts {\n  bpPerPx?: number\n  colorBy?: ColorBy\n  stopToken?: string\n}\n\nexport function mismatchLen(mismatch: Mismatch) {\n  return !isInterbase(mismatch.type) ? mismatch.length : 1\n}\n\nexport function isInterbase(type: string) {\n  return type === 'softclip' || type === 'hardclip' || type === 'insertion'\n}\n\nexport function inc(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin[strand]++\n}\n\nexport function incWithProbabilities(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  probability: number,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin.probabilities.push(probability)\n  thisBin[strand]++\n}\n","import { inc, isInterbase, mismatchLen } from './util'\n\nimport type { Mismatch, PreBaseCoverageBin, SkipMap } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion } from '@jbrowse/core/util/types'\n\nexport function processMismatches({\n  feature,\n  region,\n  bins,\n  skipmap,\n}: {\n  region: AugmentedRegion\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  skipmap: SkipMap\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n\n  // normal SNP based coloring\n  for (const mismatch of mismatches) {\n    const mstart = fstart + mismatch.start\n    const mlen = mismatchLen(mismatch)\n    const mend = mstart + mlen\n    for (let j = mstart; j < mstart + mlen; j++) {\n      const epos = j - region.start\n      if (epos >= 0 && epos < bins.length) {\n        const bin = bins[epos]!\n        const { base, altbase, type } = mismatch\n        const interbase = isInterbase(type)\n\n        if (type === 'deletion' || type === 'skip') {\n          inc(bin, fstrand, 'delskips', type)\n          bin.depth--\n        } else if (!interbase) {\n          inc(bin, fstrand, 'snps', base)\n          bin.ref.entryDepth--\n          bin.ref[fstrand]--\n          bin.refbase = altbase\n        } else {\n          inc(bin, fstrand, 'noncov', type)\n        }\n      }\n    }\n\n    if (mismatch.type === 'skip') {\n      // for upper case XS and TS: reports the literal strand of the genomic\n      // transcript\n      const tags = feature.get('tags')\n      const xs = tags?.XS || tags?.TS\n      // for lower case ts from minimap2: genomic transcript flipped by read\n      // strand\n      const ts = tags?.ts\n      const effectiveStrand =\n        xs === '+'\n          ? 1\n          : xs === '-'\n            ? -1\n            : (ts === '+' ? 1 : xs === '-' ? -1 : 0) * fstrand\n      const hash = `${mstart}_${mend}_${effectiveStrand}`\n      if (skipmap[hash] === undefined) {\n        skipmap[hash] = {\n          feature: feature,\n          start: mstart,\n          end: mend,\n          strand: fstrand,\n          effectiveStrand,\n          score: 0,\n        }\n      }\n      skipmap[hash].score++\n    }\n  }\n}\n","import { max, sum } from '@jbrowse/core/util'\n\nimport { incWithProbabilities } from './util'\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition'\n\nimport type { ColorBy, PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport function processModifications({\n  feature,\n  colorBy,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  colorBy?: ColorBy\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const fend = feature.get('end')\n  const twoColor = colorBy?.modifications?.twoColor\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n\n  // this is a hole-y array, does not work with normal for loop\n  // eslint-disable-next-line unicorn/no-array-for-each\n  getMaxProbModAtEachPosition(feature)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      if (isolatedModification && type !== isolatedModification) {\n        return\n      }\n      const epos = pos + fstart - region.start\n      if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n        if (bins[epos] === undefined) {\n          bins[epos] = {\n            depth: 0,\n            readsCounted: 0,\n            snps: {},\n            ref: {\n              probabilities: [],\n              entryDepth: 0,\n              '-1': 0,\n              0: 0,\n              1: 0,\n            },\n            mods: {},\n            nonmods: {},\n            delskips: {},\n            noncov: {},\n          }\n        }\n\n        const s = 1 - sum(allProbs)\n        const bin = bins[epos]\n        bin.refbase = regionSequence[epos]\n        if (twoColor && s > max(allProbs)) {\n          incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s)\n        } else {\n          incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob)\n        }\n      }\n      pos++\n    },\n  )\n}\n","import { doesIntersect2 } from '@jbrowse/core/util'\n\nimport { parseCigar } from '../MismatchParser'\nimport { getMethBins } from '../ModificationParser'\nimport { incWithProbabilities } from './util'\n\nimport type { Mismatch, PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport function processReferenceCpGs({\n  feature,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n  const r = regionSequence.toLowerCase()\n  if (seq) {\n    const cigarOps = parseCigar(feature.get('CIGAR'))\n    const { methBins, methProbs } = getMethBins(feature, cigarOps)\n    const dels = mismatches.filter(f => f.type === 'deletion')\n\n    // methylation based coloring takes into account both reference sequence\n    // CpG detection and reads\n    for (let i = 0; i < fend - fstart; i++) {\n      const j = i + fstart\n      const l1 = r[j - region.start + 1]\n      const l2 = r[j - region.start + 2]\n      if (l1 === 'c' && l2 === 'g') {\n        const bin0 = bins[j - region.start]\n        const bin1 = bins[j - region.start + 1]\n        const b0 = methBins[i]\n        const b1 = methBins[i + 1]\n        const p0 = methProbs[i]\n        const p1 = methProbs[i + 1]\n\n        // color\n        if (\n          (b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n          (b1 && (p1 !== undefined ? p1 > 0.5 : true))\n        ) {\n          if (bin0) {\n            incWithProbabilities(bin0, fstrand, 'mods', 'cpg_meth', p0 || 0)\n            bin0.ref.entryDepth--\n            bin0.ref[fstrand]--\n          }\n          if (bin1) {\n            incWithProbabilities(bin1, fstrand, 'mods', 'cpg_meth', p1 || 0)\n            bin1.ref.entryDepth--\n            bin1.ref[fstrand]--\n          }\n        } else {\n          if (bin0) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j,\n                  j + 1,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin0,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p0 || 0),\n              )\n              bin0.ref.entryDepth--\n              bin0.ref[fstrand]--\n            }\n          }\n          if (bin1) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j + 1,\n                  j + 2,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin1,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p1 || 0),\n              )\n              bin1.ref.entryDepth--\n              bin1.ref[fstrand]--\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport { fetchSequence } from '../util'\nimport { generateCoverageBins } from './generateCoverageBins'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  protected async configure() {\n    const subadapterConfig = this.getConf('subadapter')\n    const sequenceConf = subadapterConfig.sequenceAdapter\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfig)\n\n    const sequenceAdapter = sequenceConf\n      ? await this.getSubAdapter?.(sequenceConf)\n      : undefined\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    return {\n      subadapter: dataAdapter.dataAdapter as BaseFeatureDataAdapter,\n      sequenceAdapter: sequenceAdapter?.dataAdapter as\n        | BaseFeatureDataAdapter\n        | undefined,\n    }\n  }\n\n  async fetchSequence(region: Region) {\n    const { sequenceAdapter } = await this.configure()\n    if (!sequenceAdapter) {\n      return undefined\n    }\n    return fetchSequence(region, sequenceAdapter)\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { subadapter } = await this.configure()\n      const features = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n\n      const { bins, skipmap } = await generateCoverageBins({\n        features,\n        region,\n        opts,\n        fetchSequence: (region: Region) => this.fetchSequence(region),\n      })\n\n      let index = 0\n      for (const bin of bins) {\n        // bins is a holey array\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (bin) {\n          const start = region.start + index\n          observer.next(\n            new SimpleFeature({\n              id: `${this.id}-${start}`,\n              data: {\n                score: bin.depth,\n                snpinfo: bin,\n                start,\n                end: start + 1,\n                refName: region.refName,\n              },\n            }),\n          )\n        }\n        index++\n      }\n\n      // make fake features from the coverage\n      for (const [key, skip] of Object.entries(skipmap)) {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              effectiveStrand: skip.effectiveStrand,\n            },\n          }),\n        )\n      }\n\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n}\n","import { sum } from '@jbrowse/core/util'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport { processDepth } from './processDepth'\nimport { processMismatches } from './processMismatches'\nimport { processModifications } from './processModifications'\nimport { processReferenceCpGs } from './processReferenceCpGs'\n\nimport type { Opts } from './util'\nimport type { PreBaseCoverageBin, SkipMap } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport async function generateCoverageBins({\n  fetchSequence,\n  features,\n  region,\n  opts,\n}: {\n  features: Feature[]\n  region: Region\n  opts: Opts\n  fetchSequence: (arg: Region) => Promise<string>\n}) {\n  const { stopToken, colorBy } = opts\n  const skipmap = {} as SkipMap\n  const bins = [] as PreBaseCoverageBin[]\n  const start2 = Math.max(0, region.start - 1)\n  const diff = region.start - start2\n\n  let start = performance.now()\n  for (const feature of features) {\n    if (performance.now() - start > 400) {\n      checkStopToken(stopToken)\n      start = performance.now()\n    }\n    processDepth({\n      feature,\n      bins,\n      region,\n    })\n\n    if (colorBy?.type === 'modifications') {\n      const regionSequence =\n        (await fetchSequence({\n          ...region,\n          start: start2,\n          end: region.end + 1,\n        })) || ''\n      processModifications({\n        feature,\n        colorBy,\n        bins,\n        region,\n        regionSequence: regionSequence.slice(diff),\n      })\n    } else if (colorBy?.type === 'methylation') {\n      const regionSequence =\n        (await fetchSequence({\n          ...region,\n          start: start2,\n          end: region.end + 1,\n        })) || ''\n      processReferenceCpGs({\n        feature,\n        bins,\n        region,\n        regionSequence,\n      })\n    }\n    processMismatches({ feature, skipmap, bins, region })\n  }\n\n  for (const bin of bins) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (bin) {\n      bin.mods = Object.fromEntries(\n        Object.entries(bin.mods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n      bin.nonmods = Object.fromEntries(\n        Object.entries(bin.nonmods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n    }\n  }\n\n  return {\n    bins,\n    skipmap,\n  }\n}\n","import { getNextRefPos, parseCigar } from '../MismatchParser'\nimport { getModPositions, getModProbabilities } from '../ModificationParser'\nimport { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  cigarOps?: string[],\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const ops = cigarOps || parseCigar(feature.get('CIGAR'))\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n"],"names":["processDepth","feature","bins","region","fstart","get","fend","fstrand","regionLength","end","start","j","i","undefined","depth","readsCounted","ref","probabilities","entryDepth","snps","mods","nonmods","delskips","noncov","mismatchLen","mismatch","isInterbase","type","length","inc","bin","strand","field","thisBin","incWithProbabilities","probability","push","processMismatches","skipmap","mismatches","mstart","mlen","mend","epos","base","altbase","interbase","refbase","tags","xs","XS","TS","ts","effectiveStrand","hash","score","processModifications","colorBy","regionSequence","twoColor","modifications","isolatedModification","getMaxProbModAtEachPosition","forEach","allProbs","prob","pos","s","sum","max","processReferenceCpGs","seq","r","toLowerCase","cigarOps","parseCigar","methBins","methProbs","getMethBins","dels","filter","f","l1","l2","bin0","bin1","b0","b1","p0","p1","some","d","doesIntersect2","SNPCoverageAdapter","BaseFeatureDataAdapter","configure","subadapterConfig","this","getConf","sequenceConf","sequenceAdapter","dataAdapter","getSubAdapter","Error","subadapter","fetchSequence","getFeatures","opts","ObservableCreate","async","features","firstValueFrom","pipe","toArray","stopToken","start2","Math","diff","performance","now","checkStopToken","slice","Object","fromEntries","entries","map","key","val","avgProbability","generateCoverageBins","index","observer","next","SimpleFeature","id","data","snpinfo","refName","skip","complete","getMultiRegionFeatureDensityStats","regions","getRefNames","mm","getTagAlt","ops","getModPositions","getModProbabilities","maxProbModForPosition","probIndex","positions","idx","getNextRefPos","old"],"sourceRoot":""}