"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[2930],{82930:(t,e,n)=>{n.r(e),n.d(e,{default:()=>f});const s=BigInt(32);"getBigInt64"in DataView||(DataView.prototype.getBigInt64=function(t,e){return function(t,e,n){const i=Number(!!n),a=Number(!n);return BigInt(t.getInt32(e,n)*a+t.getInt32(e+4,n)*i)<<s|BigInt(t.getUint32(e,n)*i+t.getUint32(e+4,n)*a)}(this,t,e)}),"getBigUint64"in DataView||(DataView.prototype.getBigUint64=function(t,e){return function(t,e,n){const i=t.getUint32(e,n),a=t.getUint32(e+4,n),r=Number(!!n),o=Number(!n);return BigInt(i*o+a*r)<<s|BigInt(i*r+a*o)}(this,t,e)});var i=n(44688);const a=["T","C","A","G"],r=[];for(let t=0;t<256;t++)r.push(a[t>>6&3]+a[t>>4&3]+a[t>>2&3]+a[3&t]);const o=r.map((t=>t.toLowerCase()));class c{constructor({filehandle:t,path:e}){if(t)this.filehandle=t;else{if(!e)throw new Error("must supply path or filehandle");this.filehandle=new i.EY(e)}}async _detectEndianness(){const t=await this.filehandle.read(8,0),e=new DataView(t.buffer);if(440477507!==e.getInt32(0,!0))throw new Error("not a 2bit file");this.version=e.getInt32(0,!0)}getHeader(){return this.headerP||(this.headerP=this._getHeader().catch((t=>{throw this.headerP=void 0,t}))),this.headerP}async _getHeader(){await this._detectEndianness();const t=await this.filehandle.read(16,0),e=!0,n=new DataView(t.buffer,t.byteOffset,t.length);let s=0;const i=n.getInt32(s,e);if(s+=4,440477507!==i)throw new Error(`Wrong magic number ${i}`);const a=n.getInt32(s,e);s+=4;const r=n.getUint32(s,e);return s+=4,{version:a,magic:i,sequenceCount:r,reserved:n.getUint32(s,e)}}getIndex(){return this.indexP||(this.indexP=this._getIndex().catch((t=>{throw this.indexP=void 0,t}))),this.indexP}async _getIndex(){const t=await this.getHeader(),e=8+t.sequenceCount*(257+(1===this.version?8:4)),n=await this.filehandle.read(e,8),s=!0,i=new DataView(n.buffer,n.byteOffset,n.length);let a=0;const r=i.getUint32(a,s);a+=4,a+=4;const o=[],c=new TextDecoder("utf8");for(let e=0;e<r;e++){const e=i.getUint8(a);a+=1;const r=c.decode(n.subarray(a,a+e));if(a+=e,1===t.version){const t=Number(i.getBigUint64(a,s));a+=8,o.push({offset:t,name:r})}else{const t=i.getUint32(a,s);a+=4,o.push({offset:t,name:r})}}return Object.fromEntries(o.map((({name:t,offset:e})=>[t,e])))}async getSequenceNames(){const t=await this.getIndex();return Object.keys(t)}async getSequenceSizes(){const t=await this.getIndex(),e=Object.keys(t),n=await Promise.all(Object.values(t).map((t=>this._getSequenceSize(t)))),s={};for(const[t,i]of e.entries())s[i]=n[t];return s}async getSequenceSize(t){const e=(await this.getIndex())[t];return e?this._getSequenceSize(e):void 0}async _getSequenceSize(t){return this._record1(t).then((t=>t.dnaSize))}async _record1(t,e=8){const n=await this.filehandle.read(e,t),s=!0;let i=0;const a=new DataView(n.buffer,n.byteOffset,n.length),r=a.getUint32(i,s);i+=4;const o=a.getUint32(i,s);return i+=4,{dnaSize:r,nBlockCount:o}}async _record2(t,e){const n=await this.filehandle.read(e,t),s=!0;let i=0;const a=new DataView(n.buffer,n.byteOffset,n.length),r=a.getUint32(i,s);i+=4;const o=[];for(let t=0;t<r;t++){const t=a.getUint32(i,s);i+=4,o.push(t)}const c=[];for(let t=0;t<r;t++){const t=a.getUint32(i,s);i+=4,c.push(t)}return{maskBlockCount:a.getUint32(i,s),nBlockSizes:c,nBlockStarts:o}}async _record3(t,e){const n=await this.filehandle.read(e,t),s=!0;let i=0;const a=new DataView(n.buffer,n.byteOffset,n.length),r=a.getUint32(i,s);i+=4;const o=[];for(let t=0;t<r;t++){const t=a.getUint32(i,s);i+=4,o.push(t)}const c=[];for(let t=0;t<r;t++){const t=a.getUint32(i,s);i+=4,c.push(t)}return{maskBlockCount:r,maskBlockSizes:c,maskBlockStarts:o,reserved:a.getInt32(i,s)}}async _getSequenceRecord(t){const e=await this._record1(t),n=8*e.nBlockCount+8,s=await this._record2(t+4,n),i=8*s.maskBlockCount+8,a=await this._record3(t+4+n-4,i);return{dnaSize:e.dnaSize,nBlocks:{starts:s.nBlockStarts,sizes:s.nBlockSizes},maskBlocks:{starts:a.maskBlockStarts,sizes:a.maskBlockSizes},dnaPosition:t+4+n-4+i}}async getSequence(t,e=0,n=Number.POSITIVE_INFINITY){const s=(await this.getIndex())[t];if(!s)return;const i=await this._getSequenceRecord(s);if(e<0)throw new TypeError("regionStart cannot be less than 0");n>i.dnaSize&&(n=i.dnaSize);const a=this._getOverlappingBlocks(e,n,i.nBlocks.starts,i.nBlocks.sizes),c=this._getOverlappingBlocks(e,n,i.maskBlocks.starts,i.maskBlocks.sizes),h=Math.ceil((n-e)/4)+1,u=Math.floor(e/4),l=await this.filehandle.read(h,i.dnaPosition+u);let g="";for(let t=e;t<n;t+=1){for(;c.length>0&&c[0].end<=t;)c.shift();const e=c[0]&&c[0].start<=t&&c[0].end>t;if(a[0]&&t>=a[0].start&&t<a[0].end){const s=a.shift();for(;t<s.end&&t<n;t+=1)g+=e?"n":"N";t-=1}else{const n=t%4,s=l[Math.floor(t/4)-u];g+=e?o[s][n]:r[s][n]}}return g}_getOverlappingBlocks(t,e,n,s){let i,a;for(const[r,o]of n.entries())if(t>=o+s[r]||e<=o){if(void 0!==i){a=r;break}}else void 0===i&&(i=r);if(void 0===i)return[];void 0===a&&(a=n.length);const r=new Array(a-i);for(let t=i;t<a;t+=1)r[t-i]={start:n[t],end:n[t]+s[t],size:s[t]};return r}}var h=n(68584),u=n(46377),l=n(99834),g=n(66885),d=n(6434);class f extends u.BaseSequenceAdapter{async initChromSizes(){const t=(0,h.readConfObject)(this.config,"chromSizesLocation");if("/path/to/default.chrom.sizes"!==t.uri&&""!==t.uri){const e=(0,l.openLocation)(t,this.pluginManager),n=await e.readFile("utf8");return Object.fromEntries(n.split(/\n|\r\n|\r/).filter((t=>!!t.trim())).map((t=>{const[e,n]=t.split("\t");return[e,+n]})))}}async setupPre(){return{twobit:new c({filehandle:(0,l.openLocation)(this.getConf("twoBitLocation"),this.pluginManager)}),chromSizesData:await this.initChromSizes()}}async setup(){return this.setupP||(this.setupP=this.setupPre().catch((t=>{throw this.setupP=void 0,t}))),this.setupP}async getRefNames(){const{chromSizesData:t,twobit:e}=await this.setup();return t?Object.keys(t):e.getSequenceNames()}async getRegions(){const{chromSizesData:t,twobit:e}=await this.setup();if(t)return Object.keys(t).map((e=>({refName:e,start:0,end:t[e]})));{const t=await e.getSequenceSizes();return Object.keys(t).map((e=>({refName:e,start:0,end:t[e]})))}}getFeatures({refName:t,start:e,end:n}){return(0,g.ObservableCreate)((async s=>{const{twobit:i}=await this.setup(),a=await i.getSequenceSize(t),r=void 0!==a?Math.min(a,n):n,o=await i.getSequence(t,e,r);o&&s.next(new d.A({id:`${t} ${e}-${r}`,data:{refName:t,start:e,end:r,seq:o}})),s.complete()}))}}}}]);
//# sourceMappingURL=2930.e07d8747.chunk.js.map