{"version":3,"file":"static/js/504.87e45936.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedGraphAdapter/BedGraphAdapter.ts","../../../packages/core/src/util/parseLineByLine.ts"],"sourcesContent":["import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  IntervalTree,\n  SimpleFeature,\n  fetchAndMaybeUnzip,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nexport default class BedGraphAdapter extends BaseFeatureDataAdapter {\n  protected bedFeatures?: Promise<{\n    header: string\n    features: Record<string, string[]>\n    columnNames: string[]\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree<Feature> | undefined> | undefined\n  > = {}\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { features } = await this.loadData()\n    const lines = features[refName]\n    if (!lines) {\n      return undefined\n    }\n    const names = (await this.getNames())?.slice(3) || []\n    const intervalTree = new IntervalTree<Feature>()\n    for (let i = 0, l = lines.length; i < l; i++) {\n      const line = lines[i]!\n      const [refName, s, e, ...rest] = line.split('\\t')\n\n      for (let j = 0, l2 = rest.length; j < l2; j++) {\n        const uniqueId = `${this.id}-${refName}-${i}-${j}`\n        const start = +s!\n        const end = +e!\n        const score = +rest[j]!\n        const source = names[j] || `col${j}`\n        if (score) {\n          intervalTree.insert(\n            [start, end],\n            new SimpleFeature({\n              id: uniqueId,\n              data: {\n                refName,\n                start,\n                end,\n                score,\n                source,\n              },\n            }),\n          )\n        }\n      }\n    }\n\n    return intervalTree\n  }\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { features } = await this.loadData(opts)\n    return Object.keys(features)\n  }\n  private async loadDataP(opts: BaseOptions = {}) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedGraphLocation')\n    const buffer = await fetchAndMaybeUnzip(openLocation(bedLoc, pm), opts)\n    const features = {} as Record<string, string[]>\n    const headerLines = [] as string[]\n    parseLineByLine(\n      buffer,\n      line => {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else {\n          const tab = line.indexOf('\\t')\n          const refName = line.slice(0, tab)\n          if (!features[refName]) {\n            features[refName] = []\n          }\n          features[refName].push(line)\n        }\n        return true\n      },\n      opts.statusCallback,\n    )\n\n    const columnNames = this.getConf('columnNames')\n\n    return {\n      header: headerLines.join('\\n'),\n      features,\n      columnNames,\n    }\n  }\n\n  async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch((e: unknown) => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  async loadData(opts: BaseOptions = {}) {\n    if (!this.bedFeatures) {\n      this.bedFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedFeatures\n  }\n  public getFeatures(query: Region, _opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureIntervalTree(refName)\n      for (const feature of intervalTree?.search([start, end]) || []) {\n        observer.next(feature)\n      }\n      observer.complete()\n    })\n  }\n}\n","import { getProgressDisplayStr } from './index.ts'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n"],"names":["BedGraphAdapter","BaseFeatureDataAdapter","intervalTrees","getNames","header","columnNames","this","loadData","length","defline","split","filter","f","at","includes","slice","map","field","trim","undefined","loadFeatureIntervalTreeHelper","refName","features","lines","names","intervalTree","IntervalTree","i","l","line","s","e","rest","j","l2","uniqueId","id","start","end","score","source","insert","SimpleFeature","data","getRefNames","opts","Object","keys","loadDataP","pm","pluginManager","bedLoc","getConf","buffer","fetchAndMaybeUnzip","openLocation","headerLines","parseLineByLine","startsWith","push","tab","indexOf","statusCallback","join","loadFeatureIntervalTree","catch","bedFeatures","getFeatures","query","_opts","ObservableCreate","async","feature","search","observer","next","complete","lineCallback","decoder","TextDecoder","blockStart","n","lineEnd","b","subarray","decode","getProgressDisplayStr"],"ignoreList":[],"sourceRoot":""}