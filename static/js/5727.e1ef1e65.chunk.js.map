{"version":3,"file":"static/js/5727.e1ef1e65.chunk.js","mappings":"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","sources":["../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/util.ts","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/getOrientationColor.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/AlignmentConnections.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Breakends.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/PairedFeatures.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Translocations.tsx","../../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Overlay.tsx"],"sourcesContent":["import { parseBreakend } from '@gmod/vcf'\nimport { assembleLocStringFast, notEmpty } from '@jbrowse/core/util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\n// this finds candidate alignment features, aimed at plotting split reads from\n// BAM/CRAM files\nexport function getBadlyPairedAlignments(features: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n  const alreadyPairedWithSamePosition = new Set<string>()\n\n  // this finds candidate features that share the same name\n  for (const feature of features.values()) {\n    const flags = feature.get('flags')\n    const id = feature.id()\n    const supp = assembleLocStringFast({\n      refName: feature.get('refName'),\n      start: feature.get('start'),\n      end: feature.get('end'),\n    })\n    const unmapped = flags & 4\n    const correctlyPaired = flags & 2\n\n    if (\n      !alreadySeen.has(id) &&\n      !alreadyPairedWithSamePosition.has(supp) &&\n      !correctlyPaired &&\n      !unmapped\n    ) {\n      const n = feature.get('name')\n      let val = candidates.get(n)\n      if (!val) {\n        val = []\n        candidates.set(n, val)\n      }\n      val.push(feature)\n    }\n    alreadySeen.add(feature.id())\n    alreadyPairedWithSamePosition.add(supp)\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\n// this finds candidate alignment features, aimed at plotting split reads from\n// BAM/CRAM files\nexport function getMatchedAlignmentFeatures(features: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  // this finds candidate features that share the same name\n  for (const feature of features.values()) {\n    const id = feature.id()\n    const unmapped = feature.get('flags') & 4\n    const hasSA = !!feature.get('tags')?.SA\n    if (!alreadySeen.has(id) && !unmapped && hasSA) {\n      const n = feature.get('name')\n      let val = candidates.get(n)\n      if (!val) {\n        val = []\n        candidates.set(n, val)\n      }\n      val.push(feature)\n    }\n    alreadySeen.add(feature.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\nexport function hasPairedReads(features: Map<string, Feature>) {\n  for (const f of features.values()) {\n    if (f.get('flags') & 1) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function findMatchingAlt(feat1: Feature, feat2: Feature) {\n  const alts = feat1.get('ALT') as string[] | undefined\n  if (alts) {\n    return new Map(\n      alts\n        .map(alt => parseBreakend(alt))\n        .filter(notEmpty)\n        .map(bnd => [bnd.MatePosition, bnd]),\n    ).get(`${feat2.get('refName')}:${feat2.get('start') + 1}`)\n  }\n  return undefined\n}\n\n// Returns paired BND features across multiple views by inspecting the ALT\n// field to get exact coordinate matches\nexport function getMatchedBreakendFeatures(feats: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('type') === 'breakend') {\n      const alts = f.get('ALT') as string[] | undefined\n      if (alts) {\n        for (const a of alts) {\n          const cur = `${f.get('refName')}:${f.get('start') + 1}`\n          const bnd = parseBreakend(a)\n          if (bnd) {\n            const val = candidates.get(cur)\n            if (!val) {\n              candidates.set(bnd.MatePosition || 'none', [f])\n            } else {\n              val.push(f)\n            }\n          }\n        }\n      }\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\n// Getting \"matched\" TRA means just return all TRA\nexport function getMatchedTranslocationFeatures(feats: Map<string, Feature>) {\n  const ret: Feature[][] = []\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('ALT')[0] === '<TRA>') {\n      ret.push([f])\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return ret\n}\n\n// Getting \"matched\" TRA means just return all TRA\nexport function getMatchedPairedFeatures(feats: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('type') === 'paired_feature') {\n      const r1 = f.id().replace('-r1', '')\n      const r2 = f.id().replace('-r2', '')\n      if (f.id().endsWith('-r1')) {\n        if (!candidates.get(r1)) {\n          candidates.set(r1, [])\n        }\n        candidates.get(r1)!.push(f)\n      } else if (f.id().endsWith('-r2')) {\n        if (!candidates.get(r2)) {\n          candidates.set(r2, [])\n        }\n        candidates.get(r2)!.push(f)\n      }\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n","import { alpha } from '@mui/material'\n// orientation definitions from igv.js, see also\n// https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\nexport const orientationTypes = {\n  fr: {\n    F1R2: 'LR',\n    F2R1: 'LR',\n\n    F1F2: 'LL',\n    F2F1: 'LL',\n\n    R1R2: 'RR',\n    R2R1: 'RR',\n\n    R1F2: 'RL',\n    R2F1: 'RL',\n  } as Record<string, string>,\n\n  rf: {\n    R1F2: 'LR',\n    R2F1: 'LR',\n\n    R1R2: 'LL',\n    R2R1: 'LL',\n\n    F1F2: 'RR',\n    F2F1: 'RR',\n\n    F1R2: 'RL',\n    F2R1: 'RL',\n  } as Record<string, string>,\n\n  ff: {\n    F2F1: 'LR',\n    R1R2: 'LR',\n\n    F2R1: 'LL',\n    R1F2: 'LL',\n\n    R2F1: 'RR',\n    F1R2: 'RR',\n\n    R2R1: 'RL',\n    F1F2: 'RL',\n  } as Record<string, string>,\n}\n\nexport const pairMap = {\n  LR: 'color_pair_lr',\n  LL: 'color_pair_ll',\n  RR: 'color_pair_rr',\n  RL: 'color_pair_rl',\n} as const\n\n// manually calculated by running\n// const color = require('color')\n// Object.fromEntries(Object.entries(fillColor).map(([key,val])=>{\n//   return [key, color(val).darken('0.3').hex()]\n// }))\n// this avoids (expensive) use of Color module at runtime\nexport const strokeColor = {\n  color_fwd_strand_not_proper: alpha('#CA6767', 0.8),\n  color_rev_strand_not_proper: alpha('#7272AA', 0.8),\n  color_fwd_strand: alpha('#DC2A2A', 0.8),\n  color_rev_strand: alpha('#4141BA', 0.8),\n  color_fwd_missing_mate: alpha('#921111', 0.8),\n  color_rev_missing_mate: alpha('#111192', 0.8),\n  color_fwd_diff_chr: alpha('#000000', 0.8),\n  color_rev_diff_chr: alpha('#696969', 0.8),\n  color_pair_lr: alpha('#8C8C8C', 0.8),\n  color_pair_rr: alpha('#00005A', 0.8),\n  color_pair_rl: alpha('#005A5A', 0.8),\n  color_pair_ll: alpha('#005A00', 0.8),\n  color_nostrand: alpha('#8C8C8C', 0.8),\n  color_interchrom: alpha('#5A005A', 0.8),\n  color_longinsert: alpha('#B30000', 0.8),\n  color_shortinsert: alpha('#FF3A5C', 0.8),\n  color_unknown: alpha('#555', 0.8),\n}\n\nconst defaultColor = strokeColor.color_unknown\n\nexport function getPairedOrientationColorOrDefault(f: {\n  pair_orientation?: string\n}) {\n  const type = orientationTypes.fr\n  const r = type[f.pair_orientation || ''] as keyof typeof pairMap\n  const type2 = pairMap[r] as keyof typeof strokeColor\n  return r === 'LR' ? undefined : strokeColor[type2]\n}\n\nexport function getLongReadOrientationColorOrDefault(s1: number, s2: number) {\n  if (s1 === -1 && s2 === 1) {\n    return strokeColor.color_pair_rr\n  } else if (s1 === 1 && s2 === -1) {\n    return strokeColor.color_pair_ll\n  } else {\n    return strokeColor.color_unknown\n  }\n}\n\nexport function getLongReadOrientationAbnormal(s1: number, s2: number) {\n  if (s1 === -1 && s2 === 1) {\n    return true\n  } else if (s1 === 1 && s2 === -1) {\n    return true\n  } else {\n    return false\n  }\n}\n\nexport function isAbnormalOrientation(f: { pair_orientation?: string }) {\n  const type = orientationTypes.fr\n  const r = type[f.pair_orientation || ''] as keyof typeof pairMap\n  return r !== 'LR'\n}\n\nexport function getPairedOrientationColor(f: { pair_orientation?: string }) {\n  return getPairedOrientationColorOrDefault(f) || defaultColor\n}\n","import { useMemo, useState } from 'react'\n\nimport { getSession, getStrokeProps } from '@jbrowse/core/util'\nimport { useTheme } from '@mui/material'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\n\nimport {\n  getBadlyPairedAlignments,\n  getMatchedAlignmentFeatures,\n  hasPairedReads,\n} from './util'\nimport {\n  getPxFromCoordinate,\n  heightFromSpecificLevel,\n  useNextFrame,\n  yPos,\n} from '../util'\nimport {\n  getLongReadOrientationAbnormal,\n  getLongReadOrientationColorOrDefault,\n  getPairedOrientationColor,\n  isAbnormalOrientation,\n} from './getOrientationColor'\n\nimport type { BreakpointViewModel } from '../model'\n\nconst [LEFT, , RIGHT] = [0, 1, 2, 3] as const\n\nconst AlignmentConnections = observer(function ({\n  model,\n  trackId,\n  parentRef,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement | null>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { interactiveOverlay, views, showIntraviewLinks } = model\n  const theme = useTheme()\n  const session = getSession(model)\n  const snap = getSnapshot(model)\n  const { assemblyManager } = session\n  const v0 = views[0]\n  const assembly = v0 ? assemblyManager.get(v0.assemblyNames[0]!) : undefined\n  useNextFrame(snap)\n  const allFeatures = model.getTrackFeatures(trackId)\n  const hasPaired = useMemo(() => hasPairedReads(allFeatures), [allFeatures])\n  const layoutMatches = useMemo(() => {\n    const layoutMatches = model.getMatchedFeaturesInLayout(\n      trackId,\n      hasPaired\n        ? getBadlyPairedAlignments(allFeatures)\n        : getMatchedAlignmentFeatures(allFeatures),\n    )\n    if (!hasPaired) {\n      for (const m of layoutMatches) {\n        m.sort((a, b) => a.clipPos - b.clipPos)\n      }\n    }\n    return layoutMatches\n  }, [allFeatures, trackId, hasPaired, model])\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n\n  let yOffset = 0\n  if (parentRef.current) {\n    const rect = parentRef.current.getBoundingClientRect()\n    yOffset = rect.top\n  }\n\n  return assembly ? (\n    <g\n      fill=\"none\"\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        // we follow a path in the list of chunks, not from top to bottom, just in series\n        // following x1,y1 -> x2,y2\n        for (let i = 0; i < chunk.length - 1; i++) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]!\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]!\n\n          if (!c1 || !c2) {\n            console.warn('received null layout for a overlay feature')\n            return null\n          }\n\n          // disable rendering connections in a single row\n          if (!showIntraviewLinks && level1 === level2) {\n            return null\n          }\n          const f1ref = assembly.getCanonicalRefName(f1.get('refName'))\n          const f2ref = assembly.getCanonicalRefName(f2.get('refName'))\n\n          if (!f1ref || !f2ref) {\n            throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n          }\n          const r = {\n            pair_orientation: f1.get('pair_orientation'),\n          }\n\n          const s1 = f1.get('strand')\n          const s2 = f2.get('strand')\n          const sameRef = f1ref === f2ref\n          const checkOrientation = sameRef\n          let orientationColor = ''\n          let isAbnormal = false\n          if (checkOrientation) {\n            if (hasPaired) {\n              orientationColor = getPairedOrientationColor(r)\n              isAbnormal = isAbnormalOrientation(r)\n            } else {\n              orientationColor = getLongReadOrientationColorOrDefault(s1, s2)\n              isAbnormal = getLongReadOrientationAbnormal(s1, s2)\n            }\n          }\n          const p1 = c1[s1 === -1 ? LEFT : RIGHT]\n          const sn1 = s2 === -1\n          const p2 = hasPaired ? c2[sn1 ? LEFT : RIGHT] : c2[sn1 ? RIGHT : LEFT]\n          const x1 = getPxFromCoordinate(views[level1]!, f1ref, p1)\n          const x2 = getPxFromCoordinate(views[level2]!, f2ref, p2)\n          const reversed1 = views[level1]!.pxToBp(x1).reversed\n          const reversed2 = views[level2]!.pxToBp(x2).reversed\n          const rf1 = reversed1 ? -1 : 1\n          const rf2 = reversed2 ? -1 : 1\n          const tracks = views.map(v => v.getTrack(trackId))\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yOffset\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yOffset\n          const sameLevel = level1 === level2\n          const abnormalSpecialRenderFlag = sameLevel && isAbnormal\n          const trackHeight = abnormalSpecialRenderFlag\n            ? tracks[level1].displays[0].height\n            : 0\n          const pf1 = hasPaired ? -1 : 1\n          const y0 = heightFromSpecificLevel(\n            views,\n            trackId,\n            level1,\n            getTrackYPosOverride,\n          )\n\n          // possible todo: use totalCurveHeight to possibly make alternative\n          // squiggle if the S is too small\n          const path = [\n            'M',\n            x1,\n            y1,\n            'C',\n\n            // first bezier x,y\n            x1 + 200 * f1.get('strand') * rf1,\n            abnormalSpecialRenderFlag\n              ? Math.min(y0 - yOffset + trackHeight, y1 + trackHeight)\n              : y1,\n\n            // second bezier x,y\n            x2 - 200 * f2.get('strand') * rf2 * pf1,\n            abnormalSpecialRenderFlag\n              ? Math.min(y0 - yOffset + trackHeight, y2 + trackHeight)\n              : y2,\n\n            // third bezier x,y\n            x2,\n            y2,\n          ].join(' ')\n          const id = `${f1.id()}-${f2.id()}`\n          ret.push(\n            <path\n              d={path}\n              key={id}\n              data-testid=\"r1\"\n              pointerEvents={interactiveOverlay ? 'auto' : undefined}\n              strokeWidth={mouseoverElt === id ? 5 : 1}\n              {...getStrokeProps(\n                orientationColor || theme.palette.text.disabled,\n              )}\n              onClick={() => {\n                const featureWidget = session.addWidget?.(\n                  'BreakpointAlignmentsWidget',\n                  'breakpointAlignments',\n                  {\n                    featureData: {\n                      feature1: (\n                        allFeatures.get(f1.id()) || { toJSON: () => {} }\n                      ).toJSON(),\n                      feature2: (\n                        allFeatures.get(f2.id()) || { toJSON: () => {} }\n                      ).toJSON(),\n                    },\n                  },\n                )\n                session.showWidget?.(featureWidget)\n              }}\n              onMouseOver={() => {\n                setMouseoverElt(id)\n              }}\n              onMouseOut={() => {\n                setMouseoverElt(undefined)\n              }}\n            />,\n          )\n        }\n        return ret\n      })}\n    </g>\n  ) : null\n})\n\nexport default AlignmentConnections\n","import { useMemo, useState } from 'react'\n\nimport { getSession } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\n\nimport { findMatchingAlt, getMatchedBreakendFeatures } from './util'\nimport { getPxFromCoordinate, useNextFrame, yPos } from '../util'\n\nimport type { BreakpointViewModel } from '../model'\n\nconst [LEFT] = [0, 1, 2, 3] as const\n\nconst Breakends = observer(function ({\n  model,\n  trackId,\n  parentRef: ref,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement | null>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { interactiveOverlay, views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const totalFeatures = model.getTrackFeatures(trackId)\n  const layoutMatches = useMemo(\n    () =>\n      model.getMatchedFeaturesInLayout(\n        trackId,\n        getMatchedBreakendFeatures(totalFeatures),\n      ),\n    [totalFeatures, trackId, model],\n  )\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const snap = getSnapshot(model)\n  useNextFrame(snap)\n  const assembly = assemblyManager.get(views[0]!.assemblyNames[0]!)\n\n  if (!assembly) {\n    return null\n  }\n\n  let yoff = 0\n  if (ref.current) {\n    const rect = ref.current.getBoundingClientRect()\n    yoff = rect.top\n  }\n\n  return (\n    <g\n      stroke=\"green\"\n      strokeWidth={5}\n      fill=\"none\"\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        // we follow a path in the list of chunks, not from top to bottom, just\n        // in series following x1,y1 -> x2,y2\n        for (let i = 0; i < chunk.length - 1; i += 1) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]!\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]!\n          const id = f1.id()\n\n          const relevantAlt = findMatchingAlt(f1, f2)\n          if (!c1 || !c2) {\n            return null\n          }\n          const f1origref = f1.get('refName')\n          const f2origref = f2.get('refName')\n          const f1ref = assembly.getCanonicalRefName(f1origref)\n          const f2ref = assembly.getCanonicalRefName(f2origref)\n          if (!f1ref || !f2ref) {\n            throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n          }\n          const x1 = getPxFromCoordinate(views[level1]!, f1ref, c1[LEFT])\n          const x2 = getPxFromCoordinate(views[level2]!, f2ref, c2[LEFT])\n          const reversed1 = views[level1]!.pxToBp(x1).reversed\n          const reversed2 = views[level2]!.pxToBp(x2).reversed\n\n          const tracks = views.map(v => v.getTrack(trackId))\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yoff\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yoff\n          if (!relevantAlt) {\n            console.warn('the relevant ALT allele was not found, cannot render')\n          } else {\n            const path = [\n              'M', // move to\n              x1 -\n                20 *\n                  (relevantAlt.Join === 'left' ? -1 : 1) *\n                  (reversed1 ? -1 : 1),\n              y1,\n              'L', // line to\n              x1,\n              y1,\n              'L', // line to\n              x2,\n              y2,\n              'L', // line to\n              x2 -\n                20 *\n                  (relevantAlt.MateDirection === 'left' ? 1 : -1) *\n                  (reversed2 ? -1 : 1),\n              y2,\n            ].join(' ')\n            ret.push(\n              <path\n                d={path}\n                data-testid=\"r2\"\n                pointerEvents={interactiveOverlay ? 'auto' : undefined}\n                key={JSON.stringify(path)}\n                strokeWidth={id === mouseoverElt ? 10 : 5}\n                onClick={() => {\n                  const featureWidget = session.addWidget?.(\n                    'VariantFeatureWidget',\n                    'variantFeature',\n                    {\n                      featureData: totalFeatures.get(id)?.toJSON(),\n                    },\n                  )\n                  session.showWidget?.(featureWidget)\n                }}\n                onMouseOver={() => {\n                  setMouseoverElt(id)\n                }}\n                onMouseOut={() => {\n                  setMouseoverElt(undefined)\n                }}\n              />,\n            )\n          }\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default Breakends\n","import { useMemo, useState } from 'react'\n\nimport { getSession } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\n\nimport { getMatchedPairedFeatures } from './util'\nimport { getPxFromCoordinate, useNextFrame, yPos } from '../util'\n\nimport type { BreakpointViewModel } from '../model'\n\nconst [LEFT] = [0, 1, 2, 3] as const\n\nconst PairedFeatures = observer(function ({\n  model,\n  trackId,\n  parentRef: ref,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement | null>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { interactiveOverlay, views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const totalFeatures = model.getTrackFeatures(trackId)\n  const layoutMatches = useMemo(\n    () =>\n      model.getMatchedFeaturesInLayout(\n        trackId,\n        getMatchedPairedFeatures(totalFeatures),\n      ),\n    [totalFeatures, trackId, model],\n  )\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const snap = getSnapshot(model)\n  useNextFrame(snap)\n  const assembly = assemblyManager.get(views[0]!.assemblyNames[0]!)\n\n  if (!assembly) {\n    return null\n  }\n\n  let yoff = 0\n  if (ref.current) {\n    const rect = ref.current.getBoundingClientRect()\n    yoff = rect.top\n  }\n\n  return (\n    <g\n      stroke=\"green\"\n      strokeWidth={5}\n      fill=\"none\"\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        // we follow a path in the list of chunks, not from top to bottom, just\n        // in series following x1,y1 -> x2,y2\n        for (let i = 0; i < chunk.length - 1; i += 1) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]!\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]!\n          const id = f1.id()\n\n          if (!c1 || !c2) {\n            return null\n          }\n          const f1origref = f1.get('refName')\n          const f2origref = f2.get('refName')\n          const f1ref = assembly.getCanonicalRefName(f1origref)\n          const f2ref = assembly.getCanonicalRefName(f2origref)\n          if (!f1ref || !f2ref) {\n            throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n          }\n          const x1 = getPxFromCoordinate(views[level1]!, f1ref, c1[LEFT])\n          const x2 = getPxFromCoordinate(views[level2]!, f2ref, c2[LEFT])\n\n          const tracks = views.map(v => v.getTrack(trackId))\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yoff\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yoff\n          const path = [\n            'M', // move to\n            x1,\n            y1,\n            'L', // line to\n            x2,\n            y2,\n          ].join(' ')\n          ret.push(\n            <path\n              d={path}\n              data-testid=\"r2\"\n              key={JSON.stringify(path)}\n              pointerEvents={interactiveOverlay ? 'auto' : undefined}\n              strokeWidth={id === mouseoverElt ? 10 : 5}\n              onClick={() => {\n                const featureWidget = session.addWidget?.(\n                  'VariantFeatureWidget',\n                  'variantFeature',\n                  {\n                    featureData: totalFeatures.get(id)?.toJSON(),\n                  },\n                )\n                session.showWidget?.(featureWidget)\n              }}\n              onMouseOver={() => {\n                setMouseoverElt(id)\n              }}\n              onMouseOut={() => {\n                setMouseoverElt(undefined)\n              }}\n            />,\n          )\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default PairedFeatures\n","import { useMemo, useState } from 'react'\n\nimport { getSession } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\nimport { getSnapshot } from 'mobx-state-tree'\n\nimport { getMatchedTranslocationFeatures } from './util'\nimport { getPxFromCoordinate, useNextFrame, yPos } from '../util'\n\nimport type { BreakpointViewModel } from '../model'\nimport type { LayoutRecord } from '../types'\n\nconst [LEFT] = [0, 1, 2, 3] as const\n\nfunction str(s: string) {\n  if (s === '+') {\n    return 1\n  } else if (s === '-') {\n    return -1\n  } else {\n    return 0\n  }\n}\n\nconst Translocations = observer(function ({\n  model,\n  trackId,\n  parentRef: ref,\n  getTrackYPosOverride,\n}: {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement | null>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { interactiveOverlay, views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const totalFeatures = model.getTrackFeatures(trackId)\n  const layoutMatches = useMemo(\n    () =>\n      model.getMatchedFeaturesInLayout(\n        trackId,\n        getMatchedTranslocationFeatures(totalFeatures),\n      ),\n\n    [totalFeatures, trackId, model],\n  )\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const snap = getSnapshot(model)\n  useNextFrame(snap)\n\n  const assembly = assemblyManager.get(views[0]!.assemblyNames[0]!)\n  if (!assembly) {\n    return null\n  }\n\n  let yOffset = 0\n  if (ref.current) {\n    const rect = ref.current.getBoundingClientRect()\n    yOffset = rect.top\n  }\n\n  // we hardcode the TRA to go to the \"other view\" and if there is none, we\n  // just return null here note: would need to do processing of the INFO\n  // CHR2/END and see which view could contain those coordinates to really do\n  // it properly\n  if (views.length < 2) {\n    return null\n  }\n  return (\n    <g\n      fill=\"none\"\n      stroke=\"green\"\n      strokeWidth={5}\n      data-testid={layoutMatches.length ? `${trackId}-loaded` : trackId}\n    >\n      {layoutMatches.map(chunk => {\n        // we follow a path in the list of chunks, not from top to bottom,\n        // just in series following x1,y1 -> x2,y2\n        const ret = []\n        for (const { layout: c1, feature: f1, level: level1 } of chunk) {\n          const level2 = level1 === 0 ? 1 : 0\n          const id = f1.id()\n          if (!c1) {\n            return null\n          }\n\n          const info = f1.get('INFO')\n          const chr2 = info.CHR2[0]\n          const end2 = info.END[0]\n          const res = info.STRANDS?.[0]?.split('') // not all files have STRANDS\n          const [myDirection, mateDirection] = res ?? ['.', '.']\n\n          const r = getPxFromCoordinate(views[level2]!, chr2, end2)\n          if (r) {\n            const c2: LayoutRecord = [r, 0, r + 1, 0]\n            const x1 = getPxFromCoordinate(\n              views[level1]!,\n              f1.get('refName'),\n              c1[LEFT],\n            )\n            const x2 = r\n            const reversed1 = views[level1]!.pxToBp(x1).reversed\n            const reversed2 = views[level2]!.pxToBp(x2).reversed\n\n            const tracks = views.map(v => v.getTrack(trackId))\n            const y1 =\n              yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n              yOffset\n            const y2 =\n              yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n              yOffset\n\n            const path = [\n              'M', // move to\n              x1 - 20 * str(myDirection) * (reversed1 ? -1 : 1),\n              y1,\n              'L', // line to\n              x1,\n              y1,\n              'L', // line to as const\n              x2,\n              y2,\n              'L', // line to\n              x2 - 20 * str(mateDirection) * (reversed2 ? -1 : 1),\n              y2,\n            ].join(' ')\n            ret.push(\n              <path\n                d={path}\n                key={JSON.stringify(path)}\n                pointerEvents={interactiveOverlay ? 'auto' : undefined}\n                strokeWidth={id === mouseoverElt ? 10 : 5}\n                onClick={() => {\n                  const featureWidget = session.addWidget?.(\n                    'VariantFeatureWidget',\n                    'variantFeature',\n                    {\n                      featureData: (\n                        totalFeatures.get(id) || { toJSON: () => {} }\n                      ).toJSON(),\n                    },\n                  )\n                  session.showWidget?.(featureWidget)\n                }}\n                onMouseOver={() => {\n                  setMouseoverElt(id)\n                }}\n                onMouseOut={() => {\n                  setMouseoverElt(undefined)\n                }}\n              />,\n            )\n          }\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default Translocations\n","import { observer } from 'mobx-react'\n\nimport AlignmentConnections from './AlignmentConnections'\nimport Breakends from './Breakends'\nimport PairedFeatures from './PairedFeatures'\nimport Translocations from './Translocations'\n\nimport type { BreakpointViewModel } from '../model'\n\nconst Overlay = observer(function (props: {\n  parentRef: React.RefObject<SVGSVGElement | null>\n  model: BreakpointViewModel\n  trackId: string\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { model, trackId } = props\n  const tracks = model.getMatchedTracks(trackId)\n  const type = tracks[0]?.type\n\n  // curvy line type arcs\n  if (type === 'AlignmentsTrack') {\n    return <AlignmentConnections {...props} />\n  }\n\n  // translocation type arcs\n  else if (type === 'VariantTrack') {\n    return model.hasTranslocations(trackId) ? (\n      <Translocations {...props} />\n    ) : model.hasPairedFeatures(trackId) ? (\n      <PairedFeatures {...props} />\n    ) : (\n      <Breakends {...props} />\n    )\n  }\n\n  // unknown\n  else {\n    return null\n  }\n})\n\nexport default Overlay\n"],"names":["findMatchingAlt","feat1","feat2","alts","get","Map","map","alt","parseBreakend","filter","notEmpty","bnd","MatePosition","orientationTypes","F1R2","F2R1","F1F2","F2F1","R1R2","R2R1","R1F2","R2F1","pairMap","LR","LL","RR","RL","strokeColor","color_fwd_strand_not_proper","alpha","color_rev_strand_not_proper","color_fwd_strand","color_rev_strand","color_fwd_missing_mate","color_rev_missing_mate","color_fwd_diff_chr","color_rev_diff_chr","color_pair_lr","color_pair_rr","color_pair_rl","color_pair_ll","color_nostrand","color_interchrom","color_longinsert","color_shortinsert","color_unknown","defaultColor","getLongReadOrientationColorOrDefault","s1","s2","getLongReadOrientationAbnormal","LEFT","RIGHT","observer","model","trackId","parentRef","getTrackYPosOverride","interactiveOverlay","views","showIntraviewLinks","theme","useTheme","session","getSession","snap","getSnapshot","assemblyManager","v0","assembly","assemblyNames","undefined","useNextFrame","allFeatures","getTrackFeatures","hasPaired","useMemo","features","f","values","hasPairedReads","layoutMatches","getMatchedFeaturesInLayout","candidates","alreadySeen","Set","alreadyPairedWithSamePosition","feature","flags","id","supp","assembleLocStringFast","refName","start","end","unmapped","correctlyPaired","has","n","val","set","push","add","v","length","getBadlyPairedAlignments","hasSA","SA","getMatchedAlignmentFeatures","m","sort","a","b","clipPos","mouseoverElt","setMouseoverElt","useState","yOffset","current","rect","getBoundingClientRect","top","_jsx","fill","children","chunk","ret","i","layout","c1","f1","level","level1","c2","f2","level2","console","warn","f1ref","getCanonicalRefName","f2ref","Error","r","pair_orientation","orientationColor","isAbnormal","getPairedOrientationColorOrDefault","p1","sn1","p2","x1","getPxFromCoordinate","x2","rf1","pxToBp","reversed","rf2","tracks","getTrack","y1","yPos","y2","abnormalSpecialRenderFlag","trackHeight","displays","height","pf1","y0","heightFromSpecificLevel","path","Math","min","join","d","pointerEvents","strokeWidth","getStrokeProps","palette","text","disabled","onClick","featureWidget","addWidget","featureData","feature1","toJSON","feature2","showWidget","onMouseOver","onMouseOut","ref","totalFeatures","feats","cur","getMatchedBreakendFeatures","yoff","stroke","relevantAlt","f1origref","f2origref","reversed1","reversed2","Join","MateDirection","JSON","stringify","r1","replace","r2","endsWith","getMatchedPairedFeatures","str","s","getMatchedTranslocationFeatures","info","chr2","CHR2","end2","END","res","STRANDS","split","myDirection","mateDirection","props","getMatchedTracks","type","AlignmentConnections","hasTranslocations","Translocations","hasPairedFeatures","PairedFeatures","Breakends"],"sourceRoot":""}