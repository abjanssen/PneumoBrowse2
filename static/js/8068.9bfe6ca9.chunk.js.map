{"version":3,"file":"static/js/8068.9bfe6ca9.chunk.js","mappings":"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","sources":["../../../node_modules/.pnpm/pako-esm2@2.0.2/node_modules/pako-esm2/src/zlib/trees.js","../../../node_modules/.pnpm/pako-esm2@2.0.2/node_modules/pako-esm2/src/zlib/deflate.js","../../../node_modules/.pnpm/pako-esm2@2.0.2/node_modules/pako-esm2/src/deflate.js"],"sourcesContent":["// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nimport { Z_BINARY, Z_FIXED, Z_TEXT, Z_UNKNOWN } from './constants.js'\nimport { arraySet } from '../utils/common.js'\n\nfunction zero(buf) {\n  var len = buf.length\n  while (--len >= 0) {\n    buf[len] = 0\n  }\n}\n\n// From zutil.h\n\nvar STORED_BLOCK = 0\nvar STATIC_TREES = 1\nvar DYN_TREES = 2\n/* The three kinds of block type */\n\nvar MIN_MATCH = 3\nvar MAX_MATCH = 258\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES = 29\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS = 256\n/* number of literal bytes 0..255 */\n\nvar L_CODES = LITERALS + 1 + LENGTH_CODES\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES = 30\n/* number of distance codes */\n\nvar BL_CODES = 19\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE = 2 * L_CODES + 1\n/* maximum heap size */\n\nvar MAX_BITS = 15\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size = 16\n/* size of bit buffer in bi_buf */\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK = 256\n/* end of block literal code */\n\nvar REP_3_6 = 16\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10 = 17\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nvar extra_lbits =\n  /* extra bits for each length code */\n  [\n    0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5,\n    5, 5, 5, 0,\n  ]\n\nvar extra_dbits =\n  /* extra bits for each distance code */\n  [\n    0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10,\n    11, 11, 12, 12, 13, 13,\n  ]\n\nvar extra_blbits =\n  /* extra bits for each bit length code */\n  [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]\n\nvar bl_order = [\n  16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15,\n]\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512 /* see definition of array dist_code below */\n\n// !!!! Use flat array instead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist\n/* First normalized distance for each code (0 = distance of 1) */\n\nfunction StaticTreeDesc(\n  static_tree,\n  extra_bits,\n  extra_base,\n  elems,\n  max_length,\n) {\n  this.static_tree = static_tree /* static tree or NULL */\n  this.extra_bits = extra_bits /* extra bits for each code or NULL */\n  this.extra_base = extra_base /* base index for extra_bits */\n  this.elems = elems /* max number of elements in the tree */\n  this.max_length = max_length /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree = static_tree && static_tree.length\n}\n\nvar static_l_desc\nvar static_d_desc\nvar static_bl_desc\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree /* the dynamic tree */\n  this.max_code = 0 /* largest code with non zero frequency */\n  this.stat_desc = stat_desc /* the corresponding static tree */\n}\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)]\n}\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n  //    put_byte(s, (uch)((w) & 0xff));\n  //    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = w & 0xff\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff\n}\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > Buf_size - length) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff\n    put_short(s, s.bi_buf)\n    s.bi_buf = value >> (Buf_size - s.bi_valid)\n    s.bi_valid += length - Buf_size\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff\n    s.bi_valid += length\n  }\n}\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2] /*.Code*/, tree[c * 2 + 1] /*.Len*/)\n}\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0\n  do {\n    res |= code & 1\n    code >>>= 1\n    res <<= 1\n  } while (--len > 0)\n  return res >>> 1\n}\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf)\n    s.bi_buf = 0\n    s.bi_valid = 0\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff\n    s.bi_buf >>= 8\n    s.bi_valid -= 8\n  }\n}\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc) {\n  //    deflate_state *s;\n  //    tree_desc *desc;    /* the tree descriptor */\n  var tree = desc.dyn_tree\n  var max_code = desc.max_code\n  var stree = desc.stat_desc.static_tree\n  var has_stree = desc.stat_desc.has_stree\n  var extra = desc.stat_desc.extra_bits\n  var base = desc.stat_desc.extra_base\n  var max_length = desc.stat_desc.max_length\n  var h /* heap index */\n  var n, m /* iterate over the tree elements */\n  var bits /* bit length */\n  var xbits /* extra bits */\n  var f /* frequency */\n  var overflow = 0 /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1] /*.Len*/ = 0 /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h]\n    bits = tree[tree[n * 2 + 1] /*.Dad*/ * 2 + 1] /*.Len*/ + 1\n    if (bits > max_length) {\n      bits = max_length\n      overflow++\n    }\n    tree[n * 2 + 1] /*.Len*/ = bits\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) {\n      continue\n    } /* not a leaf node */\n\n    s.bl_count[bits]++\n    xbits = 0\n    if (n >= base) {\n      xbits = extra[n - base]\n    }\n    f = tree[n * 2] /*.Freq*/\n    s.opt_len += f * (bits + xbits)\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1] /*.Len*/ + xbits)\n    }\n  }\n  if (overflow === 0) {\n    return\n  }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1\n    while (s.bl_count[bits] === 0) {\n      bits--\n    }\n    s.bl_count[bits]-- /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2 /* move one overflow item as its brother */\n    s.bl_count[max_length]--\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2\n  } while (overflow > 0)\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits]\n    while (n !== 0) {\n      m = s.heap[--h]\n      if (m > max_code) {\n        continue\n      }\n      if (tree[m * 2 + 1] /*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]) /*.Len*/ * tree[m * 2] /*.Freq*/\n        tree[m * 2 + 1] /*.Len*/ = bits\n      }\n      n--\n    }\n  }\n}\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count) {\n  //    ct_data *tree;             /* the tree to decorate */\n  //    int max_code;              /* largest code with non zero frequency */\n  //    ushf *bl_count;            /* number of codes at each bit length */\n  var next_code = new Array(\n    MAX_BITS + 1,\n  ) /* next code value for each bit length */\n  var code = 0 /* running code value */\n  var bits /* bit index */\n  var n /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0; n <= max_code; n++) {\n    var len = tree[n * 2 + 1] /*.Len*/\n    if (len === 0) {\n      continue\n    }\n    /* Now reverse the bits */\n    tree[n * 2] /*.Code*/ = bi_reverse(next_code[len]++, len)\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n /* iterates over tree elements */\n  var bits /* bit counter */\n  var length /* length value */\n  var code /* code value */\n  var dist /* distance index */\n  var bl_count = new Array(MAX_BITS + 1)\n  /* number of codes at each bit length for an optimal tree */\n\n  static_ltree = new Array((L_CODES + 2) * 2)\n  zero(static_ltree)\n\n  static_dtree = new Array(D_CODES * 2)\n  zero(static_dtree)\n\n  _dist_code = new Array(DIST_CODE_LEN)\n  zero(_dist_code)\n\n  _length_code = new Array(MAX_MATCH - MIN_MATCH + 1)\n  zero(_length_code)\n\n  base_length = new Array(LENGTH_CODES)\n  zero(base_length)\n\n  base_dist = new Array(D_CODES)\n  zero(base_dist)\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n  /*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length\n    for (n = 0; n < 1 << extra_lbits[code]; n++) {\n      _length_code[length++] = code\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist\n    for (n = 0; n < 1 << extra_dbits[code]; n++) {\n      _dist_code[dist++] = code\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7 /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7\n    for (n = 0; n < 1 << (extra_dbits[code] - 7); n++) {\n      _dist_code[256 + dist++] = code\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0\n  }\n\n  n = 0\n  while (n <= 143) {\n    static_ltree[n * 2 + 1] /*.Len*/ = 8\n    n++\n    bl_count[8]++\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1] /*.Len*/ = 9\n    n++\n    bl_count[9]++\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1] /*.Len*/ = 7\n    n++\n    bl_count[7]++\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1] /*.Len*/ = 8\n    n++\n    bl_count[8]++\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count)\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1] /*.Len*/ = 5\n    static_dtree[n * 2] /*.Code*/ = bi_reverse(n, 5)\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(\n    static_ltree,\n    extra_lbits,\n    LITERALS + 1,\n    L_CODES,\n    MAX_BITS,\n  )\n  static_d_desc = new StaticTreeDesc(\n    static_dtree,\n    extra_dbits,\n    0,\n    D_CODES,\n    MAX_BITS,\n  )\n  static_bl_desc = new StaticTreeDesc(\n    new Array(0),\n    extra_blbits,\n    0,\n    BL_CODES,\n    MAX_BL_BITS,\n  )\n\n  //static_init_done = true;\n}\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES; n++) {\n    s.dyn_ltree[n * 2] /*.Freq*/ = 0\n  }\n  for (n = 0; n < D_CODES; n++) {\n    s.dyn_dtree[n * 2] /*.Freq*/ = 0\n  }\n  for (n = 0; n < BL_CODES; n++) {\n    s.bl_tree[n * 2] /*.Freq*/ = 0\n  }\n\n  s.dyn_ltree[END_BLOCK * 2] /*.Freq*/ = 1\n  s.opt_len = s.static_len = 0\n  s.last_lit = s.matches = 0\n}\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s) {\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf)\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf\n  }\n  s.bi_buf = 0\n  s.bi_valid = 0\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header) {\n  //DeflateState *s;\n  //charf    *buf;    /* the input data */\n  //unsigned len;     /* its length */\n  //int      header;  /* true if block header must be written */\n  bi_windup(s) /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len)\n    put_short(s, ~len)\n  }\n  //  while (len--) {\n  //    put_byte(s, *buf++);\n  //  }\n  arraySet(s.pending_buf, s.window, buf, len, s.pending)\n  s.pending += len\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2\n  var _m2 = m * 2\n  return (\n    tree[_n2] /*.Freq*/ < tree[_m2] /*.Freq*/ ||\n    (tree[_n2] /*.Freq*/ === tree[_m2] /*.Freq*/ && depth[n] <= depth[m])\n  )\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k) {\n  //    deflate_state *s;\n  //    ct_data *tree;  /* the tree to restore */\n  //    int k;               /* node to move down */\n  var v = s.heap[k]\n  var j = k << 1 /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len && smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) {\n      break\n    }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j]\n    k = j\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1\n  }\n  s.heap[k] = v\n}\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree) {\n  //    deflate_state *s;\n  //    const ct_data *ltree; /* literal tree */\n  //    const ct_data *dtree; /* distance tree */\n  var dist /* distance of matched string */\n  var lc /* match length or unmatched char (if dist == 0) */\n  var lx = 0 /* running index in l_buf */\n  var code /* the code to send */\n  var extra /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist =\n        (s.pending_buf[s.d_buf + lx * 2] << 8) |\n        s.pending_buf[s.d_buf + lx * 2 + 1]\n      lc = s.pending_buf[s.l_buf + lx]\n      lx++\n\n      if (dist === 0) {\n        send_code(s, lc, ltree) /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc]\n        send_code(s, code + LITERALS + 1, ltree) /* send the length code */\n        extra = extra_lbits[code]\n        if (extra !== 0) {\n          lc -= base_length[code]\n          send_bits(s, lc, extra) /* send the extra length bits */\n        }\n        dist-- /* dist is now the match distance - 1 */\n        code = d_code(dist)\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree) /* send the distance code */\n        extra = extra_dbits[code]\n        if (extra !== 0) {\n          dist -= base_dist[code]\n          send_bits(s, dist, extra) /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n    } while (lx < s.last_lit)\n  }\n\n  send_code(s, END_BLOCK, ltree)\n}\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc) {\n  //    deflate_state *s;\n  //    tree_desc *desc; /* the tree descriptor */\n  var tree = desc.dyn_tree\n  var stree = desc.stat_desc.static_tree\n  var has_stree = desc.stat_desc.has_stree\n  var elems = desc.stat_desc.elems\n  var n, m /* iterate over heap elements */\n  var max_code = -1 /* largest code with non zero frequency */\n  var node /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0\n  s.heap_max = HEAP_SIZE\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2] /*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n\n      s.depth[n] = 0\n    } else {\n      tree[n * 2 + 1] /*.Len*/ = 0\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = max_code < 2 ? ++max_code : 0\n    tree[node * 2] /*.Freq*/ = 1\n    s.depth[node] = 0\n    s.opt_len--\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1] /*.Len*/\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = s.heap_len >> 1 /*int /2*/; n >= 1; n--) {\n    pqdownheap(s, tree, n)\n  }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1 /*SMALLEST*/]\n    s.heap[1 /*SMALLEST*/] = s.heap[s.heap_len--]\n    pqdownheap(s, tree, 1 /*SMALLEST*/)\n    /***/\n\n    m = s.heap[1 /*SMALLEST*/] /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m\n\n    /* Create a new node father of n and m */\n    tree[node * 2] /*.Freq*/ = tree[n * 2] /*.Freq*/ + tree[m * 2] /*.Freq*/\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1\n    tree[n * 2 + 1] /*.Dad*/ = tree[m * 2 + 1] /*.Dad*/ = node\n\n    /* and insert the new node in the heap */\n    s.heap[1 /*SMALLEST*/] = node++\n    pqdownheap(s, tree, 1 /*SMALLEST*/)\n  } while (s.heap_len >= 2)\n\n  s.heap[--s.heap_max] = s.heap[1 /*SMALLEST*/]\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc)\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count)\n}\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code) {\n  //    deflate_state *s;\n  //    ct_data *tree;   /* the tree to be scanned */\n  //    int max_code;    /* and its largest code of non zero frequency */\n  var n /* iterates over all tree elements */\n  var prevlen = -1 /* last emitted length */\n  var curlen /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1] /*.Len*/ /* length of next code */\n\n  var count = 0 /* repeat count of the current code */\n  var max_count = 7 /* max repeat count */\n  var min_count = 4 /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138\n    min_count = 3\n  }\n  tree[(max_code + 1) * 2 + 1] /*.Len*/ = 0xffff /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen\n    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/\n\n    if (++count < max_count && curlen === nextlen) {\n      continue\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2] /*.Freq*/ += count\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        s.bl_tree[curlen * 2] /*.Freq*/++\n      }\n      s.bl_tree[REP_3_6 * 2] /*.Freq*/++\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2] /*.Freq*/++\n    } else {\n      s.bl_tree[REPZ_11_138 * 2] /*.Freq*/++\n    }\n\n    count = 0\n    prevlen = curlen\n\n    if (nextlen === 0) {\n      max_count = 138\n      min_count = 3\n    } else if (curlen === nextlen) {\n      max_count = 6\n      min_count = 3\n    } else {\n      max_count = 7\n      min_count = 4\n    }\n  }\n}\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code) {\n  //    deflate_state *s;\n  //    ct_data *tree; /* the tree to be scanned */\n  //    int max_code;       /* and its largest code of non zero frequency */\n  var n /* iterates over all tree elements */\n  var prevlen = -1 /* last emitted length */\n  var curlen /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1] /*.Len*/ /* length of next code */\n\n  var count = 0 /* repeat count of the current code */\n  var max_count = 7 /* max repeat count */\n  var min_count = 4 /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */ /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138\n    min_count = 3\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen\n    nextlen = tree[(n + 1) * 2 + 1] /*.Len*/\n\n    if (++count < max_count && curlen === nextlen) {\n      continue\n    } else if (count < min_count) {\n      do {\n        send_code(s, curlen, s.bl_tree)\n      } while (--count !== 0)\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree)\n        count--\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree)\n      send_bits(s, count - 3, 2)\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree)\n      send_bits(s, count - 3, 3)\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree)\n      send_bits(s, count - 11, 7)\n    }\n\n    count = 0\n    prevlen = curlen\n    if (nextlen === 0) {\n      max_count = 138\n      min_count = 3\n    } else if (curlen === nextlen) {\n      max_count = 6\n      min_count = 3\n    } else {\n      max_count = 7\n      min_count = 4\n    }\n  }\n}\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code)\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code)\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc)\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1] /*.Len*/ !== 0) {\n      break\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex\n}\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes) {\n  //    deflate_state *s;\n  //    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n  var rank /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5) /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1, 5)\n  send_bits(s, blcodes - 4, 4) /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1] /*.Len*/, 3)\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1) /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1) /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f\n  var n\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if (black_mask & 1 && s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {\n      return Z_BINARY\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (\n    s.dyn_ltree[9 * 2] /*.Freq*/ !== 0 ||\n    s.dyn_ltree[10 * 2] /*.Freq*/ !== 0 ||\n    s.dyn_ltree[13 * 2] /*.Freq*/ !== 0\n  ) {\n    return Z_TEXT\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2] /*.Freq*/ !== 0) {\n      return Z_TEXT\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY\n}\n\nvar static_init_done = false\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nexport function _tr_init(s) {\n  if (!static_init_done) {\n    tr_static_init()\n    static_init_done = true\n  }\n\n  s.l_desc = new TreeDesc(s.dyn_ltree, static_l_desc)\n  s.d_desc = new TreeDesc(s.dyn_dtree, static_d_desc)\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc)\n\n  s.bi_buf = 0\n  s.bi_valid = 0\n\n  /* Initialize the first block of the first file: */\n  init_block(s)\n}\n\n/* ===========================================================================\n * Send a stored block\n */\nexport function _tr_stored_block(s, buf, stored_len, last) {\n  //DeflateState *s;\n  //charf *buf;       /* input block */\n  //ulg stored_len;   /* length of input block */\n  //int last;         /* one if this is the last block for a file */\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3) /* send block type */\n  copy_block(s, buf, stored_len, true) /* with header */\n}\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nexport function _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3)\n  send_code(s, END_BLOCK, static_ltree)\n  bi_flush(s)\n}\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nexport function _tr_flush_block(s, buf, stored_len, last) {\n  //DeflateState *s;\n  //charf *buf;       /* input block, or NULL if too old */\n  //ulg stored_len;   /* length of input block */\n  //int last;         /* one if this is the last block for a file */\n  var opt_lenb, static_lenb /* opt_len and static_len in bytes */\n  var max_blindex = 0 /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s)\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc)\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc)\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s)\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3\n    static_lenb = (s.static_len + 3 + 7) >>> 3\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) {\n      opt_lenb = static_lenb\n    }\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5 /* force a stored block */\n  }\n\n  if (stored_len + 4 <= opt_lenb && buf !== -1) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last)\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3)\n    compress_block(s, static_ltree, static_dtree)\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3)\n    send_all_trees(\n      s,\n      s.l_desc.max_code + 1,\n      s.d_desc.max_code + 1,\n      max_blindex + 1,\n    )\n    compress_block(s, s.dyn_ltree, s.dyn_dtree)\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s)\n\n  if (last) {\n    bi_windup(s)\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nexport function _tr_tally(s, dist, lc) {\n  //    deflate_state *s;\n  //    unsigned dist;  /* distance of matched string */\n  //    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2] = (dist >>> 8) & 0xff\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff\n  s.last_lit++\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2] /*.Freq*/++\n  } else {\n    s.matches++\n    /* Here, lc is the match length - MIN_MATCH */\n    dist-- /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2] /*.Freq*/++\n    s.dyn_dtree[d_code(dist) * 2] /*.Freq*/++\n  }\n\n  // (!) This block is disabled in zlib defaults,\n  // don't enable it for binary compatibility\n\n  //#ifdef TRUNCATE_BLOCK\n  //  /* Try to guess if it is profitable to stop the current block here */\n  //  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n  //    /* Compute an upper bound for the compressed length */\n  //    out_length = s.last_lit*8;\n  //    in_length = s.strstart - s.block_start;\n  //\n  //    for (dcode = 0; dcode < D_CODES; dcode++) {\n  //      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n  //    }\n  //    out_length >>>= 3;\n  //    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n  //    //       s->last_lit, in_length, out_length,\n  //    //       100L - out_length*100L/in_length));\n  //    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n  //      return true;\n  //    }\n  //  }\n  //#endif\n\n  return s.last_lit === s.lit_bufsize - 1\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n","// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nimport adler32 from './adler32.js'\nimport {\n  Z_BLOCK,\n  Z_BUF_ERROR,\n  Z_DATA_ERROR,\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED,\n  Z_FILTERED,\n  Z_FINISH,\n  Z_FIXED,\n  Z_FULL_FLUSH,\n  Z_HUFFMAN_ONLY,\n  Z_NO_FLUSH,\n  Z_OK,\n  Z_PARTIAL_FLUSH,\n  Z_RLE,\n  Z_STREAM_END,\n  Z_STREAM_ERROR,\n  Z_UNKNOWN,\n} from './constants.js'\nimport crc32 from './crc32.js'\nimport msg from './messages.js'\nimport {\n  _tr_align,\n  _tr_flush_block,\n  _tr_init,\n  _tr_stored_block,\n  _tr_tally,\n} from './trees.js'\nimport { Buf16, Buf8, arraySet } from '../utils/common.js'\n\nvar MAX_MEM_LEVEL = 9\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8\n\nvar LENGTH_CODES = 29\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS = 256\n/* number of literal bytes 0..255 */\nvar L_CODES = LITERALS + 1 + LENGTH_CODES\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES = 30\n/* number of distance codes */\nvar BL_CODES = 19\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE = 2 * L_CODES + 1\n/* maximum heap size */\nvar MAX_BITS = 15\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3\nvar MAX_MATCH = 258\nvar MIN_LOOKAHEAD = MAX_MATCH + MIN_MATCH + 1\n\nvar PRESET_DICT = 0x20\n\nvar INIT_STATE = 42\nvar EXTRA_STATE = 69\nvar NAME_STATE = 73\nvar COMMENT_STATE = 91\nvar HCRC_STATE = 103\nvar BUSY_STATE = 113\nvar FINISH_STATE = 666\n\nvar BS_NEED_MORE = 1 /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE = 2 /* block flush performed */\nvar BS_FINISH_STARTED = 3 /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE = 4 /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03 // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode]\n  return errorCode\n}\n\nfunction rank(f) {\n  return (f << 1) - (f > 4 ? 9 : 0)\n}\n\nfunction zero(buf) {\n  var len = buf.length\n  while (--len >= 0) {\n    buf[len] = 0\n  }\n}\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state\n\n  //_tr_flush_bits(s);\n  var len = s.pending\n  if (len > strm.avail_out) {\n    len = strm.avail_out\n  }\n  if (len === 0) {\n    return\n  }\n\n  arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out)\n  strm.next_out += len\n  s.pending_out += len\n  strm.total_out += len\n  strm.avail_out -= len\n  s.pending -= len\n  if (s.pending === 0) {\n    s.pending_out = 0\n  }\n}\n\nfunction flush_block_only(s, last) {\n  _tr_flush_block(\n    s,\n    s.block_start >= 0 ? s.block_start : -1,\n    s.strstart - s.block_start,\n    last,\n  )\n  s.block_start = s.strstart\n  flush_pending(s.strm)\n}\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b\n}\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n  //  put_byte(s, (Byte)(b >> 8));\n  //  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff\n  s.pending_buf[s.pending++] = b & 0xff\n}\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in\n\n  if (len > size) {\n    len = size\n  }\n  if (len === 0) {\n    return 0\n  }\n\n  strm.avail_in -= len\n\n  // zmemcpy(buf, strm->next_in, len);\n  arraySet(buf, strm.input, strm.next_in, len, start)\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start)\n  } else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start)\n  }\n\n  strm.next_in += len\n  strm.total_in += len\n\n  return len\n}\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length /* max hash chain length */\n  var scan = s.strstart /* current string */\n  var match /* matched string */\n  var len /* length of current match */\n  var best_len = s.prev_length /* best match length so far */\n  var nice_match = s.nice_match /* stop if match long enough */\n  var limit =\n    s.strstart > s.w_size - MIN_LOOKAHEAD\n      ? s.strstart - (s.w_size - MIN_LOOKAHEAD)\n      : 0 /*NIL*/\n\n  var _win = s.window // shortcut\n\n  var wmask = s.w_mask\n  var prev = s.prev\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH\n  var scan_end1 = _win[scan + best_len - 1]\n  var scan_end = _win[scan + best_len]\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) {\n    nice_match = s.lookahead\n  }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (\n      _win[match + best_len] !== scan_end ||\n      _win[match + best_len - 1] !== scan_end1 ||\n      _win[match] !== _win[scan] ||\n      _win[++match] !== _win[scan + 1]\n    ) {\n      continue\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2\n    match++\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      _win[++scan] === _win[++match] &&\n      scan < strend\n    )\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan)\n    scan = strend - MAX_MATCH\n\n    if (len > best_len) {\n      s.match_start = cur_match\n      best_len = len\n      if (len >= nice_match) {\n        break\n      }\n      scan_end1 = _win[scan + best_len - 1]\n      scan_end = _win[scan + best_len]\n    }\n  } while (\n    (cur_match = prev[cur_match & wmask]) > limit &&\n    --chain_length !== 0\n  )\n\n  if (best_len <= s.lookahead) {\n    return best_len\n  }\n  return s.lookahead\n}\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size\n  var p, n, m, more, str\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n      arraySet(s.window, s.window, _w_size, _w_size, 0)\n      s.match_start -= _w_size\n      s.strstart -= _w_size\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size\n      p = n\n      do {\n        m = s.head[--p]\n        s.head[p] = m >= _w_size ? m - _w_size : 0\n      } while (--n)\n\n      n = _w_size\n      p = n\n      do {\n        m = s.prev[--p]\n        s.prev[p] = m >= _w_size ? m - _w_size : 0\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n)\n\n      more += _w_size\n    }\n    if (s.strm.avail_in === 0) {\n      break\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more)\n    s.lookahead += n\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert\n      s.ins_h = s.window[str]\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask\n      //#if MIN_MATCH != 3\n      //        Call update_hash() MIN_MATCH-3 more times\n      //#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h =\n          ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) &\n          s.hash_mask\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h]\n        s.head[s.ins_h] = str\n        str++\n        s.insert--\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0)\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n  //  if (s.high_water < s.window_size) {\n  //    var curr = s.strstart + s.lookahead;\n  //    var init = 0;\n  //\n  //    if (s.high_water < curr) {\n  //      /* Previous high water mark below current data -- zero WIN_INIT\n  //       * bytes or up to end of window, whichever is less.\n  //       */\n  //      init = s.window_size - curr;\n  //      if (init > WIN_INIT)\n  //        init = WIN_INIT;\n  //      zmemzero(s->window + curr, (unsigned)init);\n  //      s->high_water = curr + init;\n  //    }\n  //    else if (s->high_water < (ulg)curr + WIN_INIT) {\n  //      /* High water mark at or above current data, but below current data\n  //       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n  //       * to end of window, whichever is less.\n  //       */\n  //      init = (ulg)curr + WIN_INIT - s->high_water;\n  //      if (init > s->window_size - s->high_water)\n  //        init = s->window_size - s->high_water;\n  //      zmemzero(s->window + s->high_water, (unsigned)init);\n  //      s->high_water += init;\n  //    }\n  //  }\n  //\n  //  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n  //    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n      //      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n      //        s.block_start >= s.w_size)) {\n      //        throw  new Error(\"slide too late\");\n      //      }\n\n      fill_window(s)\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE\n      }\n\n      if (s.lookahead === 0) {\n        break\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n    //    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead\n    s.lookahead = 0\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start\n      s.strstart = max_start\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false)\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= s.w_size - MIN_LOOKAHEAD) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false)\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true)\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n    return BS_FINISH_DONE\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false)\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head /* head of the hash chain */\n  var bflush /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s)\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE\n      }\n      if (s.lookahead === 0) {\n        break /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0 /*NIL*/\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h =\n        ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &\n        s.hash_mask\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n      s.head[s.ins_h] = s.strstart\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (\n      hash_head !== 0 /*NIL*/ &&\n      s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD\n    ) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head)\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(\n        s,\n        s.strstart - s.match_start,\n        s.match_length - MIN_MATCH,\n      )\n\n      s.lookahead -= s.match_length\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (\n        s.match_length <= s.max_lazy_match /*max_insert_length*/ &&\n        s.lookahead >= MIN_MATCH\n      ) {\n        s.match_length-- /* string at strstart already in table */\n        do {\n          s.strstart++\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h =\n            ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &\n            s.hash_mask\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = s.strstart\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0)\n        s.strstart++\n      } else {\n        s.strstart += s.match_length\n        s.match_length = 0\n        s.ins_h = s.window[s.strstart]\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h =\n          ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask\n\n        //#if MIN_MATCH != 3\n        //                Call UPDATE_HASH() MIN_MATCH-3 more times\n        //#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart])\n\n      s.lookahead--\n      s.strstart++\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false)\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true)\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n    return BS_FINISH_DONE\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false)\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head /* head of hash chain */\n  var bflush /* set if current block must be flushed */\n\n  var max_insert\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s)\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE\n      }\n      if (s.lookahead === 0) {\n        break\n      } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0 /*NIL*/\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h =\n        ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &\n        s.hash_mask\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n      s.head[s.ins_h] = s.strstart\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length\n    s.prev_match = s.match_start\n    s.match_length = MIN_MATCH - 1\n\n    if (\n      hash_head !== 0 /*NIL*/ &&\n      s.prev_length < s.max_lazy_match &&\n      s.strstart - hash_head <= s.w_size - MIN_LOOKAHEAD /*MAX_DIST(s)*/\n    ) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head)\n      /* longest_match() sets match_start */\n\n      if (\n        s.match_length <= 5 &&\n        (s.strategy === Z_FILTERED ||\n          (s.match_length === MIN_MATCH &&\n            s.strstart - s.match_start > 4096)) /*TOO_FAR*/\n      ) {\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = _tr_tally(\n        s,\n        s.strstart - 1 - s.prev_match,\n        s.prev_length - MIN_MATCH,\n      )\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1\n      s.prev_length -= 2\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h =\n            ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) &\n            s.hash_mask\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h]\n          s.head[s.ins_h] = s.strstart\n          /***/\n        }\n      } while (--s.prev_length !== 0)\n      s.match_available = 0\n      s.match_length = MIN_MATCH - 1\n      s.strstart++\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false)\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE\n        }\n        /***/\n      }\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart - 1])\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false)\n        /***/\n      }\n      s.strstart++\n      s.lookahead--\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1\n      s.strstart++\n      s.lookahead--\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart - 1])\n\n    s.match_available = 0\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true)\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n    return BS_FINISH_DONE\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false)\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE\n}\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush /* set if current block must be flushed */\n  var prev /* byte at distance one to match */\n  var scan, strend /* scan goes up to strend for length of run */\n\n  var _win = s.window\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s)\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE\n      }\n      if (s.lookahead === 0) {\n        break\n      } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1\n      prev = _win[scan]\n      if (\n        prev === _win[++scan] &&\n        prev === _win[++scan] &&\n        prev === _win[++scan]\n      ) {\n        strend = s.strstart + MAX_MATCH\n        do {\n          /*jshint noempty:false*/\n        } while (\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          prev === _win[++scan] &&\n          scan < strend\n        )\n        s.match_length = MAX_MATCH - (strend - scan)\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = _tr_tally(s, 1, s.match_length - MIN_MATCH)\n\n      s.lookahead -= s.match_length\n      s.strstart += s.match_length\n      s.match_length = 0\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = _tr_tally(s, 0, s.window[s.strstart])\n\n      s.lookahead--\n      s.strstart++\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false)\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n  }\n  s.insert = 0\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true)\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n    return BS_FINISH_DONE\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false)\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s)\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE\n        }\n        break /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = _tr_tally(s, 0, s.window[s.strstart])\n    s.lookahead--\n    s.strstart++\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false)\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE\n      }\n      /***/\n    }\n  }\n  s.insert = 0\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true)\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED\n    }\n    /***/\n    return BS_FINISH_DONE\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false)\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length\n  this.max_lazy = max_lazy\n  this.nice_length = nice_length\n  this.max_chain = max_chain\n  this.func = func\n}\n\nlet configurationTable = function () {\n  const table = [\n    /*      good lazy nice chain */\n    new Config(0, 0, 0, 0, deflate_stored) /* 0 store only */,\n    new Config(4, 4, 8, 4, deflate_fast) /* 1 max speed, no lazy matches */,\n    new Config(4, 5, 16, 8, deflate_fast) /* 2 */,\n    new Config(4, 6, 32, 32, deflate_fast) /* 3 */,\n\n    new Config(4, 4, 16, 16, deflate_slow) /* 4 lazy matches */,\n    new Config(8, 16, 32, 32, deflate_slow) /* 5 */,\n    new Config(8, 16, 128, 128, deflate_slow) /* 6 */,\n    new Config(8, 32, 128, 256, deflate_slow) /* 7 */,\n    new Config(32, 128, 258, 1024, deflate_slow) /* 8 */,\n    new Config(32, 258, 258, 4096, deflate_slow) /* 9 max compression */,\n  ]\n\n  configurationTable = () => table\n  return table\n}\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head) // Fill with NIL (= 0);\n\n  const table = configurationTable()\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = table[s.level].max_lazy\n  s.good_match = table[s.level].good_length\n  s.nice_match = table[s.level].nice_length\n  s.max_chain_length = table[s.level].max_chain\n\n  s.strstart = 0\n  s.block_start = 0\n  s.lookahead = 0\n  s.insert = 0\n  s.match_length = s.prev_length = MIN_MATCH - 1\n  s.match_available = 0\n  s.ins_h = 0\n}\n\nfunction DeflateState() {\n  this.strm = null /* pointer back to this zlib stream */\n  this.status = 0 /* as the name implies */\n  this.pending_buf = null /* output still pending */\n  this.pending_buf_size = 0 /* size of pending_buf */\n  this.pending_out = 0 /* next pending byte to output to the stream */\n  this.pending = 0 /* nb of bytes in the pending buffer */\n  this.wrap = 0 /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null /* gzip header information to write */\n  this.gzindex = 0 /* where in extra, name, or comment */\n  this.method = Z_DEFLATED /* can only be DEFLATED */\n  this.last_flush = -1 /* value of flush param for previous deflate call */\n\n  this.w_size = 0 /* LZ77 window size (32K by default) */\n  this.w_bits = 0 /* log2(w_size)  (8..16) */\n  this.w_mask = 0 /* w_size - 1 */\n\n  this.window = null\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0 /* hash index of string to be inserted */\n  this.hash_size = 0 /* number of elements in hash table */\n  this.hash_bits = 0 /* log2(hash_size) */\n  this.hash_mask = 0 /* hash_size-1 */\n\n  this.hash_shift = 0\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0 /* length of best match */\n  this.prev_match = 0 /* previous match */\n  this.match_available = 0 /* set if previous match exists */\n  this.strstart = 0 /* start of string to insert */\n  this.match_start = 0 /* start of matching string */\n  this.lookahead = 0 /* number of valid bytes ahead in window */\n\n  this.prev_length = 0\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0 /* compression level (1..9) */\n  this.strategy = 0 /* favor or force Huffman coding*/\n\n  this.good_match = 0\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0 /* Stop searching when current match exceeds this */\n\n  /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree = Buf16(HEAP_SIZE * 2)\n  this.dyn_dtree = Buf16((2 * D_CODES + 1) * 2)\n  this.bl_tree = Buf16((2 * BL_CODES + 1) * 2)\n  zero(this.dyn_ltree)\n  zero(this.dyn_dtree)\n  zero(this.bl_tree)\n\n  this.l_desc = null /* desc. for literal tree */\n  this.d_desc = null /* desc. for distance tree */\n  this.bl_desc = null /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = Buf16(MAX_BITS + 1)\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = Buf16(2 * L_CODES + 1) /* heap used to build the Huffman trees */\n  zero(this.heap)\n\n  this.heap_len = 0 /* number of elements in the heap */\n  this.heap_max = 0 /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = Buf16(2 * L_CODES + 1) //uch depth[2*L_CODES+1];\n  zero(this.depth)\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0 /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0 /* running index in l_buf */\n\n  this.d_buf = 0\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0 /* bit length of current block with optimal trees */\n  this.static_len = 0 /* bit length of current block with static trees */\n  this.matches = 0 /* number of string matches in current block */\n  this.insert = 0 /* bytes at end of window left to insert */\n\n  this.bi_buf = 0\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\nexport function deflateResetKeep(strm) {\n  var s\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR)\n  }\n\n  strm.total_in = strm.total_out = 0\n  strm.data_type = Z_UNKNOWN\n\n  s = strm.state\n  s.pending = 0\n  s.pending_out = 0\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = s.wrap ? INIT_STATE : BUSY_STATE\n  strm.adler =\n    s.wrap === 2\n      ? 0 // crc32(0, Z_NULL, 0)\n      : 1 // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH\n  _tr_init(s)\n  return Z_OK\n}\n\nexport function deflateReset(strm) {\n  var ret = deflateResetKeep(strm)\n  if (ret === Z_OK) {\n    lm_init(strm.state)\n  }\n  return ret\n}\n\nexport function deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) {\n    return Z_STREAM_ERROR\n  }\n  if (strm.state.wrap !== 2) {\n    return Z_STREAM_ERROR\n  }\n  strm.state.gzhead = head\n  return Z_OK\n}\n\nexport function deflateInit2(\n  strm,\n  level,\n  method,\n  windowBits,\n  memLevel,\n  strategy,\n) {\n  if (!strm) {\n    // === Z_NULL\n    return Z_STREAM_ERROR\n  }\n  var wrap = 1\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6\n  }\n\n  if (windowBits < 0) {\n    /* suppress zlib wrapper */\n    wrap = 0\n    windowBits = -windowBits\n  } else if (windowBits > 15) {\n    wrap = 2 /* write gzip wrapper instead */\n    windowBits -= 16\n  }\n\n  if (\n    memLevel < 1 ||\n    memLevel > MAX_MEM_LEVEL ||\n    method !== Z_DEFLATED ||\n    windowBits < 8 ||\n    windowBits > 15 ||\n    level < 0 ||\n    level > 9 ||\n    strategy < 0 ||\n    strategy > Z_FIXED\n  ) {\n    return err(strm, Z_STREAM_ERROR)\n  }\n\n  if (windowBits === 8) {\n    windowBits = 9\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState()\n\n  strm.state = s\n  s.strm = strm\n\n  s.wrap = wrap\n  s.gzhead = null\n  s.w_bits = windowBits\n  s.w_size = 1 << s.w_bits\n  s.w_mask = s.w_size - 1\n\n  s.hash_bits = memLevel + 7\n  s.hash_size = 1 << s.hash_bits\n  s.hash_mask = s.hash_size - 1\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH)\n\n  s.window = Buf8(s.w_size * 2)\n  s.head = Buf16(s.hash_size)\n  s.prev = Buf16(s.w_size)\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6) /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = Buf8(s.pending_buf_size)\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize\n\n  s.level = level\n  s.strategy = strategy\n  s.method = method\n\n  return deflateReset(strm)\n}\n\nexport function deflateInit(strm, level) {\n  return deflateInit2(\n    strm,\n    level,\n    Z_DEFLATED,\n    MAX_WBITS,\n    DEF_MEM_LEVEL,\n    Z_DEFAULT_STRATEGY,\n  )\n}\n\nexport function deflate(strm, flush) {\n  var old_flush, s\n  var beg, val // for gzip header write only\n\n  if (!strm || !strm.state || flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR\n  }\n\n  s = strm.state\n\n  if (\n    !strm.output ||\n    (!strm.input && strm.avail_in !== 0) ||\n    (s.status === FINISH_STATE && flush !== Z_FINISH)\n  ) {\n    return err(strm, strm.avail_out === 0 ? Z_BUF_ERROR : Z_STREAM_ERROR)\n  }\n\n  s.strm = strm /* just in case */\n  old_flush = s.last_flush\n  s.last_flush = flush\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n    if (s.wrap === 2) {\n      // GZIP header\n      strm.adler = 0 //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31)\n      put_byte(s, 139)\n      put_byte(s, 8)\n      if (!s.gzhead) {\n        // s->gzhead == Z_NULL\n        put_byte(s, 0)\n        put_byte(s, 0)\n        put_byte(s, 0)\n        put_byte(s, 0)\n        put_byte(s, 0)\n        put_byte(\n          s,\n          s.level === 9\n            ? 2\n            : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2\n              ? 4\n              : 0,\n        )\n        put_byte(s, OS_CODE)\n        s.status = BUSY_STATE\n      } else {\n        put_byte(\n          s,\n          (s.gzhead.text ? 1 : 0) +\n            (s.gzhead.hcrc ? 2 : 0) +\n            (!s.gzhead.extra ? 0 : 4) +\n            (!s.gzhead.name ? 0 : 8) +\n            (!s.gzhead.comment ? 0 : 16),\n        )\n        put_byte(s, s.gzhead.time & 0xff)\n        put_byte(s, (s.gzhead.time >> 8) & 0xff)\n        put_byte(s, (s.gzhead.time >> 16) & 0xff)\n        put_byte(s, (s.gzhead.time >> 24) & 0xff)\n        put_byte(\n          s,\n          s.level === 9\n            ? 2\n            : s.strategy >= Z_HUFFMAN_ONLY || s.level < 2\n              ? 4\n              : 0,\n        )\n        put_byte(s, s.gzhead.os & 0xff)\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff)\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff)\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0)\n        }\n        s.gzindex = 0\n        s.status = EXTRA_STATE\n      }\n    } // DEFLATE header\n    else {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8\n      var level_flags = -1\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0\n      } else if (s.level < 6) {\n        level_flags = 1\n      } else if (s.level === 6) {\n        level_flags = 2\n      } else {\n        level_flags = 3\n      }\n      header |= level_flags << 6\n      if (s.strstart !== 0) {\n        header |= PRESET_DICT\n      }\n      header += 31 - (header % 31)\n\n      s.status = BUSY_STATE\n      putShortMSB(s, header)\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16)\n        putShortMSB(s, strm.adler & 0xffff)\n      }\n      strm.adler = 1 // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n  //#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra /* != Z_NULL*/) {\n      beg = s.pending /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n          flush_pending(strm)\n          beg = s.pending\n          if (s.pending === s.pending_buf_size) {\n            break\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff)\n        s.gzindex++\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0\n        s.status = NAME_STATE\n      }\n    } else {\n      s.status = NAME_STATE\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name /* != Z_NULL*/) {\n      beg = s.pending /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n          flush_pending(strm)\n          beg = s.pending\n          if (s.pending === s.pending_buf_size) {\n            val = 1\n            break\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff\n        } else {\n          val = 0\n        }\n        put_byte(s, val)\n      } while (val !== 0)\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)\n      }\n      if (val === 0) {\n        s.gzindex = 0\n        s.status = COMMENT_STATE\n      }\n    } else {\n      s.status = COMMENT_STATE\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment /* != Z_NULL*/) {\n      beg = s.pending /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)\n          }\n          flush_pending(strm)\n          beg = s.pending\n          if (s.pending === s.pending_buf_size) {\n            val = 1\n            break\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff\n        } else {\n          val = 0\n        }\n        put_byte(s, val)\n      } while (val !== 0)\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg)\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE\n      }\n    } else {\n      s.status = HCRC_STATE\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm)\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff)\n        put_byte(s, (strm.adler >> 8) & 0xff)\n        strm.adler = 0 //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE\n      }\n    } else {\n      s.status = BUSY_STATE\n    }\n  }\n  //#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm)\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1\n      return Z_OK\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (\n    strm.avail_in === 0 &&\n    rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH\n  ) {\n    return err(strm, Z_BUF_ERROR)\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR)\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (\n    strm.avail_in !== 0 ||\n    s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)\n  ) {\n    var bstate =\n      s.strategy === Z_HUFFMAN_ONLY\n        ? deflate_huff(s, flush)\n        : s.strategy === Z_RLE\n          ? deflate_rle(s, flush)\n          : configurationTable()[s.level].func(s, flush)\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        _tr_align(s)\n      } else if (flush !== Z_BLOCK) {\n        /* FULL_FLUSH or SYNC_FLUSH */\n\n        _tr_stored_block(s, 0, 0, false)\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/ /* forget history */\n          zero(s.head) // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0\n            s.block_start = 0\n            s.insert = 0\n          }\n        }\n      }\n      flush_pending(strm)\n      if (strm.avail_out === 0) {\n        s.last_flush = -1 /* avoid BUF_ERROR at next call, see above */\n        return Z_OK\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) {\n    return Z_OK\n  }\n  if (s.wrap <= 0) {\n    return Z_STREAM_END\n  }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff)\n    put_byte(s, (strm.adler >> 8) & 0xff)\n    put_byte(s, (strm.adler >> 16) & 0xff)\n    put_byte(s, (strm.adler >> 24) & 0xff)\n    put_byte(s, strm.total_in & 0xff)\n    put_byte(s, (strm.total_in >> 8) & 0xff)\n    put_byte(s, (strm.total_in >> 16) & 0xff)\n    put_byte(s, (strm.total_in >> 24) & 0xff)\n  } else {\n    putShortMSB(s, strm.adler >>> 16)\n    putShortMSB(s, strm.adler & 0xffff)\n  }\n\n  flush_pending(strm)\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) {\n    s.wrap = -s.wrap\n  }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END\n}\n\nexport function deflateEnd(strm) {\n  var status\n\n  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {\n    return Z_STREAM_ERROR\n  }\n\n  status = strm.state.status\n  if (\n    status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR)\n  }\n\n  strm.state = null\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK\n}\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nexport function deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length\n\n  var s\n  var str, n\n  var wrap\n  var avail\n  var next\n  var input\n  var tmpDict\n\n  if (!strm /*== Z_NULL*/ || !strm.state /*== Z_NULL*/) {\n    return Z_STREAM_ERROR\n  }\n\n  s = strm.state\n  wrap = s.wrap\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0)\n  }\n\n  s.wrap = 0 /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {\n      /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head) // Fill with NIL (= 0);\n      s.strstart = 0\n      s.block_start = 0\n      s.insert = 0\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = Buf8(s.w_size)\n    arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0)\n    dictionary = tmpDict\n    dictLength = s.w_size\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in\n  next = strm.next_in\n  input = strm.input\n  strm.avail_in = dictLength\n  strm.next_in = 0\n  strm.input = dictionary\n  fill_window(s)\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart\n    n = s.lookahead - (MIN_MATCH - 1)\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h =\n        ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) &\n        s.hash_mask\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h]\n\n      s.head[s.ins_h] = str\n      str++\n    } while (--n)\n    s.strstart = str\n    s.lookahead = MIN_MATCH - 1\n    fill_window(s)\n  }\n  s.strstart += s.lookahead\n  s.block_start = s.strstart\n  s.insert = s.lookahead\n  s.lookahead = 0\n  s.match_length = s.prev_length = MIN_MATCH - 1\n  s.match_available = 0\n  strm.next_in = next\n  strm.input = input\n  strm.avail_in = avail\n  s.wrap = wrap\n  return Z_OK\n}\n\nexport var deflateInfo = 'pako deflate (from Nodeca project)'\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n","import { Buf8, assign, flattenChunks, shrinkBuf } from './utils/common.js'\nimport { buf2binstring, string2buf } from './utils/strings.js'\nimport {\n  Z_DEFAULT_COMPRESSION,\n  Z_DEFAULT_STRATEGY,\n  Z_DEFLATED,\n  Z_FINISH,\n  Z_NO_FLUSH,\n  Z_OK,\n  Z_STREAM_END,\n  Z_SYNC_FLUSH,\n} from './zlib/constants.js'\nimport {\n  deflate as zlibDeflate,\n  deflateEnd,\n  deflateInit2,\n  deflateSetDictionary,\n  deflateSetHeader,\n} from './zlib/deflate.js'\nimport msg from './zlib/messages.js'\nimport ZStream from './zlib/zstream.js'\n\nvar toString = Object.prototype.toString\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overridden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nexport class Deflate {\n  constructor(options) {\n    this.options = assign(\n      {\n        level: Z_DEFAULT_COMPRESSION,\n        method: Z_DEFLATED,\n        chunkSize: 16384,\n        windowBits: 15,\n        memLevel: 8,\n        strategy: Z_DEFAULT_STRATEGY,\n        to: '',\n      },\n      options || {},\n    )\n\n    var opt = this.options\n\n    if (opt.raw && opt.windowBits > 0) {\n      opt.windowBits = -opt.windowBits\n    } else if (opt.gzip && opt.windowBits > 0 && opt.windowBits < 16) {\n      opt.windowBits += 16\n    }\n\n    this.err = 0 // error code, if happens (0 = Z_OK)\n    this.msg = '' // error message\n    this.ended = false // used to avoid multiple onEnd() calls\n    this.chunks = [] // chunks of compressed data\n\n    this.strm = new ZStream()\n    this.strm.avail_out = 0\n\n    var status = deflateInit2(\n      this.strm,\n      opt.level,\n      opt.method,\n      opt.windowBits,\n      opt.memLevel,\n      opt.strategy,\n    )\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status])\n    }\n\n    if (opt.header) {\n      deflateSetHeader(this.strm, opt.header)\n    }\n\n    if (opt.dictionary) {\n      var dict\n      // Convert data if needed\n      if (typeof opt.dictionary === 'string') {\n        // If we need to compress text, change encoding to utf8.\n        dict = string2buf(opt.dictionary)\n      } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(opt.dictionary)\n      } else {\n        dict = opt.dictionary\n      }\n\n      status = deflateSetDictionary(this.strm, dict)\n\n      if (status !== Z_OK) {\n        throw new Error(msg[status])\n      }\n\n      this._dict_set = true\n    }\n  }\n\n  /**\n   * Deflate#push(data[, mode]) -> Boolean\n   * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n   *   converted to utf8 byte sequence.\n   * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n   *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` means Z_FINISH.\n   *\n   * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n   * new compressed chunks. Returns `true` on success. The last data block must have\n   * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n   * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n   * can use mode Z_SYNC_FLUSH, keeping the compression context.\n   *\n   * On fail call [[Deflate#onEnd]] with error code and return false.\n   *\n   * We strongly recommend to use `Uint8Array` on input for best speed (output\n   * array format is detected automatically). Also, don't skip last param and always\n   * use the same type in your code (boolean or number). That will improve JS speed.\n   *\n   * For regular `Array`-s make sure all elements are [0..255].\n   *\n   * ##### Example\n   *\n   * ```javascript\n   * push(chunk, false); // push one of data chunks\n   * ...\n   * push(chunk, true);  // push last chunk\n   * ```\n   **/\n  push(data, mode) {\n    var strm = this.strm\n    var chunkSize = this.options.chunkSize\n    var status, _mode\n\n    if (this.ended) {\n      return false\n    }\n\n    _mode = mode === ~~mode ? mode : mode === true ? Z_FINISH : Z_NO_FLUSH\n\n    // Convert data if needed\n    if (typeof data === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      strm.input = string2buf(data)\n    } else if (toString.call(data) === '[object ArrayBuffer]') {\n      strm.input = new Uint8Array(data)\n    } else {\n      strm.input = data\n    }\n\n    strm.next_in = 0\n    strm.avail_in = strm.input.length\n\n    do {\n      if (strm.avail_out === 0) {\n        strm.output = Buf8(chunkSize)\n        strm.next_out = 0\n        strm.avail_out = chunkSize\n      }\n      status = zlibDeflate(strm, _mode) /* no bad return value */\n\n      if (status !== Z_STREAM_END && status !== Z_OK) {\n        this.onEnd(status)\n        this.ended = true\n        return false\n      }\n      if (\n        strm.avail_out === 0 ||\n        (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))\n      ) {\n        if (this.options.to === 'string') {\n          this.onData(buf2binstring(shrinkBuf(strm.output, strm.next_out)))\n        } else {\n          this.onData(shrinkBuf(strm.output, strm.next_out))\n        }\n      }\n    } while (\n      (strm.avail_in > 0 || strm.avail_out === 0) &&\n      status !== Z_STREAM_END\n    )\n\n    // Finalize on the last chunk.\n    if (_mode === Z_FINISH) {\n      status = deflateEnd(this.strm)\n      this.onEnd(status)\n      this.ended = true\n      return status === Z_OK\n    }\n\n    // callback interim results if Z_SYNC_FLUSH.\n    if (_mode === Z_SYNC_FLUSH) {\n      this.onEnd(Z_OK)\n      strm.avail_out = 0\n      return true\n    }\n\n    return true\n  }\n\n  /**\n   * Deflate#onData(chunk) -> Void\n   * - chunk (Uint8Array|Array|String): output data. Type of array depends\n   *   on js engine support. When string output requested, each chunk\n   *   will be string.\n   *\n   * By default, stores data blocks in `chunks[]` property and glue\n   * those in `onEnd`. Override this handler, if you need another behaviour.\n   **/\n  onData(chunk) {\n    this.chunks.push(chunk)\n  }\n\n  /**\n   * Deflate#onEnd(status) -> Void\n   * - status (Number): deflate status. 0 (Z_OK) on success,\n   *   other if not.\n   *\n   * Called once after you tell deflate that the input stream is\n   * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n   * or if an error happened. By default - join collected chunks,\n   * free memory and fill `results` / `err` properties.\n   **/\n  onEnd(status) {\n    // On success - join\n    if (status === Z_OK) {\n      if (this.options.to === 'string') {\n        this.result = this.chunks.join('')\n      } else {\n        this.result = flattenChunks(this.chunks)\n      }\n    }\n    this.chunks = []\n    this.err = status\n    this.msg = this.strm.msg\n  }\n}\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nexport function deflate(input, options) {\n  var deflator = new Deflate(options)\n\n  deflator.push(input, true)\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) {\n    throw deflator.msg || msg[deflator.err]\n  }\n\n  return deflator.result\n}\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nexport function deflateRaw(input, options) {\n  options = options || {}\n  options.raw = true\n  return deflate(input, options)\n}\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nexport function gzip(input, options) {\n  options = options || {}\n  options.gzip = true\n  return deflate(input, options)\n}\n"],"names":["zero","buf","len","length","static_ltree","static_dtree","_dist_code","_length_code","base_length","base_dist","static_l_desc","static_d_desc","static_bl_desc","extra_lbits","extra_dbits","extra_blbits","bl_order","StaticTreeDesc","static_tree","extra_bits","extra_base","elems","max_length","this","has_stree","TreeDesc","dyn_tree","stat_desc","max_code","d_code","dist","put_short","s","w","pending_buf","pending","send_bits","value","bi_valid","bi_buf","send_code","c","tree","bi_reverse","code","res","gen_codes","bl_count","bits","n","next_code","Array","MAX_BITS","init_block","LITERALS","dyn_ltree","dyn_dtree","bl_tree","END_BLOCK","opt_len","static_len","last_lit","matches","bi_windup","smaller","m","depth","_n2","_m2","pqdownheap","k","v","heap","j","heap_len","compress_block","ltree","dtree","lc","extra","lx","d_buf","l_buf","build_tree","desc","node","stree","heap_max","h","xbits","f","base","overflow","gen_bitlen","scan_tree","curlen","prevlen","nextlen","count","max_count","min_count","REP_3_6","REPZ_3_10","REPZ_11_138","send_tree","static_init_done","_tr_stored_block","stored_len","last","arraySet","window","copy_block","_tr_tally","lit_bufsize","MAX_MATCH","MIN_LOOKAHEAD","HCRC_STATE","BUSY_STATE","FINISH_STATE","err","strm","errorCode","msg","rank","flush_pending","state","avail_out","output","pending_out","next_out","total_out","flush_block_only","opt_lenb","static_lenb","max_blindex","level","data_type","Z_UNKNOWN","black_mask","Z_BINARY","Z_TEXT","detect_data_type","l_desc","d_desc","bl_desc","BL_CODES","build_bl_tree","strategy","Z_FIXED","lcodes","dcodes","blcodes","send_all_trees","_tr_flush_block","block_start","strstart","put_byte","b","putShortMSB","read_buf","start","size","avail_in","input","next_in","wrap","adler","adler32","crc32","total_in","longest_match","cur_match","match","chain_length","max_chain_length","scan","best_len","prev_length","nice_match","limit","w_size","_win","wmask","w_mask","prev","strend","scan_end1","scan_end","good_match","lookahead","match_start","fill_window","p","more","str","_w_size","window_size","hash_size","head","insert","ins_h","hash_shift","hash_mask","deflate_stored","flush","max_block_size","pending_buf_size","Z_NO_FLUSH","max_start","Z_FINISH","deflate_fast","hash_head","bflush","match_length","max_lazy_match","MIN_MATCH","deflate_slow","max_insert","prev_match","Z_FILTERED","match_available","Config","good_length","max_lazy","nice_length","max_chain","func","configurationTable","table","DeflateState","status","gzhead","gzindex","method","Z_DEFLATED","last_flush","w_bits","hash_bits","Buf16","HEAP_SIZE","deflateReset","ret","D_CODES","LENGTH_CODES","L_CODES","tr_static_init","_tr_init","Z_OK","Z_STREAM_ERROR","deflateResetKeep","lm_init","deflate","old_flush","beg","val","Z_BLOCK","Z_BUF_ERROR","text","hcrc","name","comment","time","Z_HUFFMAN_ONLY","os","header","charCodeAt","bstate","deflate_huff","Z_RLE","deflate_rle","Z_PARTIAL_FLUSH","STATIC_TREES","bi_flush","_tr_align","Z_FULL_FLUSH","Z_STREAM_END","toString","Object","prototype","Deflate","constructor","options","assign","Z_DEFAULT_COMPRESSION","chunkSize","windowBits","memLevel","Z_DEFAULT_STRATEGY","to","opt","raw","gzip","ended","chunks","ZStream","Buf8","deflateInit2","Error","dictionary","dict","string2buf","call","Uint8Array","avail","next","tmpDict","dictLength","deflateSetDictionary","_dict_set","push","data","mode","_mode","zlibDeflate","onEnd","Z_SYNC_FLUSH","onData","buf2binstring","shrinkBuf","Z_DATA_ERROR","deflateEnd","chunk","result","join","flattenChunks","deflator"],"ignoreList":[],"sourceRoot":""}