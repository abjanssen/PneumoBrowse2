{"version":3,"file":"static/js/5980.8fff0cdb.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/generateRepeatMaskerFeature.ts","../../../plugins/bed/src/generateUcscTranscript.ts","../../../plugins/bed/src/util.ts","../../../plugins/bed/src/generateBedMethylFeature.ts","../../../plugins/bed/src/BedTabixAdapter/BedTabixAdapter.ts"],"sourcesContent":["export function isRepeatMaskerDescriptionField(desc?: string): desc is string {\n  const ret = desc?.trim().split(' ')\n  return [0, 1, 2, 3, 5, 6].every(s =>\n    ret?.[s] !== undefined ? !Number.isNaN(+ret[s]) : false,\n  )\n}\n\nfunction makeRepeatTrackDescription(description?: string) {\n  if (isRepeatMaskerDescriptionField(description)) {\n    const [\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    ] = description.trim().split(' ')\n    return {\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    }\n  }\n  return { description }\n}\n\nexport function generateRepeatMaskerFeature({\n  uniqueId,\n  refName,\n  start,\n  end,\n  description,\n  ...rest\n}: {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  description: string\n  [key: string]: unknown\n}) {\n  const { subfeatures, ...rest2 } = rest\n  return {\n    ...rest2,\n    ...makeRepeatTrackDescription(description),\n    uniqueId,\n    refName,\n    start,\n    end,\n  }\n}\n","import type { MinimalFeature } from './types.ts'\n\nexport function isUcscTranscript({\n  thickStart,\n  blockCount,\n  strand,\n}: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return thickStart && blockCount && strand !== 0\n}\n\n/**\n * Calculate phase for each CDS based on cumulative widths.\n * Phase = (3 - cumulative_cds_width % 3) % 3\n * CDS must be in transcriptional order (5' to 3')\n */\nfunction calculatePhasesFromCds(\n  cdsRegions: { start: number; end: number }[],\n  strand: number,\n) {\n  // Sort in transcriptional order: ascending for +strand, descending for -strand\n  const sorted = [...cdsRegions].sort((a, b) =>\n    strand > 0 ? a.start - b.start : b.start - a.start,\n  )\n\n  const phaseMap = new Map<number, number>()\n  let cumulativeWidth = 0\n\n  for (const cds of sorted) {\n    // Phase is how many bases at the START of this CDS complete the previous codon\n    const phase = (3 - (cumulativeWidth % 3)) % 3\n    phaseMap.set(cds.start, phase)\n    cumulativeWidth += cds.end - cds.start\n  }\n\n  return phaseMap\n}\n\n/**\n * Convert UCSC exonFrames (reading frame 0,1,2) to GFF phase (bases to skip 0,1,2)\n * Frame 0 → phase 0 (first base at codon position 0, skip 0)\n * Frame 1 → phase 2 (first base at codon position 1, skip 2 to next codon)\n * Frame 2 → phase 1 (first base at codon position 2, skip 1 to next codon)\n */\nfunction frameToPhase(frame: number) {\n  return (3 - frame) % 3\n}\n\ninterface UcscTranscriptInput {\n  uniqueId: string\n  strand?: number\n  thickStart: number\n  thickEnd: number\n  refName: string\n  start: number\n  end: number\n  subfeatures: MinimalFeature[]\n  [key: string]: unknown\n}\n\ninterface UcscTranscriptOutput {\n  uniqueId: string\n  strand: number\n  type: string\n  refName: string\n  start: number\n  end: number\n  subfeatures: MinimalFeature[]\n  [key: string]: unknown\n}\n\nexport function generateUcscTranscript(\n  data: UcscTranscriptInput,\n): UcscTranscriptOutput {\n  const { strand = 0, uniqueId, start, end, ...rest } = data\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    refName,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    chromStarts: _4,\n    blockStarts: _5,\n    blockSizes: _6,\n    blockCount: _7,\n    ...rest2\n  } = rest\n\n  // exonFrames from bigGenePred - the @gmod/bed parser returns it in genomic order\n  const exonFrames = (rest2.exonFrames ?? rest2._exonFrames) as\n    | number[]\n    | undefined\n\n  const feats = oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n\n  const fiveUTR = strand > 0 ? 'five_prime_UTR' : 'three_prime_UTR'\n  const threeUTR = strand > 0 ? 'three_prime_UTR' : 'five_prime_UTR'\n\n  const { cdsEndStat, cdsStartStat } = rest2\n  if (cdsStartStat === 'none' && cdsEndStat === 'none') {\n    return {\n      ...rest2,\n      uniqueId,\n      strand,\n      type: 'transcript',\n      refName,\n      start,\n      end,\n      subfeatures: feats.map(e => ({ ...e, type: 'exon' })),\n    }\n  }\n\n  // If exonFrames not available, calculate phases from CDS regions\n  let calculatedPhases: Map<number, number> | undefined\n  if (!exonFrames) {\n    const cdsRegions: { start: number; end: number }[] = []\n    for (const block of feats) {\n      const { start, end } = block\n      if (thickStart < end && thickEnd > start) {\n        cdsRegions.push({\n          start: Math.max(start, thickStart),\n          end: Math.min(end, thickEnd),\n        })\n      }\n    }\n    calculatedPhases = calculatePhasesFromCds(cdsRegions, strand)\n  }\n\n  const subfeatures: MinimalFeature[] = []\n  for (const [i, feat] of feats.entries()) {\n    const block = feat\n    const { start, end } = block\n\n    if (thickStart >= end) {\n      // entire block is 5' UTR\n      subfeatures.push({ type: fiveUTR, start, end, refName })\n    } else if (thickEnd <= start) {\n      // entire block is 3' UTR\n      subfeatures.push({ type: threeUTR, start, end, refName })\n    } else {\n      // block overlaps CDS region - may have UTR on either side\n      if (start < thickStart) {\n        subfeatures.push({ type: fiveUTR, start, end: thickStart, refName })\n      }\n\n      const cdsStart = Math.max(start, thickStart)\n      const cdsEnd = Math.min(end, thickEnd)\n\n      // Get phase from exonFrames (with conversion) or calculated phases\n      let phase = 0\n      if (exonFrames) {\n        const frame = exonFrames[i]\n        if (frame !== undefined && frame >= 0) {\n          phase = frameToPhase(frame)\n        }\n      } else if (calculatedPhases) {\n        phase = calculatedPhases.get(cdsStart) ?? 0\n      }\n\n      subfeatures.push({\n        type: 'CDS',\n        phase,\n        start: cdsStart,\n        end: cdsEnd,\n        refName,\n      })\n\n      if (end > thickEnd) {\n        subfeatures.push({ type: threeUTR, start: thickEnd, end, refName })\n      }\n    }\n  }\n\n  return {\n    ...rest2,\n    uniqueId,\n    strand,\n    type: 'mRNA',\n    refName,\n    start,\n    end,\n    subfeatures,\n  }\n}\n","import {\n  generateBedMethylFeature,\n  isBedMethylFeature,\n} from './generateBedMethylFeature.ts'\nimport {\n  generateRepeatMaskerFeature,\n  isRepeatMaskerDescriptionField,\n} from './generateRepeatMaskerFeature.ts'\nimport {\n  generateUcscTranscript,\n  isUcscTranscript,\n} from './generateUcscTranscript.ts'\n\nimport type { MinimalFeature } from './types.ts'\nimport type BED from '@gmod/bed'\n\nfunction defaultParser(fields: string[], splitLine: string[]) {\n  const obj = {} as Record<string, string>\n  let hasBlockCount = false\n\n  for (const [i, element] of splitLine.entries()) {\n    const field = fields[i]\n    if (field) {\n      obj[field] = element!\n      if (field === 'blockCount') {\n        hasBlockCount = true\n      }\n    }\n  }\n\n  // heuristically try to determine whether to follow 'slow path' as there can\n  // be many features in e.g. GWAS type data\n  if (hasBlockCount) {\n    const {\n      blockStarts,\n      blockCount,\n      chromStarts,\n      thickEnd,\n      thickStart,\n      blockSizes,\n      ...rest\n    } = obj\n\n    return {\n      ...rest,\n      blockStarts: arrayify(blockStarts),\n      chromStarts: arrayify(chromStarts),\n      blockSizes: arrayify(blockSizes),\n      thickStart: thickStart ? +thickStart : undefined,\n      thickEnd: thickEnd ? +thickEnd : undefined,\n      blockCount: blockCount ? +blockCount : undefined,\n    } as Record<string, unknown>\n  }\n\n  return obj\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes?: number[]\n  blockStarts?: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts ?? blockStarts ?? []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] ?? 0) + start\n    const bsize = blockSizes?.[b]\n    if (bsize && bsize > 0) {\n      subfeatures.push({\n        uniqueId: `${uniqueId}-${b}`,\n        start: bmin,\n        end: bmin + bsize,\n        refName,\n        type: 'block',\n      })\n    }\n  }\n  return subfeatures\n}\n\nexport function featureData({\n  line,\n  colRef,\n  colStart,\n  colEnd,\n  scoreColumn,\n  parser,\n  uniqueId,\n  names,\n}: {\n  line: string\n  colRef: number\n  colStart: number\n  colEnd: number\n  scoreColumn: string\n  parser: BED\n  uniqueId: string\n  names?: string[]\n}) {\n  const splitLine = line.split('\\t')\n  const refName = splitLine[colRef]!\n  const start = Number.parseInt(splitLine[colStart]!, 10)\n  const end =\n    Number.parseInt(splitLine[colEnd]!, 10) + (colStart === colEnd ? 1 : 0)\n\n  return featureData2({\n    splitLine,\n    refName,\n    start,\n    end,\n    parser,\n    uniqueId,\n    scoreColumn,\n    names,\n  })\n}\n\nfunction parseStrand(strand: unknown) {\n  if (strand === '-' || strand === -1) {\n    return -1\n  }\n  if (strand === '+' || strand === 1) {\n    return 1\n  }\n  return 0\n}\n\ninterface FeatureData {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  strand?: number | string\n  score?: number\n  type?: string\n  subfeatures?: MinimalFeature[]\n  [key: string]: unknown\n}\n\nexport function featureData2({\n  splitLine,\n  refName,\n  start,\n  end,\n  parser,\n  uniqueId,\n  scoreColumn,\n  names,\n}: {\n  splitLine: string[]\n  refName: string\n  start: number\n  end: number\n  parser: BED\n  uniqueId: string\n  scoreColumn: string\n  names?: string[]\n}): FeatureData {\n  const data = names\n    ? defaultParser(names, splitLine)\n    : parser.parseLine(splitLine, { uniqueId })\n  const {\n    strand: strand2,\n    score: score2,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n\n  const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined\n  const strand = parseStrand(strand2)\n\n  const subfeatures = rest.blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts: rest.chromStarts,\n        blockCount: rest.blockCount,\n        blockSizes: rest.blockSizes,\n        blockStarts: rest.blockStarts,\n      })\n    : undefined\n\n  if (isBedMethylFeature({ splitLine, start, end })) {\n    return generateBedMethylFeature({\n      splitLine,\n      uniqueId,\n      refName,\n      start,\n      end,\n    })\n  }\n\n  if (isRepeatMaskerDescriptionField(rest.description)) {\n    const {\n      chromStarts: _4,\n      blockSizes: _5,\n      blockStarts: _6,\n      blockCount: _7,\n      thickStart: _8,\n      thickEnd: _9,\n      description,\n      ...rest2\n    } = rest\n    return generateRepeatMaskerFeature({\n      ...rest2,\n      description,\n      uniqueId,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    })\n  }\n\n  if (\n    subfeatures &&\n    isUcscTranscript({\n      strand,\n      blockCount: rest.blockCount,\n      thickStart: rest.thickStart,\n    })\n  ) {\n    return generateUcscTranscript({\n      ...rest,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      uniqueId,\n      subfeatures,\n      thickStart: rest.thickStart as number,\n      thickEnd: rest.thickEnd as number,\n    })\n  }\n\n  return {\n    ...rest,\n    uniqueId,\n    score,\n    start,\n    end,\n    strand,\n    refName,\n    subfeatures,\n  }\n}\n\nexport function arrayify(f?: string | number[]) {\n  if (f === undefined) {\n    return undefined\n  }\n  if (typeof f === 'string') {\n    return f.split(',').map(s => +s)\n  }\n  return f\n}\n","// this uses modkit bedMethyl. unclear how to reliably detect minimal 9+2 bedMethyl\nexport function isBedMethylFeature({\n  splitLine,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  start: number\n  end: number\n}) {\n  return (\n    +(splitLine[6] || 0) === start &&\n    +(splitLine[7] || 0) === end &&\n    [9, 10, 11, 12, 13, 14, 15, 16, 17].every(\n      r => splitLine[r] && !Number.isNaN(+splitLine[r]),\n    )\n  )\n}\n\nexport function generateBedMethylFeature({\n  splitLine,\n  uniqueId,\n  refName,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n}) {\n  // see\n  // https://github.com/nanoporetech/modkit?tab=readme-ov-file#description-of-bedmethyl-output\n  const [\n    ,\n    ,\n    ,\n    code,\n    ,\n    strand,\n    ,\n    ,\n    color,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  ] = splitLine\n\n  return {\n    uniqueId,\n    refName,\n    start,\n    end,\n    code,\n    score: +fraction_modified! || 0,\n    strand,\n    color,\n    source: code,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  }\n}\n","import BED from '@gmod/bed'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { SimpleFeature, updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport { featureData } from '../util.ts'\n\nimport type PluginManager from '@jbrowse/core/PluginManager'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\nimport type { Feature, FileLocation, Region } from '@jbrowse/core/util'\n\nexport default class BedTabixAdapter extends BaseFeatureDataAdapter {\n  private parser: BED\n\n  protected bed: TabixIndexedFile\n\n  protected columnNames: string[]\n\n  protected scoreColumn: string\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  setupP?: Promise<{\n    meta: Awaited<ReturnType<TabixIndexedFile['getMetadata']>>\n  }>\n\n  public constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const bedGzLoc = this.getConf('bedGzLocation') as FileLocation\n    const type = this.getConf(['index', 'indexType'])\n    const loc = this.getConf(['index', 'location'])\n    const autoSql = this.getConf('autoSql')\n    const pm = this.pluginManager\n\n    this.bed = new TabixIndexedFile({\n      filehandle: openLocation(bedGzLoc, pm),\n      csiFilehandle: type === 'CSI' ? openLocation(loc, pm) : undefined,\n      tbiFilehandle: type !== 'CSI' ? openLocation(loc, pm) : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n    this.columnNames = this.getConf('columnNames')\n    this.scoreColumn = this.getConf('scoreColumn')\n    this.parser = new BED({ autoSql })\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    return this.bed.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    return this.bed.getHeader(opts)\n  }\n\n  async getMetadataPre2(_opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.getMetadataPre().catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getMetadataPre() {\n    const meta = await this.bed.getMetadata()\n    return { meta }\n  }\n\n  async getMetadata(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, () =>\n      this.getMetadataPre2(opts),\n    )\n  }\n\n  async getNames() {\n    if (this.columnNames.length) {\n      return this.columnNames\n    }\n    const header = await this.getHeader()\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(f => f.trim())\n      : undefined\n  }\n\n  public getFeatures(query: Region, opts?: BaseOptions) {\n    const { stopToken, statusCallback = () => {} } = opts || {}\n    return ObservableCreate<Feature>(async observer => {\n      const { meta } = await this.getMetadata()\n      const { columnNumbers } = meta\n      const colRef = columnNumbers.ref - 1\n      const colStart = columnNumbers.start - 1\n      const colEnd = columnNumbers.end - 1\n      const names = await this.getNames()\n      let start = performance.now()\n      checkStopToken(stopToken)\n      await updateStatus('Downloading features', statusCallback, () =>\n        this.bed.getLines(query.refName, query.start, query.end, {\n          lineCallback: (line, fileOffset) => {\n            if (performance.now() - start > 500) {\n              checkStopToken(stopToken)\n              start = performance.now()\n            }\n            observer.next(\n              new SimpleFeature(\n                featureData({\n                  line,\n                  colRef,\n                  colStart,\n                  colEnd,\n                  scoreColumn: this.scoreColumn,\n                  parser: this.parser,\n                  uniqueId: `${this.id}-${fileOffset}`,\n                  names,\n                }),\n              ),\n            )\n          },\n          stopToken,\n        }),\n      )\n      observer.complete()\n    }, stopToken)\n  }\n}\n"],"names":["isRepeatMaskerDescriptionField","desc","ret","trim","split","every","s","undefined","Number","isNaN","makeRepeatTrackDescription","description","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","frameToPhase","frame","featureData","line","colRef","colStart","colEnd","scoreColumn","parser","uniqueId","names","splitLine","featureData2","refName","start","parseInt","end","data","fields","obj","hasBlockCount","i","element","entries","field","blockStarts","blockCount","chromStarts","thickEnd","thickStart","blockSizes","rest","arrayify","defaultParser","parseLine","strand","strand2","score","score2","chrom","_1","chromStart","_2","chromEnd","_3","parseStrand","subfeatures","starts","b","bmin","bsize","push","type","makeBlocks","r","isBedMethylFeature","code","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","source","generateBedMethylFeature","_4","_5","_6","_7","_8","_9","rest2","generateRepeatMaskerFeature","isUcscTranscript","oldSubfeatures","exonFrames","_exonFrames","feats","filter","child","sort","a","fiveUTR","threeUTR","cdsEndStat","cdsStartStat","map","e","calculatedPhases","cdsRegions","block","Math","max","min","sorted","phaseMap","Map","cumulativeWidth","cds","phase","set","calculatePhasesFromCds","feat","cdsStart","cdsEnd","get","generateUcscTranscript","f","BedTabixAdapter","BaseFeatureDataAdapter","constructor","config","getSubAdapter","pluginManager","super","bedGzLoc","this","getConf","loc","autoSql","pm","bed","TabixIndexedFile","filehandle","openLocation","csiFilehandle","tbiFilehandle","chunkCacheSize","columnNames","BED","getRefNames","opts","getReferenceSequenceNames","getHeader","getMetadataPre2","_opts","setupP","getMetadataPre","catch","meta","getMetadata","statusCallback","updateStatus","getNames","length","defline","at","includes","slice","getFeatures","query","stopToken","ObservableCreate","async","columnNumbers","ref","performance","now","checkStopToken","getLines","lineCallback","fileOffset","observer","next","SimpleFeature","id","complete"],"ignoreList":[],"sourceRoot":""}