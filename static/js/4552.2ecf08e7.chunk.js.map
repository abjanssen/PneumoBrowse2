{"version":3,"file":"static/js/4552.2ecf08e7.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BigBedAdapter/BigBedAdapter.ts","../../../plugins/bed/src/generateRepeatMaskerFeature.ts","../../../plugins/bed/src/generateUcscTranscript.ts","../../../plugins/bed/src/util.ts","../../../plugins/bed/src/generateBedMethylFeature.ts"],"sourcesContent":["import { BigBed } from '@gmod/bbi'\nimport BED from '@gmod/bed'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  SimpleFeature,\n  doesIntersect2,\n  max,\n  min,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { firstValueFrom, toArray } from 'rxjs'\n\nimport { featureData2 } from '../util.ts'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\nimport type { Region } from '@jbrowse/core/util/types'\nimport type { Observer } from 'rxjs'\n\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n  private cachedP?: Promise<{\n    bigbed: BigBed\n    header: Awaited<ReturnType<BigBed['getHeader']>>\n    parser: BED\n  }>\n\n  public async configurePre(opts?: BaseOptions) {\n    const pm = this.pluginManager\n    const bigbed = new BigBed({\n      filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n    })\n    const header = await bigbed.getHeader(opts)\n    const parser = new BED({\n      autoSql: header.autoSql,\n    })\n    return {\n      bigbed,\n      header,\n      parser,\n    }\n  }\n\n  public async configure(opts?: BaseOptions) {\n    if (!this.cachedP) {\n      this.cachedP = this.configurePre(opts).catch((e: unknown) => {\n        this.cachedP = undefined\n        throw e\n      })\n    }\n    return this.cachedP\n  }\n\n  public async getRefNames(opts?: BaseOptions) {\n    const { header } = await this.configure(opts)\n    return Object.keys(header.refsByName)\n  }\n\n  // allow using BigBedAdapter for aliases with chromAlias.bb file from UCSC\n  public async getRefNameAliases(opts?: BaseOptions) {\n    const { header } = await this.configure(opts)\n    const ret = await Promise.all(\n      Object.keys(header.refsByName).map(\n        async refName =>\n          (\n            await firstValueFrom(\n              this.getFeatures({\n                assemblyName: '',\n                refName,\n                start: 0,\n                end: 1,\n              }).pipe(toArray()),\n            )\n          )[0]!,\n      ),\n    )\n    return ret\n      .map(r => r.toJSON())\n      .map(r => ({\n        refName: r.ucsc,\n        aliases: [r.ncbi, r.refseq, r.genbank],\n        override: true,\n      }))\n  }\n\n  public async getData() {\n    const refNames = await this.getRefNames()\n    const features = []\n    for (const refName of refNames) {\n      const f = await firstValueFrom(\n        this.getFeatures({\n          assemblyName: 'unknown',\n          refName,\n          start: 0,\n          end: Number.MAX_SAFE_INTEGER,\n        }).pipe(toArray()),\n      )\n      features.push(f)\n    }\n    return features.flat()\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { parser, header } = await this.configure(opts)\n    const { version, fileType } = header\n    const { fields, ...autoSql } = parser.autoSql\n    return {\n      version,\n      fileType,\n      autoSql,\n      fields: await this.getMetadata(opts),\n    }\n  }\n  async getMetadata(opts?: BaseOptions) {\n    const { parser } = await this.configure(opts)\n    const { fields } = parser.autoSql\n    return Object.fromEntries(\n      fields.map(({ name, comment }) => [name, comment]),\n    )\n  }\n\n  public async getFeaturesHelper({\n    query,\n    opts,\n    observer,\n    allowRedispatch,\n    originalQuery = query,\n  }: {\n    query: Region\n    opts: BaseOptions\n    observer: Observer<Feature>\n    allowRedispatch: boolean\n    originalQuery?: Region\n  }) {\n    const { statusCallback = () => {} } = opts\n    const scoreColumn = this.getConf('scoreColumn')\n    const aggregateField = this.getConf('aggregateField')\n    const { parser, bigbed } = await updateStatus(\n      'Downloading header',\n      statusCallback,\n      () => this.configure(opts),\n    )\n    const feats = await updateStatus(\n      'Downloading features',\n      statusCallback,\n      () =>\n        bigbed.getFeatures(query.refName, query.start, query.end, {\n          basesPerSpan: query.end - query.start,\n        }),\n    )\n\n    await updateStatus('Processing features', statusCallback, async () => {\n      const parentAggregation = {} as Record<string, SimpleFeatureSerialized[]>\n      const parentAggregationFlat = []\n\n      if (feats.some(f => f.uniqueId === undefined)) {\n        throw new Error('found uniqueId undefined')\n      }\n      for (const feat of feats) {\n        const splitLine = [\n          query.refName,\n          `${feat.start}`,\n          `${feat.end}`,\n          ...(feat.rest?.split('\\t') || []),\n        ]\n        const data = parser.parseLine(splitLine, {\n          uniqueId: feat.uniqueId!,\n        })\n\n        const aggr = data[aggregateField]\n        const aggrIsNotNone = aggr && aggr !== 'none'\n        if (aggrIsNotNone && !parentAggregation[aggr]) {\n          parentAggregation[aggr] = []\n        }\n        const {\n          uniqueId,\n          type,\n          chrom,\n          chromStart,\n          chromEnd,\n          description,\n          chromStarts: chromStarts2,\n          blockStarts: blockStarts2,\n          blockSizes: blockSizes2,\n          score: score2,\n          blockCount,\n          thickStart,\n          thickEnd,\n          strand,\n          ...rest\n        } = data\n\n        const f = featureData2({\n          ...rest,\n          scoreColumn,\n          splitLine,\n          parser,\n          uniqueId,\n          start: feat.start,\n          end: feat.end,\n          refName: query.refName,\n        })\n        if (aggrIsNotNone) {\n          parentAggregation[aggr]!.push(f)\n          parentAggregationFlat.push(f)\n        } else {\n          if (\n            doesIntersect2(\n              f.start,\n              f.end,\n              originalQuery.start,\n              originalQuery.end,\n            )\n          ) {\n            observer.next(\n              new SimpleFeature({\n                id: `${this.id}-${uniqueId}`,\n                data: f,\n              }),\n            )\n          }\n        }\n      }\n\n      if (allowRedispatch && parentAggregationFlat.length) {\n        let minStart = Number.POSITIVE_INFINITY\n        let maxEnd = Number.NEGATIVE_INFINITY\n        for (const feat of parentAggregationFlat) {\n          if (feat.start < minStart) {\n            minStart = feat.start\n          }\n          if (feat.end > maxEnd) {\n            maxEnd = feat.end\n          }\n        }\n\n        if (maxEnd > query.end || minStart < query.start) {\n          await this.getFeaturesHelper({\n            query: {\n              ...query,\n              // re-query with 500kb added onto start and end, in order to catch\n              // gene subfeatures that may not overlap your view\n              start: minStart - 500_000,\n              end: maxEnd + 500_000,\n            },\n            opts,\n            observer,\n            allowRedispatch: false,\n            originalQuery: query,\n          })\n          return\n        }\n      }\n\n      Object.entries(parentAggregation).map(([name, subfeatures]) => {\n        const s = min(subfeatures.map(f => f.start))\n        const e = max(subfeatures.map(f => f.end))\n        if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n          const subs = subfeatures.sort((a, b) =>\n            a.uniqueId.localeCompare(b.uniqueId),\n          )\n          // Check if any features in the subs array overlap with each other.\n          // This helps avoid aggregating features, like in bacterial GFF,\n          // where two genes have the same gene name but are distinct locations\n          // on the genome\n          //\n          // If they do, we'll create a single parent feature with all\n          // subfeatures (use the computed parent aggregation)\n          if (\n            subs.some((a, i) =>\n              subs.some(\n                (b, j) =>\n                  i !== j && doesIntersect2(a.start, a.end, b.start, b.end),\n              ),\n            )\n          ) {\n            observer.next(\n              new SimpleFeature({\n                id: `${this.id}-${subs[0]?.uniqueId}-parent`,\n                data: {\n                  type: 'gene',\n                  subfeatures: subs,\n                  strand: subs[0]?.strand || 1,\n                  name,\n                  start: s,\n                  end: e,\n                  refName: query.refName,\n                },\n              }),\n            )\n          }\n\n          // Otherwise, we'll create individual parent features for each subfeature (remove parent aggregation)\n          else {\n            for (const sub of subs) {\n              observer.next(\n                new SimpleFeature({\n                  id: `${this.id}-${sub.uniqueId}-parent`,\n                  data: {\n                    type: 'gene',\n                    subfeatures: [sub],\n                    strand: subs[0]?.strand || 1,\n                    name,\n                    start: sub.start,\n                    end: sub.end,\n                    refName: query.refName,\n                  },\n                }),\n              )\n            }\n          }\n        }\n      })\n    })\n\n    observer.complete()\n  }\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        await this.getFeaturesHelper({\n          query: {\n            ...query,\n            start: query.start,\n            end: query.end,\n          },\n          opts,\n          observer,\n          allowRedispatch: true,\n        })\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n}\n","export function isRepeatMaskerDescriptionField(desc?: string): desc is string {\n  const ret = desc?.trim().split(' ')\n  return [0, 1, 2, 3, 5, 6].every(s =>\n    ret?.[s] !== undefined ? !Number.isNaN(+ret[s]) : false,\n  )\n}\n\nfunction makeRepeatTrackDescription(description?: string) {\n  if (isRepeatMaskerDescriptionField(description)) {\n    const [\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    ] = description.trim().split(' ')\n    return {\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    }\n  }\n  return { description }\n}\n\nexport function generateRepeatMaskerFeature({\n  uniqueId,\n  refName,\n  start,\n  end,\n  description,\n  ...rest\n}: {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  description: string\n  [key: string]: unknown\n}) {\n  const { subfeatures, ...rest2 } = rest\n  return {\n    ...rest2,\n    ...makeRepeatTrackDescription(description),\n    uniqueId,\n    refName,\n    start,\n    end,\n  }\n}\n","import type { MinimalFeature } from './types.ts'\n\nexport function isUcscTranscript({\n  thickStart,\n  blockCount,\n  strand,\n}: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return thickStart && blockCount && strand !== 0\n}\n\n/**\n * Calculate phase for each CDS based on cumulative widths.\n * Phase = (3 - cumulative_cds_width % 3) % 3\n * CDS must be in transcriptional order (5' to 3')\n */\nfunction calculatePhasesFromCds(\n  cdsRegions: { start: number; end: number }[],\n  strand: number,\n) {\n  // Sort in transcriptional order: ascending for +strand, descending for -strand\n  const sorted = [...cdsRegions].sort((a, b) =>\n    strand > 0 ? a.start - b.start : b.start - a.start,\n  )\n\n  const phaseMap = new Map<number, number>()\n  let cumulativeWidth = 0\n\n  for (const cds of sorted) {\n    // Phase is how many bases at the START of this CDS complete the previous codon\n    const phase = (3 - (cumulativeWidth % 3)) % 3\n    phaseMap.set(cds.start, phase)\n    cumulativeWidth += cds.end - cds.start\n  }\n\n  return phaseMap\n}\n\n/**\n * Convert UCSC exonFrames (reading frame 0,1,2) to GFF phase (bases to skip 0,1,2)\n * Frame 0 → phase 0 (first base at codon position 0, skip 0)\n * Frame 1 → phase 2 (first base at codon position 1, skip 2 to next codon)\n * Frame 2 → phase 1 (first base at codon position 2, skip 1 to next codon)\n */\nfunction frameToPhase(frame: number) {\n  return (3 - frame) % 3\n}\n\ninterface UcscTranscriptInput {\n  uniqueId: string\n  strand?: number\n  thickStart: number\n  thickEnd: number\n  refName: string\n  start: number\n  end: number\n  subfeatures: MinimalFeature[]\n  [key: string]: unknown\n}\n\ninterface UcscTranscriptOutput {\n  uniqueId: string\n  strand: number\n  type: string\n  refName: string\n  start: number\n  end: number\n  subfeatures: MinimalFeature[]\n  [key: string]: unknown\n}\n\nexport function generateUcscTranscript(\n  data: UcscTranscriptInput,\n): UcscTranscriptOutput {\n  const { strand = 0, uniqueId, start, end, ...rest } = data\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    refName,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    chromStarts: _4,\n    blockStarts: _5,\n    blockSizes: _6,\n    blockCount: _7,\n    ...rest2\n  } = rest\n\n  // exonFrames from bigGenePred - the @gmod/bed parser returns it in genomic order\n  const exonFrames = (rest2.exonFrames ?? rest2._exonFrames) as\n    | number[]\n    | undefined\n\n  const feats = oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n\n  const fiveUTR = strand > 0 ? 'five_prime_UTR' : 'three_prime_UTR'\n  const threeUTR = strand > 0 ? 'three_prime_UTR' : 'five_prime_UTR'\n\n  const { cdsEndStat, cdsStartStat } = rest2\n  if (cdsStartStat === 'none' && cdsEndStat === 'none') {\n    return {\n      ...rest2,\n      uniqueId,\n      strand,\n      type: 'transcript',\n      refName,\n      start,\n      end,\n      subfeatures: feats.map(e => ({ ...e, type: 'exon' })),\n    }\n  }\n\n  // If exonFrames not available, calculate phases from CDS regions\n  let calculatedPhases: Map<number, number> | undefined\n  if (!exonFrames) {\n    const cdsRegions: { start: number; end: number }[] = []\n    for (const block of feats) {\n      const { start, end } = block\n      if (thickStart < end && thickEnd > start) {\n        cdsRegions.push({\n          start: Math.max(start, thickStart),\n          end: Math.min(end, thickEnd),\n        })\n      }\n    }\n    calculatedPhases = calculatePhasesFromCds(cdsRegions, strand)\n  }\n\n  const subfeatures: MinimalFeature[] = []\n  for (const [i, feat] of feats.entries()) {\n    const block = feat\n    const { start, end } = block\n\n    if (thickStart >= end) {\n      // entire block is 5' UTR\n      subfeatures.push({ type: fiveUTR, start, end, refName })\n    } else if (thickEnd <= start) {\n      // entire block is 3' UTR\n      subfeatures.push({ type: threeUTR, start, end, refName })\n    } else {\n      // block overlaps CDS region - may have UTR on either side\n      if (start < thickStart) {\n        subfeatures.push({ type: fiveUTR, start, end: thickStart, refName })\n      }\n\n      const cdsStart = Math.max(start, thickStart)\n      const cdsEnd = Math.min(end, thickEnd)\n\n      // Get phase from exonFrames (with conversion) or calculated phases\n      let phase = 0\n      if (exonFrames) {\n        const frame = exonFrames[i]\n        if (frame !== undefined && frame >= 0) {\n          phase = frameToPhase(frame)\n        }\n      } else if (calculatedPhases) {\n        phase = calculatedPhases.get(cdsStart) ?? 0\n      }\n\n      subfeatures.push({\n        type: 'CDS',\n        phase,\n        start: cdsStart,\n        end: cdsEnd,\n        refName,\n      })\n\n      if (end > thickEnd) {\n        subfeatures.push({ type: threeUTR, start: thickEnd, end, refName })\n      }\n    }\n  }\n\n  return {\n    ...rest2,\n    uniqueId,\n    strand,\n    type: 'mRNA',\n    refName,\n    start,\n    end,\n    subfeatures,\n  }\n}\n","import {\n  generateBedMethylFeature,\n  isBedMethylFeature,\n} from './generateBedMethylFeature.ts'\nimport {\n  generateRepeatMaskerFeature,\n  isRepeatMaskerDescriptionField,\n} from './generateRepeatMaskerFeature.ts'\nimport {\n  generateUcscTranscript,\n  isUcscTranscript,\n} from './generateUcscTranscript.ts'\n\nimport type { MinimalFeature } from './types'\nimport type BED from '@gmod/bed'\n\nfunction defaultParser(fields: string[], splitLine: string[]) {\n  const obj = {} as Record<string, string>\n  let hasBlockCount = false\n\n  for (const [i, element] of splitLine.entries()) {\n    const field = fields[i]\n    if (field) {\n      obj[field] = element!\n      if (field === 'blockCount') {\n        hasBlockCount = true\n      }\n    }\n  }\n\n  // heuristically try to determine whether to follow 'slow path' as there can\n  // be many features in e.g. GWAS type data\n  if (hasBlockCount) {\n    const {\n      blockStarts,\n      blockCount,\n      chromStarts,\n      thickEnd,\n      thickStart,\n      blockSizes,\n      ...rest\n    } = obj\n\n    return {\n      ...rest,\n      blockStarts: arrayify(blockStarts),\n      chromStarts: arrayify(chromStarts),\n      blockSizes: arrayify(blockSizes),\n      thickStart: thickStart ? +thickStart : undefined,\n      thickEnd: thickEnd ? +thickEnd : undefined,\n      blockCount: blockCount ? +blockCount : undefined,\n    } as Record<string, unknown>\n  }\n\n  return obj\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes?: number[]\n  blockStarts?: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts ?? blockStarts ?? []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] ?? 0) + start\n    const bsize = blockSizes?.[b]\n    if (bsize && bsize > 0) {\n      subfeatures.push({\n        uniqueId: `${uniqueId}-${b}`,\n        start: bmin,\n        end: bmin + bsize,\n        refName,\n        type: 'block',\n      })\n    }\n  }\n  return subfeatures\n}\n\nexport function featureData({\n  line,\n  colRef,\n  colStart,\n  colEnd,\n  scoreColumn,\n  parser,\n  uniqueId,\n  names,\n}: {\n  line: string\n  colRef: number\n  colStart: number\n  colEnd: number\n  scoreColumn: string\n  parser: BED\n  uniqueId: string\n  names?: string[]\n}) {\n  const splitLine = line.split('\\t')\n  const refName = splitLine[colRef]!\n  const start = Number.parseInt(splitLine[colStart]!, 10)\n  const end =\n    Number.parseInt(splitLine[colEnd]!, 10) + (colStart === colEnd ? 1 : 0)\n\n  return featureData2({\n    splitLine,\n    refName,\n    start,\n    end,\n    parser,\n    uniqueId,\n    scoreColumn,\n    names,\n  })\n}\n\nfunction parseStrand(strand: unknown) {\n  if (strand === '-' || strand === -1) {\n    return -1\n  }\n  if (strand === '+' || strand === 1) {\n    return 1\n  }\n  return 0\n}\n\ninterface FeatureData {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  strand?: number | string\n  score?: number\n  type?: string\n  subfeatures?: MinimalFeature[]\n  [key: string]: unknown\n}\n\nexport function featureData2({\n  splitLine,\n  refName,\n  start,\n  end,\n  parser,\n  uniqueId,\n  scoreColumn,\n  names,\n}: {\n  splitLine: string[]\n  refName: string\n  start: number\n  end: number\n  parser: BED\n  uniqueId: string\n  scoreColumn: string\n  names?: string[]\n}): FeatureData {\n  const data = names\n    ? defaultParser(names, splitLine)\n    : parser.parseLine(splitLine, { uniqueId })\n  const {\n    strand: strand2,\n    score: score2,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n\n  const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined\n  const strand = parseStrand(strand2)\n\n  const subfeatures = rest.blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts: rest.chromStarts,\n        blockCount: rest.blockCount,\n        blockSizes: rest.blockSizes,\n        blockStarts: rest.blockStarts,\n      })\n    : undefined\n\n  if (isBedMethylFeature({ splitLine, start, end })) {\n    return generateBedMethylFeature({\n      splitLine,\n      uniqueId,\n      refName,\n      start,\n      end,\n    })\n  }\n\n  if (isRepeatMaskerDescriptionField(rest.description)) {\n    const {\n      chromStarts: _4,\n      blockSizes: _5,\n      blockStarts: _6,\n      blockCount: _7,\n      thickStart: _8,\n      thickEnd: _9,\n      description,\n      ...rest2\n    } = rest\n    return generateRepeatMaskerFeature({\n      ...rest2,\n      description,\n      uniqueId,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    })\n  }\n\n  if (\n    subfeatures &&\n    isUcscTranscript({\n      strand,\n      blockCount: rest.blockCount,\n      thickStart: rest.thickStart,\n    })\n  ) {\n    return generateUcscTranscript({\n      ...rest,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      uniqueId,\n      subfeatures,\n      thickStart: rest.thickStart as number,\n      thickEnd: rest.thickEnd as number,\n    })\n  }\n\n  return {\n    ...rest,\n    uniqueId,\n    score,\n    start,\n    end,\n    strand,\n    refName,\n    subfeatures,\n  }\n}\n\nexport function arrayify(f?: string | number[]) {\n  if (f === undefined) {\n    return undefined\n  }\n  if (typeof f === 'string') {\n    return f.split(',').map(s => +s)\n  }\n  return f\n}\n","// this uses modkit bedMethyl. unclear how to reliably detect minimal 9+2 bedMethyl\nexport function isBedMethylFeature({\n  splitLine,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  start: number\n  end: number\n}) {\n  return (\n    +(splitLine[6] || 0) === start &&\n    +(splitLine[7] || 0) === end &&\n    [9, 10, 11, 12, 13, 14, 15, 16, 17].every(\n      r => splitLine[r] && !Number.isNaN(+splitLine[r]),\n    )\n  )\n}\n\nexport function generateBedMethylFeature({\n  splitLine,\n  uniqueId,\n  refName,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n}) {\n  // see\n  // https://github.com/nanoporetech/modkit?tab=readme-ov-file#description-of-bedmethyl-output\n  const [\n    ,\n    ,\n    ,\n    code,\n    ,\n    strand,\n    ,\n    ,\n    color,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  ] = splitLine\n\n  return {\n    uniqueId,\n    refName,\n    start,\n    end,\n    code,\n    score: +fraction_modified! || 0,\n    strand,\n    color,\n    source: code,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  }\n}\n"],"names":["BigBedAdapter","BaseFeatureDataAdapter","configurePre","opts","pm","this","pluginManager","bigbed","BigBed","filehandle","openLocation","getConf","header","getHeader","parser","BED","autoSql","configure","cachedP","catch","e","undefined","getRefNames","Object","keys","refsByName","getRefNameAliases","Promise","all","map","async","firstValueFrom","getFeatures","assemblyName","refName","start","end","pipe","toArray","r","toJSON","ucsc","aliases","ncbi","refseq","genbank","override","getData","refNames","features","f","Number","MAX_SAFE_INTEGER","push","flat","version","fileType","fields","getMetadata","fromEntries","name","comment","getFeaturesHelper","query","observer","allowRedispatch","originalQuery","statusCallback","scoreColumn","aggregateField","updateStatus","feats","basesPerSpan","parentAggregation","parentAggregationFlat","some","uniqueId","Error","feat","splitLine","rest","split","data","parseLine","aggr","aggrIsNotNone","type","chrom","chromStart","chromEnd","description","chromStarts","chromStarts2","blockStarts","blockStarts2","blockSizes","blockSizes2","score","score2","blockCount","thickStart","thickEnd","strand","featureData2","doesIntersect2","next","SimpleFeature","id","length","minStart","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","entries","subfeatures","s","min","max","subs","sort","a","b","localeCompare","i","j","sub","complete","ObservableCreate","error","stopToken","isRepeatMaskerDescriptionField","desc","ret","trim","every","isNaN","makeRepeatTrackDescription","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","frameToPhase","frame","featureData","line","colRef","colStart","colEnd","names","parseInt","obj","hasBlockCount","element","field","arrayify","defaultParser","strand2","_1","_2","_3","parseStrand","starts","bmin","bsize","makeBlocks","isBedMethylFeature","code","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","source","generateBedMethylFeature","_4","_5","_6","_7","_8","_9","rest2","generateRepeatMaskerFeature","isUcscTranscript","oldSubfeatures","exonFrames","_exonFrames","filter","child","fiveUTR","threeUTR","cdsEndStat","cdsStartStat","calculatedPhases","cdsRegions","block","Math","sorted","phaseMap","Map","cumulativeWidth","cds","phase","set","calculatePhasesFromCds","cdsStart","cdsEnd","get","generateUcscTranscript"],"ignoreList":[],"sourceRoot":""}