{"version":3,"file":"static/js/5483.6cd633d3.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/util.ts","../../../plugins/comparative-adapters/src/MCScanAnchorsAdapter/MCScanAnchorsAdapter.ts"],"sourcesContent":["import { fetchAndMaybeUnzipText } from '@jbrowse/core/util'\n\nimport type { PAFRecord } from './PAFAdapter/util.ts'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { GenericFilehandle } from 'generic-filehandle2'\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f && !f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start!,\n            end: +end!,\n            score: +score!,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  return fetchAndMaybeUnzipText(file, opts)\n}\n\nexport function zip(a: number[], b: number[]) {\n  return a.map((e, i) => [e, b[i]] as [number, number])\n}\n\nexport function parsePAFLine(line: string) {\n  const parts = line.split('\\t')\n  const extraFields = parts.slice(12)\n  const extra: Record<string, string | number> = {\n    numMatches: +parts[9]!,\n    blockLen: +parts[10]!,\n    mappingQual: +parts[11]!,\n  }\n\n  // Process extra fields only if they exist\n  if (extraFields.length) {\n    for (const field of extraFields) {\n      const colonIndex = field.indexOf(':')\n      extra[field.slice(0, colonIndex)] = field.slice(colonIndex + 3)\n    }\n  }\n\n  return {\n    tname: parts[5],\n    tstart: +parts[7]!,\n    tend: +parts[8]!,\n    qname: parts[0],\n    qstart: +parts[2]!,\n    qend: +parts[3]!,\n    strand: parts[4] === '-' ? -1 : 1,\n    extra,\n  } as PAFRecord\n}\n\nexport function flipCigar(cigar: string[]) {\n  const arr = []\n  for (let i = cigar.length - 2; i >= 0; i -= 2) {\n    arr.push(cigar[i])\n    const op = cigar[i + 1]\n    if (op === 'D') {\n      arr.push('I')\n    } else if (op === 'I') {\n      arr.push('D')\n    } else {\n      arr.push(op)\n    }\n  }\n  return arr\n}\n\nexport function swapIndelCigar(cigar: string) {\n  return cigar.replaceAll('D', 'K').replaceAll('I', 'D').replaceAll('K', 'I')\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { SimpleFeature, doesIntersect2, updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport { parseBed, readFile } from '../util.ts'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\ninterface BareFeature {\n  strand: number\n  refName: string\n  start: number\n  end: number\n  score: number\n  name: string\n}\n\ntype Row = [BareFeature, BareFeature, number, number]\n\nexport default class MCScanAnchorsAdapter extends BaseFeatureDataAdapter {\n  private setupP?: Promise<{\n    assemblyNames: string[]\n    feats: Row[]\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  async setup(opts: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n  async setupPre(opts: BaseOptions) {\n    const { statusCallback = () => {} } = opts\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n\n    const pm = this.pluginManager\n    const bed1 = openLocation(this.getConf('bed1Location'), pm)\n    const bed2 = openLocation(this.getConf('bed2Location'), pm)\n    const mcscan = openLocation(this.getConf('mcscanAnchorsLocation'), pm)\n    const [bed1text, bed2text, mcscantext] = await updateStatus(\n      'Downloading data',\n      statusCallback,\n      () => Promise.all([bed1, bed2, mcscan].map(r => readFile(r, opts))),\n    )\n\n    const bed1Map = parseBed(bed1text!)\n    const bed2Map = parseBed(bed2text!)\n    const feats = mcscantext!\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f && f !== '###')\n      .map((line, index) => {\n        const [name1, name2, score] = line.split('\\t')\n        const r1 = bed1Map.get(name1)\n        const r2 = bed2Map.get(name2)\n        if (!r1 || !r2) {\n          throw new Error(`feature not found, ${name1} ${name2} ${r1} ${r2}`)\n        }\n        return [r1, r2, +score!, index] as Row\n      })\n\n    return {\n      assemblyNames,\n      feats,\n    }\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures so is not\n    // really that important, and has to be true or else getFeatures is never\n    // called (BaseFeatureDataAdapter filters it out)\n    return true\n  }\n\n  getAssemblyNames() {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    return assemblyNames\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    // @ts-expect-error\n    const r1 = opts.regions?.[0].assemblyName\n    const { feats } = await this.setup(opts)\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    if (idx !== -1) {\n      const set = new Set<string>()\n      for (const feat of feats) {\n        set.add(idx === 0 ? feat[0].refName : feat[1].refName)\n      }\n      return [...set]\n    }\n    console.warn('Unable to do ref renaming on adapter')\n    return []\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { assemblyNames, feats } = await this.setup(opts)\n\n      // The index of the assembly name in the region list corresponds to\n      // the adapter in the subadapters list\n      const index = assemblyNames.indexOf(region.assemblyName)\n      if (index !== -1) {\n        const flip = index === 0\n        for (const f of feats) {\n          const [r1, r2, score, rowNum] = f\n          const [f1, f2] = !flip ? [r2, r1] : [r1, r2]\n          if (\n            f1.refName === region.refName &&\n            doesIntersect2(region.start, region.end, f1.start, f1.end)\n          ) {\n            observer.next(\n              new SimpleFeature({\n                ...f1,\n                uniqueId: `${index}-${rowNum}`,\n                syntenyId: rowNum,\n\n                // note: strand would be -1 if the two features are on opposite\n                // strands, indicating inverted alignment\n                strand: f1.strand * f2.strand,\n                assemblyName: assemblyNames[+!flip],\n                score,\n                mate: {\n                  ...f2,\n                  assemblyName: assemblyNames[+flip],\n                },\n              }),\n            )\n          }\n        }\n      }\n\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n}\n"],"names":["parseBed","text","Map","split","filter","f","startsWith","map","line","refName","start","end","name","score","strand","async","readFile","file","opts","fetchAndMaybeUnzipText","parsePAFLine","parts","extraFields","slice","extra","numMatches","blockLen","mappingQual","length","field","colonIndex","indexOf","tname","tstart","tend","qname","qstart","qend","flipCigar","cigar","arr","i","push","op","swapIndelCigar","replaceAll","MCScanAnchorsAdapter","BaseFeatureDataAdapter","setup","this","setupP","setupPre","catch","e","undefined","statusCallback","assemblyNames","getConf","pm","pluginManager","bed1","openLocation","bed2","mcscan","bed1text","bed2text","mcscantext","updateStatus","Promise","all","r","bed1Map","bed2Map","feats","index","name1","name2","r1","get","r2","Error","hasDataForRefName","getAssemblyNames","getRefNames","regions","assemblyName","idx","set","Set","feat","add","console","warn","getFeatures","region","ObservableCreate","flip","rowNum","f1","f2","doesIntersect2","observer","next","SimpleFeature","uniqueId","syntenyId","mate","complete"],"ignoreList":[],"sourceRoot":""}