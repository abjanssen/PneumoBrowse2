{"version":3,"file":"static/js/9314.b7ed476f.chunk.js","mappings":"wHAOO,SAASA,EAASC,GACvB,MAAmB,iBAARA,EACFA,EAAMA,GAAQ,EACG,iBAARA,GAAmC,KAAfA,EAAIC,QACjCC,OAAOC,UAAUH,EAI5B,C,kCCfO,SAASI,EAAYC,GAC1B,MAAe,MAAXA,EACK,EACa,MAAXA,GACD,OAER,CAEJ,CAEO,SAASC,EAAcC,GAC5B,OAAO,IAAIC,YAAY,QACpBC,OAAOF,GACPG,MAAM,cACNC,KAAIC,GAAKA,EAAEX,SACXY,QAAOD,KAAOA,GACnB,C,6HCVO,SAASE,EAAeP,GAC7B,MAAMQ,GAAQT,EAAAA,EAAAA,GAAcC,GACtBS,EAASD,EAAMF,QAAOI,GAAKA,EAAEC,WAAW,OAAMC,KAAK,MACnDC,EAAOL,EAAMF,QAAOI,IAAMA,EAAEC,WAAW,OACvCG,EAAY,IAAIC,EAAAA,EAAI,CAAEN,WACtBO,EAAO,IAAIC,IACXC,EAAO,GACb,IAAIC,EAAI,EACR,IAAK,MAAMC,KAAQP,EAAM,CACvB,MAAOQ,EAAOC,EAAKC,EAAIC,EAAKC,EAAKC,EAAMC,EAAQC,EAAMC,KAAWC,GAC9DV,EAAKjB,MAAM,MACP4B,EAAMC,OAAOC,YACjBL,GAAMzB,MAAM,KACTC,KAAIC,GAAKA,EAAEX,SACXU,KAAI8B,IACH,MAAOC,EAAKC,EAAM,QAAUF,EAAE/B,MAAM,KAC9BkC,EAAI,QAAQF,EAAKzC,SACvBsB,EAAKsB,IAAID,GACT,MAAME,EAAIH,EAAI1C,OACd,MAAO,CAAC2C,GAAG7C,EAAAA,EAAAA,GAAS+C,IAAMA,EAAIA,EAAE,KAC5B,IAEVrB,EAAKsB,KAAK,CAERC,SAAU,CACRpB,QACAC,KAAMA,EACNC,KACAC,MACAC,MACAC,MAAMlC,EAAAA,EAAAA,GAASkC,IAASA,EAAOA,EAC/BC,SACAE,YACGE,KACAC,OAAOC,YACRnB,EAAU4B,QAAQtC,KAAI,CAACuC,EAAGC,IAAQ,CAACD,EAAGb,EAAKc,QAI/CC,QAAS,IAAIC,EAAAA,EAAW,CACtBC,OAAQjC,EACRkC,QAASlC,EAAUmC,UAAU7B,GAC7B8B,GAAI,OAAO/B,MACVgC,WAELhC,GACF,CACA,MAAO,CACLiC,QAAS,CACP,QACA,MACA,KACA,MACA,MACA,OACA,YACGpC,EACH,YACGF,EAAU4B,SACbtC,KAAIiD,IAAK,CAAGC,KAAMD,MACpBE,OAAQ,CACNrC,QAGN,C","sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/isNumber.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/util.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/VcfImport.ts"],"sourcesContent":["/**\n * is-number <https://github.com/jonschlinkert/is-number>\n *\n * Copyright (c) 2014-present, Jon Schlinkert.\n * Released under the MIT License.\n */\n\nexport function isNumber(num: unknown): num is number {\n  if (typeof num === 'number') {\n    return num - num === 0\n  } else if (typeof num === 'string' && num.trim() !== '') {\n    return Number.isFinite(+num)\n  } else {\n    return false\n  }\n}\n","export function parseStrand(strand?: string) {\n  if (strand === '+') {\n    return 1\n  } else if (strand === '-') {\n    return -1\n  } else {\n    return undefined\n  }\n}\n\nexport function bufferToLines(buffer: Uint8Array) {\n  return new TextDecoder('utf8')\n    .decode(buffer)\n    .split(/\\n|\\r\\n|\\r/)\n    .map(f => f.trim())\n    .filter(f => !!f)\n}\n","import VCF from '@gmod/vcf'\nimport { VcfFeature } from '@jbrowse/plugin-variants'\n\nimport { isNumber } from './isNumber'\nimport { bufferToLines } from './util'\n\nexport function parseVcfBuffer(buffer: Uint8Array) {\n  const lines = bufferToLines(buffer)\n  const header = lines.filter(l => l.startsWith('#')).join('\\n')\n  const body = lines.filter(l => !l.startsWith('#'))\n  const vcfParser = new VCF({ header })\n  const keys = new Set<string>()\n  const rows = []\n  let i = 0\n  for (const line of body) {\n    const [CHROM, POS, ID, REF, ALT, QUAL, FILTER, INFO, FORMAT, ...rest] =\n      line.split('\\t')\n    const ret = Object.fromEntries(\n      INFO?.split(';')\n        .map(f => f.trim())\n        .map(e => {\n          const [key, val = 'true'] = e.split('=')\n          const k = `INFO.${key!.trim()}`\n          keys.add(k)\n          const v = val.trim()\n          return [k, isNumber(v) ? +v : v]\n        }) || [],\n    )\n    rows.push({\n      // what is displayed\n      cellData: {\n        CHROM,\n        POS: +POS!,\n        ID,\n        REF,\n        ALT,\n        QUAL: isNumber(QUAL) ? +QUAL : QUAL,\n        FILTER,\n        FORMAT,\n        ...ret,\n        ...Object.fromEntries(\n          vcfParser.samples.map((s, idx) => [s, rest[idx]]),\n        ),\n      },\n      // a simplefeatureserializd\n      feature: new VcfFeature({\n        parser: vcfParser,\n        variant: vcfParser.parseLine(line),\n        id: `vcf-${i}`,\n      }).toJSON(),\n    })\n    i++\n  }\n  return {\n    columns: [\n      'CHROM',\n      'POS',\n      'ID',\n      'REF',\n      'ALT',\n      'QUAL',\n      'FILTER',\n      ...keys,\n      'FORMAT',\n      ...vcfParser.samples,\n    ].map(c => ({ name: c })),\n    rowSet: {\n      rows,\n    },\n  }\n}\n"],"names":["isNumber","num","trim","Number","isFinite","parseStrand","strand","bufferToLines","buffer","TextDecoder","decode","split","map","f","filter","parseVcfBuffer","lines","header","l","startsWith","join","body","vcfParser","VCF","keys","Set","rows","i","line","CHROM","POS","ID","REF","ALT","QUAL","FILTER","INFO","FORMAT","rest","ret","Object","fromEntries","e","key","val","k","add","v","push","cellData","samples","s","idx","feature","VcfFeature","parser","variant","parseLine","id","toJSON","columns","c","name","rowSet"],"sourceRoot":""}