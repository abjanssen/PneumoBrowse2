{"version":3,"file":"static/js/2598.7b7273be.chunk.js","mappings":"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","sources":["../../../node_modules/@flatten-js/interval-tree/src/classes/Interval.ts","../../../node_modules/@flatten-js/interval-tree/src/classes/Node.ts","../../../node_modules/@flatten-js/interval-tree/src/utils/constants.ts","../../../node_modules/@flatten-js/interval-tree/src/classes/IntervalTree.ts"],"sourcesContent":["/**\n * Created by Alex Bol on 4/1/2017.\n */\n\n/**\n * Interval abstractions used by the interval tree.\n *\n * This module defines an abstract IntervalBase and several concrete interval types.\n * An interval represents a closed range [low, high] over a comparable domain. The base\n * class provides default semantics for 1D comparable endpoints (number, bigint, string, Date):\n * - Ordering: lexicographic by (low, then high) via less_than and equal_to.\n * - Intersection: two intervals intersect if neither ends strictly before the other.\n * - Augmentation: merge(other) returns a new interval spanning the union of ranges; this is\n *   used by the tree to maintain augmented \"max\" values (computed by merging), not via any\n *   static helpers.\n * - Serialization: output() returns a tuple [low, high] for external APIs.\n *\n * Specializations can override comparison and other behaviors:\n * - Interval (default export): 1D interval with default comparable endpoints.\n * - Interval2D: lexicographic 2D interval with endpoints as points [x, y]; overrides\n *   comparison and intersection in the lexicographic plane.\n *\n * Consumers may pass either:\n * - A concrete IntervalBase instance (e.g., new Interval2D(...)), or\n * - A numeric pair [low, high], which the tree converts to the default 1D Interval.\n *\n * See the TypeScript types in src/types.ts for Comparable and accepted IntervalInput forms.\n */\n\nimport type { Comparable } from '../types';\n\n// Abstract base for intervals. Concrete variants extend this.\nexport abstract class IntervalBase {\n    low: Comparable;\n    high: Comparable;\n\n    constructor(low: Comparable, high: Comparable) {\n        this.low = low;\n        this.high = high;\n    }\n\n    // Each concrete interval should implement clone to keep its own type\n    abstract clone(): IntervalBase;\n\n    get max(): IntervalBase {\n        return this.clone();\n    }\n\n    // Default numeric/date comparison (lexicographic by low then high)\n    less_than(other_interval: IntervalBase): boolean {\n        return (this.low as any) < (other_interval.low as any) ||\n            ((this.low as any) === (other_interval.low as any) && (this.high as any) < (other_interval.high as any));\n    }\n\n    equal_to(other_interval: IntervalBase): boolean {\n        return (this.low as any) === (other_interval.low as any) && (this.high as any) === (other_interval.high as any);\n    }\n\n    intersect(other_interval: IntervalBase): boolean {\n        return !this.not_intersect(other_interval);\n    }\n\n    not_intersect(other_interval: IntervalBase): boolean {\n        return ((this.high as any) < (other_interval.low as any) || (other_interval.high as any) < (this.low as any));\n    }\n\n    merge(other_interval: IntervalBase): IntervalBase {\n        // By default choose min low, max high using < and >\n        const low = (this.low === undefined)\n            ? other_interval.low\n            : (((this.low as any) < (other_interval.low as any)) ? this.low : other_interval.low);\n        const high = (this.high === undefined)\n            ? other_interval.high\n            : (((this.high as any) > (other_interval.high as any)) ? this.high : other_interval.high);\n        // Return instance of the same concrete class\n        const cloned = this.clone();\n        cloned.low = low;\n        cloned.high = high;\n        return cloned;\n    }\n\n    output(): [Comparable, Comparable] {\n        return [this.low, this.high];\n    }\n    \n    // Instance-level comparator so child classes can customize value comparison semantics\n    comparable_less_than(val1: Comparable, val2: Comparable): boolean {\n        return (val1 as any) < (val2 as any);\n    }\n}\n\n// 1D numeric/date interval (default)\nclass Interval extends IntervalBase {\n    clone(): Interval {\n        return new Interval(this.low, this.high);\n    }\n}\n\n\n// 2D interval with lexicographic comparison for points [x, y]\nexport class Interval2D extends IntervalBase {\n    constructor(low: [number, number], high: [number, number]) {\n        super(low, high);\n    }\n\n    private static pointLess(a: [number, number], b: [number, number]): boolean {\n        return a[0] < b[0] || (a[0] === b[0] && a[1] < b[1]);\n    }\n\n    private static pointEq(a: [number, number], b: [number, number]): boolean {\n        return a[0] === b[0] && a[1] === b[1];\n    }\n\n    clone(): Interval2D {\n        return new Interval2D(this.low as [number, number], this.high as [number, number]);\n    }\n\n    less_than(other: IntervalBase): boolean {\n        const a = this.low as [number, number];\n        const b = other.low as [number, number];\n        if (Interval2D.pointLess(a, b)) return true;\n        if (Interval2D.pointEq(a, b)) {\n            const ah = this.high as [number, number];\n            const bh = other.high as [number, number];\n            return Interval2D.pointLess(ah, bh);\n        }\n        return false;\n    }\n\n    equal_to(other: IntervalBase): boolean {\n        return Interval2D.pointEq(this.low as [number, number], other.low as [number, number]) &&\n            Interval2D.pointEq(this.high as [number, number], other.high as [number, number]);\n    }\n\n    not_intersect(other: IntervalBase): boolean {\n        // Non-intersection in lexicographic 2D ordering (simplistic): treat ranges in the ordered space\n        const highLess = Interval2D.pointLess(this.high as [number, number], other.low as [number, number]);\n        const otherHighLess = Interval2D.pointLess(other.high as [number, number], this.low as [number, number]);\n        return highLess || otherHighLess;\n    }\n\n    merge(other: IntervalBase): Interval2D {\n        const lowA = this.low as [number, number];\n        const lowB = other.low as [number, number];\n        const highA = this.high as [number, number];\n        const highB = other.high as [number, number];\n        const low = Interval2D.pointLess(lowA, lowB) ? lowA : lowB;\n        const high = Interval2D.pointLess(highA, highB) ? highB : highA;\n        return new Interval2D(low, high);\n    }\n\n    // Override value comparator to handle 2D points lexicographically\n    comparable_less_than(val1: [number, number], val2: [number, number]): boolean {\n        return Interval2D.pointLess(val1, val2);\n    }\n\n    output(): [[number, number], [number, number]] {\n        return [this.low as [number, number], this.high as [number, number]];\n    }\n}\n\nexport default Interval;\n\n","/**\n * Created by Alex Bol on 4/1/2017.\n */\n\nimport Interval, { IntervalBase } from './Interval';\nimport { RB_TREE_COLOR_BLACK, type NodeColor } from '../utils/constants';\nimport type {IntervalInput} from '../types';\n\nclass Node<V = any> {\n    left: Node<V> | null;\n    right: Node<V> | null;\n    parent: Node<V> | null;\n    color: NodeColor;\n    item: { key?: IntervalBase; values: V[] };\n    max: IntervalBase | undefined;\n\n    constructor(\n        key?: IntervalInput,\n        value?: V,\n        left: Node<V> | null = null,\n        right: Node<V> | null = null,\n        parent: Node<V> | null = null,\n        color: NodeColor = RB_TREE_COLOR_BLACK\n    ) {\n        this.left = left;\n        this.right = right;\n        this.parent = parent;\n        this.color = color;\n\n        this.item = { key: undefined, values: [] };\n        if (value !== undefined) {\n            this.item.values.push(value);\n        }\n\n        // Initialize key if provided\n        if (key !== undefined) {\n            if (Array.isArray(key)) {\n                const [rawLow, rawHigh] = key;\n                if (!Number.isNaN(rawLow) && !Number.isNaN(rawHigh)) {\n                    let low = rawLow;\n                    let high = rawHigh;\n                    if (low > high) [low, high] = [high, low];\n                    this.item.key = new Interval(low, high);\n                }\n            } else {\n                // Assume a concrete IntervalBase implementation was passed\n                this.item.key = key as IntervalBase;\n            }\n        }\n\n        this.max = this.item.key ? this.item.key.max : undefined;\n    }\n\n    isNil(): boolean {\n        return (\n            this.item.key === undefined &&\n            this.item.values.length === 0 &&\n            this.left === null &&\n            this.right === null &&\n            this.color === RB_TREE_COLOR_BLACK\n        );\n    }\n\n    private requireKey(): IntervalBase {\n        if (!this.item.key) {\n            throw new Error('Node key is undefined (nil/sentinel). Operation is not applicable.');\n        }\n        return this.item.key;\n    }\n\n    less_than(other_node: Node<V>): boolean {\n        // Compare nodes by key only; values are stored in a bucket\n        const a = this.requireKey();\n        const b = other_node.requireKey();\n        return a.less_than(b);\n    }\n\n    _value_equal(other_node: Node<V>): boolean {\n        // Deprecated in bucket mode; kept for backward compatibility if ever used\n        // Compare first elements if exist\n        const a = this.item.values[0] as any;\n        const b = other_node.item.values[0] as any;\n        return a && b && a.equal_to ? a.equal_to(b) : a === b;\n    }\n\n    equal_to(other_node: Node<V>): boolean {\n        // Nodes are equal if keys are equal; values are kept in a bucket\n        const a = this.requireKey();\n        const b = other_node.requireKey();\n        return a.equal_to(b);\n    }\n\n    intersect(other_node: Node<V>): boolean {\n        const a = this.requireKey();\n        const b = other_node.requireKey();\n        return a.intersect(b);\n    }\n\n    copy_data(other_node: Node<V>): void {\n        this.item.key = other_node.item.key;\n        this.item.values = other_node.item.values.slice();\n    }\n\n    update_max(): void {\n        // use key (Interval) max property instead of key.high\n        this.max = this.item.key ? this.item.key.max : undefined;\n\n        if (this.right && this.right.max) {\n            this.max = this.max ? this.max.merge(this.right.max) : this.right.max;\n        }\n\n        if (this.left && this.left.max) {\n            this.max = this.max ? this.max.merge(this.left.max) : this.left.max;\n        }\n    }\n\n    // Other_node does not intersect any node of left subtree\n    not_intersect_left_subtree(search_node: Node<V>): boolean {\n        if (!this.left) return true;\n        const high = this.left.max ? this.left.max.high : this.left.item.key!.high;\n        const selfKey = this.requireKey();\n        const searchKey = search_node.requireKey();\n        return selfKey.comparable_less_than(high, searchKey.low);\n    }\n\n    // Other_node does not intersect right subtree\n    not_intersect_right_subtree(search_node: Node<V>): boolean {\n        if (!this.right) return true;\n        const low = this.right.max ? this.right.max.low : this.right.item.key!.low;\n        const selfKey = this.requireKey();\n        const searchKey = search_node.requireKey();\n        return selfKey.comparable_less_than(searchKey.high, low);\n    }\n}\n\nexport default Node;\n","/**\n * Created by Alex Bol on 3/28/2017.\n */\n\n'use strict';\n\n// module.exports = {\n//     RB_TREE_COLOR_RED: 0,\n//     RB_TREE_COLOR_BLACK: 1\n// };\n\n/**\n * Red-Black Tree color constants\n */\nexport const RB_TREE_COLOR_RED = 1;\nexport const RB_TREE_COLOR_BLACK = 0;\n\nexport type NodeColor = typeof RB_TREE_COLOR_RED | typeof RB_TREE_COLOR_BLACK;\n\n","/**\n * Created by Alex Bol on 3/31/2017.\n */\n\nimport Node from './Node';\nimport { IntervalBase } from './Interval';\nimport { RB_TREE_COLOR_BLACK, RB_TREE_COLOR_RED } from '../utils/constants';\nimport type { IntervalInput } from '../types';\n\n/**\n * Implementation of interval binary search tree\n * Interval tree stores items which are couples of {key:interval, value: value}\n * Interval is an object with high and low properties or simply pair [low,high] of numeric values\n */\nclass IntervalTree<V = unknown> {\n    root: Node<V> | null;\n    nil_node: Node<V>;\n\n    /**\n     * Construct new empty instance of IntervalTree\n     */\n    constructor() {\n        this.root = null;\n        this.nil_node = new Node<V>();\n    }\n\n    /**\n     * Returns number of items stored in the interval tree\n     * @returns {number}\n     */\n    get size(): number {\n        let count = 0;\n        this.tree_walk(this.root, (node) => count += node.item.values.length);\n        return count;\n    }\n\n    /**\n     * Returns array of sorted keys in the ascending order\n     * @returns {Array}\n     */\n    get keys(): any[] {\n        const res: any[] = [];\n        this.tree_walk(this.root, (node) =>\n            res.push(node.item.key!.output())\n        );\n        return res;\n    }\n\n    /**\n     * Return array of values in the ascending keys order\n     * @returns {Array}\n     */\n    get values(): V[] {\n        const res: V[] = [];\n        this.tree_walk(this.root, (node) => {\n            for (const v of node.item.values) res.push(v);\n        });\n        return res;\n    }\n\n    /**\n     * Returns array of items (<key,value> pairs) in the ascended keys order\n     * @returns {Array}\n     */\n    get items(): Array<{ key: any; value: V }> {\n        const res: Array<{ key: any; value: V }> = [];\n        this.tree_walk(this.root, (node) => {\n            const keyOut = node.item.key!.output();\n            for (const v of node.item.values) {\n                res.push({ key: keyOut, value: v });\n            }\n        });\n        return res;\n    }\n\n    /**\n     * Returns true if tree is empty\n     * @returns {boolean}\n     */\n    isEmpty(): boolean {\n        return this.root == null || this.root === this.nil_node;\n    }\n\n    /**\n     * Clear tree\n     */\n    clear(): void {\n        this.root = null;\n    }\n\n    /**\n     * Insert new item into interval tree\n     * @param key - interval object or array of two numbers [low, high]\n     * @param value - value representing any object (optional)\n     * @returns returns reference to inserted node\n     */\n    insert(key: IntervalInput, value: V = key as any): Node<V> | undefined {\n        if (key === undefined) return;\n        // If node with the same key exists, append value to its bucket\n        const existing = this.tree_search(this.root, new Node<V>(key));\n        if (existing) {\n            existing.item.values.push(value as any);\n            return existing;\n        }\n        const insert_node = new Node<V>(key, value, this.nil_node, this.nil_node, null, RB_TREE_COLOR_RED);\n        this.tree_insert(insert_node);\n        this.recalc_max(insert_node);\n        return insert_node;\n    }\n\n    /**\n     * Returns true if item {key,value} exist in the tree\n     * @param key - interval correspondent to keys stored in the tree\n     * @param value - value object to be checked\n     * @returns true if item {key, value} exist in the tree, false otherwise\n     */\n    exist(key: IntervalInput, value: V = key as any): boolean {\n        const node = this.tree_search(this.root, new Node<V>(key));\n        if (!node) return false;\n        // If value is omitted (or equals key by default), treat as key existence\n        if (arguments.length < 2 || value === (key as any)) return true;\n        // Check if value exists in the bucket\n        return node.item.values.some((v: any) => (v && (v as any).equal_to ? (v as any).equal_to(value) : v === value));\n    }\n\n    /**\n     * Remove entry {key, value} from the tree\n     * @param key - interval correspondent to keys stored in the tree\n     * @param value - value object\n     * @returns deleted node or undefined if not found\n     */\n    remove(key: IntervalInput, value: V = key as any): Node<V> | undefined {\n        const node = this.tree_search(this.root, new Node<V>(key));\n        if (!node) return undefined;\n        // If value omitted, remove entire node\n        if (arguments.length < 2) {\n            this.tree_delete(node);\n            return node;\n        }\n        // Remove one matching value from bucket\n        const idx = node.item.values.findIndex((v: any) => (v && (v as any).equal_to ? (v as any).equal_to(value) : v === value));\n        if (idx >= 0) {\n            node.item.values.splice(idx, 1);\n            // If bucket is now empty, remove node from tree\n            if (node.item.values.length === 0) {\n                this.tree_delete(node);\n            }\n            return node;\n        }\n        return undefined;\n    }\n\n    /**\n     * Returns array of entry values which keys intersect with given interval\n     * If no values stored in the tree, returns array of keys which intersect given interval\n     * @param interval - search interval, or tuple [low, high]\n     * @param outputMapperFn - optional function that maps (value, key) to custom output\n     * @returns {Array}\n     */\n    // Overloads for better type inference\n    search(interval: IntervalInput): V[];\n    search<T>(interval: IntervalInput, outputMapperFn: (value: V, key: IntervalBase) => T): T[];\n    search(\n        interval: IntervalInput,\n        outputMapperFn: (value: V, key: IntervalBase) => any = (value, key) =>\n            value === (key as any) ? key.output() : value\n    ): any[] {\n        const search_node = new Node<V>(interval);\n        const resp_nodes: Node<V>[] = [];\n        this.tree_search_interval(this.root, search_node, resp_nodes);\n        const res: any[] = [];\n        for (const node of resp_nodes) {\n            for (const v of node.item.values) {\n                res.push(outputMapperFn(v, node.item.key!));\n            }\n        }\n        return res;\n    }\n\n    /**\n     * Returns true if intersection between given and any interval stored in the tree found\n     * @param interval - search interval or tuple [low, high]\n     * @returns {boolean}\n     */\n    intersect_any(interval: IntervalInput): boolean {\n        const search_node = new Node<V>(interval);\n        return this.tree_find_any_interval(this.root, search_node);\n    }\n\n    /**\n     * Tree visitor. For each node implement a callback function.\n     * Method calls a callback function with two parameters (key, value)\n     * @param visitor - function to be called for each tree item\n     */\n    forEach(visitor: (key: IntervalBase, value: V) => void): void {\n        this.tree_walk(this.root, (node) => {\n            for (const v of node.item.values) visitor(node.item.key!, v);\n        });\n    }\n\n    /**\n     * Value Mapper. Walk through every node and map node value to another value\n     * @param callback - function to be called for each tree item\n     */\n    map<U>(callback: (value: V, key: IntervalBase) => U): IntervalTree<U> {\n        const tree = new IntervalTree<U>();\n        this.tree_walk(this.root, (node) => {\n            for (const v of node.item.values) {\n                tree.insert(node.item.key!, callback(v, node.item.key!));\n            }\n        });\n        return tree;\n    }\n\n    /**\n     * Iterator\n     * @param interval - optional if the iterator is intended to start from the beginning\n     * @param outputMapperFn - optional function that maps (value, key) to custom output\n     * @returns {Iterator}\n     */\n    // Overloads for better type inference\n    iterate(): IterableIterator<V>;\n    iterate(interval: IntervalInput): IterableIterator<V>;\n    iterate<T>(interval: IntervalInput | undefined, outputMapperFn: (value: V, key: IntervalBase) => T): IterableIterator<T>;\n    *iterate(\n        interval?: IntervalInput,\n        outputMapperFn: (value: V, key: IntervalBase) => any = (value, key) =>\n            value === (key as any) ? key.output() : value\n    ): IterableIterator<any> {\n        let node: Node<V> | null = null;\n        if (interval) {\n            node = this.tree_search_nearest_forward(this.root, new Node<V>(interval));\n        } else if (this.root) {\n            node = this.local_minimum(this.root);\n        }\n        while (node) {\n            for (const v of node.item.values) {\n                yield outputMapperFn(v, node.item.key!);\n            }\n            node = this.tree_successor(node);\n        }\n    }\n\n    /**\n     * Recalculate max property upward from given node to root\n     * @param node - starting node\n     */\n    recalc_max(node: Node<V>): void {\n        let node_current = node;\n        while (node_current.parent != null) {\n            node_current.parent.update_max();\n            node_current = node_current.parent;\n        }\n    }\n\n    /**\n     * Insert node into tree and rebalance\n     * @param insert_node - node to insert\n     */\n    tree_insert(insert_node: Node<V>): void {\n        let current_node: Node<V> | null = this.root;\n        let parent_node: Node<V> | null = null;\n\n        if (this.root == null || this.root === this.nil_node) {\n            this.root = insert_node;\n        } else {\n            while (current_node !== this.nil_node) {\n                parent_node = current_node!;\n                if (insert_node.less_than(current_node!)) {\n                    current_node = current_node!.left;\n                } else {\n                    current_node = current_node!.right;\n                }\n            }\n\n            insert_node.parent = parent_node;\n\n            if (insert_node.less_than(parent_node!)) {\n                parent_node!.left = insert_node;\n            } else {\n                parent_node!.right = insert_node;\n            }\n        }\n\n        this.insert_fixup(insert_node);\n    }\n\n    /**\n     * Restore red-black tree properties after insertion\n     * @param insert_node - inserted node\n     */\n    insert_fixup(insert_node: Node<V>): void {\n        let current_node: Node<V>;\n        let uncle_node: Node<V>;\n\n        current_node = insert_node;\n        while (current_node !== this.root && current_node.parent!.color === RB_TREE_COLOR_RED) {\n            if (current_node.parent === current_node.parent!.parent!.left) {\n                uncle_node = current_node.parent!.parent!.right!;\n                if (uncle_node.color === RB_TREE_COLOR_RED) {\n                    current_node.parent!.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent!.parent!.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent!.parent!;\n                } else {\n                    if (current_node === current_node.parent!.right) {\n                        current_node = current_node.parent!;\n                        this.rotate_left(current_node);\n                    }\n                    current_node.parent!.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent!.parent!.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent!.parent!);\n                }\n            } else {\n                uncle_node = current_node.parent!.parent!.left!;\n                if (uncle_node.color === RB_TREE_COLOR_RED) {\n                    current_node.parent!.color = RB_TREE_COLOR_BLACK;\n                    uncle_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent!.parent!.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent!.parent!;\n                } else {\n                    if (current_node === current_node.parent!.left) {\n                        current_node = current_node.parent!;\n                        this.rotate_right(current_node);\n                    }\n                    current_node.parent!.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent!.parent!.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent!.parent!);\n                }\n            }\n        }\n\n        this.root!.color = RB_TREE_COLOR_BLACK;\n    }\n\n    /**\n     * Delete node from tree and rebalance\n     * @param delete_node - node to delete\n     */\n    tree_delete(delete_node: Node<V>): void {\n        let cut_node: Node<V>;\n        let fix_node: Node<V>;\n\n        if (delete_node.left === this.nil_node || delete_node.right === this.nil_node) {\n            cut_node = delete_node;\n        } else {\n            cut_node = this.tree_successor(delete_node)!;\n        }\n\n        if (cut_node.left !== this.nil_node) {\n            fix_node = cut_node.left!;\n        } else {\n            fix_node = cut_node.right!;\n        }\n\n        fix_node.parent = cut_node.parent;\n\n        if (cut_node === this.root) {\n            this.root = fix_node;\n        } else {\n            if (cut_node === cut_node.parent!.left) {\n                cut_node.parent!.left = fix_node;\n            } else {\n                cut_node.parent!.right = fix_node;\n            }\n            cut_node.parent!.update_max();\n        }\n\n        this.recalc_max(fix_node);\n\n        if (cut_node !== delete_node) {\n            delete_node.copy_data(cut_node);\n            delete_node.update_max();\n            this.recalc_max(delete_node);\n        }\n\n        if (cut_node.color === RB_TREE_COLOR_BLACK) {\n            this.delete_fixup(fix_node);\n        }\n    }\n\n    /**\n     * Restore red-black tree properties after deletion\n     * @param fix_node - node to fix from\n     */\n    delete_fixup(fix_node: Node<V>): void {\n        let current_node = fix_node;\n        let brother_node: Node<V>;\n\n        while (\n            current_node !== this.root &&\n            current_node.parent != null &&\n            current_node.color === RB_TREE_COLOR_BLACK\n            ) {\n            if (current_node === current_node.parent!.left) {\n                brother_node = current_node.parent!.right!;\n                if (brother_node.color === RB_TREE_COLOR_RED) {\n                    brother_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent!.color = RB_TREE_COLOR_RED;\n                    this.rotate_left(current_node.parent!);\n                    brother_node = current_node.parent!.right!;\n                }\n                if (\n                    brother_node.left!.color === RB_TREE_COLOR_BLACK &&\n                    brother_node.right!.color === RB_TREE_COLOR_BLACK\n                ) {\n                    brother_node.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent!;\n                } else {\n                    if (brother_node.right!.color === RB_TREE_COLOR_BLACK) {\n                        brother_node.color = RB_TREE_COLOR_RED;\n                        brother_node.left!.color = RB_TREE_COLOR_BLACK;\n                        this.rotate_right(brother_node);\n                        brother_node = current_node.parent!.right!;\n                    }\n                    brother_node.color = current_node.parent!.color;\n                    current_node.parent!.color = RB_TREE_COLOR_BLACK;\n                    brother_node.right!.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_left(current_node.parent!);\n                    current_node = this.root!;\n                }\n            } else {\n                brother_node = current_node.parent!.left!;\n                if (brother_node.color === RB_TREE_COLOR_RED) {\n                    brother_node.color = RB_TREE_COLOR_BLACK;\n                    current_node.parent!.color = RB_TREE_COLOR_RED;\n                    this.rotate_right(current_node.parent!);\n                    brother_node = current_node.parent!.left!;\n                }\n                if (\n                    brother_node.left!.color === RB_TREE_COLOR_BLACK &&\n                    brother_node.right!.color === RB_TREE_COLOR_BLACK\n                ) {\n                    brother_node.color = RB_TREE_COLOR_RED;\n                    current_node = current_node.parent!;\n                } else {\n                    if (brother_node.left!.color === RB_TREE_COLOR_BLACK) {\n                        brother_node.color = RB_TREE_COLOR_RED;\n                        brother_node.right!.color = RB_TREE_COLOR_BLACK;\n                        this.rotate_left(brother_node);\n                        brother_node = current_node.parent!.left!;\n                    }\n                    brother_node.color = current_node.parent!.color;\n                    current_node.parent!.color = RB_TREE_COLOR_BLACK;\n                    brother_node.left!.color = RB_TREE_COLOR_BLACK;\n                    this.rotate_right(current_node.parent!);\n                    current_node = this.root!;\n                }\n            }\n        }\n\n        current_node.color = RB_TREE_COLOR_BLACK;\n    }\n\n    /**\n     * Search for node with given key and value\n     * @param node - starting node\n     * @param search_node - node to search for\n     * @returns found node or undefined\n     */\n    tree_search(node: Node<V> | null, search_node: Node<V>): Node<V> | undefined {\n        if (node == null || node === this.nil_node) return undefined;\n\n        if (search_node.equal_to(node)) {\n            return node;\n        }\n        if (search_node.less_than(node)) {\n            return this.tree_search(node.left, search_node);\n        } else {\n            return this.tree_search(node.right, search_node);\n        }\n    }\n\n    /**\n     * Find nearest forward node from given interval\n     * @param node - starting node\n     * @param search_node - search interval as node\n     * @returns nearest forward node or null\n     */\n    tree_search_nearest_forward(node: Node<V> | null, search_node: Node<V>): Node<V> | null {\n        let best: Node<V> | null = null;\n        let curr = node;\n        while (curr && curr !== this.nil_node) {\n            if (curr.less_than(search_node)) {\n                if (curr.intersect(search_node)) {\n                    best = curr;\n                    curr = curr.left;\n                } else {\n                    curr = curr.right;\n                }\n            } else {\n                if (!best || curr.less_than(best)) best = curr;\n                curr = curr.left;\n            }\n        }\n        return best || null;\n    }\n\n    /**\n     * Search all intervals intersecting given interval\n     * @param node - starting node\n     * @param search_node - search interval as node\n     * @param res - result array to collect found nodes\n     */\n    tree_search_interval(node: Node<V> | null, search_node: Node<V>, res: Node<V>[]): void {\n        if (node != null && node !== this.nil_node) {\n            if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                this.tree_search_interval(node.left, search_node, res);\n            }\n            if (node.intersect(search_node)) {\n                res.push(node);\n            }\n            if (node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                this.tree_search_interval(node.right, search_node, res);\n            }\n        }\n    }\n\n    /**\n     * Check if any interval intersects with given interval\n     * @param node - starting node\n     * @param search_node - search interval as node\n     * @returns true if intersection found\n     */\n    tree_find_any_interval(node: Node<V> | null, search_node: Node<V>): boolean {\n        let found = false;\n        if (node != null && node !== this.nil_node) {\n            if (node.left !== this.nil_node && !node.not_intersect_left_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.left, search_node);\n            }\n            if (!found) {\n                found = node.intersect(search_node);\n            }\n            if (!found && node.right !== this.nil_node && !node.not_intersect_right_subtree(search_node)) {\n                found = this.tree_find_any_interval(node.right, search_node);\n            }\n        }\n        return found;\n    }\n\n    /**\n     * Find node with minimum key in subtree\n     * @param node - root of subtree\n     * @returns node with minimum key\n     */\n    local_minimum(node: Node<V>): Node<V> {\n        let node_min = node;\n        while (node_min.left != null && node_min.left !== this.nil_node) {\n            node_min = node_min.left;\n        }\n        return node_min;\n    }\n\n    /**\n     * Find node with maximum key in subtree\n     * @param node - root of subtree\n     * @returns node with maximum key\n     */\n    local_maximum(node: Node<V>): Node<V> {\n        let node_max = node;\n        while (node_max.right != null && node_max.right !== this.nil_node) {\n            node_max = node_max.right;\n        }\n        return node_max;\n    }\n\n    /**\n     * Find successor node (next in sorted order)\n     * @param node - current node\n     * @returns successor node or null\n     */\n    tree_successor(node: Node<V>): Node<V> | null {\n        let node_successor: Node<V> | null;\n        let current_node: Node<V>;\n        let parent_node: Node<V> | null;\n\n        if (node.right !== this.nil_node) {\n            node_successor = this.local_minimum(node.right!);\n        } else {\n            current_node = node;\n            parent_node = node.parent;\n            while (parent_node != null && parent_node.right === current_node) {\n                current_node = parent_node;\n                parent_node = parent_node.parent;\n            }\n            node_successor = parent_node;\n        }\n        return node_successor;\n    }\n\n    /**\n     * Left rotation around node x\n     * @param x - node to rotate\n     */\n    rotate_left(x: Node<V>): void {\n        const y = x.right!;\n\n        x.right = y.left;\n\n        if (y.left !== this.nil_node) {\n            y.left!.parent = x;\n        }\n        y.parent = x.parent;\n\n        if (x === this.root) {\n            this.root = y;\n        } else {\n            if (x === x.parent!.left) {\n                x.parent!.left = y;\n            } else {\n                x.parent!.right = y;\n            }\n        }\n        y.left = x;\n        x.parent = y;\n\n        if (x !== null && x !== this.nil_node) {\n            x.update_max();\n        }\n\n        if (y != null && y !== this.nil_node) {\n            y.update_max();\n        }\n    }\n\n    /**\n     * Right rotation around node y\n     * @param y - node to rotate\n     */\n    rotate_right(y: Node<V>): void {\n        const x = y.left!;\n\n        y.left = x.right;\n\n        if (x.right !== this.nil_node) {\n            x.right!.parent = y;\n        }\n        x.parent = y.parent;\n\n        if (y === this.root) {\n            this.root = x;\n        } else {\n            if (y === y.parent!.left) {\n                y.parent!.left = x;\n            } else {\n                y.parent!.right = x;\n            }\n        }\n        x.right = y;\n        y.parent = x;\n\n        if (y !== null && y !== this.nil_node) {\n            y.update_max();\n        }\n\n        if (x != null && x !== this.nil_node) {\n            x.update_max();\n        }\n    }\n\n    /**\n     * Performs in-order traversal of the tree\n     * Applies action callback to each node in ascending order of keys\n     * @param node - starting node for traversal (typically root)\n     * @param action - callback function to be executed for each node\n     */\n    tree_walk(node: Node<V> | null, action: (node: Node<V>) => void): void {\n        if (node != null && node !== this.nil_node) {\n            this.tree_walk(node.left, action);\n            action(node);\n            this.tree_walk(node.right, action);\n        }\n    }\n\n    /**\n     * Test red-black tree property: all red nodes have exactly two black child nodes\n     * @returns true if property holds\n     */\n    testRedBlackProperty(): boolean {\n        let res = true;\n        this.tree_walk(this.root, function (node) {\n            if (node.color === RB_TREE_COLOR_RED) {\n                if (\n                    !(\n                        node.left!.color === RB_TREE_COLOR_BLACK &&\n                        node.right!.color === RB_TREE_COLOR_BLACK\n                    )\n                ) {\n                    res = false;\n                }\n            }\n        });\n        return res;\n    }\n\n    /**\n     * Test red-black tree property: every path from root to leaf has same black height\n     * @param node - starting node\n     * @returns black height\n     * @throws Error if property is violated\n     */\n    testBlackHeightProperty(node: Node<V>): number {\n        let height = 0;\n        let heightLeft = 0;\n        let heightRight = 0;\n        if (node.color === RB_TREE_COLOR_BLACK) {\n            height++;\n        }\n        if (node.left !== this.nil_node) {\n            heightLeft = this.testBlackHeightProperty(node.left!);\n        } else {\n            heightLeft = 1;\n        }\n        if (node.right !== this.nil_node) {\n            heightRight = this.testBlackHeightProperty(node.right!);\n        } else {\n            heightRight = 1;\n        }\n        if (heightLeft !== heightRight) {\n            throw new Error('Red-black height property violated');\n        }\n        height += heightLeft;\n        return height;\n    }\n}\n\nexport default IntervalTree;\n"],"names":["IntervalBase","constructor","low","high","this","max","clone","less_than","other_interval","equal_to","intersect","not_intersect","merge","undefined","cloned","output","comparable_less_than","val1","val2","Interval","Node","key","value","left","right","parent","color","item","values","push","Array","isArray","rawLow","rawHigh","Number","isNaN","isNil","length","requireKey","Error","other_node","a","b","_value_equal","copy_data","slice","update_max","not_intersect_left_subtree","search_node","selfKey","searchKey","not_intersect_right_subtree","IntervalTree","root","nil_node","size","count","tree_walk","node","keys","res","v","items","keyOut","isEmpty","clear","insert","existing","tree_search","insert_node","tree_insert","recalc_max","exist","arguments","some","remove","tree_delete","idx","findIndex","splice","search","interval","outputMapperFn","resp_nodes","tree_search_interval","intersect_any","tree_find_any_interval","forEach","visitor","map","callback","tree","iterate","tree_search_nearest_forward","local_minimum","tree_successor","node_current","current_node","parent_node","insert_fixup","uncle_node","rotate_left","rotate_right","delete_node","cut_node","fix_node","delete_fixup","brother_node","best","curr","found","node_min","local_maximum","node_max","node_successor","x","y","action","testRedBlackProperty","testBlackHeightProperty","height","heightLeft","heightRight"],"sourceRoot":""}