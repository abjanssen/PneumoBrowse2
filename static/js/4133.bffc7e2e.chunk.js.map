{"version":3,"file":"static/js/4133.bffc7e2e.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts","../../../node_modules/@gmod/bam/src/virtualOffset.ts","../../../node_modules/@gmod/bam/src/chunk.ts","../../../node_modules/@gmod/bam/src/util.ts","../../../node_modules/@gmod/bam/src/indexFile.ts","../../../node_modules/@gmod/bam/src/bai.ts","../../../node_modules/@gmod/bam/src/csi.ts","../../../node_modules/@gmod/bam/src/constants.ts","../../../node_modules/@gmod/bam/src/record.ts","../../../node_modules/@gmod/bam/src/sam.ts","../../../node_modules/@gmod/bam/src/bamFile.ts","../../../node_modules/@gmod/bam/src/htsget.ts","../../../node_modules/@gmod/bam/node_modules/buffer/index.js","../../../node_modules/crc/mjs/calculators/crc32.js","../../../node_modules/crc/mjs/create_buffer.js","../../../node_modules/crc/mjs/crc32.js","../../../node_modules/crc/mjs/define_crc.js"],"sourcesContent":["class NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter {\n  callbacks = new Set<Function>()\n  currentMessage: unknown\n\n  addCallback(callback: Function = () => {}): void {\n    this.callbacks.add(callback)\n    callback(this.currentMessage)\n  }\n\n  callback(message: unknown) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController'\nimport AggregateStatusReporter from './AggregateStatusReporter'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: Function,\n) => Promise<U>\n\ninterface Entry<U> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U>>\n  private fillCallback: FillCallback<T, U>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U>\n    cache: Cache<Entry<U>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(key: string, data: T, signal?: AbortSignal, statusCallback?: Function) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: unknown) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch(error => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      error => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: Function,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n","export default class VirtualOffset {\n  public blockPosition: number\n  public dataPosition: number\n  constructor(blockPosition: number, dataPosition: number) {\n    this.blockPosition = blockPosition // < offset of the compressed data block\n    this.dataPosition = dataPosition // < offset into the uncompressed data\n  }\n\n  toString() {\n    return `${this.blockPosition}:${this.dataPosition}`\n  }\n\n  compareTo(b: VirtualOffset) {\n    return (\n      this.blockPosition - b.blockPosition || this.dataPosition - b.dataPosition\n    )\n  }\n\n  static min(...args: VirtualOffset[]) {\n    let min\n    let i = 0\n    for (; !min; i += 1) {\n      min = args[i]\n    }\n    for (; i < args.length; i += 1) {\n      if (min.compareTo(args[i]) > 0) {\n        min = args[i]\n      }\n    }\n    return min\n  }\n}\nexport function fromBytes(bytes: Buffer, offset = 0, bigendian = false) {\n  if (bigendian) {\n    throw new Error('big-endian virtual file offsets not implemented')\n  }\n\n  return new VirtualOffset(\n    bytes[offset + 7] * 0x10000000000 +\n      bytes[offset + 6] * 0x100000000 +\n      bytes[offset + 5] * 0x1000000 +\n      bytes[offset + 4] * 0x10000 +\n      bytes[offset + 3] * 0x100 +\n      bytes[offset + 2],\n    (bytes[offset + 1] << 8) | bytes[offset],\n  )\n}\n","import VirtualOffset from './virtualOffset'\n\n// little class representing a chunk in the index\nexport default class Chunk {\n  public buffer?: Buffer\n\n  constructor(\n    public minv: VirtualOffset,\n    public maxv: VirtualOffset,\n    public bin: number,\n    public _fetchedSize?: number,\n  ) {}\n\n  toUniqueString() {\n    return `${this.minv.toString()}..${this.maxv.toString()} (bin ${\n      this.bin\n    }, fetchedSize ${this.fetchedSize()})`\n  }\n\n  toString() {\n    return this.toUniqueString()\n  }\n\n  compareTo(b: Chunk) {\n    return (\n      this.minv.compareTo(b.minv) ||\n      this.maxv.compareTo(b.maxv) ||\n      this.bin - b.bin\n    )\n  }\n\n  fetchedSize() {\n    if (this._fetchedSize !== undefined) {\n      return this._fetchedSize\n    }\n    return this.maxv.blockPosition + (1 << 16) - this.minv.blockPosition\n  }\n}\n","import Long from 'long'\nimport Chunk from './chunk'\nimport VirtualOffset from './virtualOffset'\n\nexport function timeout(ms: number) {\n  return new Promise(resolve => setTimeout(resolve, ms))\n}\n\n/**\n * Properly check if the given AbortSignal is aborted.\n * Per the standard, if the signal reads as aborted,\n * this function throws either a DOMException AbortError, or a regular error\n * with a `code` attribute set to `ERR_ABORTED`.\n *\n * For convenience, passing `undefined` is a no-op\n *\n * @param {AbortSignal} [signal] an AbortSignal, or anything with an `aborted` attribute\n * @returns nothing\n */\nexport function checkAbortSignal(signal?: AbortSignal) {\n  if (!signal) {\n    return\n  }\n\n  if (signal.aborted) {\n    // console.log('bam aborted!')\n    if (typeof DOMException === 'undefined') {\n      const e = new Error('aborted')\n      //@ts-ignore\n      e.code = 'ERR_ABORTED'\n      throw e\n    } else {\n      throw new DOMException('aborted', 'AbortError')\n    }\n  }\n}\n\n/**\n * Skips to the next tick, then runs `checkAbortSignal`.\n * Await this to inside an otherwise synchronous loop to\n * provide a place to break when an abort signal is received.\n * @param {AbortSignal} signal\n */\nexport async function abortBreakPoint(signal?: AbortSignal) {\n  await Promise.resolve()\n  checkAbortSignal(signal)\n}\n\nexport function canMergeBlocks(chunk1: Chunk, chunk2: Chunk) {\n  return (\n    chunk2.minv.blockPosition - chunk1.maxv.blockPosition < 65000 &&\n    chunk2.maxv.blockPosition - chunk1.minv.blockPosition < 5000000\n  )\n}\n\nexport interface BamOpts {\n  viewAsPairs?: boolean\n  pairAcrossChr?: boolean\n  maxInsertSize?: number\n  signal?: AbortSignal\n}\n\nexport interface BaseOpts {\n  signal?: AbortSignal\n}\n\nexport function makeOpts(obj: AbortSignal | BaseOpts = {}): BaseOpts {\n  return 'aborted' in obj ? ({ signal: obj } as BaseOpts) : obj\n}\n\nexport function optimizeChunks(chunks: Chunk[], lowest?: VirtualOffset) {\n  const mergedChunks: Chunk[] = []\n  let lastChunk: Chunk | undefined\n\n  if (chunks.length === 0) {\n    return chunks\n  }\n\n  chunks.sort((c0, c1) => {\n    const dif = c0.minv.blockPosition - c1.minv.blockPosition\n    return dif === 0 ? c0.minv.dataPosition - c1.minv.dataPosition : dif\n  })\n\n  for (const chunk of chunks) {\n    if (!lowest || chunk.maxv.compareTo(lowest) > 0) {\n      if (lastChunk === undefined) {\n        mergedChunks.push(chunk)\n        lastChunk = chunk\n      } else {\n        if (canMergeBlocks(lastChunk, chunk)) {\n          if (chunk.maxv.compareTo(lastChunk.maxv) > 0) {\n            lastChunk.maxv = chunk.maxv\n          }\n        } else {\n          mergedChunks.push(chunk)\n          lastChunk = chunk\n        }\n      }\n    }\n  }\n\n  return mergedChunks\n}\n\nexport function parsePseudoBin(bytes: Buffer, offset: number) {\n  return {\n    lineCount: Long.fromBytesLE(\n      Array.prototype.slice.call(bytes, offset, offset + 8),\n      true,\n    ).toNumber(),\n  }\n}\n\nexport function findFirstData(\n  firstDataLine: VirtualOffset | undefined,\n  virtualOffset: VirtualOffset,\n) {\n  return firstDataLine\n    ? firstDataLine.compareTo(virtualOffset) > 0\n      ? virtualOffset\n      : firstDataLine\n    : virtualOffset\n}\n\nexport function parseNameBytes(\n  namesBytes: Buffer,\n  renameRefSeq: (arg: string) => string = s => s,\n) {\n  let currRefId = 0\n  let currNameStart = 0\n  const refIdToName = []\n  const refNameToId: Record<string, number> = {}\n  for (let i = 0; i < namesBytes.length; i += 1) {\n    if (!namesBytes[i]) {\n      if (currNameStart < i) {\n        let refName = namesBytes.toString('utf8', currNameStart, i)\n        refName = renameRefSeq(refName)\n        refIdToName[currRefId] = refName\n        refNameToId[refName] = currRefId\n      }\n      currNameStart = i + 1\n      currRefId += 1\n    }\n  }\n  return { refNameToId, refIdToName }\n}\n","import { GenericFilehandle } from 'generic-filehandle'\nimport Chunk from './chunk'\nimport { BaseOpts } from './util'\n\nexport default abstract class IndexFile {\n  public filehandle: GenericFilehandle\n  public renameRefSeq: (s: string) => string\n\n  /**\n   * @param {filehandle} filehandle\n   * @param {function} [renameRefSeqs]\n   */\n  constructor({\n    filehandle,\n    renameRefSeq = (n: string) => n,\n  }: {\n    filehandle: GenericFilehandle\n    renameRefSeq?: (a: string) => string\n  }) {\n    this.filehandle = filehandle\n    this.renameRefSeq = renameRefSeq\n  }\n  public abstract lineCount(refId: number): Promise<number>\n  public abstract indexCov(\n    refId: number,\n    start?: number,\n    end?: number,\n  ): Promise<{ start: number; end: number; score: number }[]>\n\n  public abstract blocksForRange(\n    chrId: number,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ): Promise<Chunk[]>\n}\n","import VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\n\nimport { optimizeChunks, parsePseudoBin, findFirstData, BaseOpts } from './util'\nimport IndexFile from './indexFile'\n\nconst BAI_MAGIC = 21578050 // BAI\\1\n\nfunction roundDown(n: number, multiple: number) {\n  return n - (n % multiple)\n}\nfunction roundUp(n: number, multiple: number) {\n  return n - (n % multiple) + multiple\n}\n\nfunction reg2bins(beg: number, end: number) {\n  end -= 1\n  return [\n    [0, 0],\n    [1 + (beg >> 26), 1 + (end >> 26)],\n    [9 + (beg >> 23), 9 + (end >> 23)],\n    [73 + (beg >> 20), 73 + (end >> 20)],\n    [585 + (beg >> 17), 585 + (end >> 17)],\n    [4681 + (beg >> 14), 4681 + (end >> 14)],\n  ] as const\n}\n\nexport default class BAI extends IndexFile {\n  public setupP?: ReturnType<BAI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices[refId]?.stats?.lineCount || 0\n  }\n\n  // fetch and parse the index\n  async _parse(opts?: BaseOpts) {\n    const bytes = (await this.filehandle.readFile(opts)) as Buffer\n\n    // check BAI magic numbers\n    if (bytes.readUInt32LE(0) !== BAI_MAGIC) {\n      throw new Error('Not a BAI file')\n    }\n\n    const refCount = bytes.readInt32LE(4)\n    const depth = 5\n    const binLimit = ((1 << ((depth + 1) * 3)) - 1) / 7\n\n    // read the indexes for each reference sequence\n    let curr = 8\n    let firstDataLine: VirtualOffset | undefined\n\n    type BinIndex = Record<string, Chunk[]>\n    type LinearIndex = VirtualOffset[]\n    const indices = new Array<{\n      binIndex: BinIndex\n      linearIndex: LinearIndex\n      stats?: { lineCount: number }\n    }>(refCount)\n    for (let i = 0; i < refCount; i++) {\n      // the binning index\n      const binCount = bytes.readInt32LE(curr)\n      let stats\n\n      curr += 4\n      const binIndex: Record<number, Chunk[]> = {}\n\n      for (let j = 0; j < binCount; j += 1) {\n        const bin = bytes.readUInt32LE(curr)\n        curr += 4\n        if (bin === binLimit + 1) {\n          curr += 4\n          stats = parsePseudoBin(bytes, curr + 16)\n          curr += 32\n        } else if (bin > binLimit + 1) {\n          throw new Error('bai index contains too many bins, please use CSI')\n        } else {\n          const chunkCount = bytes.readInt32LE(curr)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k++) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      const linearCount = bytes.readInt32LE(curr)\n      curr += 4\n      // as we're going through the linear index, figure out the smallest\n      // virtual offset in the indexes, which tells us where the BAM header\n      // ends\n      const linearIndex = new Array<VirtualOffset>(linearCount)\n      for (let j = 0; j < linearCount; j++) {\n        const offset = fromBytes(bytes, curr)\n        curr += 8\n        firstDataLine = findFirstData(firstDataLine, offset)\n        linearIndex[j] = offset\n      }\n\n      indices[i] = { binIndex, linearIndex, stats }\n    }\n\n    return {\n      bai: true,\n      firstDataLine,\n      maxBlockSize: 1 << 16,\n      indices,\n      refCount,\n    }\n  }\n\n  async indexCov(\n    seqId: number,\n    start?: number,\n    end?: number,\n    opts: BaseOpts = {},\n  ): Promise<{ start: number; end: number; score: number }[]> {\n    const v = 16384\n    const range = start !== undefined\n    const indexData = await this.parse(opts)\n    const seqIdx = indexData.indices[seqId]\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!seqIdx) {\n      return []\n    }\n    const { linearIndex = [], stats } = seqIdx\n    if (linearIndex.length === 0) {\n      return []\n    }\n    const e = end === undefined ? (linearIndex.length - 1) * v : roundUp(end, v)\n    const s = start === undefined ? 0 : roundDown(start, v)\n    const depths = range\n      ? new Array((e - s) / v)\n      : new Array(linearIndex.length - 1)\n    const totalSize = linearIndex[linearIndex.length - 1].blockPosition\n    if (e > (linearIndex.length - 1) * v) {\n      throw new Error('query outside of range of linear index')\n    }\n    let currentPos = linearIndex[s / v].blockPosition\n    for (let i = s / v, j = 0; i < e / v; i++, j++) {\n      depths[j] = {\n        score: linearIndex[i + 1].blockPosition - currentPos,\n        start: i * v,\n        end: i * v + v,\n      }\n      currentPos = linearIndex[i + 1].blockPosition\n    }\n    return depths.map(d => ({\n      ...d,\n      score: (d.score * (stats?.lineCount || 0)) / totalSize,\n    }))\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!indexData) {\n      return []\n    }\n    const ba = indexData.indices[refId]\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!ba) {\n      return []\n    }\n\n    // List of bin #s that overlap min, max\n    const overlappingBins = reg2bins(min, max)\n    const chunks: Chunk[] = []\n\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (const binChunk of binChunks) {\n            chunks.push(new Chunk(binChunk.minv, binChunk.maxv, bin))\n          }\n        }\n      }\n    }\n\n    // Use the linear index to find minimum file position of chunks that could\n    // contain alignments in the region\n    const nintv = ba.linearIndex.length\n    let lowest: VirtualOffset | undefined\n    const minLin = Math.min(min >> 14, nintv - 1)\n    const maxLin = Math.min(max >> 14, nintv - 1)\n    for (let i = minLin; i <= maxLin; ++i) {\n      const vp = ba.linearIndex[i]\n\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (vp && (!lowest || vp.compareTo(lowest) < 0)) {\n        lowest = vp\n      }\n    }\n\n    return optimizeChunks(chunks, lowest)\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices[seqId]?.binIndex\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\nimport VirtualOffset, { fromBytes } from './virtualOffset'\nimport Chunk from './chunk'\nimport {\n  optimizeChunks,\n  findFirstData,\n  parsePseudoBin,\n  parseNameBytes,\n  BaseOpts,\n} from './util'\n\nimport IndexFile from './indexFile'\n\nconst CSI1_MAGIC = 21582659 // CSI\\1\nconst CSI2_MAGIC = 38359875 // CSI\\2\n\nfunction lshift(num: number, bits: number) {\n  return num * 2 ** bits\n}\nfunction rshift(num: number, bits: number) {\n  return Math.floor(num / 2 ** bits)\n}\n\nexport default class CSI extends IndexFile {\n  private maxBinNumber = 0\n  private depth = 0\n  private minShift = 0\n\n  public setupP?: ReturnType<CSI['_parse']>\n\n  async lineCount(refId: number, opts?: BaseOpts) {\n    const indexData = await this.parse(opts)\n    return indexData.indices[refId]?.stats?.lineCount || 0\n  }\n\n  async indexCov() {\n    return []\n  }\n\n  parseAuxData(bytes: Buffer, offset: number) {\n    const formatFlags = bytes.readInt32LE(offset)\n    const coordinateType =\n      formatFlags & 0x10000 ? 'zero-based-half-open' : '1-based-closed'\n    const format = (\n      { 0: 'generic', 1: 'SAM', 2: 'VCF' } as Record<number, string>\n    )[formatFlags & 0xf]\n    if (!format) {\n      throw new Error(`invalid Tabix preset format flags ${formatFlags}`)\n    }\n    const columnNumbers = {\n      ref: bytes.readInt32LE(offset + 4),\n      start: bytes.readInt32LE(offset + 8),\n      end: bytes.readInt32LE(offset + 12),\n    }\n    const metaValue = bytes.readInt32LE(offset + 16)\n    const metaChar = metaValue ? String.fromCharCode(metaValue) : ''\n    const skipLines = bytes.readInt32LE(offset + 20)\n    const nameSectionLength = bytes.readInt32LE(offset + 24)\n\n    return {\n      columnNumbers,\n      coordinateType,\n      metaValue,\n      metaChar,\n      skipLines,\n      format,\n      formatFlags,\n      ...parseNameBytes(\n        bytes.subarray(offset + 28, offset + 28 + nameSectionLength),\n        this.renameRefSeq,\n      ),\n    }\n  }\n\n  // fetch and parse the index\n  async _parse(opts: { signal?: AbortSignal }) {\n    const buffer = await this.filehandle.readFile(opts)\n    const bytes = await unzip(buffer)\n\n    let csiVersion\n    // check TBI magic numbers\n    if (bytes.readUInt32LE(0) === CSI1_MAGIC) {\n      csiVersion = 1\n    } else if (bytes.readUInt32LE(0) === CSI2_MAGIC) {\n      csiVersion = 2\n    } else {\n      throw new Error('Not a CSI file')\n      // TODO: do we need to support big-endian CSI files?\n    }\n\n    this.minShift = bytes.readInt32LE(4)\n    this.depth = bytes.readInt32LE(8)\n    this.maxBinNumber = ((1 << ((this.depth + 1) * 3)) - 1) / 7\n    const auxLength = bytes.readInt32LE(12)\n    const aux = auxLength >= 30 ? this.parseAuxData(bytes, 16) : undefined\n    const refCount = bytes.readInt32LE(16 + auxLength)\n\n    type BinIndex = Record<string, Chunk[]>\n\n    // read the indexes for each reference sequence\n    let curr = 16 + auxLength + 4\n    let firstDataLine: VirtualOffset | undefined\n    const indices = new Array<{\n      binIndex: BinIndex\n      stats?: { lineCount: number }\n    }>(refCount)\n    for (let i = 0; i < refCount; i++) {\n      // the binning index\n      const binCount = bytes.readInt32LE(curr)\n      curr += 4\n      const binIndex: Record<string, Chunk[]> = {}\n      let stats // < provided by parsing a pseudo-bin, if present\n      for (let j = 0; j < binCount; j++) {\n        const bin = bytes.readUInt32LE(curr)\n        curr += 4\n        if (bin > this.maxBinNumber) {\n          stats = parsePseudoBin(bytes, curr + 28)\n          curr += 28 + 16\n        } else {\n          firstDataLine = findFirstData(firstDataLine, fromBytes(bytes, curr))\n          curr += 8\n          const chunkCount = bytes.readInt32LE(curr)\n          curr += 4\n          const chunks = new Array<Chunk>(chunkCount)\n          for (let k = 0; k < chunkCount; k += 1) {\n            const u = fromBytes(bytes, curr)\n            curr += 8\n            const v = fromBytes(bytes, curr)\n            curr += 8\n            firstDataLine = findFirstData(firstDataLine, u)\n            chunks[k] = new Chunk(u, v, bin)\n          }\n          binIndex[bin] = chunks\n        }\n      }\n\n      indices[i] = { binIndex, stats }\n    }\n\n    return {\n      csiVersion,\n      firstDataLine,\n      indices,\n      refCount,\n      csi: true,\n      maxBlockSize: 1 << 16,\n      ...aux,\n    }\n  }\n\n  async blocksForRange(\n    refId: number,\n    min: number,\n    max: number,\n    opts: BaseOpts = {},\n  ) {\n    if (min < 0) {\n      min = 0\n    }\n\n    const indexData = await this.parse(opts)\n    const ba = indexData.indices[refId]\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (!ba) {\n      return []\n    }\n    const overlappingBins = this.reg2bins(min, max)\n\n    if (overlappingBins.length === 0) {\n      return []\n    }\n\n    const chunks = []\n    // Find chunks in overlapping bins.  Leaf bins (< 4681) are not pruned\n    for (const [start, end] of overlappingBins) {\n      for (let bin = start; bin <= end; bin++) {\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (ba.binIndex[bin]) {\n          const binChunks = ba.binIndex[bin]\n          for (const c of binChunks) {\n            chunks.push(c)\n          }\n        }\n      }\n    }\n\n    return optimizeChunks(chunks, new VirtualOffset(0, 0))\n  }\n\n  /**\n   * calculate the list of bins that may overlap with region [beg,end)\n   * (zero-based half-open)\n   */\n  reg2bins(beg: number, end: number) {\n    beg -= 1 // < convert to 1-based closed\n    if (beg < 1) {\n      beg = 1\n    }\n    if (end > 2 ** 50) {\n      end = 2 ** 34\n    } // 17 GiB ought to be enough for anybody\n    end -= 1\n    let l = 0\n    let t = 0\n    let s = this.minShift + this.depth * 3\n    const bins = []\n    for (; l <= this.depth; s -= 3, t += lshift(1, l * 3), l += 1) {\n      const b = t + rshift(beg, s)\n      const e = t + rshift(end, s)\n      if (e - b + bins.length > this.maxBinNumber) {\n        throw new Error(\n          `query ${beg}-${end} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`,\n        )\n      }\n      bins.push([b, e] as const)\n    }\n    return bins\n  }\n\n  async parse(opts: BaseOpts = {}) {\n    if (!this.setupP) {\n      this.setupP = this._parse(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async hasRefSeq(seqId: number, opts: BaseOpts = {}) {\n    const header = await this.parse(opts)\n    return !!header.indices[seqId]?.binIndex\n  }\n}\n","export default {\n  //  the read is paired in sequencing, no matter whether it is mapped in a pair\n  BAM_FPAIRED: 1,\n  //  the read is mapped in a proper pair\n  BAM_FPROPER_PAIR: 2,\n  //  the read itself is unmapped; conflictive with BAM_FPROPER_PAIR\n  BAM_FUNMAP: 4,\n  //  the mate is unmapped\n  BAM_FMUNMAP: 8,\n  //  the read is mapped to the reverse strand\n  BAM_FREVERSE: 16,\n  //  the mate is mapped to the reverse strand\n  BAM_FMREVERSE: 32,\n  //  this is read1\n  BAM_FREAD1: 64,\n  //  this is read2\n  BAM_FREAD2: 128,\n  //  not primary alignment\n  BAM_FSECONDARY: 256,\n  //  QC failure\n  BAM_FQCFAIL: 512,\n  //  optical or PCR duplicate\n  BAM_FDUP: 1024,\n  //  supplementary alignment\n  BAM_FSUPPLEMENTARY: 2048,\n}\n","import Constants from './constants'\nimport type { Buffer } from 'buffer'\n\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('')\nconst CIGAR_DECODER = 'MIDNSHP=X???????'.split('')\n\ninterface Bytes {\n  start: number\n  end: number\n  byteArray: Buffer\n}\nexport default class BamRecord {\n  public fileOffset: number\n  private bytes: Bytes\n\n  constructor(args: { bytes: Bytes; fileOffset: number }) {\n    this.bytes = args.bytes\n    this.fileOffset = args.fileOffset\n  }\n\n  get byteArray() {\n    return this.bytes.byteArray\n  }\n\n  get flags() {\n    return (\n      (this.byteArray.readInt32LE(this.bytes.start + 16) & 0xffff0000) >> 16\n    )\n  }\n  get ref_id() {\n    return this.byteArray.readInt32LE(this.bytes.start + 4)\n  }\n\n  get start() {\n    return this.byteArray.readInt32LE(this.bytes.start + 8)\n  }\n\n  get end() {\n    return this.start + this.length_on_ref\n  }\n\n  get id() {\n    return this.fileOffset\n  }\n\n  get mq() {\n    const mq = (this.bin_mq_nl & 0xff00) >> 8\n    return mq === 255 ? undefined : mq\n  }\n\n  get score() {\n    return this.mq\n  }\n\n  get qual() {\n    if (this.isSegmentUnmapped()) {\n      return\n    }\n\n    const p =\n      this.b0 +\n      this.read_name_length +\n      this.num_cigar_ops * 4 +\n      this.num_seq_bytes\n    return this.byteArray.subarray(p, p + this.seq_length)\n  }\n\n  get strand() {\n    return this.isReverseComplemented() ? -1 : 1\n  }\n\n  get b0() {\n    return this.bytes.start + 36\n  }\n  get name() {\n    return this.byteArray.toString(\n      'ascii',\n      this.b0,\n      this.b0 + this.read_name_length - 1,\n    )\n  }\n\n  get tags() {\n    const { byteArray } = this.bytes\n    let p =\n      this.b0 +\n      this.read_name_length +\n      this.num_cigar_ops * 4 +\n      this.num_seq_bytes +\n      this.seq_length\n\n    const blockEnd = this.bytes.end\n    const tags = {} as Record<string, unknown>\n    while (p < blockEnd) {\n      const tag = String.fromCharCode(byteArray[p], byteArray[p + 1])\n      const type = String.fromCharCode(byteArray[p + 2])\n      p += 3\n\n      if (type === 'A') {\n        tags[tag] = String.fromCharCode(byteArray[p])\n        p += 1\n      } else if (type === 'i') {\n        tags[tag] = byteArray.readInt32LE(p)\n        p += 4\n      } else if (type === 'I') {\n        tags[tag] = byteArray.readUInt32LE(p)\n        p += 4\n      } else if (type === 'c') {\n        tags[tag] = byteArray.readInt8(p)\n        p += 1\n      } else if (type === 'C') {\n        tags[tag] = byteArray.readUInt8(p)\n        p += 1\n      } else if (type === 's') {\n        tags[tag] = byteArray.readInt16LE(p)\n        p += 2\n      } else if (type === 'S') {\n        tags[tag] = byteArray.readUInt16LE(p)\n        p += 2\n      } else if (type === 'f') {\n        tags[tag] = byteArray.readFloatLE(p)\n        p += 4\n      } else if (type === 'Z' || type === 'H') {\n        const value = []\n        while (p <= blockEnd) {\n          const cc = byteArray[p++]\n          if (cc !== 0) {\n            value.push(String.fromCharCode(cc))\n          } else {\n            break\n          }\n        }\n        tags[tag] = value.join('')\n      } else if (type === 'B') {\n        const cc = byteArray[p++]\n        const Btype = String.fromCharCode(cc)\n        const limit = byteArray.readInt32LE(p)\n        p += 4\n        if (Btype === 'i') {\n          if (tag === 'CG') {\n            const value = []\n            for (let k = 0; k < limit; k++) {\n              const cigop = byteArray.readInt32LE(p)\n              const lop = cigop >> 4\n              const op = CIGAR_DECODER[cigop & 0xf]\n              value.push(lop + op)\n              p += 4\n            }\n            tags[tag] = value.join('')\n          } else {\n            const value = []\n            for (let k = 0; k < limit; k++) {\n              value.push(byteArray.readInt32LE(p))\n              p += 4\n            }\n            tags[tag] = value\n          }\n        } else if (Btype === 'I') {\n          if (tag === 'CG') {\n            const value = []\n            for (let k = 0; k < limit; k++) {\n              const cigop = byteArray.readUInt32LE(p)\n              const lop = cigop >> 4\n              const op = CIGAR_DECODER[cigop & 0xf]\n              value.push(lop + op)\n              p += 4\n            }\n            tags[tag] = value.join('')\n          } else {\n            const value = []\n            for (let k = 0; k < limit; k++) {\n              value.push(byteArray.readUInt32LE(p))\n              p += 4\n            }\n            tags[tag] = value\n          }\n        } else if (Btype === 's') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(byteArray.readInt16LE(p))\n            p += 2\n          }\n          tags[tag] = value\n        } else if (Btype === 'S') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(byteArray.readUInt16LE(p))\n            p += 2\n          }\n          tags[tag] = value\n        } else if (Btype === 'c') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(byteArray.readInt8(p))\n            p += 1\n          }\n          tags[tag] = value\n        } else if (Btype === 'C') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(byteArray.readUInt8(p))\n            p += 1\n          }\n          tags[tag] = value\n        } else if (Btype === 'f') {\n          const value = []\n          for (let k = 0; k < limit; k++) {\n            value.push(byteArray.readFloatLE(p))\n            p += 4\n          }\n          tags[tag] = value\n        }\n      } else {\n        console.error('Unknown BAM tag type', type)\n        break\n      }\n    }\n    return tags\n  }\n\n  /**\n   * @returns {boolean} true if the read is paired, regardless of whether both\n   * segments are mapped\n   */\n  isPaired() {\n    return !!(this.flags & Constants.BAM_FPAIRED)\n  }\n\n  /** @returns {boolean} true if the read is paired, and both segments are mapped */\n  isProperlyPaired() {\n    return !!(this.flags & Constants.BAM_FPROPER_PAIR)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isSegmentUnmapped() {\n    return !!(this.flags & Constants.BAM_FUNMAP)\n  }\n\n  /** @returns {boolean} true if the read itself is unmapped; conflictive with isProperlyPaired */\n  isMateUnmapped() {\n    return !!(this.flags & Constants.BAM_FMUNMAP)\n  }\n\n  /** @returns {boolean} true if the read is mapped to the reverse strand */\n  isReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FREVERSE)\n  }\n\n  /** @returns {boolean} true if the mate is mapped to the reverse strand */\n  isMateReverseComplemented() {\n    return !!(this.flags & Constants.BAM_FMREVERSE)\n  }\n\n  /** @returns {boolean} true if this is read number 1 in a pair */\n  isRead1() {\n    return !!(this.flags & Constants.BAM_FREAD1)\n  }\n\n  /** @returns {boolean} true if this is read number 2 in a pair */\n  isRead2() {\n    return !!(this.flags & Constants.BAM_FREAD2)\n  }\n\n  /** @returns {boolean} true if this is a secondary alignment */\n  isSecondary() {\n    return !!(this.flags & Constants.BAM_FSECONDARY)\n  }\n\n  /** @returns {boolean} true if this read has failed QC checks */\n  isFailedQc() {\n    return !!(this.flags & Constants.BAM_FQCFAIL)\n  }\n\n  /** @returns {boolean} true if the read is an optical or PCR duplicate */\n  isDuplicate() {\n    return !!(this.flags & Constants.BAM_FDUP)\n  }\n\n  /** @returns {boolean} true if this is a supplementary alignment */\n  isSupplementary() {\n    return !!(this.flags & Constants.BAM_FSUPPLEMENTARY)\n  }\n\n  get cigarAndLength() {\n    if (this.isSegmentUnmapped()) {\n      return {\n        length_on_ref: 0,\n        CIGAR: '',\n      }\n    }\n\n    const numCigarOps = this.num_cigar_ops\n    let p = this.b0 + this.read_name_length\n    const CIGAR = []\n\n    // check for CG tag by inspecting whether the CIGAR field contains a clip\n    // that consumes entire seqLen\n    let cigop = this.byteArray.readInt32LE(p)\n    let lop = cigop >> 4\n    let op = CIGAR_DECODER[cigop & 0xf]\n    if (op === 'S' && lop === this.seq_length) {\n      // if there is a CG the second CIGAR field will be a N tag the represents\n      // the length on ref\n      p += 4\n      cigop = this.byteArray.readInt32LE(p)\n      lop = cigop >> 4\n      op = CIGAR_DECODER[cigop & 0xf]\n      if (op !== 'N') {\n        console.warn('CG tag with no N tag')\n      }\n      return {\n        CIGAR: this.tags.CG as string,\n        length_on_ref: lop,\n      }\n    } else {\n      let lref = 0\n      for (let c = 0; c < numCigarOps; ++c) {\n        cigop = this.byteArray.readInt32LE(p)\n        lop = cigop >> 4\n        op = CIGAR_DECODER[cigop & 0xf]\n        CIGAR.push(lop + op)\n        // soft clip, hard clip, and insertion don't count toward the length on\n        // the reference\n        if (op !== 'H' && op !== 'S' && op !== 'I') {\n          lref += lop\n        }\n\n        p += 4\n      }\n\n      return {\n        CIGAR: CIGAR.join(''),\n        length_on_ref: lref,\n      }\n    }\n  }\n\n  get length_on_ref() {\n    return this.cigarAndLength.length_on_ref\n  }\n\n  get CIGAR() {\n    return this.cigarAndLength.CIGAR\n  }\n\n  get num_cigar_ops() {\n    return this.flag_nc & 0xffff\n  }\n\n  get read_name_length() {\n    return this.bin_mq_nl & 0xff\n  }\n\n  get num_seq_bytes() {\n    return (this.seq_length + 1) >> 1\n  }\n\n  get seq() {\n    const { byteArray } = this.bytes\n    const p = this.b0 + this.read_name_length + this.num_cigar_ops * 4\n    const seqBytes = this.num_seq_bytes\n    const len = this.seq_length\n    const buf = []\n    let i = 0\n    for (let j = 0; j < seqBytes; ++j) {\n      const sb = byteArray[p + j]\n      buf.push(SEQRET_DECODER[(sb & 0xf0) >> 4])\n      i++\n      if (i < len) {\n        buf.push(SEQRET_DECODER[sb & 0x0f])\n        i++\n      }\n    }\n    return buf.join('')\n  }\n\n  // adapted from igv.js\n  get pair_orientation() {\n    if (\n      !this.isSegmentUnmapped() &&\n      !this.isMateUnmapped() &&\n      this.ref_id === this.next_refid\n    ) {\n      const s1 = this.isReverseComplemented() ? 'R' : 'F'\n      const s2 = this.isMateReverseComplemented() ? 'R' : 'F'\n      let o1 = ' '\n      let o2 = ' '\n      if (this.isRead1()) {\n        o1 = '1'\n        o2 = '2'\n      } else if (this.isRead2()) {\n        o1 = '2'\n        o2 = '1'\n      }\n\n      const tmp = []\n      const isize = this.template_length\n      if (isize > 0) {\n        tmp[0] = s1\n        tmp[1] = o1\n        tmp[2] = s2\n        tmp[3] = o2\n      } else {\n        tmp[2] = s1\n        tmp[3] = o1\n        tmp[0] = s2\n        tmp[1] = o2\n      }\n      return tmp.join('')\n    }\n    return undefined\n  }\n\n  get bin_mq_nl() {\n    return this.byteArray.readInt32LE(this.bytes.start + 12)\n  }\n\n  get flag_nc() {\n    return this.byteArray.readInt32LE(this.bytes.start + 16)\n  }\n\n  get seq_length() {\n    return this.byteArray.readInt32LE(this.bytes.start + 20)\n  }\n\n  get next_refid() {\n    return this.byteArray.readInt32LE(this.bytes.start + 24)\n  }\n\n  get next_pos() {\n    return this.byteArray.readInt32LE(this.bytes.start + 28)\n  }\n\n  get template_length() {\n    return this.byteArray.readInt32LE(this.bytes.start + 32)\n  }\n\n  toJSON() {\n    const data: Record<string, any> = {}\n    for (const k of Object.keys(this)) {\n      if (k.startsWith('_') || k === 'bytes') {\n        continue\n      }\n      //@ts-ignore\n      data[k] = this[k]\n    }\n\n    return data\n  }\n}\n\nfunction cacheGetter<T>(ctor: { prototype: T }, prop: keyof T): void {\n  const desc = Object.getOwnPropertyDescriptor(ctor.prototype, prop)\n  if (!desc) {\n    throw new Error('OH NO, NO PROPERTY DESCRIPTOR')\n  }\n  // eslint-disable-next-line @typescript-eslint/unbound-method\n  const getter = desc.get\n  if (!getter) {\n    throw new Error('OH NO, NOT A GETTER')\n  }\n  Object.defineProperty(ctor.prototype, prop, {\n    get() {\n      const ret = getter.call(this)\n      Object.defineProperty(this, prop, { value: ret })\n      return ret\n    },\n  })\n}\n\ncacheGetter(BamRecord, 'tags')\ncacheGetter(BamRecord, 'cigarAndLength')\ncacheGetter(BamRecord, 'seq')\ncacheGetter(BamRecord, 'qual')\n","export function parseHeaderText(text: string) {\n  const lines = text.split(/\\r?\\n/)\n  const data: { tag: string; data: { tag: string; value: string }[] }[] = []\n  for (const line of lines) {\n    const [tag, ...fields] = line.split(/\\t/)\n    if (tag) {\n      data.push({\n        tag: tag.slice(1),\n        data: fields.map(f => {\n          const r = f.indexOf(':')\n          const fieldTag = f.slice(0, r)\n          const value = f.slice(r + 1)\n          return { tag: fieldTag, value }\n        }),\n      })\n    }\n  }\n  return data\n}\n","import { Buffer } from 'buffer'\nimport crc32 from 'crc/crc32'\nimport { unzip, unzipChunkSlice } from '@gmod/bgzf-filehandle'\nimport { LocalFile, RemoteFile, GenericFilehandle } from 'generic-filehandle'\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport QuickLRU from 'quick-lru'\n\n// locals\nimport BAI from './bai'\nimport CSI from './csi'\nimport Chunk from './chunk'\nimport BAMFeature from './record'\nimport { parseHeaderText } from './sam'\nimport { checkAbortSignal, timeout, makeOpts, BamOpts, BaseOpts } from './util'\n\nexport const BAM_MAGIC = 21840194\n\nconst blockLen = 1 << 16\n\nasync function gen2array<T>(gen: AsyncIterable<T[]>): Promise<T[]> {\n  let out: T[] = []\n  for await (const x of gen) {\n    out = out.concat(x)\n  }\n  return out\n}\n\ninterface Args {\n  chunk: Chunk\n  opts: BaseOpts\n}\n\nclass NullFilehandle {\n  public read(): Promise<any> {\n    throw new Error('never called')\n  }\n  public stat(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public readFile(): Promise<any> {\n    throw new Error('never called')\n  }\n\n  public close(): Promise<any> {\n    throw new Error('never called')\n  }\n}\nexport default class BamFile {\n  public renameRefSeq: (a: string) => string\n  public bam: GenericFilehandle\n  public header?: string\n  public chrToIndex?: Record<string, number>\n  public indexToChr?: { refName: string; length: number }[]\n  public yieldThreadTime: number\n  public index?: BAI | CSI\n  public htsget = false\n  public headerP?: ReturnType<BamFile['getHeaderPre']>\n\n  private featureCache = new AbortablePromiseCache<Args, BAMFeature[]>({\n    cache: new QuickLRU({\n      maxSize: 50,\n    }),\n    fill: async (args: Args, signal) => {\n      const { chunk, opts } = args\n      const { data, cpositions, dpositions } = await this._readChunk({\n        chunk,\n        opts: { ...opts, signal },\n      })\n      return this.readBamFeatures(data, cpositions, dpositions, chunk)\n    },\n  })\n\n  constructor({\n    bamFilehandle,\n    bamPath,\n    bamUrl,\n    baiPath,\n    baiFilehandle,\n    baiUrl,\n    csiPath,\n    csiFilehandle,\n    csiUrl,\n    htsget,\n    yieldThreadTime = 100,\n    renameRefSeqs = n => n,\n  }: {\n    bamFilehandle?: GenericFilehandle\n    bamPath?: string\n    bamUrl?: string\n    baiPath?: string\n    baiFilehandle?: GenericFilehandle\n    baiUrl?: string\n    csiPath?: string\n    csiFilehandle?: GenericFilehandle\n    csiUrl?: string\n    renameRefSeqs?: (a: string) => string\n    yieldThreadTime?: number\n    htsget?: boolean\n  }) {\n    this.renameRefSeq = renameRefSeqs\n\n    if (bamFilehandle) {\n      this.bam = bamFilehandle\n    } else if (bamPath) {\n      this.bam = new LocalFile(bamPath)\n    } else if (bamUrl) {\n      this.bam = new RemoteFile(bamUrl)\n    } else if (htsget) {\n      this.htsget = true\n      this.bam = new NullFilehandle()\n    } else {\n      throw new Error('unable to initialize bam')\n    }\n    if (csiFilehandle) {\n      this.index = new CSI({ filehandle: csiFilehandle })\n    } else if (csiPath) {\n      this.index = new CSI({ filehandle: new LocalFile(csiPath) })\n    } else if (csiUrl) {\n      this.index = new CSI({ filehandle: new RemoteFile(csiUrl) })\n    } else if (baiFilehandle) {\n      this.index = new BAI({ filehandle: baiFilehandle })\n    } else if (baiPath) {\n      this.index = new BAI({ filehandle: new LocalFile(baiPath) })\n    } else if (baiUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(baiUrl) })\n    } else if (bamPath) {\n      this.index = new BAI({ filehandle: new LocalFile(`${bamPath}.bai`) })\n    } else if (bamUrl) {\n      this.index = new BAI({ filehandle: new RemoteFile(`${bamUrl}.bai`) })\n    } else if (htsget) {\n      this.htsget = true\n    } else {\n      throw new Error('unable to infer index format')\n    }\n    this.yieldThreadTime = yieldThreadTime\n  }\n\n  async getHeaderPre(origOpts?: BaseOpts) {\n    const opts = makeOpts(origOpts)\n    if (!this.index) {\n      return\n    }\n    const indexData = await this.index.parse(opts)\n    const ret = indexData.firstDataLine\n      ? indexData.firstDataLine.blockPosition + 65535\n      : undefined\n    let buffer\n    if (ret) {\n      const s = ret + blockLen\n      const res = await this.bam.read(Buffer.alloc(s), 0, s, 0, opts)\n      if (!res.bytesRead) {\n        throw new Error('Error reading header')\n      }\n      buffer = res.buffer.subarray(0, Math.min(res.bytesRead, ret))\n    } else {\n      buffer = await this.bam.readFile(opts)\n    }\n\n    const uncba = await unzip(buffer)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n\n    this.header = uncba.toString('utf8', 8, 8 + headLen)\n    const { chrToIndex, indexToChr } = await this._readRefSeqs(\n      headLen + 8,\n      65535,\n      opts,\n    )\n    this.chrToIndex = chrToIndex\n    this.indexToChr = indexToChr\n\n    return parseHeaderText(this.header)\n  }\n\n  getHeader(opts?: BaseOpts) {\n    if (!this.headerP) {\n      this.headerP = this.getHeaderPre(opts).catch((e: unknown) => {\n        this.headerP = undefined\n        throw e\n      })\n    }\n    return this.headerP\n  }\n\n  async getHeaderText(opts: BaseOpts = {}) {\n    await this.getHeader(opts)\n    return this.header\n  }\n\n  // the full length of the refseq block is not given in advance so this grabs\n  // a chunk and doubles it if all refseqs haven't been processed\n  async _readRefSeqs(\n    start: number,\n    refSeqBytes: number,\n    opts?: BaseOpts,\n  ): Promise<{\n    chrToIndex: Record<string, number>\n    indexToChr: { refName: string; length: number }[]\n  }> {\n    if (start > refSeqBytes) {\n      return this._readRefSeqs(start, refSeqBytes * 2, opts)\n    }\n    const size = refSeqBytes + blockLen\n    const { bytesRead, buffer } = await this.bam.read(\n      Buffer.alloc(size),\n      0,\n      refSeqBytes,\n      0,\n      opts,\n    )\n    if (!bytesRead) {\n      throw new Error('Error reading refseqs from header')\n    }\n    const uncba = await unzip(\n      buffer.subarray(0, Math.min(bytesRead, refSeqBytes)),\n    )\n    const nRef = uncba.readInt32LE(start)\n    let p = start + 4\n    const chrToIndex: Record<string, number> = {}\n    const indexToChr: { refName: string; length: number }[] = []\n    for (let i = 0; i < nRef; i += 1) {\n      const lName = uncba.readInt32LE(p)\n      const refName = this.renameRefSeq(\n        uncba.toString('utf8', p + 4, p + 4 + lName - 1),\n      )\n      const lRef = uncba.readInt32LE(p + lName + 4)\n\n      chrToIndex[refName] = i\n      indexToChr.push({ refName, length: lRef })\n\n      p = p + 8 + lName\n      if (p > uncba.length) {\n        console.warn(\n          `BAM header is very big.  Re-fetching ${refSeqBytes} bytes.`,\n        )\n        return this._readRefSeqs(start, refSeqBytes * 2, opts)\n      }\n    }\n    return { chrToIndex, indexToChr }\n  }\n\n  async getRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    return gen2array(this.streamRecordsForRange(chr, min, max, opts))\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    await this.getHeader(opts)\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined || !this.index) {\n      yield []\n    } else {\n      const chunks = await this.index.blocksForRange(chrId, min - 1, max, opts)\n      yield* this._fetchChunkFeatures(chunks, chrId, min, max, opts)\n    }\n  }\n\n  async *_fetchChunkFeatures(\n    chunks: Chunk[],\n    chrId: number,\n    min: number,\n    max: number,\n    opts: BamOpts = {},\n  ) {\n    const { viewAsPairs } = opts\n    const feats = [] as BAMFeature[][]\n    let done = false\n\n    for (const chunk of chunks) {\n      const records = await this.featureCache.get(\n        chunk.toString(),\n        { chunk, opts },\n        opts.signal,\n      )\n\n      const recs = [] as BAMFeature[]\n      for (const feature of records) {\n        if (feature.ref_id === chrId) {\n          if (feature.start >= max) {\n            // past end of range, can stop iterating\n            done = true\n            break\n          } else if (feature.end >= min) {\n            // must be in range\n            recs.push(feature)\n          }\n        }\n      }\n      feats.push(recs)\n      yield recs\n      if (done) {\n        break\n      }\n    }\n\n    checkAbortSignal(opts.signal)\n    if (viewAsPairs) {\n      yield this.fetchPairs(chrId, feats, opts)\n    }\n  }\n\n  async fetchPairs(chrId: number, feats: BAMFeature[][], opts: BamOpts) {\n    const { pairAcrossChr, maxInsertSize = 200000 } = opts\n    const unmatedPairs: Record<string, boolean> = {}\n    const readIds: Record<string, number> = {}\n    feats.map(ret => {\n      const readNames: Record<string, number> = {}\n      for (const element of ret) {\n        const name = element.name\n        const id = element.id\n        if (!readNames[name]) {\n          readNames[name] = 0\n        }\n        readNames[name]++\n        readIds[id] = 1\n      }\n      for (const [k, v] of Object.entries(readNames)) {\n        if (v === 1) {\n          unmatedPairs[k] = true\n        }\n      }\n    })\n\n    const matePromises: Promise<Chunk[]>[] = []\n    feats.map(ret => {\n      for (const f of ret) {\n        const name = f.name\n        const start = f.start\n        const pnext = f.next_pos\n        const rnext = f.next_refid\n        if (\n          this.index &&\n          unmatedPairs[name] &&\n          (pairAcrossChr ||\n            (rnext === chrId && Math.abs(start - pnext) < maxInsertSize))\n        ) {\n          matePromises.push(\n            this.index.blocksForRange(rnext, pnext, pnext + 1, opts),\n          )\n        }\n      }\n    })\n\n    // filter out duplicate chunks (the blocks are lists of chunks, blocks are\n    // concatenated, then filter dup chunks)\n    const map = new Map<string, Chunk>()\n    const res = await Promise.all(matePromises)\n    for (const m of res.flat()) {\n      if (!map.has(m.toString())) {\n        map.set(m.toString(), m)\n      }\n    }\n\n    const mateFeatPromises = await Promise.all(\n      [...map.values()].map(async c => {\n        const { data, cpositions, dpositions, chunk } = await this._readChunk({\n          chunk: c,\n          opts,\n        })\n        const mateRecs = [] as BAMFeature[]\n        for (const feature of await this.readBamFeatures(\n          data,\n          cpositions,\n          dpositions,\n          chunk,\n        )) {\n          if (unmatedPairs[feature.name] && !readIds[feature.id]) {\n            mateRecs.push(feature)\n          }\n        }\n        return mateRecs\n      }),\n    )\n    return mateFeatPromises.flat()\n  }\n\n  async _readRegion(position: number, size: number, opts: BaseOpts = {}) {\n    const { bytesRead, buffer } = await this.bam.read(\n      Buffer.alloc(size),\n      0,\n      size,\n      position,\n      opts,\n    )\n\n    return buffer.subarray(0, Math.min(bytesRead, size))\n  }\n\n  async _readChunk({ chunk, opts }: { chunk: Chunk; opts: BaseOpts }) {\n    const buffer = await this._readRegion(\n      chunk.minv.blockPosition,\n      chunk.fetchedSize(),\n      opts,\n    )\n\n    const {\n      buffer: data,\n      cpositions,\n      dpositions,\n    } = await unzipChunkSlice(buffer, chunk)\n    return { data, cpositions, dpositions, chunk }\n  }\n\n  async readBamFeatures(\n    ba: Buffer,\n    cpositions: number[],\n    dpositions: number[],\n    chunk: Chunk,\n  ) {\n    let blockStart = 0\n    const sink = [] as BAMFeature[]\n    let pos = 0\n    let last = +Date.now()\n\n    while (blockStart + 4 < ba.length) {\n      const blockSize = ba.readInt32LE(blockStart)\n      const blockEnd = blockStart + 4 + blockSize - 1\n\n      // increment position to the current decompressed status\n      // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n      if (dpositions) {\n        while (blockStart + chunk.minv.dataPosition >= dpositions[pos++]) {}\n        pos--\n      }\n\n      // only try to read the feature if we have all the bytes for it\n      if (blockEnd < ba.length) {\n        const feature = new BAMFeature({\n          bytes: {\n            byteArray: ba,\n            start: blockStart,\n            end: blockEnd,\n          },\n          // the below results in an automatically calculated file-offset based\n          // ID if the info for that is available, otherwise crc32 of the\n          // features\n          //\n          // cpositions[pos] refers to actual file offset of a bgzip block\n          // boundaries\n          //\n          // we multiply by (1 <<8) in order to make sure each block has a\n          // \"unique\" address space so that data in that block could never\n          // overlap\n          //\n          // then the blockStart-dpositions is an uncompressed file offset from\n          // that bgzip block boundary, and since the cpositions are multiplied\n          // by (1 << 8) these uncompressed offsets get a unique space\n          //\n          // this has an extra chunk.minv.dataPosition added on because it\n          // blockStart starts at 0 instead of chunk.minv.dataPosition\n          //\n          // the +1 is just to avoid any possible uniqueId 0 but this does not\n          // realistically happen\n          fileOffset:\n            cpositions.length > 0\n              ? cpositions[pos] * (1 << 8) +\n                (blockStart - dpositions[pos]) +\n                chunk.minv.dataPosition +\n                1\n              : // must be slice, not subarray for buffer polyfill on web\n                // eslint-disable-next-line @typescript-eslint/no-deprecated\n                crc32.signed(ba.slice(blockStart, blockEnd)),\n        })\n\n        sink.push(feature)\n        if (this.yieldThreadTime && +Date.now() - last > this.yieldThreadTime) {\n          await timeout(1)\n          last = +Date.now()\n        }\n      }\n\n      blockStart = blockEnd + 1\n    }\n    return sink\n  }\n\n  async hasRefSeq(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? false : this.index?.hasRefSeq(seqId)\n  }\n\n  async lineCount(seqName: string) {\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined || !this.index ? 0 : this.index.lineCount(seqId)\n  }\n\n  async indexCov(seqName: string, start?: number, end?: number) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined ? [] : this.index.indexCov(seqId, start, end)\n  }\n\n  async blocksForRange(\n    seqName: string,\n    start: number,\n    end: number,\n    opts?: BaseOpts,\n  ) {\n    if (!this.index) {\n      return []\n    }\n    await this.index.parse()\n    const seqId = this.chrToIndex?.[seqName]\n    return seqId === undefined\n      ? []\n      : this.index.blocksForRange(seqId, start, end, opts)\n  }\n}\n","import { unzip } from '@gmod/bgzf-filehandle'\nimport { Buffer } from 'buffer'\nimport { BaseOpts, BamOpts } from './util'\nimport BamFile, { BAM_MAGIC } from './bamFile'\nimport Chunk from './chunk'\nimport { parseHeaderText } from './sam'\n\ninterface HtsgetChunk {\n  url: string\n  headers?: Record<string, string>\n}\nasync function concat(arr: HtsgetChunk[], opts?: Record<string, any>) {\n  const res = await Promise.all(\n    arr.map(async chunk => {\n      const { url, headers } = chunk\n      if (url.startsWith('data:')) {\n        return Buffer.from(url.split(',')[1], 'base64')\n      } else {\n        //remove referer header, it is not even allowed to be specified\n        // @ts-expect-error\n\n        const { referer, ...rest } = headers\n        const res = await fetch(url, {\n          ...opts,\n          headers: { ...opts?.headers, ...rest },\n        })\n        if (!res.ok) {\n          throw new Error(\n            `HTTP ${res.status} fetching ${url}: ${await res.text()}`,\n          )\n        }\n        return Buffer.from(await res.arrayBuffer())\n      }\n    }),\n  )\n\n  return Buffer.concat(await Promise.all(res.map(elt => unzip(elt))))\n}\n\nexport default class HtsgetFile extends BamFile {\n  private baseUrl: string\n\n  private trackId: string\n\n  constructor(args: { trackId: string; baseUrl: string }) {\n    super({ htsget: true })\n    this.baseUrl = args.baseUrl\n    this.trackId = args.trackId\n  }\n\n  async *streamRecordsForRange(\n    chr: string,\n    min: number,\n    max: number,\n    opts?: BamOpts,\n  ) {\n    const base = `${this.baseUrl}/${this.trackId}`\n    const url = `${base}?referenceName=${chr}&start=${min}&end=${max}&format=BAM`\n    const chrId = this.chrToIndex?.[chr]\n    if (chrId === undefined) {\n      yield []\n    } else {\n      const result = await fetch(url, { ...opts })\n      if (!result.ok) {\n        throw new Error(\n          `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n        )\n      }\n      const data = await result.json()\n      const uncba = await concat(data.htsget.urls.slice(1), opts)\n\n      yield* this._fetchChunkFeatures(\n        [\n          // fake stuff to pretend to be a Chunk\n          {\n            buffer: uncba,\n            _fetchedSize: undefined,\n            bin: 0,\n            compareTo() {\n              return 0\n            },\n            toUniqueString() {\n              return `${chr}_${min}_${max}`\n            },\n            fetchedSize() {\n              return 0\n            },\n            minv: {\n              dataPosition: 0,\n              blockPosition: 0,\n              compareTo: () => 0,\n            },\n            maxv: {\n              dataPosition: Number.MAX_SAFE_INTEGER,\n              blockPosition: 0,\n              compareTo: () => 0,\n            },\n            toString() {\n              return `${chr}_${min}_${max}`\n            },\n          },\n        ],\n        chrId,\n        min,\n        max,\n        opts,\n      )\n    }\n  }\n\n  async _readChunk({ chunk }: { chunk: Chunk; opts: BaseOpts }) {\n    if (!chunk.buffer) {\n      throw new Error('expected chunk.buffer in htsget')\n    }\n    return { data: chunk.buffer, cpositions: [], dpositions: [], chunk }\n  }\n\n  async getHeader(opts: BaseOpts = {}) {\n    const url = `${this.baseUrl}/${this.trackId}?referenceName=na&class=header`\n    const result = await fetch(url, opts)\n    if (!result.ok) {\n      throw new Error(\n        `HTTP ${result.status} fetching ${url}: ${await result.text()}`,\n      )\n    }\n    const data = await result.json()\n    const uncba = await concat(data.htsget.urls, opts)\n\n    if (uncba.readInt32LE(0) !== BAM_MAGIC) {\n      throw new Error('Not a BAM file')\n    }\n    const headLen = uncba.readInt32LE(4)\n    const headerText = uncba.toString('utf8', 8, 8 + headLen)\n    const samHeader = parseHeaderText(headerText)\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ref ID numbers and names\n    const idToName: { refName: string; length: number }[] = []\n    const nameToId: Record<string, number> = {}\n    const sqLines = samHeader.filter(l => l.tag === 'SQ')\n    for (const [refId, sqLine] of sqLines.entries()) {\n      let refName = ''\n      let length = 0\n      for (const item of sqLine.data) {\n        if (item.tag === 'SN') {\n          refName = item.value\n        } else if (item.tag === 'LN') {\n          length = +item.value\n        }\n      }\n      nameToId[refName] = refId\n      idToName[refId] = { refName, length }\n    }\n    this.chrToIndex = nameToId\n    this.indexToChr = idToName\n    return samHeader\n  }\n}\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nconst base64 = require('base64-js')\nconst ieee754 = require('ieee754')\nconst customInspectSymbol =\n  (typeof Symbol === 'function' && typeof Symbol['for'] === 'function') // eslint-disable-line dot-notation\n    ? Symbol['for']('nodejs.util.inspect.custom') // eslint-disable-line dot-notation\n    : null\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nconst K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    const arr = new Uint8Array(1)\n    const proto = { foo: function () { return 42 } }\n    Object.setPrototypeOf(proto, Uint8Array.prototype)\n    Object.setPrototypeOf(arr, proto)\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nObject.defineProperty(Buffer.prototype, 'parent', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.buffer\n  }\n})\n\nObject.defineProperty(Buffer.prototype, 'offset', {\n  enumerable: true,\n  get: function () {\n    if (!Buffer.isBuffer(this)) return undefined\n    return this.byteOffset\n  }\n})\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('The value \"' + length + '\" is invalid for option \"size\"')\n  }\n  // Return an augmented `Uint8Array` instance\n  const buf = new Uint8Array(length)\n  Object.setPrototypeOf(buf, Buffer.prototype)\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new TypeError(\n        'The \"string\" argument must be of type string. Received type number'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  if (ArrayBuffer.isView(value)) {\n    return fromArrayView(value)\n  }\n\n  if (value == null) {\n    throw new TypeError(\n      'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n      'or Array-like Object. Received type ' + (typeof value)\n    )\n  }\n\n  if (isInstance(value, ArrayBuffer) ||\n      (value && isInstance(value.buffer, ArrayBuffer))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof SharedArrayBuffer !== 'undefined' &&\n      (isInstance(value, SharedArrayBuffer) ||\n      (value && isInstance(value.buffer, SharedArrayBuffer)))) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'number') {\n    throw new TypeError(\n      'The \"value\" argument must not be of type number. Received type number'\n    )\n  }\n\n  const valueOf = value.valueOf && value.valueOf()\n  if (valueOf != null && valueOf !== value) {\n    return Buffer.from(valueOf, encodingOrOffset, length)\n  }\n\n  const b = fromObject(value)\n  if (b) return b\n\n  if (typeof Symbol !== 'undefined' && Symbol.toPrimitive != null &&\n      typeof value[Symbol.toPrimitive] === 'function') {\n    return Buffer.from(value[Symbol.toPrimitive]('string'), encodingOrOffset, length)\n  }\n\n  throw new TypeError(\n    'The first argument must be one of type string, Buffer, ArrayBuffer, Array, ' +\n    'or Array-like Object. Received type ' + (typeof value)\n  )\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nObject.setPrototypeOf(Buffer.prototype, Uint8Array.prototype)\nObject.setPrototypeOf(Buffer, Uint8Array)\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be of type number')\n  } else if (size < 0) {\n    throw new RangeError('The value \"' + size + '\" is invalid for option \"size\"')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpreted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('Unknown encoding: ' + encoding)\n  }\n\n  const length = byteLength(string, encoding) | 0\n  let buf = createBuffer(length)\n\n  const actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  const length = array.length < 0 ? 0 : checked(array.length) | 0\n  const buf = createBuffer(length)\n  for (let i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayView (arrayView) {\n  if (isInstance(arrayView, Uint8Array)) {\n    const copy = new Uint8Array(arrayView)\n    return fromArrayBuffer(copy.buffer, copy.byteOffset, copy.byteLength)\n  }\n  return fromArrayLike(arrayView)\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\"offset\" is outside of buffer bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\"length\" is outside of buffer bounds')\n  }\n\n  let buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(buf, Buffer.prototype)\n\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    const len = checked(obj.length) | 0\n    const buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj.length !== undefined) {\n    if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n      return createBuffer(0)\n    }\n    return fromArrayLike(obj)\n  }\n\n  if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n    return fromArrayLike(obj.data)\n  }\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true &&\n    b !== Buffer.prototype // so Buffer.isBuffer(Buffer.prototype) will be false\n}\n\nBuffer.compare = function compare (a, b) {\n  if (isInstance(a, Uint8Array)) a = Buffer.from(a, a.offset, a.byteLength)\n  if (isInstance(b, Uint8Array)) b = Buffer.from(b, b.offset, b.byteLength)\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError(\n      'The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array'\n    )\n  }\n\n  if (a === b) return 0\n\n  let x = a.length\n  let y = b.length\n\n  for (let i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  let i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  const buffer = Buffer.allocUnsafe(length)\n  let pos = 0\n  for (i = 0; i < list.length; ++i) {\n    let buf = list[i]\n    if (isInstance(buf, Uint8Array)) {\n      if (pos + buf.length > buffer.length) {\n        if (!Buffer.isBuffer(buf)) buf = Buffer.from(buf)\n        buf.copy(buffer, pos)\n      } else {\n        Uint8Array.prototype.set.call(\n          buffer,\n          buf,\n          pos\n        )\n      }\n    } else if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    } else {\n      buf.copy(buffer, pos)\n    }\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (ArrayBuffer.isView(string) || isInstance(string, ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    throw new TypeError(\n      'The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. ' +\n      'Received type ' + typeof string\n    )\n  }\n\n  const len = string.length\n  const mustMatch = (arguments.length > 2 && arguments[2] === true)\n  if (!mustMatch && len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) {\n          return mustMatch ? -1 : utf8ToBytes(string).length // assume utf8\n        }\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  let loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coercion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  const i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  const len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (let i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  const len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (let i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  const len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (let i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  const length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.toLocaleString = Buffer.prototype.toString\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  let str = ''\n  const max = exports.INSPECT_MAX_BYTES\n  str = this.toString('hex', 0, max).replace(/(.{2})/g, '$1 ').trim()\n  if (this.length > max) str += ' ... '\n  return '<Buffer ' + str + '>'\n}\nif (customInspectSymbol) {\n  Buffer.prototype[customInspectSymbol] = Buffer.prototype.inspect\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (isInstance(target, Uint8Array)) {\n    target = Buffer.from(target, target.offset, target.byteLength)\n  }\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError(\n      'The \"target\" argument must be one of type Buffer or Uint8Array. ' +\n      'Received type ' + (typeof target)\n    )\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  let x = thisEnd - thisStart\n  let y = end - start\n  const len = Math.min(x, y)\n\n  const thisCopy = this.slice(thisStart, thisEnd)\n  const targetCopy = target.slice(start, end)\n\n  for (let i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [val], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  let indexSize = 1\n  let arrLength = arr.length\n  let valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  let i\n  if (dir) {\n    let foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      let found = true\n      for (let j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  const remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  const strLen = string.length\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  let i\n  for (i = 0; i < length; ++i) {\n    const parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  const remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  let loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return asciiWrite(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  const res = []\n\n  let i = start\n  while (i < end) {\n    const firstByte = buf[i]\n    let codePoint = null\n    let bytesPerSequence = (firstByte > 0xEF)\n      ? 4\n      : (firstByte > 0xDF)\n          ? 3\n          : (firstByte > 0xBF)\n              ? 2\n              : 1\n\n    if (i + bytesPerSequence <= end) {\n      let secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nconst MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  const len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  let res = ''\n  let i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  let ret = ''\n  end = Math.min(buf.length, end)\n\n  for (let i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  const len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  let out = ''\n  for (let i = start; i < end; ++i) {\n    out += hexSliceLookupTable[buf[i]]\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  const bytes = buf.slice(start, end)\n  let res = ''\n  // If bytes.length is odd, the last 8 bits must be ignored (same as node.js)\n  for (let i = 0; i < bytes.length - 1; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  const len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  const newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  Object.setPrototypeOf(newBuf, Buffer.prototype)\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUintLE =\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUintBE =\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  let val = this[offset + --byteLength]\n  let mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUint8 =\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUint16LE =\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUint16BE =\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUint32LE =\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUint32BE =\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readBigUInt64LE = defineBigIntMethod(function readBigUInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const lo = first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24\n\n  const hi = this[++offset] +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    last * 2 ** 24\n\n  return BigInt(lo) + (BigInt(hi) << BigInt(32))\n})\n\nBuffer.prototype.readBigUInt64BE = defineBigIntMethod(function readBigUInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const hi = first * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  const lo = this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last\n\n  return (BigInt(hi) << BigInt(32)) + BigInt(lo)\n})\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let val = this[offset]\n  let mul = 1\n  let i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  let i = byteLength\n  let mul = 1\n  let val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  const val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readBigInt64LE = defineBigIntMethod(function readBigInt64LE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = this[offset + 4] +\n    this[offset + 5] * 2 ** 8 +\n    this[offset + 6] * 2 ** 16 +\n    (last << 24) // Overflow\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(first +\n    this[++offset] * 2 ** 8 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 24)\n})\n\nBuffer.prototype.readBigInt64BE = defineBigIntMethod(function readBigInt64BE (offset) {\n  offset = offset >>> 0\n  validateNumber(offset, 'offset')\n  const first = this[offset]\n  const last = this[offset + 7]\n  if (first === undefined || last === undefined) {\n    boundsError(offset, this.length - 8)\n  }\n\n  const val = (first << 24) + // Overflow\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    this[++offset]\n\n  return (BigInt(val) << BigInt(32)) +\n    BigInt(this[++offset] * 2 ** 24 +\n    this[++offset] * 2 ** 16 +\n    this[++offset] * 2 ** 8 +\n    last)\n})\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUintLE =\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let mul = 1\n  let i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUintBE =\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    const maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUint8 =\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUint16LE =\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint16BE =\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUint32LE =\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUint32BE =\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction wrtBigUInt64LE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  lo = lo >> 8\n  buf[offset++] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  hi = hi >> 8\n  buf[offset++] = hi\n  return offset\n}\n\nfunction wrtBigUInt64BE (buf, value, offset, min, max) {\n  checkIntBI(value, min, max, buf, offset, 7)\n\n  let lo = Number(value & BigInt(0xffffffff))\n  buf[offset + 7] = lo\n  lo = lo >> 8\n  buf[offset + 6] = lo\n  lo = lo >> 8\n  buf[offset + 5] = lo\n  lo = lo >> 8\n  buf[offset + 4] = lo\n  let hi = Number(value >> BigInt(32) & BigInt(0xffffffff))\n  buf[offset + 3] = hi\n  hi = hi >> 8\n  buf[offset + 2] = hi\n  hi = hi >> 8\n  buf[offset + 1] = hi\n  hi = hi >> 8\n  buf[offset] = hi\n  return offset + 8\n}\n\nBuffer.prototype.writeBigUInt64LE = defineBigIntMethod(function writeBigUInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeBigUInt64BE = defineBigIntMethod(function writeBigUInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, BigInt(0), BigInt('0xffffffffffffffff'))\n})\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = 0\n  let mul = 1\n  let sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    const limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  let i = byteLength - 1\n  let mul = 1\n  let sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeBigInt64LE = defineBigIntMethod(function writeBigInt64LE (value, offset = 0) {\n  return wrtBigUInt64LE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nBuffer.prototype.writeBigInt64BE = defineBigIntMethod(function writeBigInt64BE (value, offset = 0) {\n  return wrtBigUInt64BE(this, value, offset, -BigInt('0x8000000000000000'), BigInt('0x7fffffffffffffff'))\n})\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!Buffer.isBuffer(target)) throw new TypeError('argument should be a Buffer')\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('Index out of range')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  const len = end - start\n\n  if (this === target && typeof Uint8Array.prototype.copyWithin === 'function') {\n    // Use built-in when available, missing from IE11\n    this.copyWithin(targetStart, start, end)\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, end),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n    if (val.length === 1) {\n      const code = val.charCodeAt(0)\n      if ((encoding === 'utf8' && code < 128) ||\n          encoding === 'latin1') {\n        // Fast path: If `val` fits into a single byte, use that numeric value.\n        val = code\n      }\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  } else if (typeof val === 'boolean') {\n    val = Number(val)\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  let i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    const bytes = Buffer.isBuffer(val)\n      ? val\n      : Buffer.from(val, encoding)\n    const len = bytes.length\n    if (len === 0) {\n      throw new TypeError('The value \"' + val +\n        '\" is invalid for argument \"value\"')\n    }\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// CUSTOM ERRORS\n// =============\n\n// Simplified versions from Node, changed for Buffer-only usage\nconst errors = {}\nfunction E (sym, getMessage, Base) {\n  errors[sym] = class NodeError extends Base {\n    constructor () {\n      super()\n\n      Object.defineProperty(this, 'message', {\n        value: getMessage.apply(this, arguments),\n        writable: true,\n        configurable: true\n      })\n\n      // Add the error code to the name to include it in the stack trace.\n      this.name = `${this.name} [${sym}]`\n      // Access the stack to generate the error message including the error code\n      // from the name.\n      this.stack // eslint-disable-line no-unused-expressions\n      // Reset the name to the actual name.\n      delete this.name\n    }\n\n    get code () {\n      return sym\n    }\n\n    set code (value) {\n      Object.defineProperty(this, 'code', {\n        configurable: true,\n        enumerable: true,\n        value,\n        writable: true\n      })\n    }\n\n    toString () {\n      return `${this.name} [${sym}]: ${this.message}`\n    }\n  }\n}\n\nE('ERR_BUFFER_OUT_OF_BOUNDS',\n  function (name) {\n    if (name) {\n      return `${name} is outside of buffer bounds`\n    }\n\n    return 'Attempt to access memory outside buffer bounds'\n  }, RangeError)\nE('ERR_INVALID_ARG_TYPE',\n  function (name, actual) {\n    return `The \"${name}\" argument must be of type number. Received type ${typeof actual}`\n  }, TypeError)\nE('ERR_OUT_OF_RANGE',\n  function (str, range, input) {\n    let msg = `The value of \"${str}\" is out of range.`\n    let received = input\n    if (Number.isInteger(input) && Math.abs(input) > 2 ** 32) {\n      received = addNumericalSeparator(String(input))\n    } else if (typeof input === 'bigint') {\n      received = String(input)\n      if (input > BigInt(2) ** BigInt(32) || input < -(BigInt(2) ** BigInt(32))) {\n        received = addNumericalSeparator(received)\n      }\n      received += 'n'\n    }\n    msg += ` It must be ${range}. Received ${received}`\n    return msg\n  }, RangeError)\n\nfunction addNumericalSeparator (val) {\n  let res = ''\n  let i = val.length\n  const start = val[0] === '-' ? 1 : 0\n  for (; i >= start + 4; i -= 3) {\n    res = `_${val.slice(i - 3, i)}${res}`\n  }\n  return `${val.slice(0, i)}${res}`\n}\n\n// CHECK FUNCTIONS\n// ===============\n\nfunction checkBounds (buf, offset, byteLength) {\n  validateNumber(offset, 'offset')\n  if (buf[offset] === undefined || buf[offset + byteLength] === undefined) {\n    boundsError(offset, buf.length - (byteLength + 1))\n  }\n}\n\nfunction checkIntBI (value, min, max, buf, offset, byteLength) {\n  if (value > max || value < min) {\n    const n = typeof min === 'bigint' ? 'n' : ''\n    let range\n    if (byteLength > 3) {\n      if (min === 0 || min === BigInt(0)) {\n        range = `>= 0${n} and < 2${n} ** ${(byteLength + 1) * 8}${n}`\n      } else {\n        range = `>= -(2${n} ** ${(byteLength + 1) * 8 - 1}${n}) and < 2 ** ` +\n                `${(byteLength + 1) * 8 - 1}${n}`\n      }\n    } else {\n      range = `>= ${min}${n} and <= ${max}${n}`\n    }\n    throw new errors.ERR_OUT_OF_RANGE('value', range, value)\n  }\n  checkBounds(buf, offset, byteLength)\n}\n\nfunction validateNumber (value, name) {\n  if (typeof value !== 'number') {\n    throw new errors.ERR_INVALID_ARG_TYPE(name, 'number', value)\n  }\n}\n\nfunction boundsError (value, length, type) {\n  if (Math.floor(value) !== value) {\n    validateNumber(value, type)\n    throw new errors.ERR_OUT_OF_RANGE(type || 'offset', 'an integer', value)\n  }\n\n  if (length < 0) {\n    throw new errors.ERR_BUFFER_OUT_OF_BOUNDS()\n  }\n\n  throw new errors.ERR_OUT_OF_RANGE(type || 'offset',\n                                    `>= ${type ? 1 : 0} and <= ${length}`,\n                                    value)\n}\n\n// HELPER FUNCTIONS\n// ================\n\nconst INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node takes equal signs as end of the Base64 encoding\n  str = str.split('=')[0]\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  let codePoint\n  const length = string.length\n  let leadSurrogate = null\n  const bytes = []\n\n  for (let i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  let c, hi, lo\n  const byteArray = []\n  for (let i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  let i\n  for (i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffer or Uint8Array objects from other contexts (i.e. iframes) do not pass\n// the `instanceof` check but they should be treated as of that type.\n// See: https://github.com/feross/buffer/issues/166\nfunction isInstance (obj, type) {\n  return obj instanceof type ||\n    (obj != null && obj.constructor != null && obj.constructor.name != null &&\n      obj.constructor.name === type.name)\n}\nfunction numberIsNaN (obj) {\n  // For IE11 support\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n// Create lookup table for `toString('hex')`\n// See: https://github.com/feross/buffer/issues/219\nconst hexSliceLookupTable = (function () {\n  const alphabet = '0123456789abcdef'\n  const table = new Array(256)\n  for (let i = 0; i < 16; ++i) {\n    const i16 = i * 16\n    for (let j = 0; j < 16; ++j) {\n      table[i16 + j] = alphabet[i] + alphabet[j]\n    }\n  }\n  return table\n})()\n\n// Return not function with Error if BigInt not supported\nfunction defineBigIntMethod (fn) {\n  return typeof BigInt === 'undefined' ? BufferBigIntNotDefined : fn\n}\n\nfunction BufferBigIntNotDefined () {\n  throw new Error('BigInt not supported')\n}\n","// Generated by `./pycrc.py --algorithm=table-driven --model=crc-32 --generate=c`\nlet TABLE = [\n    0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f, 0xe963a535, 0x9e6495a3,\n    0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988, 0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91,\n    0x1db71064, 0x6ab020f2, 0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,\n    0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9, 0xfa0f3d63, 0x8d080df5,\n    0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172, 0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b,\n    0x35b5a8fa, 0x42b2986c, 0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,\n    0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423, 0xcfba9599, 0xb8bda50f,\n    0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924, 0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d,\n    0x76dc4190, 0x01db7106, 0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,\n    0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d, 0x91646c97, 0xe6635c01,\n    0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e, 0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457,\n    0x65b0d9c6, 0x12b7e950, 0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,\n    0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7, 0xa4d1c46d, 0xd3d6f4fb,\n    0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0, 0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9,\n    0x5005713c, 0x270241aa, 0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,\n    0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81, 0xb7bd5c3b, 0xc0ba6cad,\n    0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a, 0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683,\n    0xe3630b12, 0x94643b84, 0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,\n    0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb, 0x196c3671, 0x6e6b06e7,\n    0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc, 0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5,\n    0xd6d6a3e8, 0xa1d1937e, 0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,\n    0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55, 0x316e8eef, 0x4669be79,\n    0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236, 0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f,\n    0xc5ba3bbe, 0xb2bd0b28, 0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,\n    0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f, 0x72076785, 0x05005713,\n    0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38, 0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21,\n    0x86d3d2d4, 0xf1d4e242, 0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,\n    0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69, 0x616bffd3, 0x166ccf45,\n    0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2, 0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db,\n    0xaed16a4a, 0xd9d65adc, 0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,\n    0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693, 0x54de5729, 0x23d967bf,\n    0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94, 0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d,\n];\nif (typeof Int32Array !== 'undefined') {\n    TABLE = new Int32Array(TABLE);\n}\nconst crc32 = (current, previous) => {\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    let crc = previous === 0 ? 0 : ~~previous ^ -1;\n    for (let index = 0; index < current.length; index++) {\n        crc = TABLE[(crc ^ current[index]) & 0xff] ^ (crc >>> 8);\n    }\n    return crc ^ -1;\n};\nexport default crc32;\n","/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable no-prototype-builtins */\nimport { Buffer } from 'buffer';\nconst createBuffer = (value, encoding) => Buffer.from(value, encoding);\nexport default createBuffer;\n","import crc32 from './calculators/crc32.js';\nimport defineCrc from './define_crc.js';\nexport default defineCrc('crc-32', crc32);\n","import createBuffer from './create_buffer.js';\nexport default function defineCrc(model, calculator) {\n    const result = (value, previous) => calculator(createBuffer(value), previous) >>> 0;\n    result.signed = (value, previous) => calculator(createBuffer(value), previous);\n    result.unsigned = result;\n    result.model = model;\n    return result;\n}\n"],"names":["NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","addSignal","signal","this","aborted","Error","add","handleAborted","addEventListener","delete","size","abort","AggregateStatusReporter","callbacks","addCallback","callback","currentMessage","message","elt","AbortablePromiseCache","constructor","fill","cache","TypeError","get","set","fillCallback","isAbortException","exception","name","code","evict","key","entry","data","statusCallback","aborter","statusReporter","newEntry","promise","settled","then","catch","error","console","checkSinglePromise","checkForSingleAbort","Object","assign","result","has","AbortSignal","cacheEntry","cachedEntry","clear","keyIter","keys","deleteCount","next","done","value","VirtualOffset","blockPosition","dataPosition","toString","compareTo","b","min","args","i","length","fromBytes","bytes","offset","bigendian","Chunk","minv","maxv","bin","_fetchedSize","toUniqueString","fetchedSize","undefined","timeout","ms","Promise","resolve","setTimeout","optimizeChunks","chunks","lowest","mergedChunks","lastChunk","sort","c0","c1","dif","chunk","push","chunk1","chunk2","parsePseudoBin","lineCount","Array","prototype","slice","call","toNumber","findFirstData","firstDataLine","virtualOffset","parseNameBytes","namesBytes","renameRefSeq","s","currRefId","currNameStart","refIdToName","refNameToId","refName","IndexFile","filehandle","n","BAI","refId","opts","parse","indices","stats","_parse","readFile","readUInt32LE","refCount","readInt32LE","curr","binCount","binIndex","j","binLimit","chunkCount","k","u","v","linearCount","linearIndex","bai","maxBlockSize","indexCov","seqId","start","end","range","seqIdx","e","roundDown","depths","totalSize","currentPos","score","map","d","blocksForRange","max","indexData","ba","overlappingBins","beg","binChunks","binChunk","nintv","minLin","Math","maxLin","vp","setupP","hasRefSeq","rshift","num","bits","floor","CSI","maxBinNumber","depth","minShift","parseAuxData","formatFlags","coordinateType","format","columnNumbers","ref","metaValue","metaChar","String","fromCharCode","skipLines","nameSectionLength","subarray","buffer","unzip","csiVersion","auxLength","aux","csi","reg2bins","c","l","t","bins","SEQRET_DECODER","split","CIGAR_DECODER","BamRecord","fileOffset","byteArray","flags","ref_id","length_on_ref","id","mq","bin_mq_nl","qual","isSegmentUnmapped","p","b0","read_name_length","num_cigar_ops","num_seq_bytes","seq_length","strand","isReverseComplemented","tags","blockEnd","tag","type","readInt8","readUInt8","readInt16LE","readUInt16LE","readFloatLE","cc","join","Btype","limit","cigop","lop","op","isPaired","isProperlyPaired","isMateUnmapped","isMateReverseComplemented","isRead1","isRead2","isSecondary","isFailedQc","isDuplicate","isSupplementary","cigarAndLength","CIGAR","numCigarOps","warn","CG","lref","flag_nc","seq","seqBytes","len","buf","sb","pair_orientation","next_refid","s1","s2","o1","o2","tmp","template_length","next_pos","toJSON","startsWith","cacheGetter","ctor","prop","desc","getOwnPropertyDescriptor","getter","defineProperty","ret","parseHeaderText","text","lines","line","fields","f","r","indexOf","BAM_MAGIC","NullFilehandle","read","stat","close","BamFile","bamFilehandle","bamPath","bamUrl","baiPath","baiFilehandle","baiUrl","csiPath","csiFilehandle","csiUrl","htsget","yieldThreadTime","renameRefSeqs","featureCache","A","maxSize","async","cpositions","dpositions","_readChunk","readBamFeatures","bam","index","getHeaderPre","origOpts","obj","makeOpts","res","alloc","bytesRead","uncba","headLen","header","chrToIndex","indexToChr","_readRefSeqs","getHeader","headerP","getHeaderText","refSeqBytes","nRef","lName","lRef","getRecordsForRange","chr","gen","out","x","concat","gen2array","streamRecordsForRange","chrId","_fetchChunkFeatures","viewAsPairs","feats","records","recs","feature","DOMException","checkAbortSignal","fetchPairs","pairAcrossChr","maxInsertSize","unmatedPairs","readIds","readNames","element","entries","matePromises","pnext","rnext","abs","Map","all","m","flat","values","mateRecs","_readRegion","position","blockStart","sink","pos","last","Date","now","crc32","signed","seqName","arr","url","headers","from","referer","rest","fetch","ok","status","arrayBuffer","HtsgetFile","super","baseUrl","trackId","json","urls","Number","MAX_SAFE_INTEGER","samHeader","idToName","nameToId","sqLines","filter","sqLine","item","base64","ieee754","customInspectSymbol","Symbol","exports","Buffer","K_MAX_LENGTH","createBuffer","RangeError","Uint8Array","setPrototypeOf","arg","encodingOrOffset","allocUnsafe","string","encoding","isEncoding","byteLength","actual","write","fromString","ArrayBuffer","isView","arrayView","isInstance","copy","fromArrayBuffer","byteOffset","fromArrayLike","fromArrayView","SharedArrayBuffer","valueOf","isBuffer","checked","numberIsNaN","isArray","fromObject","toPrimitive","assertSize","array","mustMatch","arguments","loweredCase","utf8ToBytes","base64ToBytes","toLowerCase","slowToString","hexSlice","utf8Slice","asciiSlice","latin1Slice","base64Slice","utf16leSlice","swap","bidirectionalIndexOf","val","dir","arrayIndexOf","lastIndexOf","indexSize","arrLength","valLength","readUInt16BE","foundIndex","found","hexWrite","remaining","strLen","parsed","parseInt","substr","utf8Write","blitBuffer","asciiWrite","str","charCodeAt","asciiToBytes","base64Write","ucs2Write","units","hi","lo","utf16leToBytes","fromByteArray","firstByte","codePoint","bytesPerSequence","secondByte","thirdByte","fourthByte","tempCodePoint","codePoints","MAX_ARGUMENTS_LENGTH","apply","decodeCodePointsArray","TYPED_ARRAY_SUPPORT","proto","foo","typedArraySupport","enumerable","poolSize","allocUnsafeSlow","_isBuffer","compare","a","y","list","swap16","swap32","swap64","toLocaleString","equals","inspect","replace","trim","target","thisStart","thisEnd","thisCopy","targetCopy","includes","isFinite","_arr","hexSliceLookupTable","checkOffset","ext","checkInt","wrtBigUInt64LE","checkIntBI","BigInt","wrtBigUInt64BE","checkIEEE754","writeFloat","littleEndian","noAssert","writeDouble","newBuf","readUintLE","readUIntLE","mul","readUintBE","readUIntBE","readUint8","readUint16LE","readUint16BE","readUint32LE","readUint32BE","readUInt32BE","readBigUInt64LE","defineBigIntMethod","validateNumber","first","boundsError","readBigUInt64BE","readIntLE","pow","readIntBE","readInt16BE","readInt32BE","readBigInt64LE","readBigInt64BE","readFloatBE","readDoubleLE","readDoubleBE","writeUintLE","writeUIntLE","writeUintBE","writeUIntBE","writeUint8","writeUInt8","writeUint16LE","writeUInt16LE","writeUint16BE","writeUInt16BE","writeUint32LE","writeUInt32LE","writeUint32BE","writeUInt32BE","writeBigUInt64LE","writeBigUInt64BE","writeIntLE","sub","writeIntBE","writeInt8","writeInt16LE","writeInt16BE","writeInt32LE","writeInt32BE","writeBigInt64LE","writeBigInt64BE","writeFloatLE","writeFloatBE","writeDoubleLE","writeDoubleBE","targetStart","copyWithin","errors","E","sym","getMessage","Base","writable","configurable","stack","addNumericalSeparator","ERR_OUT_OF_RANGE","checkBounds","ERR_INVALID_ARG_TYPE","ERR_BUFFER_OUT_OF_BOUNDS","input","msg","received","isInteger","INVALID_BASE64_RE","Infinity","leadSurrogate","toByteArray","base64clean","src","dst","alphabet","table","i16","fn","BufferBigIntNotDefined","TABLE","Int32Array","model","calculator","previous","unsigned","current","crc"],"sourceRoot":""}