{"version":3,"file":"static/js/2282.49ab99c1.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/wiggle/src/MultiXYPlotRenderer/renderMultiXYPlot.ts","webpack://@jbrowse/web/../../plugins/wiggle/src/drawXY.ts"],"sourcesContent":["import {\n  groupBy,\n  renderToAbstractCanvas,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\nimport { createStopTokenChecker } from '@jbrowse/core/util/stopToken'\n\nimport { drawXY } from '../drawXY.ts'\nimport { serializeWiggleFeature } from '../util.ts'\n\nimport type { MultiRenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderMultiXYPlot(\n  renderProps: MultiRenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    sources,\n    height,\n    regions,\n    bpPerPx,\n    stopToken,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  const lastCheck = createStopTokenChecker(stopToken)\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx => {\n        const groups = groupBy(features, f => f.get('source'))\n        let allReducedFeatures: Feature[] = []\n        for (const source of sources) {\n          const { reducedFeatures: reduced } = drawXY(ctx, {\n            ...renderProps,\n            features: groups[source.name] || [],\n            colorCallback: () => source.color || 'blue',\n            lastCheck,\n          })\n          allReducedFeatures = allReducedFeatures.concat(reduced)\n        }\n        return {\n          reducedFeatures: allReducedFeatures,\n        }\n      }),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { fillRectCtx, getOrigin, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, Region } from '@jbrowse/core/util'\nimport type { Colord } from '@jbrowse/core/util/colord'\nimport type {\n  LastStopTokenCheck,\n  StopToken,\n} from '@jbrowse/core/util/stopToken'\n\nfunction lighten(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 + amount)\n  return colord({\n    ...hslColor,\n    l: clamp(l, 0, 100),\n  })\n}\n\nfunction darken(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 - amount)\n  return colord({\n    ...hslColor,\n    l: clamp(l, 0, 100),\n  })\n}\n\nconst fudgeFactor = 0.3\nconst clipHeight = 2\n\nexport function drawXY(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    bpPerPx: number\n    regions: Region[]\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    config: AnyConfigurationModel\n    displayCrossHatches: boolean\n    inverted: boolean\n    offset?: number\n    lastCheck?: LastStopTokenCheck\n    stopToken?: StopToken\n    colorCallback: (f: Feature, score: number) => string\n  },\n) {\n  const {\n    features,\n    bpPerPx,\n    regions,\n    scaleOpts,\n    height: unadjustedHeight,\n    config,\n    ticks,\n    displayCrossHatches,\n    offset = 0,\n    colorCallback,\n    inverted,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  // Extract region values once to avoid repeated property access in hot loop\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionReversed = region.reversed\n\n  // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the\n  // wiggle display, and makes the height of the actual drawn area add\n  // \"padding\" to the top and bottom of the display\n  const height = unadjustedHeight - offset * 2\n\n  const filled = readConfObject(config, 'filled')\n  const clipColor = readConfObject(config, 'clipColor')\n  const summaryScoreMode = readConfObject(config, 'summaryScoreMode')\n  const pivotValue = readConfObject(config, 'bicolorPivotValue')\n  const minSize = readConfObject(config, 'minSize')\n\n  const scale = getScale({ ...scaleOpts, range: [0, height], inverted })\n  const originY = getOrigin(scaleOpts.scaleType)\n  const domain = scale.domain()\n  const niceMin = domain[0]!\n  const niceMax = domain[1]!\n\n  // Precompute scale values for fast toY calculation\n  const isLog = scaleOpts.scaleType === 'log'\n  const log2 = Math.log(2)\n  const domainSpan = niceMax - niceMin\n  const linearRatio = domainSpan !== 0 ? height / domainSpan : 0\n  const logMin = isLog ? Math.log(niceMin) / log2 : 0\n  const logMax = isLog ? Math.log(niceMax) / log2 : 0\n  const logSpan = logMax - logMin\n  const logRatio = logSpan !== 0 ? height / logSpan : 0\n  const effectiveRange = inverted ? [height, 0] : [0, height]\n  const rangeFlipped = effectiveRange[0] === height\n\n  // Inlined toY - avoids d3-scale function call overhead\n  const toY = isLog\n    ? (n: number) => {\n        const logVal = Math.log(n) / log2\n        const scaled = (logVal - logMin) * logRatio\n        const result = rangeFlipped ? scaled : height - scaled\n        return clamp(result, 0, height) + offset\n      }\n    : (n: number) => {\n        const scaled = (n - niceMin) * linearRatio\n        const result = rangeFlipped ? scaled : height - scaled\n        return clamp(result, 0, height) + offset\n      }\n\n  const toOrigin = (n: number) => toY(originY) - toY(n)\n  const getHeight = (n: number) => (filled ? toOrigin(n) : Math.max(minSize, 1))\n\n  // Precompute for inline px calculation (avoids featureSpanPx function call overhead)\n  const inverseBpPerPx = 1 / bpPerPx\n\n  let hasClipping = false\n\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n  const crossingOrigin = niceMin < pivotValue && niceMax > pivotValue\n\n  // we handle whiskers separately to render max row, min row, and avg in three\n  // passes. this reduces subpixel rendering issues. note: for stylistic\n  // reasons, clipping indicator is only drawn for score, not min/max score\n  if (summaryScoreMode === 'whiskers') {\n    let lastCol: string | undefined\n    let lastMix: string | undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      if (feature.get('summary')) {\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const max = feature.get('maxScore')\n        const c = colorCallback(feature, max)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = lighten(colord(c), 0.4).toHex())\n        fillRectCtx(leftPx, toY(max), w, getHeight(max), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n    lastMix = undefined\n    lastCol = undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const score = feature.get('score')\n      const max = feature.get('maxScore')\n      const min = feature.get('minScore')\n      const summary = feature.get('summary')\n      const c = colorCallback(feature, score)\n      const effectiveC =\n        crossingOrigin && summary\n          ? c === lastCol\n            ? lastMix\n            : (lastMix = colord(colorCallback(feature, max))\n                .mix(colord(colorCallback(feature, min)))\n                .toString())\n          : c\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n      if (\n        Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n        rightPx - leftPx > 1\n      ) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, effectiveC)\n      lastCol = c\n    }\n    lastMix = undefined\n    lastCol = undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n\n      if (feature.get('summary')) {\n        const min = feature.get('minScore')\n        const c = colorCallback(feature, min)\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = darken(colord(c), 0.4).toHex())\n\n        fillRectCtx(leftPx, toY(min), w, getHeight(min), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n  } else {\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      if (\n        Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n        rightPx - leftPx > 1\n      ) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n\n      const score = feature.get('score')\n      const c = colorCallback(feature, score)\n\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n\n      if (summaryScoreMode === 'max') {\n        const s = feature.get('summary') ? feature.get('maxScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else if (summaryScoreMode === 'min') {\n        const s = feature.get('summary') ? feature.get('minScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else {\n        fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, c)\n      }\n    }\n  }\n\n  // second pass: draw clipping\n  // avoid persisting the red fillstyle with save/restore\n  ctx.save()\n  if (hasClipping) {\n    ctx.fillStyle = clipColor\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const w = rightPx - leftPx + fudgeFactor\n      const score = feature.get('score')\n      if (score > niceMax) {\n        fillRectCtx(leftPx, offset, w, clipHeight, ctx)\n      } else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n        fillRectCtx(leftPx, unadjustedHeight, w, clipHeight, ctx)\n      }\n    }\n  }\n  ctx.restore()\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    for (const tick of ticks.values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n\n  return {\n    reducedFeatures,\n  }\n}\n"],"names":["async","renderMultiXYPlot","renderProps","features","sources","height","regions","bpPerPx","stopToken","statusCallback","region","width","end","start","lastCheck","createStopTokenChecker","reducedFeatures","rest","updateStatus","renderToAbstractCanvas","ctx","groups","groupBy","f","get","allReducedFeatures","source","reduced","drawXY","name","colorCallback","color","concat","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables","lighten","amount","hslColor","toHsl","l","colord","clamp","darken","fudgeFactor","props","scaleOpts","unadjustedHeight","config","ticks","displayCrossHatches","offset","inverted","regionStart","regionEnd","regionReversed","reversed","filled","readConfObject","clipColor","summaryScoreMode","pivotValue","minSize","scale","getScale","range","originY","getOrigin","scaleType","domain","niceMin","niceMax","isLog","log2","Math","log","domainSpan","linearRatio","logMin","logSpan","logRatio","rangeFlipped","toY","n","scaled","result","getHeight","toOrigin","max","inverseBpPerPx","hasClipping","prevLeftPx","Number","NEGATIVE_INFINITY","crossingOrigin","lastCol","lastMix","feature","values","checkStopToken2","fStart","fEnd","leftPx","rightPx","w","c","effectiveC","toHex","fillRectCtx","undefined","score","min","summary","mix","toString","floor","push","s","save","fillStyle","restore","lineWidth","strokeStyle","tick","beginPath","moveTo","round","lineTo","stroke"],"sourceRoot":""}