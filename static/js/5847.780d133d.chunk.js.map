{"version":3,"file":"static/js/5847.780d133d.chunk.js","mappings":"yLASA,MAAMA,EAAc,GACdC,EAAa,EAEZ,SAASC,EACdC,EACAC,GAWA,MAAM,SAAEC,EAAQ,QAAEC,EAAO,QAAEC,EAAO,UAAEC,EAAS,OAAEC,EAAM,OAAEC,GAAWN,EAC5DO,EAASL,EAAQ,GACjBM,GAAQC,EAAAA,EAAAA,gBAAeH,EAAQ,gBAC/BI,GAAaD,EAAAA,EAAAA,gBAAeH,EAAQ,qBACpCK,GAAWF,EAAAA,EAAAA,gBAAeH,EAAQ,YAClCM,GAAWH,EAAAA,EAAAA,gBAAeH,EAAQ,YAClCO,GAAQJ,EAAAA,EAAAA,gBAAeH,EAAQ,SAC/BQ,GAAYL,EAAAA,EAAAA,gBAAeH,EAAQ,aACnCS,EAAqB,SAAVP,GAA4C,QAAxBJ,EAAUY,UACzCC,GAAQC,EAAAA,EAAAA,UAAS,IAClBd,EACHM,WAAYK,EAAWL,OAAaS,EACpCC,MAAOL,EAAW,CAACJ,EAAU,QAASC,GAAY,CAAC,QAASA,KAIxDS,EACM,SAAVR,EACI,CAACS,EAAYC,IAAkBN,EAAMM,GACrC,CAACC,EAAkBD,KACjBd,EAAAA,EAAAA,gBAAeH,EAAQ,QAAS,CAAEkB,UAASD,UAC7CE,GANSP,EAAAA,EAAAA,UAAS,IAAKd,EAAWgB,MAAO,CAAC,EAAGf,KAM7BoB,SAChBC,EAAUD,EAAO,GACjBE,EAAUF,EAAO,GAEvB,IAAIG,EAAaC,OAAOC,kBACpBC,GAAc,EAClB,MAAMC,EAAkB,GACxB,IAAK,MAAMR,KAAWvB,EAASgC,SAAU,CACvC,MAAOC,EAAQC,IAAWC,EAAAA,EAAAA,eAAcZ,EAASjB,EAAQJ,GAGrDkC,KAAKC,MAAMJ,KAAYG,KAAKC,MAAMV,KACpCI,EAAgBO,KAAKf,GACrBI,EAAaM,GAEf,MAAMX,EAAQC,EAAQgB,IAAI,SAC1BT,EAAcA,GAAeR,EAAQI,GAAWJ,EAAQG,EACxD,MAAMe,EAAIN,EAAUD,EAAStC,EAC7BG,EAAI2C,UAAYrB,EAAGG,EAASD,GAC5BxB,EAAI4C,SAAST,EAAQ,EAAGO,EAAGpC,EAC7B,CAKA,GADAN,EAAI6C,OACAb,EAAa,CACfhC,EAAI2C,UAAY5B,EAChB,IAAK,MAAMU,KAAWvB,EAASgC,SAAU,CACvC,MAAOC,EAAQC,IAAWC,EAAAA,EAAAA,eAAcZ,EAASjB,EAAQJ,GACnDsC,EAAIN,EAAUD,EAAStC,EACvB2B,EAAQC,EAAQgB,IAAI,UACtBjB,EAAQI,GAEDJ,EAAQG,GAAmC,QAAxBtB,EAAUY,aADtC6B,EAAAA,EAAAA,aAAYX,EAAQ,EAAGO,EAAG5C,EAAYE,EAI1C,CACF,CAGA,OAFAA,EAAI+C,UAEG,CAAEd,kBACX,C","sources":["../../../plugins/wiggle/src/drawDensity.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport { featureSpanPx } from '@jbrowse/core/util'\n\nimport { fillRectCtx, getScale } from './util'\n\nimport type { ScaleOpts } from './util'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nconst fudgeFactor = 0.3\nconst clipHeight = 2\n\nexport function drawDensity(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    regions: Region[]\n    bpPerPx: number\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    displayCrossHatches: boolean\n    config: AnyConfigurationModel\n  },\n) {\n  const { features, regions, bpPerPx, scaleOpts, height, config } = props\n  const region = regions[0]!\n  const pivot = readConfObject(config, 'bicolorPivot')\n  const pivotValue = readConfObject(config, 'bicolorPivotValue')\n  const negColor = readConfObject(config, 'negColor')\n  const posColor = readConfObject(config, 'posColor')\n  const color = readConfObject(config, 'color')\n  const clipColor = readConfObject(config, 'clipColor')\n  const crossing = pivot !== 'none' && scaleOpts.scaleType !== 'log'\n  const scale = getScale({\n    ...scaleOpts,\n    pivotValue: crossing ? pivotValue : undefined,\n    range: crossing ? [negColor, 'white', posColor] : ['white', posColor],\n  })\n\n  const scale2 = getScale({ ...scaleOpts, range: [0, height] })\n  const cb =\n    color === '#f0f'\n      ? (_: Feature, score: number) => scale(score)\n      : (feature: Feature, score: number) =>\n          readConfObject(config, 'color', { feature, score })\n  const domain = scale2.domain()\n  const niceMin = domain[0]!\n  const niceMax = domain[1]!\n\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  let hasClipping = false\n  const reducedFeatures = []\n  for (const feature of features.values()) {\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n\n    // create reduced features, avoiding multiple features per px\n    if (Math.floor(leftPx) !== Math.floor(prevLeftPx)) {\n      reducedFeatures.push(feature)\n      prevLeftPx = leftPx\n    }\n    const score = feature.get('score')\n    hasClipping = hasClipping || score > niceMax || score < niceMin\n    const w = rightPx - leftPx + fudgeFactor\n    ctx.fillStyle = cb(feature, score)\n    ctx.fillRect(leftPx, 0, w, height)\n  }\n\n  // second pass: draw clipping\n  // avoid persisting the red fillstyle with save/restore\n  ctx.save()\n  if (hasClipping) {\n    ctx.fillStyle = clipColor\n    for (const feature of features.values()) {\n      const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n      const w = rightPx - leftPx + fudgeFactor\n      const score = feature.get('score')\n      if (score > niceMax) {\n        fillRectCtx(leftPx, 0, w, clipHeight, ctx)\n      } else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n        fillRectCtx(leftPx, 0, w, clipHeight, ctx)\n      }\n    }\n  }\n  ctx.restore()\n\n  return { reducedFeatures }\n}\n"],"names":["fudgeFactor","clipHeight","drawDensity","ctx","props","features","regions","bpPerPx","scaleOpts","height","config","region","pivot","readConfObject","pivotValue","negColor","posColor","color","clipColor","crossing","scaleType","scale","getScale","undefined","range","cb","_","score","feature","domain","niceMin","niceMax","prevLeftPx","Number","NEGATIVE_INFINITY","hasClipping","reducedFeatures","values","leftPx","rightPx","featureSpanPx","Math","floor","push","get","w","fillStyle","fillRect","save","fillRectCtx","restore"],"sourceRoot":""}