{"version":3,"file":"static/js/3304.08bc2b5b.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/shared/color.ts","../../../plugins/alignments/src/LinearReadArcsDisplay/drawFeats.ts"],"sourcesContent":["import { orientationTypes, pairMap } from '../util'\n\nimport type { ChainStats, ReducedFeature } from './fetchChains'\n\n/**\n * Numeric codes for pair types\n * Used to classify paired-end reads without relying on color string comparisons\n */\nexport const PairType = {\n  /** Proper pair: correct orientation (LR) and normal insert size */\n  PROPER_PAIR: 0,\n  /** Long insert: same chromosome but insert size exceeds upper threshold */\n  LONG_INSERT: 1,\n  /** Short insert: same chromosome but insert size below lower threshold */\n  SHORT_INSERT: 2,\n  /** Inter-chromosome: mates on different chromosomes */\n  INTER_CHROM: 3,\n  /** Abnormal orientation: RR, RL, LL, etc. (not LR) */\n  ABNORMAL_ORIENTATION: 4,\n  /** Unmapped mate: mate is unmapped */\n  UNMAPPED_MATE: 5,\n} as const\n\nexport type PairTypeValue = (typeof PairType)[keyof typeof PairType]\n\nexport const fillColor = {\n  color_fwd_strand_not_proper: '#ECC8C8',\n  color_rev_strand_not_proper: '#BEBED8',\n  color_fwd_strand: '#EC8B8B',\n  color_rev_strand: '#8F8FD8',\n  color_fwd_missing_mate: '#D11919',\n  color_rev_missing_mate: '#1919D1',\n  color_fwd_diff_chr: '#000',\n  color_rev_diff_chr: '#969696',\n  color_pair_lr: '#c8c8c8',\n  color_pair_rr: '#3a3a9d',\n  color_pair_rl: 'teal',\n  color_pair_ll: 'green',\n  color_nostrand: '#c8c8c8',\n  color_interchrom: 'purple',\n  color_longinsert: 'red',\n  color_shortinsert: 'pink',\n  color_unmapped_mate: '#8B008B',\n  color_unknown: 'grey',\n}\n\n// manually calculated by running\n// const color = require('color')\n// Object.fromEntries(Object.entries(fillColor).map(([key,val])=>{\n//   return [key, color(val).darken('0.3').hex()]\n// }))\n// this avoids (expensive) use of Color module at runtime\nexport const strokeColor = {\n  color_fwd_strand_not_proper: '#CA6767',\n  color_rev_strand_not_proper: '#7272AA',\n  color_fwd_strand: '#DC2A2A',\n  color_rev_strand: '#4141BA',\n  color_fwd_missing_mate: '#921111',\n  color_rev_missing_mate: '#111192',\n  color_fwd_diff_chr: '#000000',\n  color_rev_diff_chr: '#696969',\n  color_pair_lr: '#8C8C8C',\n  color_pair_rr: '#00002A',\n  color_pair_rl: '#005A5A',\n  color_pair_ll: '#005A00',\n  color_nostrand: '#8C8C8C',\n  color_interchrom: '#5A005A',\n  color_longinsert: '#B30000',\n  color_shortinsert: '#FF3A5C',\n  color_unmapped_mate: '#5A005A',\n  color_unknown: '#444',\n}\n\nconst defaultColor = [\n  fillColor.color_pair_lr,\n  strokeColor.color_pair_lr,\n] as const\n\n/**\n * Get the pair type classification for a paired-end read\n * Used internally by color functions and externally for filtering logic\n *\n * @param type - Color scheme type (insertSizeAndOrientation, orientation, insertSize)\n * @param f1 - First read in the pair\n * @param f2 - Second read in the pair\n * @param stats - Optional statistics for insert size thresholds\n * @returns Numeric code representing the pair type\n */\nexport function getPairedType({\n  type,\n  f1,\n  f2,\n  stats,\n}: {\n  type: string\n  f1: {\n    refName: string\n    pair_orientation?: string\n    tlen?: number\n    flags?: number\n  }\n  f2: { refName: string }\n  stats?: ChainStats\n}): PairTypeValue {\n  // Check for unmapped mate first (highest priority)\n  if (f1.flags !== undefined && f1.flags & 8) {\n    return PairType.UNMAPPED_MATE\n  }\n\n  // Check orientation first (if applicable)\n  if (type === 'insertSizeAndOrientation' || type === 'orientation') {\n    const orientationType = orientationTypes.fr\n    const r = orientationType[f1.pair_orientation || ''] as\n      | keyof typeof pairMap\n      | undefined\n    // If orientation is not LR (proper), it's abnormal\n    if (r && r !== 'LR') {\n      return PairType.ABNORMAL_ORIENTATION\n    }\n  }\n\n  // Check insert size (if applicable)\n  if (type === 'insertSizeAndOrientation' || type === 'insertSize') {\n    const sameRef = f1.refName === f2.refName\n    const tlen = Math.abs(f1.tlen || 0)\n\n    if (!sameRef) {\n      return PairType.INTER_CHROM\n    }\n\n    if (stats) {\n      if (tlen > stats.upper) {\n        return PairType.LONG_INSERT\n      }\n      if (tlen < stats.lower) {\n        return PairType.SHORT_INSERT\n      }\n    }\n  }\n\n  // If all checks pass, it's a proper pair\n  return PairType.PROPER_PAIR\n}\n\n/**\n * Get color for a paired-end read based on insert size only\n * Uses getPairedType() internally to determine classification\n */\nexport function getPairedInsertSizeColor(\n  f1: { refName: string; tlen?: number; flags?: number },\n  f2: { refName: string },\n  stats?: ChainStats,\n) {\n  const pairType = getPairedType({ type: 'insertSize', f1, f2, stats })\n\n  switch (pairType) {\n    case PairType.UNMAPPED_MATE:\n      return [\n        fillColor.color_unmapped_mate,\n        strokeColor.color_unmapped_mate,\n      ] as const\n    case PairType.LONG_INSERT:\n      return [fillColor.color_longinsert, strokeColor.color_longinsert] as const\n    case PairType.SHORT_INSERT:\n      return [\n        fillColor.color_shortinsert,\n        strokeColor.color_shortinsert,\n      ] as const\n    case PairType.INTER_CHROM:\n      return [fillColor.color_interchrom, strokeColor.color_interchrom] as const\n    case PairType.PROPER_PAIR:\n      return undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n * Get color for a paired-end read based on orientation only\n * Returns undefined for proper pairs (LR orientation)\n */\nexport function getPairedOrientationColorOrDefault(f: {\n  pair_orientation?: string\n  flags?: number\n}) {\n  // Check for unmapped mate first\n  if (f.flags !== undefined && f.flags & 8) {\n    return [\n      fillColor.color_unmapped_mate,\n      strokeColor.color_unmapped_mate,\n    ] as const\n  }\n\n  const type = orientationTypes.fr\n  const r = type[f.pair_orientation || ''] as keyof typeof pairMap\n  const type2 = pairMap[r] as keyof typeof fillColor\n  return r === 'LR'\n    ? undefined\n    : ([fillColor[type2], strokeColor[type2]] as const)\n}\n\n/**\n * Get color for a paired-end read based on orientation only\n * Returns default color for proper pairs\n */\nexport function getPairedOrientationColor(f: {\n  pair_orientation?: string\n  flags?: number\n}) {\n  return getPairedOrientationColorOrDefault(f) || defaultColor\n}\n\n/**\n * Get color for a paired-end read based on both insert size and orientation\n * Prioritizes orientation coloring over insert size coloring\n * Uses getPairedType() internally to determine classification\n */\nexport function getPairedInsertSizeAndOrientationColor(\n  f1: {\n    refName: string\n    pair_orientation?: string\n    tlen?: number\n    flags?: number\n  },\n  f2: { refName: string },\n  stats?: ChainStats,\n) {\n  return (\n    getPairedOrientationColorOrDefault(f1) ||\n    getPairedInsertSizeColor(f1, f2, stats) ||\n    defaultColor\n  )\n}\n\nexport function getSingletonColor(f: { tlen?: number }, stats?: ChainStats) {\n  const tlen = Math.abs(f.tlen || 0)\n  // If TLEN is abnormally large, color it dark red\n  if (stats && tlen > stats.upper) {\n    return [\n      fillColor.color_fwd_missing_mate,\n      strokeColor.color_fwd_missing_mate,\n    ] as const\n  }\n  // Otherwise use properly paired coloring for normal-looking singletons\n  return defaultColor // [fillColor.color_pair_lr, strokeColor.color_pair_lr] as const\n}\n\nexport function getPairedColor({\n  type,\n  v0,\n  v1,\n  stats,\n}: {\n  type: string\n  v0: ReducedFeature\n  v1: ReducedFeature\n  stats?: ChainStats\n}) {\n  if (type === 'insertSizeAndOrientation') {\n    return getPairedInsertSizeAndOrientationColor(v0, v1, stats)\n  }\n  if (type === 'orientation') {\n    return getPairedOrientationColor(v0)\n  }\n  if (type === 'insertSize') {\n    return getPairedInsertSizeColor(v0, v1, stats)\n  }\n  return undefined\n}\n","import { getContainingView, getSession } from '@jbrowse/core/util'\n\nimport { featurizeSA } from '../MismatchParser'\nimport {\n  getPairedInsertSizeAndOrientationColor,\n  getPairedInsertSizeColor,\n  getPairedOrientationColor,\n} from '../shared/color'\nimport { hasPairedReads } from '../shared/util'\n\nimport type { LinearReadArcsDisplayModel } from './model'\nimport type { Assembly } from '@jbrowse/core/assemblyManager/assembly'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nfunction jitter(n: number) {\n  return Math.random() * 2 * n - n\n}\n\ninterface CoreFeat {\n  strand: number\n  refName: string\n  start: number\n  end: number\n}\n\nfunction drawLineAtOffset(\n  ctx: CanvasRenderingContext2D,\n  offset: number,\n  height: number,\n  color: string,\n) {\n  // draws a vertical line off to middle of nowhere if the second end not found\n  ctx.strokeStyle = color\n  ctx.beginPath()\n  ctx.moveTo(offset, 0)\n  ctx.lineTo(offset, height)\n  ctx.stroke()\n}\n\nexport function drawFeats(\n  self: LinearReadArcsDisplayModel,\n  ctx: CanvasRenderingContext2D,\n  width: number,\n  height: number,\n) {\n  const {\n    chainData,\n    colorBy,\n    drawInter,\n    drawLongRange,\n    lineWidthSetting,\n    jitterVal,\n  } = self\n  if (!chainData) {\n    return\n  }\n  const view = getContainingView(self) as LGV\n  const { assemblyManager } = getSession(self)\n  const { chains, stats } = chainData\n  const hasPaired = hasPairedReads(chainData)\n  const asm = assemblyManager.get(view.assemblyNames[0]!)\n  const type = colorBy?.type || 'insertSizeAndOrientation'\n  if (!asm) {\n    return\n  }\n  ctx.lineWidth = lineWidthSetting\n\n  function draw(\n    k1: CoreFeat & { tlen?: number; pair_orientation?: string },\n    k2: CoreFeat,\n    assembly: Assembly,\n    longRange?: boolean,\n  ) {\n    const s1 = k1.strand\n    const s2 = k2.strand\n    const f1 = s1 === -1\n    const f2 = s2 === -1\n\n    const p1 = f1 ? k1.start : k1.end\n    const p2 = hasPaired ? (f2 ? k2.start : k2.end) : f2 ? k2.end : k2.start\n    const ra1 = assembly.getCanonicalRefName(k1.refName) || k1.refName\n    const ra2 = assembly.getCanonicalRefName(k2.refName) || k2.refName\n    const r1 = view.bpToPx({ refName: ra1, coord: p1 })?.offsetPx\n    const r2 = view.bpToPx({ refName: ra2, coord: p2 })?.offsetPx\n\n    if (r1 !== undefined && r2 !== undefined) {\n      const radius = (r2 - r1) / 2\n      const absrad = Math.abs(radius)\n      const p = r1 - view.offsetPx\n      const p2 = r2 - view.offsetPx\n      const drawArcInsteadOfBezier = absrad > 10_000\n\n      // bezier (used for non-long-range arcs) requires moveTo before beginPath\n      // arc (used for long-range) requires moveTo after beginPath (or else a\n      // unwanted line at y=0 is rendered along with the arc)\n      if (longRange && drawArcInsteadOfBezier) {\n        ctx.moveTo(p, 0)\n        ctx.beginPath()\n      } else {\n        ctx.beginPath()\n        ctx.moveTo(p, 0)\n      }\n\n      if (longRange && drawArcInsteadOfBezier) {\n        ctx.strokeStyle = 'red'\n      } else {\n        if (hasPaired) {\n          if (type === 'insertSizeAndOrientation') {\n            ctx.strokeStyle = getPairedInsertSizeAndOrientationColor(\n              k1,\n              k2,\n              stats,\n            )[0]\n          } else if (type === 'orientation') {\n            ctx.strokeStyle = getPairedOrientationColor(k1)[0]\n          } else if (type === 'insertSize') {\n            ctx.strokeStyle =\n              getPairedInsertSizeColor(k1, k2, stats)?.[0] || 'grey'\n          } else if (type === 'gradient') {\n            ctx.strokeStyle = `hsl(${Math.log10(absrad) * 10},50%,50%)`\n          }\n        } else {\n          if (type === 'orientation' || type === 'insertSizeAndOrientation') {\n            if (s1 === -1 && s2 === 1) {\n              ctx.strokeStyle = 'navy'\n            } else if (s1 === 1 && s2 === -1) {\n              ctx.strokeStyle = 'green'\n            } else {\n              ctx.strokeStyle = 'grey'\n            }\n          } else if (type === 'gradient') {\n            ctx.strokeStyle = `hsl(${Math.log10(absrad) * 10},50%,50%)`\n          }\n        }\n      }\n\n      const destX = p + radius * 2\n      const destY = Math.min(height + jitter(jitterVal), absrad)\n      if (longRange) {\n        // avoid drawing gigantic circles that glitch out the rendering,\n        // instead draw vertical lines\n        if (absrad > 100_000) {\n          drawLineAtOffset(ctx, p + jitter(jitterVal), height, 'red')\n          drawLineAtOffset(ctx, p2 + jitter(jitterVal), height, 'red')\n        } else if (drawArcInsteadOfBezier) {\n          ctx.arc(p + radius + jitter(jitterVal), 0, absrad, 0, Math.PI)\n          ctx.stroke()\n        } else {\n          ctx.bezierCurveTo(\n            p + jitter(jitterVal),\n            destY,\n            destX,\n            destY,\n            destX + jitter(jitterVal),\n            0,\n          )\n          ctx.stroke()\n        }\n      } else {\n        ctx.bezierCurveTo(\n          p + jitter(jitterVal),\n          destY,\n          destX,\n          destY,\n          destX + jitter(jitterVal),\n          0,\n        )\n        ctx.stroke()\n      }\n    } else if (r1 && drawInter) {\n      drawLineAtOffset(ctx, r1 - view.offsetPx, height, 'purple')\n    }\n  }\n\n  for (const chain of chains) {\n    // chain.length === 1, singleton (other pairs/mates not in view)\n    if (chain.length === 1 && drawLongRange) {\n      const f = chain[0]!\n      if (hasPaired && !(f.flags & 8)) {\n        const mate = {\n          refName: f.next_ref || '',\n          start: f.next_pos || 0,\n          end: f.next_pos || 0,\n          strand: f.strand,\n        }\n        draw(f, mate, asm, true)\n      } else {\n        const features = [f, ...featurizeSA(f.SA, f.id, f.strand, f.name)].sort(\n          (a, b) => a.clipPos - b.clipPos,\n        )\n        for (let i = 0; i < features.length - 1; i++) {\n          const f = features[i]!\n          const v1 = features[i + 1]!\n          draw(f, v1, asm, true)\n        }\n      }\n    } else {\n      const res = hasPaired\n        ? chain.filter(f => !(f.flags & 2048) && !(f.flags & 8))\n        : chain\n            .sort((a, b) => a.clipPos - b.clipPos)\n            .filter(f => !(f.flags & 256))\n      for (let i = 0; i < res.length - 1; i++) {\n        draw(res[i]!, res[i + 1]!, asm, false)\n      }\n    }\n  }\n}\n"],"names":["PairType","PROPER_PAIR","LONG_INSERT","SHORT_INSERT","INTER_CHROM","ABNORMAL_ORIENTATION","UNMAPPED_MATE","fillColor","color_fwd_strand_not_proper","color_rev_strand_not_proper","color_fwd_strand","color_rev_strand","color_fwd_missing_mate","color_rev_missing_mate","color_fwd_diff_chr","color_rev_diff_chr","color_pair_lr","color_pair_rr","color_pair_rl","color_pair_ll","color_nostrand","color_interchrom","color_longinsert","color_shortinsert","color_unmapped_mate","color_unknown","strokeColor","defaultColor","getPairedType","type","f1","f2","stats","undefined","flags","r","orientationTypes","fr","pair_orientation","sameRef","refName","tlen","Math","abs","upper","lower","getPairedInsertSizeColor","getPairedOrientationColorOrDefault","f","type2","pairMap","getPairedOrientationColor","getPairedInsertSizeAndOrientationColor","getSingletonColor","getPairedColor","v0","v1","jitter","n","random","drawLineAtOffset","ctx","offset","height","color","strokeStyle","beginPath","moveTo","lineTo","stroke","drawFeats","self","width","chainData","colorBy","drawInter","drawLongRange","lineWidthSetting","jitterVal","view","getContainingView","assemblyManager","getSession","chains","hasPaired","hasPairedReads","asm","get","assemblyNames","lineWidth","chain","length","features","featurizeSA","SA","id","strand","name","sort","a","b","clipPos","i","draw","next_ref","start","next_pos","end","res","filter","k1","k2","assembly","longRange","s1","s2","p1","p2","ra1","getCanonicalRefName","ra2","r1","bpToPx","coord","offsetPx","r2","radius","absrad","p","drawArcInsteadOfBezier","log10","destX","destY","min","arc","PI","bezierCurveTo"],"sourceRoot":""}