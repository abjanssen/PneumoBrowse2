{"version":3,"file":"static/js/3917.823a3939.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/getOrientationColor.tsx","webpack://@jbrowse/web/../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/overlayUtils.tsx","webpack://@jbrowse/web/../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/util.ts","webpack://@jbrowse/web/../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/AlignmentConnections.tsx","webpack://@jbrowse/web/../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Breakends.tsx","webpack://@jbrowse/web/../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/PairedFeatures.tsx","webpack://@jbrowse/web/../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Translocations.tsx","webpack://@jbrowse/web/../../plugins/breakpoint-split-view/src/BreakpointSplitView/components/Overlay.tsx"],"sourcesContent":["import { alpha } from '@mui/material'\n// orientation definitions from igv.js, see also\n// https://software.broadinstitute.org/software/igv/interpreting_pair_orientations\nexport const orientationTypes = {\n  fr: {\n    F1R2: 'LR',\n    F2R1: 'LR',\n\n    F1F2: 'LL',\n    F2F1: 'LL',\n\n    R1R2: 'RR',\n    R2R1: 'RR',\n\n    R1F2: 'RL',\n    R2F1: 'RL',\n  } as Record<string, string>,\n\n  rf: {\n    R1F2: 'LR',\n    R2F1: 'LR',\n\n    R1R2: 'LL',\n    R2R1: 'LL',\n\n    F1F2: 'RR',\n    F2F1: 'RR',\n\n    F1R2: 'RL',\n    F2R1: 'RL',\n  } as Record<string, string>,\n\n  ff: {\n    F2F1: 'LR',\n    R1R2: 'LR',\n\n    F2R1: 'LL',\n    R1F2: 'LL',\n\n    R2F1: 'RR',\n    F1R2: 'RR',\n\n    R2R1: 'RL',\n    F1F2: 'RL',\n  } as Record<string, string>,\n}\n\nexport const pairMap = {\n  LR: 'color_pair_lr',\n  LL: 'color_pair_ll',\n  RR: 'color_pair_rr',\n  RL: 'color_pair_rl',\n} as const\n\n// manually calculated by running\n// const color = require('color')\n// Object.fromEntries(Object.entries(fillColor).map(([key,val])=>{\n//   return [key, color(val).darken('0.3').hex()]\n// }))\n// this avoids (expensive) use of Color module at runtime\nexport const strokeColor = {\n  color_fwd_strand_not_proper: alpha('#CA6767', 0.8),\n  color_rev_strand_not_proper: alpha('#7272AA', 0.8),\n  color_fwd_strand: alpha('#DC2A2A', 0.8),\n  color_rev_strand: alpha('#4141BA', 0.8),\n  color_fwd_missing_mate: alpha('#921111', 0.8),\n  color_rev_missing_mate: alpha('#111192', 0.8),\n  color_fwd_diff_chr: alpha('#000000', 0.8),\n  color_rev_diff_chr: alpha('#696969', 0.8),\n  color_pair_lr: alpha('#8C8C8C', 0.8),\n  color_pair_rr: alpha('#00005A', 0.8),\n  color_pair_rl: alpha('#005A5A', 0.8),\n  color_pair_ll: alpha('#005A00', 0.8),\n  color_nostrand: alpha('#8C8C8C', 0.8),\n  color_interchrom: alpha('#5A005A', 0.8),\n  color_longinsert: alpha('#B30000', 0.8),\n  color_shortinsert: alpha('#FF3A5C', 0.8),\n  color_unknown: alpha('#555', 0.8),\n}\n\nconst defaultColor = strokeColor.color_unknown\n\nexport function getPairedOrientationColorOrDefault(f: {\n  pair_orientation?: string\n}) {\n  const type = orientationTypes.fr\n  const r = type[f.pair_orientation || ''] as keyof typeof pairMap\n  const type2 = pairMap[r] as keyof typeof strokeColor\n  return r === 'LR' ? undefined : strokeColor[type2]\n}\n\nexport function getLongReadOrientationColorOrDefault(s1: number, s2: number) {\n  if (s1 === -1 && s2 === 1) {\n    return strokeColor.color_pair_rr\n  } else if (s1 === 1 && s2 === -1) {\n    return strokeColor.color_pair_ll\n  } else {\n    return strokeColor.color_unknown\n  }\n}\n\nexport function getLongReadOrientationAbnormal(s1: number, s2: number) {\n  if (s1 === -1 && s2 === 1) {\n    return true\n  } else if (s1 === 1 && s2 === -1) {\n    return true\n  } else {\n    return false\n  }\n}\n\nexport function isAbnormalOrientation(f: { pair_orientation?: string }) {\n  const type = orientationTypes.fr\n  const r = type[f.pair_orientation || ''] as keyof typeof pairMap\n  return r !== 'LR'\n}\n\nexport function getPairedOrientationColor(f: { pair_orientation?: string }) {\n  return getPairedOrientationColorOrDefault(f) || defaultColor\n}\n","import type { BreakpointViewModel } from '../model.ts'\nimport type { Assembly } from '@jbrowse/core/assemblyManager/assembly'\nimport type { getSession } from '@jbrowse/core/util'\n\nexport const [LEFT, , RIGHT] = [0, 1, 2, 3] as const\n\nexport interface OverlayProps {\n  model: BreakpointViewModel\n  trackId: string\n  parentRef: React.RefObject<SVGSVGElement | null>\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}\n\nexport function getYOffset(parentRef: React.RefObject<SVGSVGElement | null>) {\n  // Reading ref during render is intentional for synchronous positioning\n  return parentRef.current?.getBoundingClientRect().top ?? 0\n}\n\nexport function createMouseHandlers(\n  id: string,\n  setMouseoverElt: (id: string | undefined) => void,\n  session: ReturnType<typeof getSession>,\n  widgetType: string,\n  widgetId: string,\n  featureData: unknown,\n) {\n  return {\n    onClick: () => {\n      const featureWidget = session.addWidget?.(widgetType, widgetId, {\n        featureData,\n      })\n      session.showWidget?.(featureWidget)\n    },\n    onMouseOver: () => {\n      setMouseoverElt(id)\n    },\n    onMouseOut: () => {\n      setMouseoverElt(undefined)\n    },\n  }\n}\n\nexport function getTestId(trackId: string, hasMatches: boolean) {\n  return hasMatches ? `${trackId}-loaded` : trackId\n}\n\nexport function getCanonicalRefs(\n  assembly: Assembly,\n  f1RefName: string,\n  f2RefName: string,\n) {\n  const f1ref = assembly.getCanonicalRefName(f1RefName)\n  const f2ref = assembly.getCanonicalRefName(f2RefName)\n  if (!f1ref || !f2ref) {\n    throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n  }\n  return { f1ref, f2ref }\n}\n\nexport function strandToSign(s: string) {\n  return s === '+' ? 1 : s === '-' ? -1 : 0\n}\n\nconst FLAT_ARC_HEIGHT = 30\n\nfunction arcOrLine(x1: number, y1: number, x2: number, y2: number) {\n  const midX = (x1 + x2) / 2\n  return y1 === y2\n    ? `Q ${midX} ${y1 - FLAT_ARC_HEIGHT} ${x2} ${y2}`\n    : `L ${x2} ${y2}`\n}\n\nexport function buildSimplePath(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n) {\n  return `M ${x1} ${y1} ${arcOrLine(x1, y1, x2, y2)}`\n}\n\nexport function buildBreakpointPath(\n  x1: number,\n  y1: number,\n  x2: number,\n  y2: number,\n  x1Tick: number,\n  x2Tick: number,\n) {\n  return `M ${x1Tick} ${y1} L ${x1} ${y1} ${arcOrLine(x1, y1, x2, y2)} L ${x2Tick} ${y2}`\n}\n","import { parseBreakend } from '@gmod/vcf'\nimport { assembleLocStringFast, notEmpty } from '@jbrowse/core/util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\n// this finds candidate alignment features, aimed at plotting split reads from\n// BAM/CRAM files\nexport function getBadlyPairedAlignments(features: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n  const alreadyPairedWithSamePosition = new Set<string>()\n\n  // this finds candidate features that share the same name\n  for (const feature of features.values()) {\n    const flags = feature.get('flags')\n    const id = feature.id()\n    const supp = assembleLocStringFast({\n      refName: feature.get('refName'),\n      start: feature.get('start'),\n      end: feature.get('end'),\n    })\n    const unmapped = flags & 4\n    const correctlyPaired = flags & 2\n\n    if (\n      !alreadySeen.has(id) &&\n      !alreadyPairedWithSamePosition.has(supp) &&\n      !correctlyPaired &&\n      !unmapped\n    ) {\n      const n = feature.get('name')\n      let val = candidates.get(n)\n      if (!val) {\n        val = []\n        candidates.set(n, val)\n      }\n      val.push(feature)\n    }\n    alreadySeen.add(feature.id())\n    alreadyPairedWithSamePosition.add(supp)\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\n// this finds candidate alignment features, aimed at plotting split reads from\n// BAM/CRAM files\nexport function getMatchedAlignmentFeatures(features: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  // this finds candidate features that share the same name\n  for (const feature of features.values()) {\n    const id = feature.id()\n    const unmapped = feature.get('flags') & 4\n    const hasSA = !!feature.get('tags')?.SA\n    if (!alreadySeen.has(id) && !unmapped && hasSA) {\n      const n = feature.get('name')\n      let val = candidates.get(n)\n      if (!val) {\n        val = []\n        candidates.set(n, val)\n      }\n      val.push(feature)\n    }\n    alreadySeen.add(feature.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\nexport function hasPairedReads(features: Map<string, Feature>) {\n  for (const f of features.values()) {\n    if (f.get('flags') & 1) {\n      return true\n    }\n  }\n  return false\n}\n\nexport function findMatchingAlt(feat1: Feature, feat2: Feature) {\n  const alts = feat1.get('ALT') as string[] | undefined\n  if (alts) {\n    return new Map(\n      alts\n        .map(alt => parseBreakend(alt))\n        .filter(notEmpty)\n        .map(bnd => [bnd.MatePosition, bnd]),\n    ).get(`${feat2.get('refName')}:${feat2.get('start') + 1}`)\n  }\n  return undefined\n}\n\n// Returns paired BND features across multiple views by inspecting the ALT\n// field to get exact coordinate matches\nexport function getMatchedBreakendFeatures(feats: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('type') === 'breakend') {\n      const alts = f.get('ALT') as string[] | undefined\n      if (alts) {\n        for (const a of alts) {\n          const cur = `${f.get('refName')}:${f.get('start') + 1}`\n          const bnd = parseBreakend(a)\n          if (bnd) {\n            const val = candidates.get(cur)\n            if (!val) {\n              candidates.set(bnd.MatePosition || 'none', [f])\n            } else {\n              val.push(f)\n            }\n          }\n        }\n      }\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n\n// Getting \"matched\" TRA means just return all TRA\nexport function getMatchedTranslocationFeatures(feats: Map<string, Feature>) {\n  const ret: Feature[][] = []\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('ALT')[0] === '<TRA>') {\n      ret.push([f])\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return ret\n}\n\n// Getting \"matched\" TRA means just return all TRA\nexport function getMatchedPairedFeatures(feats: Map<string, Feature>) {\n  const candidates = new Map<string, Feature[]>()\n  const alreadySeen = new Set<string>()\n\n  for (const f of feats.values()) {\n    if (!alreadySeen.has(f.id()) && f.get('type') === 'paired_feature') {\n      const r1 = f.id().replace('-r1', '')\n      const r2 = f.id().replace('-r2', '')\n      if (f.id().endsWith('-r1')) {\n        if (!candidates.get(r1)) {\n          candidates.set(r1, [])\n        }\n        candidates.get(r1)!.push(f)\n      } else if (f.id().endsWith('-r2')) {\n        if (!candidates.get(r2)) {\n          candidates.set(r2, [])\n        }\n        candidates.get(r2)!.push(f)\n      }\n    }\n    alreadySeen.add(f.id())\n  }\n\n  return [...candidates.values()].filter(v => v.length > 1)\n}\n","import { useMemo, useState } from 'react'\n\nimport { getSession, getStrokeProps } from '@jbrowse/core/util'\nimport { getSnapshot } from '@jbrowse/mobx-state-tree'\nimport { useTheme } from '@mui/material'\nimport { observer } from 'mobx-react'\n\nimport {\n  getLongReadOrientationAbnormal,\n  getLongReadOrientationColorOrDefault,\n  getPairedOrientationColor,\n  isAbnormalOrientation,\n} from './getOrientationColor.tsx'\nimport { LEFT, RIGHT, getTestId, getYOffset } from './overlayUtils.tsx'\nimport {\n  getBadlyPairedAlignments,\n  getMatchedAlignmentFeatures,\n  hasPairedReads,\n} from './util.ts'\nimport {\n  getPxFromCoordinate,\n  heightFromSpecificLevel,\n  useNextFrame,\n  yPos,\n} from '../util.ts'\n\nimport type { OverlayProps } from './overlayUtils.tsx'\n\nconst AlignmentConnections = observer(function AlignmentConnections({\n  model,\n  trackId,\n  parentRef,\n  getTrackYPosOverride,\n}: OverlayProps) {\n  const { interactiveOverlay, views, showIntraviewLinks } = model\n  const theme = useTheme()\n  const session = getSession(model)\n  const snap = getSnapshot(model)\n  const { assemblyManager } = session\n  const v0 = views[0]\n  const assembly = v0 ? assemblyManager.get(v0.assemblyNames[0]!) : undefined\n  useNextFrame(snap)\n  const allFeatures = model.getTrackFeatures(trackId)\n  const hasPaired = useMemo(() => hasPairedReads(allFeatures), [allFeatures])\n\n  const layoutMatches = useMemo(() => {\n    const matched = hasPaired\n      ? getBadlyPairedAlignments(allFeatures)\n      : getMatchedAlignmentFeatures(allFeatures)\n    const layoutMatches = model.getMatchedFeaturesInLayout(trackId, matched)\n    if (!hasPaired) {\n      for (const m of layoutMatches) {\n        m.sort((a, b) => a.clipLengthAtStartOfRead - b.clipLengthAtStartOfRead)\n      }\n    }\n    return layoutMatches\n  }, [allFeatures, trackId, hasPaired, model])\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const yOffset = getYOffset(parentRef)\n\n  const tracks = views.map(v => v.getTrack(trackId))\n\n  if (!assembly) {\n    return null\n  }\n\n  return (\n    <g fill=\"none\" data-testid={getTestId(trackId, layoutMatches.length > 0)}>\n      {layoutMatches.map(chunk => {\n        const ret = []\n        for (let i = 0; i < chunk.length - 1; i++) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]!\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]!\n\n          if (!showIntraviewLinks && level1 === level2) {\n            return null\n          }\n          const f1ref = assembly.getCanonicalRefName(f1.get('refName'))\n          const f2ref = assembly.getCanonicalRefName(f2.get('refName'))\n\n          if (!f1ref || !f2ref) {\n            throw new Error(`unable to find ref for ${f1ref || f2ref}`)\n          }\n          const r = {\n            pair_orientation: f1.get('pair_orientation'),\n          }\n\n          const s1 = f1.get('strand')\n          const s2 = f2.get('strand')\n          const sameRef = f1ref === f2ref\n          const checkOrientation = sameRef\n          let orientationColor = ''\n          let isAbnormal = false\n          if (checkOrientation) {\n            if (hasPaired) {\n              orientationColor = getPairedOrientationColor(r)\n              isAbnormal = isAbnormalOrientation(r)\n            } else {\n              orientationColor = getLongReadOrientationColorOrDefault(s1, s2)\n              isAbnormal = getLongReadOrientationAbnormal(s1, s2)\n            }\n          }\n          const p1 = c1[s1 === -1 ? LEFT : RIGHT]\n          const sn1 = s2 === -1\n          const p2 = hasPaired ? c2[sn1 ? LEFT : RIGHT] : c2[sn1 ? RIGHT : LEFT]\n          const x1 = getPxFromCoordinate(views[level1]!, f1ref, p1)\n          const x2 = getPxFromCoordinate(views[level2]!, f2ref, p2)\n          const reversed1 = views[level1]!.pxToBp(x1).reversed\n          const reversed2 = views[level2]!.pxToBp(x2).reversed\n          const rf1 = reversed1 ? -1 : 1\n          const rf2 = reversed2 ? -1 : 1\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yOffset\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yOffset\n          const sameLevel = level1 === level2\n          const abnormalSpecialRenderFlag = sameLevel && isAbnormal\n          const trackHeight = abnormalSpecialRenderFlag\n            ? tracks[level1].displays[0].height\n            : 0\n          const pf1 = hasPaired ? -1 : 1\n          const y0 = heightFromSpecificLevel(\n            views,\n            trackId,\n            level1,\n            getTrackYPosOverride,\n          )\n\n          const path = [\n            'M',\n            x1,\n            y1,\n            'C',\n            x1 + 200 * f1.get('strand') * rf1,\n            abnormalSpecialRenderFlag\n              ? Math.min(y0 - yOffset + trackHeight, y1 + trackHeight)\n              : y1,\n            x2 - 200 * f2.get('strand') * rf2 * pf1,\n            abnormalSpecialRenderFlag\n              ? Math.min(y0 - yOffset + trackHeight, y2 + trackHeight)\n              : y2,\n            x2,\n            y2,\n          ].join(' ')\n          const id = `${f1.id()}-${f2.id()}`\n          ret.push(\n            <path\n              d={path}\n              key={id}\n              data-testid=\"r1\"\n              pointerEvents={interactiveOverlay ? 'auto' : undefined}\n              strokeWidth={mouseoverElt === id ? 5 : 1}\n              {...getStrokeProps(\n                orientationColor || theme.palette.text.disabled,\n              )}\n              onClick={() => {\n                const featureWidget = session.addWidget?.(\n                  'BreakpointAlignmentsWidget',\n                  'breakpointAlignments',\n                  {\n                    featureData: {\n                      feature1: (\n                        allFeatures.get(f1.id()) || { toJSON: () => ({}) }\n                      ).toJSON(),\n                      feature2: (\n                        allFeatures.get(f2.id()) || { toJSON: () => ({}) }\n                      ).toJSON(),\n                    },\n                  },\n                )\n                session.showWidget?.(featureWidget)\n              }}\n              onMouseOver={() => {\n                setMouseoverElt(id)\n              }}\n              onMouseOut={() => {\n                setMouseoverElt(undefined)\n              }}\n            />,\n          )\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default AlignmentConnections\n","import { useMemo, useState } from 'react'\n\nimport { getSession } from '@jbrowse/core/util'\nimport { getSnapshot } from '@jbrowse/mobx-state-tree'\nimport { observer } from 'mobx-react'\n\nimport {\n  LEFT,\n  buildBreakpointPath,\n  createMouseHandlers,\n  getCanonicalRefs,\n  getTestId,\n  getYOffset,\n} from './overlayUtils.tsx'\nimport { findMatchingAlt, getMatchedBreakendFeatures } from './util.ts'\nimport { getPxFromCoordinate, useNextFrame, yPos } from '../util.ts'\n\nimport type { OverlayProps } from './overlayUtils.tsx'\n\nconst Breakends = observer(function Breakends({\n  model,\n  trackId,\n  parentRef,\n  getTrackYPosOverride,\n}: OverlayProps) {\n  const { interactiveOverlay, views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const snap = getSnapshot(model)\n  const v0 = views[0]\n  const assembly = v0 ? assemblyManager.get(v0.assemblyNames[0]!) : undefined\n  useNextFrame(snap)\n  const totalFeatures = model.getTrackFeatures(trackId)\n\n  const layoutMatches = useMemo(() => {\n    const matchedFeatures = getMatchedBreakendFeatures(totalFeatures)\n    return model.getMatchedFeaturesInLayout(trackId, matchedFeatures)\n  }, [totalFeatures, trackId, model])\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const yOffset = getYOffset(parentRef)\n  const tracks = views.map(v => v.getTrack(trackId))\n\n  if (!assembly) {\n    return null\n  }\n\n  return (\n    <g\n      stroke=\"green\"\n      strokeWidth={5}\n      fill=\"none\"\n      data-testid={getTestId(trackId, layoutMatches.length > 0)}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        for (let i = 0; i < chunk.length - 1; i += 1) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]!\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]!\n          const id = f1.id()\n\n          const relevantAlt = findMatchingAlt(f1, f2)\n          const { f1ref, f2ref } = getCanonicalRefs(\n            assembly,\n            f1.get('refName'),\n            f2.get('refName'),\n          )\n          const x1 = getPxFromCoordinate(views[level1]!, f1ref, c1[LEFT])\n          const x2 = getPxFromCoordinate(views[level2]!, f2ref, c2[LEFT])\n          const reversed1 = views[level1]!.pxToBp(x1).reversed\n          const reversed2 = views[level2]!.pxToBp(x2).reversed\n\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yOffset\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yOffset\n\n          if (!relevantAlt) {\n            console.warn('the relevant ALT allele was not found, cannot render')\n          } else {\n            const x1Tick =\n              x1 -\n              20 * (relevantAlt.Join === 'left' ? -1 : 1) * (reversed1 ? -1 : 1)\n            const x2Tick =\n              x2 -\n              20 *\n                (relevantAlt.MateDirection === 'left' ? 1 : -1) *\n                (reversed2 ? -1 : 1)\n            const path = buildBreakpointPath(x1, y1, x2, y2, x1Tick, x2Tick)\n\n            const mouseHandlers = createMouseHandlers(\n              id,\n              setMouseoverElt,\n              session,\n              'VariantFeatureWidget',\n              'variantFeature',\n              totalFeatures.get(id)?.toJSON(),\n            )\n\n            ret.push(\n              <path\n                d={path}\n                data-testid=\"r2\"\n                pointerEvents={interactiveOverlay ? 'auto' : undefined}\n                key={JSON.stringify(path)}\n                strokeWidth={id === mouseoverElt ? 10 : 5}\n                {...mouseHandlers}\n              />,\n            )\n          }\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default Breakends\n","import { useMemo, useState } from 'react'\n\nimport { getSession } from '@jbrowse/core/util'\nimport { getSnapshot } from '@jbrowse/mobx-state-tree'\nimport { observer } from 'mobx-react'\n\nimport {\n  LEFT,\n  buildSimplePath,\n  createMouseHandlers,\n  getCanonicalRefs,\n  getTestId,\n  getYOffset,\n} from './overlayUtils.tsx'\nimport { getMatchedPairedFeatures } from './util.ts'\nimport { getPxFromCoordinate, useNextFrame, yPos } from '../util.ts'\n\nimport type { OverlayProps } from './overlayUtils.tsx'\n\nconst PairedFeatures = observer(function PairedFeatures({\n  model,\n  trackId,\n  parentRef,\n  getTrackYPosOverride,\n}: OverlayProps) {\n  const { interactiveOverlay, views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const snap = getSnapshot(model)\n  const v0 = views[0]\n  const assembly = v0 ? assemblyManager.get(v0.assemblyNames[0]!) : undefined\n  useNextFrame(snap)\n  const totalFeatures = model.getTrackFeatures(trackId)\n\n  const layoutMatches = useMemo(() => {\n    const matchedFeatures = getMatchedPairedFeatures(totalFeatures)\n    return model.getMatchedFeaturesInLayout(trackId, matchedFeatures)\n  }, [totalFeatures, trackId, model])\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const yOffset = getYOffset(parentRef)\n  const tracks = views.map(v => v.getTrack(trackId))\n\n  if (!assembly) {\n    return null\n  }\n\n  return (\n    <g\n      stroke=\"green\"\n      strokeWidth={5}\n      fill=\"none\"\n      data-testid={getTestId(trackId, layoutMatches.length > 0)}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        for (let i = 0; i < chunk.length - 1; i += 1) {\n          const { layout: c1, feature: f1, level: level1 } = chunk[i]!\n          const { layout: c2, feature: f2, level: level2 } = chunk[i + 1]!\n          const id = f1.id()\n          const { f1ref, f2ref } = getCanonicalRefs(\n            assembly,\n            f1.get('refName'),\n            f2.get('refName'),\n          )\n          const x1 = getPxFromCoordinate(views[level1]!, f1ref, c1[LEFT])\n          const x2 = getPxFromCoordinate(views[level2]!, f2ref, c2[LEFT])\n\n          const y1 =\n            yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n            yOffset\n          const y2 =\n            yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n            yOffset\n\n          const path = buildSimplePath(x1, y1, x2, y2)\n          const mouseHandlers = createMouseHandlers(\n            id,\n            setMouseoverElt,\n            session,\n            'VariantFeatureWidget',\n            'variantFeature',\n            totalFeatures.get(id)?.toJSON(),\n          )\n\n          ret.push(\n            <path\n              d={path}\n              data-testid=\"r2\"\n              key={JSON.stringify(path)}\n              pointerEvents={interactiveOverlay ? 'auto' : undefined}\n              strokeWidth={id === mouseoverElt ? 10 : 5}\n              {...mouseHandlers}\n            />,\n          )\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default PairedFeatures\n","import { useMemo, useState } from 'react'\n\nimport { getSession } from '@jbrowse/core/util'\nimport { getSnapshot } from '@jbrowse/mobx-state-tree'\nimport { observer } from 'mobx-react'\n\nimport {\n  LEFT,\n  buildBreakpointPath,\n  createMouseHandlers,\n  getTestId,\n  getYOffset,\n  strandToSign,\n} from './overlayUtils.tsx'\nimport { getMatchedTranslocationFeatures } from './util.ts'\nimport { getPxFromCoordinate, useNextFrame, yPos } from '../util.ts'\n\nimport type { OverlayProps } from './overlayUtils.tsx'\nimport type { LayoutRecord } from '../types.ts'\n\nconst Translocations = observer(function Translocations({\n  model,\n  trackId,\n  parentRef,\n  getTrackYPosOverride,\n}: OverlayProps) {\n  const { interactiveOverlay, views } = model\n  const session = getSession(model)\n  const { assemblyManager } = session\n  const snap = getSnapshot(model)\n  const v0 = views[0]\n  const assembly = v0 ? assemblyManager.get(v0.assemblyNames[0]!) : undefined\n  useNextFrame(snap)\n  const totalFeatures = model.getTrackFeatures(trackId)\n\n  const layoutMatches = useMemo(() => {\n    const matchedFeatures = getMatchedTranslocationFeatures(totalFeatures)\n    return model.getMatchedFeaturesInLayout(trackId, matchedFeatures)\n  }, [totalFeatures, trackId, model])\n\n  const [mouseoverElt, setMouseoverElt] = useState<string>()\n  const yOffset = getYOffset(parentRef)\n  const tracks = views.map(v => v.getTrack(trackId))\n\n  if (!assembly) {\n    return null\n  }\n\n  // we hardcode the TRA to go to the \"other view\" and if there is none, we\n  // just return null here note: would need to do processing of the INFO\n  // CHR2/END and see which view could contain those coordinates to really do\n  // it properly\n  if (views.length < 2) {\n    return null\n  }\n\n  return (\n    <g\n      fill=\"none\"\n      stroke=\"green\"\n      strokeWidth={5}\n      data-testid={getTestId(trackId, layoutMatches.length > 0)}\n    >\n      {layoutMatches.map(chunk => {\n        const ret = []\n        for (const { layout: c1, feature: f1, level: level1 } of chunk) {\n          const level2 = level1 === 0 ? 1 : 0\n          const id = f1.id()\n\n          const info = f1.get('INFO')\n          const chr2 = info.CHR2[0]\n          const end2 = info.END[0]\n          const res = info.STRANDS?.[0]?.split('')\n          const [myDirection, mateDirection] = res ?? ['.', '.']\n\n          const r = getPxFromCoordinate(views[level2]!, chr2, end2)\n          if (r) {\n            const c2: LayoutRecord = [r, 0, r + 1, 0]\n            const x1 = getPxFromCoordinate(\n              views[level1]!,\n              f1.get('refName'),\n              c1[LEFT],\n            )\n            const x2 = r\n            const reversed1 = views[level1]!.pxToBp(x1).reversed\n            const reversed2 = views[level2]!.pxToBp(x2).reversed\n\n            const y1 =\n              yPos(trackId, level1, views, tracks, c1, getTrackYPosOverride) -\n              yOffset\n            const y2 =\n              yPos(trackId, level2, views, tracks, c2, getTrackYPosOverride) -\n              yOffset\n\n            const x1Tick =\n              x1 - 20 * strandToSign(myDirection) * (reversed1 ? -1 : 1)\n            const x2Tick =\n              x2 - 20 * strandToSign(mateDirection) * (reversed2 ? -1 : 1)\n            const path = buildBreakpointPath(x1, y1, x2, y2, x1Tick, x2Tick)\n\n            const mouseHandlers = createMouseHandlers(\n              id,\n              setMouseoverElt,\n              session,\n              'VariantFeatureWidget',\n              'variantFeature',\n              totalFeatures.get(id)?.toJSON(),\n            )\n\n            ret.push(\n              <path\n                d={path}\n                key={JSON.stringify(path)}\n                pointerEvents={interactiveOverlay ? 'auto' : undefined}\n                strokeWidth={id === mouseoverElt ? 10 : 5}\n                {...mouseHandlers}\n              />,\n            )\n          }\n        }\n        return ret\n      })}\n    </g>\n  )\n})\n\nexport default Translocations\n","import { observer } from 'mobx-react'\n\nimport AlignmentConnections from './AlignmentConnections.tsx'\nimport Breakends from './Breakends.tsx'\nimport PairedFeatures from './PairedFeatures.tsx'\nimport Translocations from './Translocations.tsx'\n\nimport type { BreakpointViewModel } from '../model.ts'\n\n// Routes to the appropriate overlay component based on track type:\n//\n// - AlignmentsTrack (BAM/CRAM): renders split read / paired-end connections\n//   using AlignmentConnections (curvy bezier arcs)\n//\n// - VariantTrack (VCF): renders structural variant connections using one of:\n//   - Translocations: for TRA type variants (uses INFO.CHR2, INFO.END)\n//   - PairedFeatures: for paired_feature type (e.g. BEDPE-style)\n//   - Breakends: for BND type variants (uses ALT field breakend notation)\nconst Overlay = observer(function Overlay(props: {\n  parentRef: React.RefObject<SVGSVGElement | null>\n  model: BreakpointViewModel\n  trackId: string\n  getTrackYPosOverride?: (trackId: string, level: number) => number\n}) {\n  const { model, trackId } = props\n  const tracks = model.getMatchedTracks(trackId)\n  const type = tracks[0]?.type\n\n  if (type === 'AlignmentsTrack') {\n    return <AlignmentConnections {...props} />\n  }\n\n  if (type === 'VariantTrack') {\n    return model.hasTranslocations(trackId) ? (\n      <Translocations {...props} />\n    ) : model.hasPairedFeatures(trackId) ? (\n      <PairedFeatures {...props} />\n    ) : (\n      <Breakends {...props} />\n    )\n  }\n\n  return null\n})\n\nexport default Overlay\n"],"names":["orientationTypes","F1R2","F2R1","F1F2","F2F1","R1R2","R2R1","R1F2","R2F1","pairMap","LR","LL","RR","RL","strokeColor","color_fwd_strand_not_proper","alpha","color_rev_strand_not_proper","color_fwd_strand","color_rev_strand","color_fwd_missing_mate","color_rev_missing_mate","color_fwd_diff_chr","color_rev_diff_chr","color_pair_lr","color_pair_rr","color_pair_rl","color_pair_ll","color_nostrand","color_interchrom","color_longinsert","color_shortinsert","color_unknown","defaultColor","getLongReadOrientationColorOrDefault","s1","s2","getLongReadOrientationAbnormal","isAbnormalOrientation","f","pair_orientation","getPairedOrientationColor","r","undefined","getPairedOrientationColorOrDefault","LEFT","RIGHT","getYOffset","parentRef","current","getBoundingClientRect","top","createMouseHandlers","id","setMouseoverElt","session","widgetType","widgetId","featureData","onClick","featureWidget","addWidget","showWidget","onMouseOver","onMouseOut","getTestId","trackId","hasMatches","getCanonicalRefs","assembly","f1RefName","f2RefName","f1ref","getCanonicalRefName","f2ref","Error","strandToSign","s","arcOrLine","x1","y1","x2","y2","buildSimplePath","buildBreakpointPath","x1Tick","x2Tick","findMatchingAlt","feat1","feat2","alts","get","Map","map","alt","parseBreakend","filter","notEmpty","bnd","MatePosition","observer","model","getTrackYPosOverride","interactiveOverlay","views","showIntraviewLinks","theme","useTheme","getSession","snap","getSnapshot","assemblyManager","v0","assemblyNames","useNextFrame","allFeatures","getTrackFeatures","hasPaired","useMemo","features","values","hasPairedReads","layoutMatches","matched","candidates","alreadySeen","Set","alreadyPairedWithSamePosition","feature","flags","supp","assembleLocStringFast","refName","start","end","unmapped","correctlyPaired","has","n","val","set","push","add","v","length","getBadlyPairedAlignments","hasSA","SA","getMatchedAlignmentFeatures","getMatchedFeaturesInLayout","m","sort","a","b","clipLengthAtStartOfRead","mouseoverElt","useState","yOffset","tracks","getTrack","_jsx","fill","children","chunk","ret","i","layout","c1","f1","level","level1","c2","f2","level2","orientationColor","isAbnormal","p1","sn1","p2","getPxFromCoordinate","rf1","pxToBp","reversed","rf2","yPos","abnormalSpecialRenderFlag","trackHeight","displays","height","pf1","y0","heightFromSpecificLevel","path","Math","min","join","d","pointerEvents","strokeWidth","getStrokeProps","palette","text","disabled","feature1","toJSON","feature2","totalFeatures","matchedFeatures","feats","cur","getMatchedBreakendFeatures","stroke","relevantAlt","reversed1","reversed2","Join","MateDirection","mouseHandlers","JSON","stringify","console","warn","r1","replace","r2","endsWith","getMatchedPairedFeatures","getMatchedTranslocationFeatures","info","chr2","CHR2","end2","END","res","STRANDS","split","myDirection","mateDirection","props","getMatchedTracks","type","AlignmentConnections","hasTranslocations","Translocations","hasPairedFeatures","PairedFeatures","Breakends"],"sourceRoot":""}