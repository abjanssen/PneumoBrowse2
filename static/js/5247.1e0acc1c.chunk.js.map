{"version":3,"file":"static/js/5247.1e0acc1c.chunk.js","mappings":"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","sources":["../../../packages/core/util/parseLineByLine.ts","../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts","../../../plugins/variants/src/VcfAdapter/vcfParser.ts"],"sourcesContent":["import { getProgressDisplayStr } from './index'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n","import IntervalTree from '@flatten-js/interval-tree'\nimport VcfParser from '@gmod/vcf'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport VcfFeature from '../VcfFeature'\nimport { parseVcfBuffer } from './vcfParser'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  vcfFeatures?: Promise<{\n    header: string\n    parser: VcfParser\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { parser } = await this.setup()\n    return parser.getMetadata()\n  }\n\n  public async setupP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const loc = openLocation(this.getConf('vcfLocation'), this.pluginManager)\n    const buffer = await fetchAndMaybeUnzip(loc, opts)\n\n    const { header, featureMap } = parseVcfBuffer(buffer, statusCallback)\n    const parser = new VcfParser({ header })\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing VCF data')\n            let idx = 0\n            const intervalTree = new IntervalTree()\n            for (const line of lines) {\n              const f = new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-${refName}-${idx++}`,\n              })\n              intervalTree.insert([f.get('start'), f.get('end')], f)\n            }\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header,\n      parser,\n      intervalTreeMap,\n    }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch((e: unknown) => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.setup()\n    return Object.keys(intervalTreeMap)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { intervalTreeMap } = await this.setup()\n        for (const f of intervalTreeMap[refName]?.(opts.statusCallback).search([\n          start,\n          end,\n        ]) || []) {\n          observer.next(f)\n        }\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n\n  async getSources() {\n    const conf = this.getConf('samplesTsvLocation')\n    if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n      const { parser } = await this.setup()\n      return parser.samples.map(name => ({\n        name,\n      }))\n    } else {\n      const txt = await openLocation(conf).readFile('utf8')\n      const lines = txt.split(/\\n|\\r\\n|\\r/)\n      const header = lines[0]!.split('\\t')\n      const { parser } = await this.setup()\n      const s = new Set(parser.samples)\n      return lines\n        .slice(1)\n        .map(line => {\n          const cols = line.split('\\t')\n          return {\n            name: cols[0]!,\n            ...Object.fromEntries(\n              // force col 0 to be called name\n              cols.slice(1).map((c, idx) => [header[idx + 1]!, c] as const),\n            ),\n          }\n        })\n        .filter(f => s.has(f.name))\n    }\n  }\n}\n","import { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\n\nimport type { StatusCallback } from '@jbrowse/core/util/parseLineByLine'\n\ninterface VcfParseResult {\n  header: string\n  featureMap: Record<string, string[]>\n}\n\n/**\n * Parse VCF buffer into header lines and feature map organized by reference name\n * @param buffer - The VCF file buffer\n * @param statusCallback - Optional callback for progress updates\n * @returns Object containing header lines and feature map\n */\nexport function parseVcfBuffer(\n  buffer: Uint8Array,\n  statusCallback: StatusCallback = () => {},\n): VcfParseResult {\n  const headerLines: string[] = []\n  const featureMap: Record<string, string[]> = {}\n\n  parseLineByLine(\n    buffer,\n    line => {\n      if (line.startsWith('#')) {\n        headerLines.push(line)\n      } else {\n        const ret = line.indexOf('\\t')\n        const refName = line.slice(0, ret)\n        if (!featureMap[refName]) {\n          featureMap[refName] = []\n        }\n        featureMap[refName].push(line)\n      }\n      return true\n    },\n    statusCallback,\n  )\n\n  return {\n    header: headerLines.join('\\n'),\n    featureMap,\n  }\n}\n"],"names":["parseLineByLine","buffer","lineCallback","statusCallback","decoder","TextDecoder","blockStart","i","length","n","indexOf","lineEnd","b","subarray","line","decode","trim","getProgressDisplayStr","VcfAdapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","getHeader","header","this","setup","getMetadata","parser","setupP","opts","loc","openLocation","getConf","pluginManager","fetchAndMaybeUnzip","featureMap","headerLines","startsWith","push","ret","refName","slice","join","parseVcfBuffer","VcfParser","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","idx","intervalTree","IntervalTree","f","VcfFeature","variant","parseLine","id","insert","get","vcfFeatures","catch","e","undefined","getRefNames","_","keys","getFeatures","region","ObservableCreate","async","start","end","search","observer","next","complete","error","stopToken","getSources","conf","uri","samples","name","readFile","split","s","Set","cols","c","filter","has"],"sourceRoot":""}