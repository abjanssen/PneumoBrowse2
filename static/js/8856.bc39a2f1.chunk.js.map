{"version":3,"file":"static/js/8856.bc39a2f1.chunk.js","mappings":"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","sources":["../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/afterAttach.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawSynteny.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/components/util.ts"],"sourcesContent":["import { getContainingView, getSession } from '@jbrowse/core/util'\nimport { bpToPx } from '@jbrowse/core/util/Base1DUtils'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\nimport { autorun, reaction } from 'mobx'\nimport { addDisposer, getSnapshot } from 'mobx-state-tree'\n\nimport { drawMouseoverSynteny, drawRef } from './drawSynteny'\n\nimport type { LinearSyntenyDisplayModel } from './model'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface Pos {\n  offsetPx: number\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\ntype LSV = LinearSyntenyViewModel\n\nexport function doAfterAttach(self: LinearSyntenyDisplayModel) {\n  addDisposer(\n    self,\n    autorun(() => {\n      const view = getContainingView(self) as LinearSyntenyViewModel\n      if (\n        !view.initialized ||\n        !view.views.every(a => a.displayedRegions.length > 0 && a.initialized)\n      ) {\n        return\n      }\n\n      const ctx1 = self.mainCanvas?.getContext('2d')\n      const ctx3 = self.cigarClickMapCanvas?.getContext('2d')\n      if (!ctx1 || !ctx3) {\n        return\n      }\n\n      const height = self.height\n      const width = view.width\n      ctx1.clearRect(0, 0, width, height)\n      ctx3.clearRect(0, 0, width, height)\n      drawRef(self, ctx1, ctx3)\n    }),\n  )\n\n  addDisposer(\n    self,\n    autorun(() => {\n      const view = getContainingView(self) as LinearSyntenyViewModel\n      if (\n        !view.initialized ||\n        !view.views.every(a => a.displayedRegions.length > 0 && a.initialized)\n      ) {\n        return\n      }\n      drawMouseoverSynteny(self)\n    }),\n  )\n\n  // this attempts to reduce recalculation of feature positions drawn by the\n  // synteny view\n  //\n  // uses a reaction to say \"we know the positions don't change in any relevant\n  // way unless bpPerPx changes or displayedRegions changes\"\n  addDisposer(\n    self,\n    reaction(\n      () => {\n        const view = getContainingView(self) as LSV\n        return {\n          bpPerPx: view.views.map(v => v.bpPerPx),\n\n          // stringifying 'deeply' accesses the displayed regions, see\n          // issue #3456\n          displayedRegions: JSON.stringify(\n            view.views.map(v => v.displayedRegions),\n          ),\n          features: self.features,\n          initialized:\n            view.initialized &&\n            view.views.every(\n              a => a.displayedRegions.length > 0 && a.initialized,\n            ),\n        }\n      },\n      ({ initialized }) => {\n        if (!initialized) {\n          return\n        }\n        const { level } = self\n        const { assemblyManager } = getSession(self)\n        const view = getContainingView(self) as LSV\n        const viewSnaps = view.views.map(view => ({\n          ...getSnapshot(view),\n          width: view.width,\n          staticBlocks: view.staticBlocks,\n          interRegionPaddingWidth: view.interRegionPaddingWidth,\n          minimumBlockWidth: view.minimumBlockWidth,\n        }))\n\n        const map = [] as FeatPos[]\n        const feats = self.features || []\n\n        for (const f of feats) {\n          const mate = f.get('mate')\n          let f1s = f.get('start')\n          let f1e = f.get('end')\n          const f2s = mate.start\n          const f2e = mate.end\n\n          if (f.get('strand') === -1) {\n            ;[f1e, f1s] = [f1s, f1e]\n          }\n          const a1 = assemblyManager.get(f.get('assemblyName'))\n          const a2 = assemblyManager.get(mate.assemblyName)\n          const r1 = f.get('refName')\n          const r2 = mate.refName\n          const ref1 = a1?.getCanonicalRefName(r1) || r1\n          const ref2 = a2?.getCanonicalRefName(r2) || r2\n          const v1 = viewSnaps[level]!\n          const v2 = viewSnaps[level + 1]!\n          const p11 = bpToPx({ self: v1, refName: ref1, coord: f1s })\n          const p12 = bpToPx({ self: v1, refName: ref1, coord: f1e })\n          const p21 = bpToPx({ self: v2, refName: ref2, coord: f2s })\n          const p22 = bpToPx({ self: v2, refName: ref2, coord: f2e })\n\n          if (\n            p11 === undefined ||\n            p12 === undefined ||\n            p21 === undefined ||\n            p22 === undefined\n          ) {\n            continue\n          }\n\n          const cigar = f.get('CIGAR') as string | undefined\n          map.push({\n            p11,\n            p12,\n            p21,\n            p22,\n            f,\n            cigar: MismatchParser.parseCigar(cigar),\n          })\n        }\n\n        self.setFeatPositions(map)\n      },\n      { fireImmediately: true },\n    ),\n  )\n}\n","import { doesIntersect2, getContainingView } from '@jbrowse/core/util'\n\nimport { draw, drawMatchSimple } from './components/util'\n\nimport type { LinearSyntenyDisplayModel } from './model'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model'\n\nexport const MAX_COLOR_RANGE = 255 * 255 * 255 // max color range\n\nfunction makeColor(idx: number) {\n  const r = Math.floor(idx / (255 * 255)) % 255\n  const g = Math.floor(idx / 255) % 255\n  const b = idx % 255\n  return `rgb(${r},${g},${b})`\n}\n\nconst colorMap = {\n  I: '#ff03',\n  N: '#0a03',\n  D: '#00f3',\n  X: 'brown',\n  M: '#f003',\n  '=': '#f003',\n}\n\nconst lineLimit = 3\n\nconst oobLimit = 1600\n\nexport function getId(r: number, g: number, b: number, unitMultiplier: number) {\n  return Math.floor((r * 255 * 255 + g * 255 + b - 1) / unitMultiplier)\n}\n\nexport function drawRef(\n  model: LinearSyntenyDisplayModel,\n  ctx1: CanvasRenderingContext2D,\n  ctx3?: CanvasRenderingContext2D,\n) {\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const drawCIGAR = view.drawCIGAR\n  const drawCIGARMatchesOnly = view.drawCIGARMatchesOnly\n  const { level, height, featPositions } = model\n  const width = view.width\n  const bpPerPxs = view.views.map(v => v.bpPerPx)\n\n  if (ctx3) {\n    ctx3.imageSmoothingEnabled = false\n  }\n\n  ctx1.beginPath()\n  const offsets = view.views.map(v => v.offsetPx)\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / featPositions.length)\n\n  // this loop is optimized to draw many thin lines with a single ctx.stroke\n  // call, a separate loop below draws larger boxes\n  ctx1.fillStyle = colorMap.M\n  ctx1.strokeStyle = colorMap.M\n  for (const { p11, p12, p21, p22 } of featPositions) {\n    const x11 = p11.offsetPx - offsets[level]!\n    const x12 = p12.offsetPx - offsets[level]!\n    const x21 = p21.offsetPx - offsets[level + 1]!\n    const x22 = p22.offsetPx - offsets[level + 1]!\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const y1 = 0\n    const y2 = height\n    const mid = (y2 - y1) / 2\n\n    // drawing a line if the results are thin results in much less pixellation\n    // than filling in a thin polygon\n    if (\n      l1 <= lineLimit &&\n      l2 <= lineLimit &&\n      x21 < width + oobLimit &&\n      x21 > -oobLimit\n    ) {\n      ctx1.moveTo(x11, y1)\n      if (drawCurves) {\n        ctx1.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        ctx1.lineTo(x21, y2)\n      }\n    }\n  }\n  ctx1.stroke()\n\n  // this loop only draws small lines as a polyline, the polyline calls\n  // ctx.stroke once is much more efficient than calling stroke() many times\n  ctx1.fillStyle = colorMap.M\n  ctx1.strokeStyle = colorMap.M\n  for (const { p11, p12, p21, p22, f, cigar } of featPositions) {\n    const x11 = p11.offsetPx - offsets[level]!\n    const x12 = p12.offsetPx - offsets[level]!\n    const x21 = p21.offsetPx - offsets[level + 1]!\n    const x22 = p22.offsetPx - offsets[level + 1]!\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const minX = Math.min(x21, x22)\n    const maxX = Math.max(x21, x22)\n    const y1 = 0\n    const y2 = height\n    const mid = (y2 - y1) / 2\n\n    if (\n      !(l1 <= lineLimit && l2 <= lineLimit) &&\n      doesIntersect2(minX, maxX, -oobLimit, view.width + oobLimit)\n    ) {\n      const s1 = f.get('strand')\n      const k1 = s1 === -1 ? x12 : x11\n      const k2 = s1 === -1 ? x11 : x12\n\n      // rev1/rev2 flip the direction of the CIGAR drawing in horizontally flipped\n      // modes. somewhat heuristically determined, but tested for\n      const rev1 = k1 < k2 ? 1 : -1\n      const rev2 = (x21 < x22 ? 1 : -1) * s1\n\n      // cx1/cx2 are the current x positions on top and bottom rows\n      let cx1 = k1\n      let cx2 = s1 === -1 ? x22 : x21\n      if (cigar.length && drawCIGAR) {\n        // continuingFlag skips drawing commands on very small CIGAR features\n        let continuingFlag = false\n\n        // px1/px2 are the previous x positions on the top and bottom rows\n        let px1 = 0\n        let px2 = 0\n        const unitMultiplier2 = Math.floor(MAX_COLOR_RANGE / cigar.length)\n\n        for (let j = 0; j < cigar.length; j += 2) {\n          const idx = j * unitMultiplier2 + 1\n\n          const len = +cigar[j]!\n          const op = cigar[j + 1] as keyof typeof colorMap\n\n          if (!continuingFlag) {\n            px1 = cx1\n            px2 = cx2\n          }\n\n          const d1 = len / bpPerPxs[level]!\n          const d2 = len / bpPerPxs[level + 1]!\n\n          if (op === 'M' || op === '=' || op === 'X') {\n            cx1 += d1 * rev1\n            cx2 += d2 * rev2\n          } else if (op === 'D' || op === 'N') {\n            cx1 += d1 * rev1\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          else if (op === 'I') {\n            cx2 += d2 * rev2\n          }\n\n          // check that we are even drawing in view here, e.g. that all\n          // points are not all less than 0 or greater than width\n          if (\n            !(\n              Math.max(px1, px2, cx1, cx2) < 0 ||\n              Math.min(px1, px2, cx1, cx2) > width\n            )\n          ) {\n            // if it is a small feature and not the last element of the\n            // CIGAR (which could skip rendering it entire if we did turn\n            // it on), then turn on continuing flag\n            const isNotLast = j < cigar.length - 2\n            if (\n              Math.abs(cx1 - px1) <= 1 &&\n              Math.abs(cx2 - px2) <= 1 &&\n              isNotLast\n            ) {\n              continuingFlag = true\n            } else {\n              // allow rendering the dominant color when using continuing\n              // flag if the last element of continuing was a large\n              // feature, else just use match\n              const letter = (continuingFlag && d1 > 1) || d2 > 1 ? op : 'M'\n              ctx1.fillStyle = colorMap[letter]\n              continuingFlag = false\n\n              if (drawCIGARMatchesOnly) {\n                if (letter === 'M') {\n                  draw(ctx1, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                  ctx1.fill()\n                }\n              } else {\n                draw(ctx1, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                ctx1.fill()\n              }\n              if (ctx3) {\n                ctx3.fillStyle = makeColor(idx)\n                draw(ctx3, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                ctx3.fill()\n              }\n            }\n          }\n        }\n      } else {\n        draw(ctx1, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n        ctx1.fill()\n      }\n    }\n  }\n\n  // draw click map\n  const ctx2 = model.clickMapCanvas?.getContext('2d')\n  if (!ctx2) {\n    return\n  }\n  ctx2.imageSmoothingEnabled = false\n  ctx2.clearRect(0, 0, width, height)\n\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let i = 0; i < featPositions.length; i++) {\n    const feature = featPositions[i]!\n    const idx = i * unitMultiplier + 1\n    ctx2.fillStyle = makeColor(idx)\n\n    // too many click map false positives with colored stroked lines\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.fill()\n      },\n      feature,\n      ctx: ctx2,\n      drawCurves,\n      level,\n      offsets,\n      oobLimit,\n      viewWidth: view.width,\n      hideTiny: true,\n      height,\n    })\n  }\n}\n\nexport function drawMouseoverSynteny(model: LinearSyntenyDisplayModel) {\n  const { level, clickId, mouseoverId } = model\n  const highResolutionScaling = 1\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const height = model.height\n  const width = view.width\n  const ctx = model.mouseoverCanvas?.getContext('2d')\n  const offsets = view.views.map(v => v.offsetPx)\n\n  if (!ctx) {\n    return\n  }\n  ctx.resetTransform()\n  ctx.scale(highResolutionScaling, highResolutionScaling)\n  ctx.clearRect(0, 0, width, height)\n  ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)'\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'\n  const feature1 = model.featMap[mouseoverId || '']\n  if (feature1) {\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.fill()\n      },\n      feature: feature1,\n      level,\n      ctx,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n  const feature2 = model.featMap[clickId || '']\n  if (feature2) {\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.stroke()\n      },\n      feature: feature2,\n      ctx,\n      level,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n}\n","import type React from 'react'\n\nimport {\n  assembleLocString,\n  doesIntersect2,\n  getContainingTrack,\n  getContainingView,\n  getSession,\n  isSessionModelWithWidgets,\n} from '@jbrowse/core/util'\n\nimport { MAX_COLOR_RANGE, getId } from '../drawSynteny'\n\nimport type { LinearSyntenyDisplayModel } from '../model'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface Pos {\n  offsetPx: number\n}\n\nexport interface ClickCoord {\n  clientX: number\n  clientY: number\n  feature: { f: Feature }\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\nexport function drawMatchSimple({\n  feature,\n  ctx,\n  offsets,\n  level,\n  cb,\n  height,\n  drawCurves,\n  oobLimit,\n  viewWidth,\n  hideTiny,\n}: {\n  feature: FeatPos\n  ctx: CanvasRenderingContext2D\n  offsets: number[]\n  level: number\n  oobLimit: number\n  viewWidth: number\n  cb: (ctx: CanvasRenderingContext2D) => void\n  height: number\n  drawCurves?: boolean\n  hideTiny?: boolean\n}) {\n  const { p11, p12, p21, p22 } = feature\n\n  const x11 = p11.offsetPx - offsets[level]!\n  const x12 = p12.offsetPx - offsets[level]!\n  const x21 = p21.offsetPx - offsets[level + 1]!\n  const x22 = p22.offsetPx - offsets[level + 1]!\n\n  const l1 = Math.abs(x12 - x11)\n  const l2 = Math.abs(x22 - x21)\n  const y1 = 0\n  const y2 = height\n  const mid = (y2 - y1) / 2\n  const minX = Math.min(x21, x22)\n  const maxX = Math.max(x21, x22)\n\n  if (!doesIntersect2(minX, maxX, -oobLimit, viewWidth + oobLimit)) {\n    return\n  }\n\n  // drawing a line if the results are thin: drawing a line results in much\n  // less pixellation than filling in a thin polygon\n  if (l1 <= 1 && l2 <= 1) {\n    // hideTiny can be used to avoid drawing mouseover for thin lines in this\n    // case\n    if (!hideTiny) {\n      ctx.beginPath()\n      ctx.moveTo(x11, y1)\n      if (drawCurves) {\n        ctx.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        ctx.lineTo(x21, y2)\n      }\n      ctx.stroke()\n    }\n  } else {\n    draw(ctx, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n    cb(ctx)\n  }\n}\n\nexport function draw(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n  drawCurves?: boolean,\n) {\n  if (drawCurves) {\n    drawBezierBox(ctx, x1, x2, y1, x3, x4, y2, mid)\n  } else {\n    drawBox(ctx, x1, x2, y1, x3, x4, y2)\n  }\n}\n\nexport function drawBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n) {\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.lineTo(x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.closePath()\n}\n\nexport function drawBezierBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n) {\n  const len1 = Math.abs(x1 - x2)\n  const len2 = Math.abs(x1 - x2)\n\n  // heuristic to not draw hourglass inversions with bezier curves when they\n  // are thin and far apart because it results in areas that are not drawn well\n  // demo https://codesandbox.io/s/fast-glitter-q3b1or?file=/src/index.js\n  if (len1 < 5 && len2 < 5 && x2 < x1 && Math.abs(x1 - x3) > 100) {\n    const tmp = x1\n    x1 = x2\n    x2 = tmp\n  }\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.bezierCurveTo(x2, mid, x3, mid, x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.bezierCurveTo(x4, mid, x1, mid, x1, y1)\n  ctx.closePath()\n}\n\nexport function onSynClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n) {\n  const view = getContainingView(model)\n  const track = getContainingTrack(model)\n  const {\n    featPositions,\n    numFeats,\n    clickMapCanvas: ref1,\n    cigarClickMapCanvas: ref2,\n    level,\n  } = model\n  if (!ref1 || !ref2) {\n    return\n  }\n  const rect = ref1.getBoundingClientRect()\n  const ctx1 = ref1.getContext('2d')\n  const ctx2 = ref2.getContext('2d')\n  if (!ctx1 || !ctx2) {\n    return\n  }\n  const x = event.clientX - rect.left\n  const y = event.clientY - rect.top\n  const [r1, g1, b1] = ctx1.getImageData(x, y, 1, 1).data\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / numFeats)\n  const id = getId(r1!, g1!, b1!, unitMultiplier)\n  const feat = featPositions[id]\n  if (feat) {\n    const { f } = feat\n    model.setClickId(f.id())\n    const session = getSession(model)\n    if (isSessionModelWithWidgets(session)) {\n      session.showWidget(\n        session.addWidget('SyntenyFeatureWidget', 'syntenyFeature', {\n          view,\n          track,\n          featureData: f.toJSON(),\n          level,\n        }),\n      )\n    }\n  }\n  return feat\n}\n\nexport function onSynContextClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n  setAnchorEl: (arg: ClickCoord) => void,\n) {\n  event.preventDefault()\n  const ref1 = model.clickMapCanvas\n  const ref2 = model.cigarClickMapCanvas\n  if (!ref1 || !ref2) {\n    return\n  }\n  const rect = ref1.getBoundingClientRect()\n  const ctx1 = ref1.getContext('2d')\n  const ctx2 = ref2.getContext('2d')\n  if (!ctx1 || !ctx2) {\n    return\n  }\n  const { clientX, clientY } = event\n  const x = clientX - rect.left\n  const y = clientY - rect.top\n  const [r1, g1, b1] = ctx1.getImageData(x, y, 1, 1).data\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / model.numFeats)\n  const id = getId(r1!, g1!, b1!, unitMultiplier)\n  const f = model.featPositions[id]\n  if (f) {\n    model.setClickId(f.f.id())\n    setAnchorEl({ clientX, clientY, feature: f })\n  }\n}\n\nexport function getTooltip({\n  feature,\n  cigarOp,\n  cigarOpLen,\n}: {\n  feature: Feature\n  cigarOp?: string\n  cigarOpLen?: string\n}) {\n  // @ts-expect-error\n  const f1 = feature.toJSON() as {\n    refName: string\n    start: number\n    end: number\n    strand?: number\n    assemblyName: string\n    identity?: number\n    name?: string\n    mate: {\n      start: number\n      end: number\n      refName: string\n      name: string\n    }\n  }\n  const f2 = f1.mate\n  const l1 = f1.end - f1.start\n  const l2 = f2.end - f2.start\n  const identity = f1.identity\n  const n1 = f1.name\n  const n2 = f2.name\n  return [\n    `Loc1: ${assembleLocString(f1)}`,\n    `Loc2: ${assembleLocString(f2)}`,\n    `Inverted: ${f1.strand === -1}`,\n    `Query len: ${l1.toLocaleString('en-US')}`,\n    `Target len: ${l2.toLocaleString('en-US')}`,\n    identity ? `Identity: ${identity.toPrecision(2)}` : '',\n    cigarOp ? `CIGAR operator: ${cigarOp}${cigarOpLen}` : '',\n    n1 ? `Name 1: ${n1}` : '',\n    n2 ? `Name 2: ${n2}` : '',\n  ]\n    .filter(f => !!f)\n    .join('<br/>')\n}\n"],"names":["doAfterAttach","self","addDisposer","autorun","view","getContainingView","initialized","views","every","a","displayedRegions","length","ctx1","mainCanvas","getContext","ctx3","cigarClickMapCanvas","height","width","clearRect","drawRef","drawMouseoverSynteny","reaction","bpPerPx","map","v","JSON","stringify","features","level","assemblyManager","getSession","viewSnaps","getSnapshot","staticBlocks","interRegionPaddingWidth","minimumBlockWidth","feats","f","mate","get","f1s","f1e","f2s","start","f2e","end","a1","a2","assemblyName","r1","r2","refName","ref1","getCanonicalRefName","ref2","v1","v2","p11","bpToPx","coord","p12","p21","p22","undefined","cigar","push","MismatchParser","setFeatPositions","fireImmediately","MAX_COLOR_RANGE","makeColor","idx","Math","floor","colorMap","I","N","D","X","M","lineLimit","oobLimit","getId","r","g","b","unitMultiplier","model","drawCurves","drawCIGAR","drawCIGARMatchesOnly","featPositions","bpPerPxs","imageSmoothingEnabled","beginPath","offsets","offsetPx","fillStyle","strokeStyle","x11","x12","x21","x22","l1","abs","l2","y1","y2","mid","moveTo","bezierCurveTo","lineTo","stroke","minX","min","maxX","max","doesIntersect2","s1","k1","rev1","rev2","cx1","cx2","continuingFlag","px1","px2","unitMultiplier2","j","len","op","d1","d2","isNotLast","letter","draw","fill","ctx2","clickMapCanvas","i","feature","drawMatchSimple","cb","ctx","viewWidth","hideTiny","clickId","mouseoverId","mouseoverCanvas","resetTransform","scale","feature1","featMap","feature2","x1","x2","x3","x4","len1","len2","tmp","closePath","drawBezierBox","drawBox","onSynClick","event","track","getContainingTrack","numFeats","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","g1","b1","getImageData","data","feat","setClickId","id","session","isSessionModelWithWidgets","showWidget","addWidget","featureData","toJSON","onSynContextClick","setAnchorEl","preventDefault","getTooltip","cigarOp","cigarOpLen","f1","f2","identity","n1","name","n2","assembleLocString","strand","toLocaleString","toPrecision","filter","join"],"sourceRoot":""}