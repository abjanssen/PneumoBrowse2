{"version":3,"file":"static/js/4441.7b888fb5.chunk.js","mappings":"yOAeOA,eAAeC,EACpBC,EACAC,GAEA,MAAM,QACJC,EAAO,OACPC,EAAM,QACNC,EAAO,QACPC,EAAO,UACPC,EAAS,eACTC,EAAiBA,QACfP,EAEEQ,EAASJ,EAAQ,GACjBK,GAASD,EAAOE,IAAMF,EAAOG,OAASN,EACtCO,EAAYT,EAASD,EAAQW,OAC7BC,GAAYC,EAAAA,EAAAA,IAAuBT,IAEnC,gBAAEU,KAAoBC,SAAeC,EAAAA,EAAAA,cACzC,iBACAX,EACA,KACEY,EAAAA,EAAAA,GAAuBV,EAAON,EAAQH,EAAaoB,IACjD,MAAMC,GAASC,EAAAA,EAAAA,SAAQrB,EAAUsB,GAAKA,EAAEC,IAAI,WAC5C,IAAIC,EAAmB,GACvBL,EAAIM,OACJ,IAAK,MAAMC,KAAUzB,EAAS,CAC5B,MAAM,gBAAEc,IAAoBY,EAAAA,EAAAA,GAASR,EAAK,IACrCpB,EACHC,SAAUoB,EAAOM,EAAOE,OAAS,GACjC1B,OAAQS,EACRkB,YAAaH,EAAOI,OAAS,OAC7BC,cAAeA,IAAM,GACrBlB,cAEFM,EAAIa,YAAc,wBAClBb,EAAIc,YACJd,EAAIe,OAAO,EAAGvB,GACdQ,EAAIgB,OAAO3B,EAAOG,GAClBQ,EAAIiB,SACJjB,EAAIkB,UAAU,EAAG1B,GACjBa,EAAQA,EAAMc,OAAOvB,EACvB,CAEA,OADAI,EAAIoB,UACG,CAAExB,gBAAiBS,MAI1BgB,EAAa,IACdxB,EACHhB,SAAUe,EAAgB0B,IAAIC,EAAAA,wBAC9BxC,SACAM,SAGF,OAAOmC,EAAAA,EAAAA,IAAUH,GAAYI,EAAAA,EAAAA,GAAqB5B,GACpD,C,gFCrDO,SAASW,EACdR,EACA0B,GAiBA,MAAM,SACJ7C,EAAQ,QACRG,EAAO,QACPC,EAAO,UACP0C,EACA5C,OAAQ6C,EACRC,OAAO,OAAEC,GAAQ,oBACjBC,EAAmB,cACnBnB,EAAa,OACboB,EAAM,OACNC,EAAS,EAAC,YACVvB,EAAW,UACXxB,EAAS,UACTQ,GAAYC,EAAAA,EAAAA,IAAuBT,IACjCwC,EACEtC,EAASJ,EAAQ,GACjBkD,EAAc9C,EAAOG,MACrB4C,EAAY/C,EAAOE,IACnB8C,EAAWhD,EAAOgD,SAClBC,EAAa,EAAIpD,EACjBI,GAAS8C,EAAYD,GAAeG,EAEpCtD,EAAS6C,EAA4B,EAATK,EAC5BK,GAAYC,EAAAA,EAAAA,IAAeP,EAAQ,aAInCQ,GADQC,EAAAA,EAAAA,UAAS,IAAKd,EAAWe,MAAO,CAAC,EAAG3D,KAC7ByD,SACfG,EAAUH,EAAO,GACjBI,EAAUJ,EAAO,GACjBK,EAAaD,EAAUD,EACvBG,EAAgC,QAAxBnB,EAAUoB,UAGlBC,EAA6B,IAAfH,EAAmB9D,EAAS8D,EAAa,EAGvDI,EAAOC,KAAKC,IAAI,GAChBC,EAASF,KAAKC,IAAIR,GAAWM,EAE7BI,EADSH,KAAKC,IAAIP,GAAWK,EACVG,EACnBE,EAAuB,IAAZD,EAAgBtE,EAASsE,EAAU,EAG9CE,EAAMT,EACPU,IACCC,EAAAA,EAAAA,OAAM1E,GAAUmE,KAAKC,IAAIK,GAAKP,EAAOG,GAAUE,EAAU,EAAGvE,GAC5DkD,EACDuB,IACCC,EAAAA,EAAAA,OAAM1E,GAAUyE,EAAIb,GAAWK,EAAa,EAAGjE,GAAUkD,EAE/D,IAAIyB,EACAC,EAAaC,OAAOC,kBACxB,MAAMjE,EAAkB,GAGxB,GAAIc,EAAa,CACfV,EAAIc,YACJd,EAAIa,YAAcH,EAClB,MAAMoD,EAAmE,GAEzE,IAAK,MAAMC,KAAWlF,EAASiD,SAAU,EACvCkC,EAAAA,EAAAA,IAAgBtE,GAChB,MAAMuE,EAASF,EAAQ3D,IAAI,SACrB8D,EAAOH,EAAQ3D,IAAI,OACnB+D,EAAS/B,GACVD,EAAY+B,GAAQ7B,GACpB4B,EAAS/B,GAAeG,EACvB+B,EAAUhC,GACXD,EAAY8B,GAAU5B,GACtB6B,EAAOhC,GAAeG,IAIb,EAAT8B,KAA8B,EAAbR,IAAmBS,EAAUD,EAAS,KAC1DvE,EAAgByE,KAAKN,GACrBJ,EAAaQ,GAEf,MAAMG,EAAQP,EAAQ3D,IAAI,SACpBmE,EAAShB,EAAIe,GAGfA,EAAQ1B,EACVkB,EAAiBO,KAAK,CACpBF,SACAK,EAAGJ,EAAUD,EAASM,EAAAA,oBACtBC,MAAM,IAECJ,EAAQ3B,IAAYG,GAC7BgB,EAAiBO,KAAK,CACpBF,SACAK,EAAGJ,EAAUD,EAASM,EAAAA,oBACtBC,MAAM,IAIV,MAAMC,OAAqBC,IAAZlB,EAAwBH,EAAIG,GAAWa,EACjDnC,GAKHpC,EAAIe,OAAOqD,EAASO,GACpB3E,EAAIgB,OAAOoD,EAASG,GACpBvE,EAAIgB,OAAOmD,EAAQI,KANnBvE,EAAIe,OAAOoD,EAAQQ,GACnB3E,EAAIgB,OAAOmD,EAAQI,GACnBvE,EAAIgB,OAAOoD,EAASG,IAMtBb,EAAUY,CACZ,CAKA,GAHAtE,EAAIiB,SAGA6C,EAAiBrE,OAAS,EAAG,CAC/BO,EAAI6E,UAAYvC,EAChB,IAAK,MAAM,OAAE6B,EAAM,EAAEK,EAAC,KAAEE,KAAUZ,EAC5BY,EACF1E,EAAI8E,SAASX,EAAQlC,EAAQuC,EAAGO,EAAAA,oBAEhC/E,EAAI8E,SACFX,EACApF,EAASgG,EAAAA,mBACTP,EACAO,EAAAA,mBAIR,CACF,MAEE,IAAK,MAAMhB,KAAWlF,EAASiD,SAAU,EACvCkC,EAAAA,EAAAA,IAAgBtE,GAChB,MAAMuE,EAASF,EAAQ3D,IAAI,SACrB8D,EAAOH,EAAQ3D,IAAI,OACnB+D,EAAS/B,GACVD,EAAY+B,GAAQ7B,GACpB4B,EAAS/B,GAAeG,EACvB+B,EAAUhC,GACXD,EAAY8B,GAAU5B,GACtB6B,EAAOhC,GAAeG,IAIb,EAAT8B,KAA8B,EAAbR,IAAmBS,EAAUD,EAAS,KAC1DvE,EAAgByE,KAAKN,GACrBJ,EAAaQ,GAEf,MAAMG,EAAQP,EAAQ3D,IAAI,SACpBmE,EAAShB,EAAIe,GACbE,EAAIJ,EAAUD,EAASM,EAAAA,oBAEvBO,EAAIpE,EAAcmD,EAASO,GAEjCtE,EAAIc,YACJd,EAAIa,YAAcmE,EAClB,MAAML,OAAqBC,IAAZlB,EAAwBH,EAAIG,GAAWa,EACjDnC,GAKHpC,EAAIe,OAAOqD,EAASO,GACpB3E,EAAIgB,OAAOoD,EAASG,GACpBvE,EAAIgB,OAAOmD,EAAQI,KANnBvE,EAAIe,OAAOoD,EAAQQ,GACnB3E,EAAIgB,OAAOmD,EAAQI,GACnBvE,EAAIgB,OAAOoD,EAASG,IAMtBvE,EAAIiB,SACJyC,EAAUY,EAENA,EAAQ1B,GACV5C,EAAI6E,UAAYvC,EAChBtC,EAAI8E,SAASX,EAAQlC,EAAQuC,EAAGO,EAAAA,qBACvBT,EAAQ3B,IAAYG,IAC7B9C,EAAI6E,UAAYvC,EAChBtC,EAAI8E,SAASX,EAAQpF,EAASgG,EAAAA,mBAAoBP,EAAGO,EAAAA,oBAEzD,CAGF,GAAIhD,EAAqB,CACvB/B,EAAIiF,UAAY,EAChBjF,EAAIa,YAAc,wBAClB,IAAK,MAAMqE,KAAQpD,EACjB9B,EAAIc,YACJd,EAAIe,OAAO,EAAGmC,KAAKiC,MAAM5B,EAAI2B,KAC7BlF,EAAIgB,OAAO3B,EAAO6D,KAAKiC,MAAM5B,EAAI2B,KACjClF,EAAIiB,QAER,CACA,MAAO,CACLrB,kBAEJ,C","sources":["../../../plugins/wiggle/src/MultiRowLineRenderer/renderMultiRowLine.ts","../../../plugins/wiggle/src/drawLine.ts"],"sourcesContent":["import {\n  groupBy,\n  renderToAbstractCanvas,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\nimport { createStopTokenChecker } from '@jbrowse/core/util/stopToken'\n\nimport { drawLine } from '../drawLine.ts'\nimport { serializeWiggleFeature } from '../util.ts'\n\nimport type { MultiRenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderMultiRowLine(\n  renderProps: MultiRenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    sources,\n    height,\n    regions,\n    bpPerPx,\n    stopToken,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const rowHeight = height / sources.length\n  const lastCheck = createStopTokenChecker(stopToken)\n\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx => {\n        const groups = groupBy(features, f => f.get('source'))\n        let feats: Feature[] = []\n        ctx.save()\n        for (const source of sources) {\n          const { reducedFeatures } = drawLine(ctx, {\n            ...renderProps,\n            features: groups[source.name] || [],\n            height: rowHeight,\n            staticColor: source.color || 'blue',\n            colorCallback: () => '', // unused when staticColor is set\n            lastCheck,\n          })\n          ctx.strokeStyle = 'rgba(200,200,200,0.8)'\n          ctx.beginPath()\n          ctx.moveTo(0, rowHeight)\n          ctx.lineTo(width, rowHeight)\n          ctx.stroke()\n          ctx.translate(0, rowHeight)\n          feats = feats.concat(reducedFeatures)\n        }\n        ctx.restore()\n        return { reducedFeatures: feats }\n      }),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp } from '@jbrowse/core/util'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { WIGGLE_CLIP_HEIGHT, WIGGLE_FUDGE_FACTOR, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type {\n  Feature,\n  LastStopTokenCheck,\n  Region,\n  StopToken,\n} from '@jbrowse/core/util'\n\nexport function drawLine(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    regions: Region[]\n    bpPerPx: number\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    displayCrossHatches: boolean\n    colorCallback: (f: Feature, score: number) => string\n    config: AnyConfigurationModel\n    offset?: number\n    stopToken?: StopToken\n    lastCheck?: LastStopTokenCheck\n    // when color is static (e.g. in Multi renderers), set strokeStyle once and skip callback\n    staticColor?: string\n  },\n) {\n  const {\n    features,\n    regions,\n    bpPerPx,\n    scaleOpts,\n    height: unadjustedHeight,\n    ticks: { values },\n    displayCrossHatches,\n    colorCallback,\n    config,\n    offset = 0,\n    staticColor,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const regionStart = region.start\n  const regionEnd = region.end\n  const reversed = region.reversed\n  const invBpPerPx = 1 / bpPerPx\n  const width = (regionEnd - regionStart) * invBpPerPx\n\n  const height = unadjustedHeight - offset * 2\n  const clipColor = readConfObject(config, 'clipColor')\n\n  // Use d3-scale only to get the \"niced\" domain, then use simple arithmetic\n  const scale = getScale({ ...scaleOpts, range: [0, height] })\n  const domain = scale.domain() as [number, number]\n  const niceMin = domain[0]\n  const niceMax = domain[1]\n  const domainSpan = niceMax - niceMin\n  const isLog = scaleOpts.scaleType === 'log'\n\n  // Precompute values for linear scale\n  const linearRatio = domainSpan !== 0 ? height / domainSpan : 0\n\n  // Precompute values for log scale (base 2)\n  const log2 = Math.log(2)\n  const logMin = Math.log(niceMin) / log2\n  const logMax = Math.log(niceMax) / log2\n  const logSpan = logMax - logMin\n  const logRatio = logSpan !== 0 ? height / logSpan : 0\n\n  // Simple arithmetic scale function - avoid d3-scale overhead in hot path\n  const toY = isLog\n    ? (n: number) =>\n        clamp(height - (Math.log(n) / log2 - logMin) * logRatio, 0, height) +\n        offset\n    : (n: number) =>\n        clamp(height - (n - niceMin) * linearRatio, 0, height) + offset\n\n  let lastVal: number | undefined\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n\n  // when staticColor is set, batch all path operations into a single stroke\n  if (staticColor) {\n    ctx.beginPath()\n    ctx.strokeStyle = staticColor\n    const clippingFeatures: { leftPx: number; w: number; high: boolean }[] = []\n\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = reversed\n        ? (regionEnd - fEnd) * invBpPerPx\n        : (fStart - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - fStart) * invBpPerPx\n        : (fEnd - regionStart) * invBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      // bitwise OR is faster than Math.floor for positive numbers\n      if ((leftPx | 0) !== (prevLeftPx | 0) || rightPx - leftPx > 1) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      const score = feature.get('score')\n      const scoreY = toY(score)\n\n      // track clipping\n      if (score > niceMax) {\n        clippingFeatures.push({\n          leftPx,\n          w: rightPx - leftPx + WIGGLE_FUDGE_FACTOR,\n          high: true,\n        })\n      } else if (score < niceMin && !isLog) {\n        clippingFeatures.push({\n          leftPx,\n          w: rightPx - leftPx + WIGGLE_FUDGE_FACTOR,\n          high: false,\n        })\n      }\n\n      const startY = lastVal !== undefined ? toY(lastVal) : scoreY\n      if (!reversed) {\n        ctx.moveTo(leftPx, startY)\n        ctx.lineTo(leftPx, scoreY)\n        ctx.lineTo(rightPx, scoreY)\n      } else {\n        ctx.moveTo(rightPx, startY)\n        ctx.lineTo(rightPx, scoreY)\n        ctx.lineTo(leftPx, scoreY)\n      }\n      lastVal = score\n    }\n    // single stroke for entire path\n    ctx.stroke()\n\n    // draw clipping indicators\n    if (clippingFeatures.length > 0) {\n      ctx.fillStyle = clipColor\n      for (const { leftPx, w, high } of clippingFeatures) {\n        if (high) {\n          ctx.fillRect(leftPx, offset, w, WIGGLE_CLIP_HEIGHT)\n        } else {\n          ctx.fillRect(\n            leftPx,\n            height - WIGGLE_CLIP_HEIGHT,\n            w,\n            WIGGLE_CLIP_HEIGHT,\n          )\n        }\n      }\n    }\n  } else {\n    // non-static color: stroke per feature (original behavior)\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = reversed\n        ? (regionEnd - fEnd) * invBpPerPx\n        : (fStart - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - fStart) * invBpPerPx\n        : (fEnd - regionStart) * invBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      // bitwise OR is faster than Math.floor for positive numbers\n      if ((leftPx | 0) !== (prevLeftPx | 0) || rightPx - leftPx > 1) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      const score = feature.get('score')\n      const scoreY = toY(score)\n      const w = rightPx - leftPx + WIGGLE_FUDGE_FACTOR\n\n      const c = colorCallback(feature, score)\n\n      ctx.beginPath()\n      ctx.strokeStyle = c\n      const startY = lastVal !== undefined ? toY(lastVal) : scoreY\n      if (!reversed) {\n        ctx.moveTo(leftPx, startY)\n        ctx.lineTo(leftPx, scoreY)\n        ctx.lineTo(rightPx, scoreY)\n      } else {\n        ctx.moveTo(rightPx, startY)\n        ctx.lineTo(rightPx, scoreY)\n        ctx.lineTo(leftPx, scoreY)\n      }\n      ctx.stroke()\n      lastVal = score\n\n      if (score > niceMax) {\n        ctx.fillStyle = clipColor\n        ctx.fillRect(leftPx, offset, w, WIGGLE_CLIP_HEIGHT)\n      } else if (score < niceMin && !isLog) {\n        ctx.fillStyle = clipColor\n        ctx.fillRect(leftPx, height - WIGGLE_CLIP_HEIGHT, w, WIGGLE_CLIP_HEIGHT)\n      }\n    }\n  }\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    for (const tick of values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n  return {\n    reducedFeatures,\n  }\n}\n"],"names":["async","renderMultiRowLine","renderProps","features","sources","height","regions","bpPerPx","stopToken","statusCallback","region","width","end","start","rowHeight","length","lastCheck","createStopTokenChecker","reducedFeatures","rest","updateStatus","renderToAbstractCanvas","ctx","groups","groupBy","f","get","feats","save","source","drawLine","name","staticColor","color","colorCallback","strokeStyle","beginPath","moveTo","lineTo","stroke","translate","concat","restore","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables","props","scaleOpts","unadjustedHeight","ticks","values","displayCrossHatches","config","offset","regionStart","regionEnd","reversed","invBpPerPx","clipColor","readConfObject","domain","getScale","range","niceMin","niceMax","domainSpan","isLog","scaleType","linearRatio","log2","Math","log","logMin","logSpan","logRatio","toY","n","clamp","lastVal","prevLeftPx","Number","NEGATIVE_INFINITY","clippingFeatures","feature","checkStopToken2","fStart","fEnd","leftPx","rightPx","push","score","scoreY","w","WIGGLE_FUDGE_FACTOR","high","startY","undefined","fillStyle","fillRect","WIGGLE_CLIP_HEIGHT","c","lineWidth","tick","round"],"ignoreList":[],"sourceRoot":""}