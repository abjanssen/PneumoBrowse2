{"version":3,"file":"static/js/7439.904356eb.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/BlastTabularAdapter/BlastTabularAdapter.ts","../../../plugins/comparative-adapters/src/SyntenyFeature/index.ts","../../../plugins/comparative-adapters/src/util.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport {\n  doesIntersect2,\n  fetchAndMaybeUnzip,\n  Feature,\n  Region,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\n\nimport { parseLineByLine } from '../util'\nimport SyntenyFeature from '../SyntenyFeature'\n\n// Blast output column names/descriptions taken from\n// https://www.ncbi.nlm.nih.gov/books/NBK279684/#_appendices_Options_for_the_commandline_a_\ninterface BlastColumns {\n  /** Query Seq-id */\n  qseqid?: string\n  /** Query GI */\n  qgi?: string\n  /** Query accesion */\n  qacc?: string\n  /** Subject Seq-id */\n  sseqid?: string\n  /** All subject Seq-id(s), separated by a ';' */\n  sallseqid?: string\n  /** Subject GI */\n  sgi?: string\n  /** All subject GIs */\n  sallgi?: string\n  /** Subject accession */\n  sacc?: string\n  /** All subject accessions */\n  sallacc?: string\n  /** Start of alignment in query */\n  qstart?: number\n  /** End of alignment in query */\n  qend?: number\n  /** Start of alignment in subject */\n  sstart?: number\n  /** End of alignment in subject */\n  send?: number\n  /** Aligned part of query sequence */\n  qseq?: string\n  /** Aligned part of subject sequence */\n  sseq?: string\n  /** Expect value */\n  evalue?: string\n  /** Bit score */\n  bitscore?: string\n  /** Raw score */\n  score?: string\n  /** Alignment length */\n  length?: string\n  /** Percentage of identical matches */\n  pident?: string\n  /** Number of identical matches */\n  nident?: string\n  /** Number of mismatches */\n  mismatch?: string\n  /** Number of positive-scoring matches */\n  positive?: string\n  /** Number of gap openings */\n  gapopen?: string\n  /** Total number of gap */\n  gaps?: string\n  /** Percentage of positive-scoring matches */\n  ppos?: string\n  /** Query and subject frames separated by a '/' */\n  frames?: string\n  /** Query frame */\n  qframe?: string\n  /** Subject frame */\n  sframe?: string\n  /** Blast traceback operations (BTOP) */\n  btop?: string\n  /** Unique Subject Taxonomy ID(s), separated by a ';'(in numerical order) */\n  staxids?: string\n  /** Unique Subject Scientific Name(s), separated by a ';' */\n  sscinames?: string\n  /** Unique Subject Common Name(s), separated by a ';' */\n  scomnames?: string\n  /**\n   * Unique Subject Blast Name(s), separated by a ';' (in alphabetical order)\n   */\n  sblastnames?: string\n  /**\n   * Unique Subject Super Kingdom(s), separated by a ';' (in alphabetical order)\n   */\n  sskingdoms?: string\n  /** Subject Title */\n  stitle?: string\n  /** All Subject Title(s), separated by a '<>' */\n  salltitles?: string\n  /** Subject Strand */\n  sstrand?: string\n  /** Query Coverage Per Subject (for all HSPs) */\n  qcovs?: string\n  /** Query Coverage Per HSP */\n  qcovhsp?: string\n  /**\n   * A measure of Query Coverage that counts a position in a subject sequence\n   * for this measure only once. The second time the position is aligned to the\n   * query is not counted towards this measure.\n   */\n  qcovus?: string\n}\n\n// Blast output column names/descriptions taken from\n// https://www.ncbi.nlm.nih.gov/books/NBK279684/#_appendices_Options_for_the_commandline_a_\ninterface BlastRecord extends BlastColumns {\n  /** Query Seq-id */\n  qseqid: string\n  /** Subject Seq-id */\n  sseqid: string\n  /** Start of alignment in query */\n  qstart: number\n  /** End of alignment in query */\n  qend: number\n  /** Start of alignment in subject */\n  sstart: number\n  /** End of alignment in subject */\n  send: number\n}\n\nfunction createBlastLineParser(columns: string) {\n  const columnNames = columns.trim().split(' ') as (keyof BlastRecord)[]\n  const qseqidIndex = columnNames.indexOf('qseqid')\n  if (qseqidIndex === -1) {\n    throw new Error('Missing required column \"qseqid\"')\n  }\n  const sseqidIndex = columnNames.indexOf('sseqid')\n  if (sseqidIndex === -1) {\n    throw new Error('Missing required column \"sseqid\"')\n  }\n  const qstartIndex = columnNames.indexOf('qstart')\n  if (qstartIndex === -1) {\n    throw new Error('Missing required column \"qstart\"')\n  }\n  const qendIndex = columnNames.indexOf('qend')\n  if (qendIndex === -1) {\n    throw new Error('Missing required column \"qend\"')\n  }\n  const sstartIndex = columnNames.indexOf('sstart')\n  if (sstartIndex === -1) {\n    throw new Error('Missing required column \"sstart\"')\n  }\n  const sendIndex = columnNames.indexOf('send')\n  if (sendIndex === -1) {\n    throw new Error('Missing required column \"send\"')\n  }\n  const columnNameSet = new Map<string, number>(\n    columnNames\n      .map((c, idx) => [c, idx] as const)\n      .filter(\n        f =>\n          !['qseqid', 'sseqid', 'qstart', 'qend', 'sstart', 'send'].includes(\n            f[0],\n          ),\n      ),\n  )\n  return (line: string): BlastRecord | undefined => {\n    if (line.startsWith('#')) {\n      return\n    }\n    const row = line.split('\\t')\n    const qseqid = row[qseqidIndex]\n    const sseqid = row[sseqidIndex]\n    const qstart = row[qstartIndex]\n    const qend = row[qendIndex]\n    const sstart = row[sstartIndex]\n    const send = row[sendIndex]\n    if (!(qseqid && sseqid && qstart && qend && sstart && send)) {\n      console.warn('Invalid BLAST line')\n      console.warn(line)\n      return\n    }\n    const record: BlastRecord = {\n      qseqid,\n      sseqid,\n      qstart: Number.parseInt(qstart),\n      qend: Number.parseInt(qend),\n      sstart: Number.parseInt(sstart),\n      send: Number.parseInt(send),\n    }\n    for (const [columnName, idx] of columnNameSet.entries()) {\n      const value = row[idx]\n      if (!value) {\n        continue\n      }\n      // @ts-expect-error\n      record[columnName] = value\n    }\n    return record\n  }\n}\n\nexport default class BlastTabularAdapter extends BaseFeatureDataAdapter {\n  private data: Promise<BlastRecord[]> | undefined\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  getData(opts?: BaseOptions): Promise<BlastRecord[]> {\n    if (!this.data) {\n      this.data = this.setup(opts).catch((e: unknown) => {\n        this.data = undefined\n        throw e\n      })\n    }\n    return this.data\n  }\n\n  async setup(opts?: BaseOptions): Promise<BlastRecord[]> {\n    const pm = this.pluginManager\n    const buf = await fetchAndMaybeUnzip(\n      openLocation(readConfObject(this.config, 'blastTableLocation'), pm),\n      opts,\n    )\n    const columns: string = readConfObject(this.config, 'columns')\n    return parseLineByLine(buf, createBlastLineParser(columns))\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures\n    // so is not really that important, and has to be true or else\n    // getFeatures is never called (BaseAdapter filters it out)\n    return true\n  }\n\n  getAssemblyNames() {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    if (assemblyNames.length === 0) {\n      const query = this.getConf('queryAssembly') as string\n      const target = this.getConf('targetAssembly') as string\n      return [query, target]\n    }\n    return assemblyNames\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    // @ts-expect-error\n    const r1 = opts.regions?.[0].assemblyName\n    const feats = await this.getData(opts)\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    if (idx !== -1) {\n      const set = new Set<string>()\n      for (const feat of feats) {\n        set.add(idx === 0 ? feat.qseqid : feat.sseqid)\n      }\n      return [...set]\n    }\n    console.warn('Unable to do ref renaming on adapter')\n    return []\n  }\n\n  getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const blastRecords = await this.getData(opts)\n      const [queryAssembly, targetAssembly] = this.getAssemblyNames()\n\n      // The index of the assembly name in the query list corresponds to the\n      // adapter in the subadapters list\n      const {\n        refName: queryRefName,\n        assemblyName: queryAssemblyName,\n        start: queryStart,\n        end: queryEnd,\n      } = query\n      if (\n        queryAssemblyName !== targetAssembly &&\n        queryAssemblyName !== queryAssembly\n      ) {\n        console.warn(`${queryAssemblyName} not found in this adapter`)\n        observer.complete()\n        return\n      }\n\n      for (let i = 0; i < blastRecords.length; i++) {\n        const r = blastRecords[i]!\n        let start: number\n        let end: number\n        let refName: string\n        let assemblyName: string | undefined\n        let mateStart: number\n        let mateEnd: number\n        let mateRefName: string\n        let mateAssemblyName: string | undefined\n\n        const { qseqid, sseqid, qstart, qend, sstart, send, ...rest } = r\n        if (queryAssemblyName === queryAssembly) {\n          start = qstart\n          end = qend\n          refName = qseqid\n          assemblyName = queryAssembly\n          mateStart = sstart\n          mateEnd = send\n          mateRefName = sseqid\n          mateAssemblyName = targetAssembly\n        } else {\n          start = sstart\n          end = send\n          refName = sseqid\n          assemblyName = targetAssembly\n          mateStart = qstart\n          mateEnd = qend\n          mateRefName = qseqid\n          mateAssemblyName = queryAssembly\n        }\n        let strand = 1\n        let mateStrand = 1\n        if (start > end) {\n          ;[start, end] = [end, start]\n          strand = -1\n        }\n        if (mateStart > mateEnd) {\n          ;[mateStart, mateEnd] = [mateEnd, mateStart]\n          mateStrand = -1\n        }\n        if (\n          refName === queryRefName &&\n          doesIntersect2(queryStart, queryEnd, start, end)\n        ) {\n          observer.next(\n            new SyntenyFeature({\n              uniqueId: i + queryAssemblyName,\n              assemblyName,\n              start,\n              end,\n              type: 'match',\n              refName,\n              strand: strand * mateStrand,\n              syntenyId: i,\n              ...rest,\n              mate: {\n                start: mateStart,\n                end: mateEnd,\n                refName: mateRefName,\n                assemblyName: mateAssemblyName,\n              },\n            }),\n          )\n        }\n      }\n\n      observer.complete()\n    })\n  }\n\n  freeResources(/* { query } */): void {}\n}\n","import { SimpleFeature } from '@jbrowse/core/util'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\n\n// locals\nconst { getMismatches } = MismatchParser\n\nexport default class SyntenyFeature extends SimpleFeature {\n  get(arg: string): any {\n    if (arg === 'mismatches') {\n      return getMismatches(this.get('CIGAR'))\n    }\n    return super.get(arg)\n  }\n}\n","import { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport { fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport type { Buffer } from 'buffer'\n\nimport { PAFRecord } from './PAFAdapter/util'\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f || f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start!,\n            end: +end!,\n            score: +score!,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  const buf = await fetchAndMaybeUnzip(file, opts)\n  const decoder = new TextDecoder('utf8')\n  return decoder.decode(buf)\n}\n\nexport function zip(a: number[], b: number[]) {\n  return a.map((e, i) => [e, b[i]] as [number, number])\n}\n\nexport function parseLineByLine<T>(\n  buffer: Buffer,\n  cb: (line: string) => T | undefined,\n): T[] {\n  let blockStart = 0\n  const entries: T[] = []\n  const decoder = new TextDecoder('utf8')\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf('\\n', blockStart)\n    if (n === -1) {\n      break\n    }\n    const b = buffer.subarray(blockStart, n)\n    const line = decoder.decode(b).trim()\n    if (line) {\n      const entry = cb(line)\n      if (entry) {\n        entries.push(entry)\n      }\n    }\n\n    blockStart = n + 1\n  }\n  return entries\n}\n\nexport function parsePAFLine(line: string) {\n  const [\n    qname,\n    ,\n    qstart,\n    qend,\n    strand,\n    tname,\n    ,\n    tstart,\n    tend,\n    numMatches,\n    blockLen,\n    mappingQual,\n    ...fields\n  ] = line.split('\\t')\n\n  const rest = Object.fromEntries(\n    fields.map(field => {\n      const r = field.indexOf(':')\n      const fieldName = field.slice(0, r)\n      const fieldValue = field.slice(r + 3)\n      return [fieldName, fieldValue]\n    }),\n  )\n\n  return {\n    tname,\n    tstart: +tstart!,\n    tend: +tend!,\n    qname,\n    qstart: +qstart!,\n    qend: +qend!,\n    strand: strand === '-' ? -1 : 1,\n    extra: {\n      numMatches: +numMatches!,\n      blockLen: +blockLen!,\n      mappingQual: +mappingQual!,\n      ...rest,\n    },\n  } as PAFRecord\n}\n\nexport function flipCigar(cigar: string[]) {\n  const arr = []\n  for (let i = cigar.length - 2; i >= 0; i -= 2) {\n    arr.push(cigar[i])\n    const op = cigar[i + 1]\n    if (op === 'D') {\n      arr.push('I')\n    } else if (op === 'I') {\n      arr.push('D')\n    } else {\n      arr.push(op)\n    }\n  }\n  return arr\n}\n\nexport function swapIndelCigar(cigar: string) {\n  return cigar.replaceAll('D', 'K').replaceAll('I', 'D').replaceAll('K', 'I')\n}\n"],"names":["BlastTabularAdapter","BaseFeatureDataAdapter","getData","opts","this","data","setup","catch","e","undefined","pm","pluginManager","buf","fetchAndMaybeUnzip","openLocation","readConfObject","config","columns","parseLineByLine","columnNames","trim","split","qseqidIndex","indexOf","Error","sseqidIndex","qstartIndex","qendIndex","sstartIndex","sendIndex","columnNameSet","Map","map","c","idx","filter","f","includes","line","startsWith","row","qseqid","sseqid","qstart","qend","sstart","send","console","warn","record","Number","parseInt","columnName","entries","value","createBlastLineParser","hasDataForRefName","getAssemblyNames","assemblyNames","getConf","length","getRefNames","r1","regions","assemblyName","feats","set","Set","feat","add","getFeatures","query","ObservableCreate","async","blastRecords","queryAssembly","targetAssembly","refName","queryRefName","queryAssemblyName","start","queryStart","end","queryEnd","observer","complete","i","r","mateStart","mateEnd","mateRefName","mateAssemblyName","rest","strand","mateStrand","doesIntersect2","next","SyntenyFeature","uniqueId","type","syntenyId","mate","freeResources","getMismatches","MismatchParser","SimpleFeature","get","arg","super","parseBed","text","name","score","readFile","file","TextDecoder","decode","zip","a","b","buffer","cb","blockStart","decoder","n","subarray","entry","push","parsePAFLine","qname","tname","tstart","tend","numMatches","blockLen","mappingQual","fields","extra","Object","fromEntries","field","slice","flipCigar","cigar","arr","op","swapIndelCigar","replaceAll"],"sourceRoot":""}