"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[2977,7706],{47046:(e,t,a)=>{a.d(t,{A:()=>i});class r{}class n{constructor(){this.signals=new Set,this.abortController=new AbortController}addSignal(e=new r){if(this.signal.aborted)throw new Error("cannot add a signal, already aborted!");this.signals.add(e),e.aborted?this.handleAborted(e):"function"==typeof e.addEventListener&&e.addEventListener("abort",(()=>{this.handleAborted(e)}))}handleAborted(e){this.signals.delete(e),0===this.signals.size&&this.abortController.abort()}get signal(){return this.abortController.signal}abort(){this.abortController.abort()}}class s{constructor(){this.callbacks=new Set}addCallback(e=()=>{}){this.callbacks.add(e),e(this.currentMessage)}callback(e){this.currentMessage=e;for(const t of this.callbacks)t(e)}}class i{constructor({fill:e,cache:t}){if("function"!=typeof e)throw new TypeError("must pass a fill function");if("object"!=typeof t)throw new TypeError("must pass a cache object");if("function"!=typeof t.get||"function"!=typeof t.set||"function"!=typeof t.delete)throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");this.cache=t,this.fillCallback=e}static isAbortException(e){return"AbortError"===e.name||"ERR_ABORTED"===e.code||"AbortError: aborted"===e.message||"Error: aborted"===e.message}evict(e,t){this.cache.get(e)===t&&this.cache.delete(e)}fill(e,t,a,r){const i=new n,o=new s;o.addCallback(r);const l={aborter:i,promise:this.fillCallback(t,i.signal,(e=>{o.callback(e)})),settled:!1,statusReporter:o,get aborted(){return this.aborter.signal.aborted}};l.aborter.addSignal(a),l.aborter.signal.addEventListener("abort",(()=>{l.settled||this.evict(e,l)})),l.promise.then((()=>{l.settled=!0}),(()=>{l.settled=!0,this.evict(e,l)})).catch((e=>{throw console.error(e),e})),this.cache.set(e,l)}static checkSinglePromise(e,t){function a(){if(null==t?void 0:t.aborted)throw Object.assign(new Error("aborted"),{code:"ERR_ABORTED"})}return e.then((e=>(a(),e)),(e=>{throw a(),e}))}has(e){return this.cache.has(e)}get(e,t,a,r){if(!a&&t instanceof AbortSignal)throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");const n=this.cache.get(e);return n?n.aborted&&!n.settled?(this.evict(e,n),this.get(e,t,a,r)):n.settled?n.promise:(n.aborter.addSignal(a),n.statusReporter.addCallback(r),i.checkSinglePromise(n.promise,a)):(this.fill(e,t,a,r),i.checkSinglePromise(this.cache.get(e).promise,a))}delete(e){const t=this.cache.get(e);t&&(t.settled||t.aborter.abort(),this.cache.delete(e))}clear(){const e=this.cache.keys();let t=0;for(let a=e.next();!a.done;a=e.next())this.delete(a.value),t+=1;return t}}},7706:(e,t,a)=>{a.d(t,{sG:()=>d,unzip:()=>i,i2:()=>o});var r=a(35451),n=a(45834),s=a(57864);async function i(e){try{let t,a=0,n=0;const i=[];let o,l=0;do{const r=e.subarray(a);if(o=new s.Inflate,({strm:t}=o),o.push(r,s.Z_SYNC_FLUSH),o.err)throw new Error(o.msg);a+=t.next_in,i[n]=o.result,l+=i[n].length,n+=1}while(t.avail_in);const h=new Uint8Array(l);for(let e=0,t=0;e<i.length;e++)h.set(i[e],t),t+=i[e].length;return r.hp.from(h)}catch(e){if(`${e}`.match(/incorrect header check/))throw new Error("problem decompressing block: incorrect gzip header check");throw e}}async function o(e,t){try{let a;const{minv:n,maxv:i}=t;let o=n.blockPosition,l=n.dataPosition;const h=[],c=[],d=[];let f=0,g=0;do{const t=e.subarray(o-n.blockPosition),r=new s.Inflate;if(({strm:a}=r),r.push(t,s.Z_SYNC_FLUSH),r.err)throw new Error(r.msg);const u=r.result;h.push(u);let w=u.length;c.push(o),d.push(l),1===h.length&&n.dataPosition&&(h[0]=h[0].subarray(n.dataPosition),w=h[0].length);const b=o;if(o+=a.next_in,l+=w,b>=i.blockPosition){h[g]=h[g].subarray(0,i.blockPosition===n.blockPosition?i.dataPosition-n.dataPosition+1:i.dataPosition+1),c.push(o),d.push(l),f+=h[g].length;break}f+=h[g].length,g++}while(a.avail_in);const u=new Uint8Array(f);for(let e=0,t=0;e<h.length;e++)u.set(h[e],t),t+=h[e].length;return{buffer:r.hp.from(u),cpositions:c,dpositions:d}}catch(e){if(`${e}`.match(/incorrect header check/))throw new Error("problem decompressing block: incorrect gzip header check");throw e}}var l=a(59086),h=a.n(l);class c{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else{if(!t)throw new TypeError("either filehandle or path must be defined");this.filehandle=new n.EY(t)}}_readLongWithOverflow(e,t=0,a=!0){const r=h().fromBytesLE(e.slice(t,t+8),a);if(r.greaterThan(Number.MAX_SAFE_INTEGER)||r.lessThan(Number.MIN_SAFE_INTEGER))throw new TypeError("integer overflow");return r.toNumber()}_getIndex(){return this.index||(this.index=this._readIndex()),this.index}async _readIndex(){let e=r.hp.allocUnsafe(8);await this.filehandle.read(e,0,8,0);const t=this._readLongWithOverflow(e,0,!0);if(!t)return[[0,0]];const a=new Array(t+1);a[0]=[0,0];const n=16*t;if(n>Number.MAX_SAFE_INTEGER)throw new TypeError("integer overflow");e=r.hp.allocUnsafe(n),await this.filehandle.read(e,0,n,8);for(let r=0;r<t;r+=1){const t=this._readLongWithOverflow(e,16*r),n=this._readLongWithOverflow(e,16*r+8);a[r+1]=[t,n]}return a}async getLastBlock(){const e=await this._getIndex();if(e.length)return e[e.length-1]}async getRelevantBlocksForRead(e,t){const a=t+e;if(0===e)return[];const r=await this._getIndex(),n=[],s=(e,a)=>{const r=e[1],n=a?a[1]:1/0;return r<=t&&n>t?0:r<t?-1:1};let i=0,o=r.length-1,l=Math.floor(r.length/2),h=s(r[l],r[l+1]);for(;0!==h;)h>0?o=l-1:h<0&&(i=l+1),l=Math.ceil((o-i)/2)+i,h=s(r[l],r[l+1]);n.push(r[l]);let c=l+1;for(;c<r.length&&(n.push(r[c]),!(r[c][1]>=a));c+=1);return n[n.length-1][1]<a&&n.push([]),n}}class d{constructor({filehandle:e,path:t,gziFilehandle:a,gziPath:r}){if(e)this.filehandle=e;else{if(!t)throw new TypeError("either filehandle or path must be defined");this.filehandle=new n.EY(t)}if(!a&&!r&&!t)throw new TypeError("either gziFilehandle or gziPath must be defined");this.gzi=new c({filehandle:a,path:a||r||!t?`${t}.gzi`:r})}async stat(){const e=await this.filehandle.stat();return Object.assign(e,{size:await this.getUncompressedFileSize(),blocks:void 0,blksize:void 0})}async getUncompressedFileSize(){const[,e]=await this.gzi.getLastBlock(),{size:t}=await this.filehandle.stat(),a=r.hp.allocUnsafe(4),{bytesRead:n}=await this.filehandle.read(a,0,4,t-28-4);if(4!==n)throw new Error("read error");return e+a.readUInt32LE(0)}async _readAndUncompressBlock(e,[t],[a]){let r=a;r||(r=(await this.filehandle.stat()).size);const n=r-t;return await this.filehandle.read(e,0,n,t),await i(e.slice(0,n))}async read(e,t,a,n){const s=await this.gzi.getRelevantBlocksForRead(a,n),i=r.hp.allocUnsafe(65536);let o=t,l=0;for(let t=0;t<s.length-1;t+=1){const r=await this._readAndUncompressBlock(i,s[t],s[t+1]),[,h]=s[t],c=h>=n?0:n-h,d=Math.min(n+a,h+r.length)-h;c>=0&&c<r.length&&(r.copy(e,o,c,d),o+=d-c,l+=d-c)}return{bytesRead:l,buffer:e}}}},71616:(e,t,a)=>{a.d(t,{tP:()=>l,BL:()=>o});var r=a(45834),n=a(7706),s=a(35451);function i(e,t){return e.offset+e.lineBytes*Math.floor(t/e.lineLength)+t%e.lineLength}class o{constructor({fasta:e,fai:t,path:a,faiPath:n}){if(e)this.fasta=e;else{if(!a)throw new Error("Need to pass filehandle for fasta or path to localfile");this.fasta=new r.EY(a)}if(t)this.fai=t;else if(n)this.fai=new r.EY(n);else{if(!a)throw new Error("Need to pass filehandle for  or path to localfile");this.fai=new r.EY(`${a}.fai`)}}async _getIndexes(e){return this.indexes||(this.indexes=async function(e,t){const a=await e.readFile(t);if(!(null==a?void 0:a.length))throw new Error("No data read from FASTA index (FAI) file");let r,n=0;const s=a.toString("utf8").split(/\r?\n/).filter((e=>/\S/.test(e))).map((e=>e.split("\t"))).filter((e=>""!==e[0])).map((e=>(r&&r.name===e[0]||(r={name:e[0],id:n},n+=1),{id:r.id,name:e[0],length:+e[1],start:0,end:+e[1],offset:+e[2],lineLength:+e[3],lineBytes:+e[4]})));return{name:Object.fromEntries(s.map((e=>[e.name,e]))),id:Object.fromEntries(s.map((e=>[e.id,e])))}}(this.fai,e)),this.indexes}async getSequenceNames(e){return Object.keys((await this._getIndexes(e)).name)}async getSequenceSizes(e){const t={},a=await this._getIndexes(e);for(const e of Object.values(a.id))t[e.name]=e.length;return t}async getSequenceSize(e,t){var a;return null===(a=(await this._getIndexes(t)).name[e])||void 0===a?void 0:a.length}async hasReferenceSequence(e,t){return!!(await this._getIndexes(t)).name[e]}async getResiduesById(e,t,a,r){const n=(await this._getIndexes(r)).id[e];if(n)return this._fetchFromIndexEntry(n,t,a,r)}async getResiduesByName(e,t,a,r){const n=(await this._getIndexes(r)).name[e];if(n)return this._fetchFromIndexEntry(n,t,a,r)}async getSequence(e,t,a,r){return this.getResiduesByName(e,t,a,r)}async _fetchFromIndexEntry(e,t=0,a,r){let n=a;if(t<0)throw new TypeError("regionStart cannot be less than 0");if((void 0===n||n>e.length)&&(n=e.length),t>=n)return"";const o=i(e,t),l=i(e,n)-o,h=s.hp.allocUnsafe(l);return await this.fasta.read(h,0,l,o,r),h.toString("utf8").replace(/\s+/g,"")}}class l extends o{constructor({fasta:e,path:t,fai:a,faiPath:r,gzi:s,gziPath:i}){super({fasta:e,path:t,fai:a,faiPath:r}),e&&s?this.fasta=new n.sG({filehandle:e,gziFilehandle:s}):t&&i&&(this.fasta=new n.sG({path:t,gziPath:i}))}}}}]);
//# sourceMappingURL=2977.aa562b03.chunk.js.map