{"version":3,"file":"static/js/2672.5703d8b9.chunk.js","mappings":"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","sources":["../../../plugins/dotplot-view/src/DotplotRenderer/clamp.ts","../../../plugins/dotplot-view/src/DotplotRenderer/drawDotplot.ts"],"sourcesContent":["import type { Feature } from '@jbrowse/core/util'\n\nconst r = 'fell outside of range due to CIGAR string'\nconst lt = '(less than min coordinate of feature)'\nconst gt = '(greater than max coordinate of feature)'\nconst fudgeFactor = 1 // allow 1px fuzzyness before warn\n\nexport function clampWithWarnX(\n  num: number,\n  min: number,\n  max: number,\n  feature: Feature,\n  warnings: Warning[],\n) {\n  const strand = feature.get('strand') || 1\n  if (strand === -1) {\n    ;[max, min] = [min, max]\n  }\n  if (num < min - fudgeFactor) {\n    let start = feature.get('start')\n    let end = feature.get('end')\n    const refName = feature.get('refName')\n    if (strand === -1) {\n      ;[end, start] = [start, end]\n    }\n\n    warnings.push({\n      message: `feature at (X ${refName}:${start}-${end}) ${r} ${lt}`,\n      effect: 'clipped the feature',\n    })\n    return min\n  }\n  if (num > max + fudgeFactor) {\n    const strand = feature.get('strand') || 1\n    const start = strand === 1 ? feature.get('start') : feature.get('end')\n    const end = strand === 1 ? feature.get('end') : feature.get('start')\n    const refName = feature.get('refName')\n\n    warnings.push({\n      message: `feature at (X ${refName}:${start}-${end}) ${r} ${gt}`,\n      effect: 'clipped the feature',\n    })\n    return max\n  }\n  return num\n}\n\nexport function clampWithWarnY(\n  num: number,\n  min: number,\n  max: number,\n  feature: Feature,\n  warnings: Warning[],\n) {\n  if (num < min - fudgeFactor) {\n    const mate = feature.get('mate')\n    const { refName, start, end } = mate\n    warnings.push({\n      message: `feature at (Y ${refName}:${start}-${end}) ${r} ${lt}`,\n      effect: 'clipped the feature',\n    })\n    return min\n  }\n  if (num > max + fudgeFactor) {\n    const mate = feature.get('mate')\n    const { refName, start, end } = mate\n\n    warnings.push({\n      message: `feature at (Y ${refName}:${start}-${end}) ${r} ${gt}`,\n      effect: 'clipped the feature',\n    })\n    return max\n  }\n  return num\n}\n\nexport interface Warning {\n  message: string\n  effect: string\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\nimport { category10 } from '@jbrowse/core/ui/colors'\nimport { bpToPx } from '@jbrowse/core/util/Base1DUtils'\nimport { colord } from '@jbrowse/core/util/colord'\nimport { getSnapshot } from '@jbrowse/mobx-state-tree'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\n\nimport { type Warning, clampWithWarnX, clampWithWarnY } from './clamp.ts'\n\nimport type { RenderArgsDeserialized } from './DotplotRenderer.ts'\nimport type { Dotplot1DViewModel } from '../DotplotView/model.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\n\nconst { parseCigar } = MismatchParser\n\n// Simple hash function to generate consistent colors for query names\nfunction hashString(str: string) {\n  let hash = 0\n  for (let i = 0; i < str.length; i++) {\n    const char = str.charCodeAt(i)\n    hash = (hash << 5) - hash + char\n    hash = hash & hash // Convert to 32bit integer\n  }\n  return Math.abs(hash)\n}\n\n// Generate a color from a query name using the category10 color palette\nfunction getQueryColor(queryName: string) {\n  const hash = hashString(queryName)\n  return category10[hash % category10.length]!\n}\n\nexport interface DotplotRenderArgsDeserialized extends RenderArgsDeserialized {\n  adapterConfig: AnyConfigurationModel\n  height: number\n  width: number\n  highResolutionScaling: number\n  alpha?: number\n  minAlignmentLength?: number\n  colorBy?: string\n  view: {\n    hview: Dotplot1DViewModel\n    vview: Dotplot1DViewModel\n  }\n}\n\nfunction applyAlpha(color: string, alpha: number) {\n  // Skip colord processing if alpha is 1 (optimization)\n  if (alpha === 1) {\n    return color\n  }\n  return colord(color).alpha(alpha).toRgbString()\n}\n\nexport async function drawDotplot(\n  ctx: CanvasRenderingContext2D,\n  props: DotplotRenderArgsDeserialized & { views: Dotplot1DViewModel[] },\n) {\n  const {\n    config,\n    views,\n    height,\n    drawCigar,\n    theme,\n    alpha = 1,\n    minAlignmentLength = 0,\n    colorBy: colorByOverride,\n  } = props\n  const color = readConfObject(config, 'color')\n  const posColor = readConfObject(config, 'posColor')\n  const negColor = readConfObject(config, 'negColor')\n  // Use override if provided, otherwise fall back to config\n  const colorBy = colorByOverride ?? readConfObject(config, 'colorBy')\n  const lineWidth = readConfObject(config, 'lineWidth')\n  const thresholds = readConfObject(config, 'thresholds')\n  const palette = readConfObject(config, 'thresholdsPalette') as string[]\n  const isCallback = config.color.isCallback\n  const hview = views[0]!\n  const vview = views[1]!\n  const db1 = hview.dynamicBlocks.contentBlocks[0]?.offsetPx\n  const db2 = vview.dynamicBlocks.contentBlocks[0]?.offsetPx\n  const warnings = [] as Warning[]\n  ctx.lineWidth = lineWidth\n\n  // we operate on snapshots of these attributes of the hview/vview because\n  // it is significantly faster than accessing the mobx objects\n  const { bpPerPx: hBpPerPx } = hview\n  const { bpPerPx: vBpPerPx } = vview\n\n  const hsnap = {\n    ...getSnapshot(hview),\n    staticBlocks: hview.staticBlocks,\n    width: hview.width,\n  }\n  const vsnap = {\n    ...getSnapshot(vview),\n    staticBlocks: vview.staticBlocks,\n    width: vview.width,\n  }\n  const t = createJBrowseTheme(theme)\n  const features = hview.features || []\n\n  // Pre-compute colors with alpha for common cases (major optimization)\n  let posColorWithAlpha: string | undefined\n  let negColorWithAlpha: string | undefined\n  let defaultColorWithAlpha: string | undefined\n\n  // Cache for query colors with alpha applied\n  const queryColorCache = new Map<string, string>()\n\n  const getQueryColorWithAlpha = (queryName: string) => {\n    if (!queryColorCache.has(queryName)) {\n      const c = getQueryColor(queryName)\n      queryColorCache.set(queryName, applyAlpha(c, alpha))\n    }\n    return queryColorCache.get(queryName)!\n  }\n\n  if (colorBy === 'strand') {\n    // Pre-compute strand colors once instead of per-feature\n    posColorWithAlpha = applyAlpha(posColor, alpha)\n    negColorWithAlpha = applyAlpha(negColor, alpha)\n  } else if (colorBy === 'default' && !isCallback) {\n    // Pre-compute default color once instead of per-feature\n    const c = color === '#f0f' ? t.palette.text.primary : color\n    defaultColorWithAlpha = applyAlpha(c, alpha)\n  }\n\n  for (const feature of features) {\n    // Cache feature properties to avoid repeated .get() calls (optimization)\n    const strand = feature.get('strand') || 1\n    const fStart = feature.get('start')\n    const fEnd = feature.get('end')\n\n    // Filter by minAlignmentLength if specified (inline for performance)\n    if (minAlignmentLength > 0) {\n      const alignmentLength = Math.abs(fEnd - fStart)\n      if (alignmentLength < minAlignmentLength) {\n        continue\n      }\n    }\n\n    const refName = feature.get('refName')\n    const mate = feature.get('mate')\n    const mateRef = mate.refName\n\n    // Calculate start/end based on strand using cached values\n    const start = strand === 1 ? fStart : fEnd\n    const end = strand === 1 ? fEnd : fStart\n\n    let colorWithAlpha: string\n\n    // Use pre-computed colors for common cases (major optimization)\n    if (colorBy === 'strand') {\n      // Use pre-computed colors (avoids applyAlpha call per feature)\n      colorWithAlpha = strand === -1 ? negColorWithAlpha! : posColorWithAlpha!\n    } else if (colorBy === 'query') {\n      // Color by query sequence name\n      const queryName = refName\n      colorWithAlpha = getQueryColorWithAlpha(queryName)\n    } else if (colorBy === 'default' && !isCallback) {\n      // Use pre-computed color (avoids applyAlpha call per feature)\n      colorWithAlpha = defaultColorWithAlpha!\n    } else {\n      // Calculate color dynamically for other modes\n      let r = 'black'\n      if (colorBy === 'identity') {\n        const identity = feature.get('identity')\n        // eslint-disable-next-line unicorn/no-for-loop\n        for (let i = 0; i < thresholds.length; i++) {\n          if (identity > +thresholds[i]) {\n            r = palette[i] || 'black'\n            break\n          }\n        }\n      } else if (colorBy === 'meanQueryIdentity') {\n        r = `hsl(${feature.get('meanScore') * 200},100%,40%)`\n      } else if (colorBy === 'mappingQuality') {\n        r = `hsl(${feature.get('mappingQual')},100%,40%)`\n      } else if (colorBy === 'default' && isCallback) {\n        r = readConfObject(config, 'color', { feature })\n      }\n      colorWithAlpha = applyAlpha(r, alpha)\n    }\n\n    ctx.fillStyle = colorWithAlpha\n    ctx.strokeStyle = colorWithAlpha\n\n    const b10 = bpToPx({ self: hsnap, refName, coord: start })\n    const b20 = bpToPx({ self: hsnap, refName, coord: end })\n    const e10 = bpToPx({ self: vsnap, refName: mateRef, coord: mate.start })\n    const e20 = bpToPx({ self: vsnap, refName: mateRef, coord: mate.end })\n    if (\n      b10 !== undefined &&\n      b20 !== undefined &&\n      e10 !== undefined &&\n      e20 !== undefined\n    ) {\n      const b1 = b10.offsetPx - db1!\n      const b2 = b20.offsetPx - db1!\n      const e1 = e10.offsetPx - db2!\n      const e2 = e20.offsetPx - db2!\n      if (Math.abs(b1 - b2) <= 4 && Math.abs(e1 - e2) <= 4) {\n        ctx.beginPath()\n        ctx.arc(b1, height - e1, lineWidth / 2, 0, 2 * Math.PI)\n        ctx.fill()\n      } else {\n        let currX = b1\n        let currY = e1\n        const cigar = feature.get('CIGAR')\n        if (drawCigar && cigar) {\n          const cigarOps = parseCigar(cigar)\n\n          ctx.beginPath()\n          ctx.moveTo(currX, height - currY)\n\n          let lastDrawnX = currX\n          let lastDrawnY = currX\n          for (let i = 0; i < cigarOps.length; i += 2) {\n            const val = +cigarOps[i]!\n            const op = cigarOps[i + 1]!\n            if (op === 'M' || op === '=' || op === 'X') {\n              currX += (val / hBpPerPx) * strand\n              currY += val / vBpPerPx\n            } else if (op === 'D' || op === 'N') {\n              currX += (val / hBpPerPx) * strand\n            } else if (op === 'I') {\n              currY += val / vBpPerPx\n            }\n            currX = clampWithWarnX(currX, b1, b2, feature, warnings)\n            currY = clampWithWarnY(currY, e1, e2, feature, warnings)\n\n            // only draw a line segment if it is bigger than 0.5px\n            if (\n              Math.abs(currX - lastDrawnX) > 0.5 ||\n              Math.abs(currY - lastDrawnY) > 0.5\n            ) {\n              ctx.lineTo(currX, height - currY)\n              lastDrawnX = currX\n              lastDrawnY = currY\n            }\n          }\n\n          ctx.stroke()\n        } else {\n          ctx.beginPath()\n          ctx.moveTo(b1, height - e1)\n          ctx.lineTo(b2, height - e2)\n          ctx.stroke()\n        }\n      }\n    } else {\n      if (warnings.length <= 5) {\n        if (b10 === undefined || b20 === undefined) {\n          warnings.push({\n            message: `feature at (X-coord: ${refName}:${start}-${end}) not plotted, fell outside of range`,\n            effect: 'feature not rendered',\n          })\n        } else {\n          warnings.push({\n            message: `feature at (Y-coord: ${mateRef}:${mate.start}-${mate.end}) not plotted, fell outside of range`,\n            effect: 'feature not rendered',\n          })\n        }\n      }\n    }\n  }\n\n  return { warnings }\n}\n"],"names":["r","lt","gt","clampWithWarnX","num","min","max","feature","warnings","strand","get","start","end","refName","push","message","effect","clampWithWarnY","mate","parseCigar","MismatchParser","applyAlpha","color","alpha","colord","toRgbString","async","drawDotplot","ctx","props","config","views","height","drawCigar","theme","minAlignmentLength","colorBy","colorByOverride","readConfObject","posColor","negColor","lineWidth","thresholds","palette","isCallback","hview","vview","db1","dynamicBlocks","contentBlocks","offsetPx","db2","bpPerPx","hBpPerPx","vBpPerPx","hsnap","getSnapshot","staticBlocks","width","vsnap","t","createJBrowseTheme","features","posColorWithAlpha","negColorWithAlpha","defaultColorWithAlpha","queryColorCache","Map","getQueryColorWithAlpha","queryName","has","c","hash","str","i","length","charCodeAt","Math","abs","hashString","category10","getQueryColor","set","text","primary","fStart","fEnd","mateRef","colorWithAlpha","identity","fillStyle","strokeStyle","b10","bpToPx","self","coord","b20","e10","e20","undefined","b1","b2","e1","e2","beginPath","arc","PI","fill","currX","currY","cigar","cigarOps","moveTo","lastDrawnX","lastDrawnY","val","op","lineTo","stroke"],"ignoreList":[],"sourceRoot":""}