{"version":3,"file":"static/js/4877.b8753ce8.chunk.js","mappings":"6OAmBe,MAAMA,UAAmBC,EAAAA,EAS5BC,SAAAA,GACR,IAAKC,KAAKC,gBAAiB,CACzB,MAAMC,EAAcF,KAAKG,QAAQ,eAC3BC,EAAWJ,KAAKG,QAAQ,CAAC,QAAS,aAElCE,EAAoB,QADRL,KAAKG,QAAQ,CAAC,QAAS,cAEzCH,KAAKC,gBAAkB,CACrBK,IAAK,IAAIC,EAAAA,GAAQ,CACfC,eAAeC,EAAAA,EAAAA,cAAaP,EAAaF,KAAKU,eAC9CC,cAAeN,GACXI,EAAAA,EAAAA,cAAaL,EAAUJ,KAAKU,oBAC5BE,EACJC,cAAgBR,OAEZO,GADAH,EAAAA,EAAAA,cAAaL,EAAUJ,KAAKU,eAEhCI,YAAaC,EAAAA,IAGnB,CACA,OAAOf,KAAKC,eACd,CAEA,wBAAMe,GACJ,MAAMC,EAASjB,KAAKkB,sBACpB,GAAKD,GAAWjB,KAAKmB,cAcrB,OAXAnB,KAAKoB,mBAAqBpB,KAAKmB,cAAcF,GAC1CI,KAAKC,IACJ,MAAMC,EAAUD,EAAEE,YAGlB,MAAO,gBAAiBD,EAAUA,OAAUX,IAE7Ca,MAAOC,IAEN,MADA1B,KAAKoB,sBAAmBR,EAClBc,IAEH1B,KAAKoB,gBACd,CAEA,eAAMO,CAAUC,GACd,MAAM,IAAEtB,GAAQN,KAAKD,YACrB,OAAOO,EAAIuB,eACb,CAEA,WAAcC,CAAMC,GAClB,MAAM,eAAEC,GAAmBD,GAAQ,CAAC,EAiBpC,OAhBA/B,KAAKiC,UAAWC,EAAAA,EAAAA,cACd,oBACAF,EACAG,UACE,IACE,MAAM,IAAE7B,GAAQN,KAAKD,YACfqC,QAAkB9B,EAAIqB,YAE5B,OADA3B,KAAKqC,WAAYC,EAAAA,EAAAA,IAAeF,GAAa,IACtCpC,KAAKqC,SACd,CAAE,MAAOX,GAGP,MAFA1B,KAAKiC,YAASrB,EACdZ,KAAKC,qBAAkBW,EACjBc,CACR,IAGG1B,KAAKiC,MACd,CAEA,iBAAMM,CAAYR,GAChB,MAAM,SAAES,SAAmBxC,KAAK8B,MAAMC,GACtC,OAAOS,CACT,CAEAC,WAAAA,CACEC,EACAX,GAIA,MAAM,QAAEY,EAAO,MAAEC,EAAK,IAAEC,EAAG,gBAAEC,GAAoBJ,GAC3C,UAAEK,EAAS,SAAEC,EAAQ,eAAEhB,EAAiBA,QAAaD,GAAQ,CAAC,EACpE,OAAOkB,EAAAA,EAAAA,kBAA0Bd,UAC/B,MAAM,IAAE7B,GAAQN,KAAKD,YACfmD,QAAwBlD,KAAKgB,2BAC7BhB,KAAK8B,MAAMC,IACjBoB,EAAAA,EAAAA,IAAeJ,GACf,MAAMK,QAAgBlB,EAAAA,EAAAA,cACpB,yBACAF,EACA,IAAM1B,EAAI+C,mBAAmBV,EAASC,EAAOC,EAAK,CAAEG,eAEtDG,EAAAA,EAAAA,IAAeJ,SAETb,EAAAA,EAAAA,cAAa,wBAAyBF,EAAgBG,UAC1D,MAAM,SAAEmB,GAAaN,GAAY,CAAC,EAGlC,IAAIO,EACAC,EAAcC,IACdC,EAAY,EAChB,GAAIR,EAAiB,CACnB,IAAK,MAAMS,KAAUP,EACdO,EAAOC,aACVJ,EAAcK,KAAKC,IAAIN,EAAaG,EAAOf,OAC3Cc,EAAYG,KAAKE,IAAIL,EAAWC,EAAOd,MAGvCa,EAAY,IACdH,QAAkBL,EAAgBc,YAAY,CAC5CrB,QAASG,GAAmBH,EAC5BC,MAAOY,EACPX,IAAKa,IAGX,CAEA,IAAK,MAAMC,KAAUP,EACfE,GAAYK,EAAOM,OAASX,IAKhCK,EAAOpC,QAAUvB,MAGZ2D,EAAOC,YAAcL,IACxBI,EAAOO,IAAMX,EAAUY,MACrBR,EAAOf,MAAQY,EACfG,EAAOd,IAAMW,IAIjBY,EAASC,KAAKV,IAEhBS,EAASE,cAGf,CAEA,uCAAMC,CACJC,EACAzC,GAEA,MAAM,IAAEzB,GAAQN,KAAKD,YAErB,OAAIO,EAAImE,MAGC,CACLC,YAHkBpE,EAAIqE,yBAAyBH,GAI/CI,eAHqB5E,KAAKG,QAAQ,mBAM/B0E,MAAMN,kCAAkCC,EAASzC,EAC1D,CAEA+C,WAAAA,CAAYC,GACV,OAAO/E,KAAKqC,WAAWG,SAASuC,EAClC,E,0EClLa,MAAMC,UAAyBnF,EAAAA,QAClCE,SAAAA,GACR,IAAKC,KAAKC,gBAAiB,CACzB,MAAMgF,EAAajF,KAAKG,QAAQ,cAC1B+E,EAAgBlF,KAAKG,QAAQ,iBACnCH,KAAKC,gBAAkB,CACrBK,IAAK,IAAI6E,EAAAA,GAAW,CAClBC,QAASH,EACTI,QAASH,EACTpE,YAAaC,EAAAA,IAGnB,CACA,OAAOf,KAAKC,eACd,E,qKClBK,MAAMqF,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EACVC,EAAU,EAEVC,EAAW,EACXC,EAAU,EAIVC,EAAkB,IAQlBC,EAA2B,IAG3BC,EAAS,mBAKTC,EAAyB,IAAIC,WAAW,CACnD,GAAI,GAAI,GAAI,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,IAAK,GAAI,MAI5DC,EAA2BC,MAAMC,KAAK,CAAEC,OAAQ,KAAO,CAACC,EAAGC,IACtEC,OAAOC,aAAaF,IAIf,SAASG,EACdC,GAEA,MAAwB,iBAAVA,GAAqBC,EAAAA,EAAAA,IAAYD,GAASA,GAAS,EACnE,C,qEC5CA,MAAME,EAAiB,mBAAmBC,MAAM,I,eCqBjC,MAAMhG,UACXiG,EAAAA,GAORC,EAAAA,GACE,MAAO,GAAGjH,KAAKuB,QAAQ0F,MAAMjH,KAAKkH,YACpC,CAEA,OAAIC,GACF,OD9BG,SAAmBC,EAAwBC,GAChD,MAAMC,EAAM,IAAIlB,MAAMiB,GACtB,IAAIb,EAAI,EACR,MAAMe,EAAYF,GAAa,EAE/B,IAAK,IAAIG,EAAI,EAAGA,EAAID,IAAaC,EAAG,CAClC,MAAMC,EAAKL,EAAWI,GACtBF,EAAId,KAAOM,GAAqB,IAALW,IAAc,GACzCH,EAAId,KAAOM,EAAoB,GAALW,EAC5B,CAEA,GAAIjB,EAAIa,EAAW,CACjB,MAAMI,EAAKL,EAAWG,GACtBD,EAAId,GAAKM,GAAqB,IAALW,IAAc,EACzC,CAEA,OAAOH,EAAII,KAAK,GAClB,CCaWC,CAAU3H,KAAK4H,YAAa5H,KAAK6H,WAC1C,CAKA,cAAIC,GACF,MAAMA,EAAyB,GA8C/B,OA7CA9H,KAAK+H,gBACH,CAACC,EAAMpF,EAAO0D,EAAQ2B,EAAMC,EAAMC,EAASC,KACrCJ,IAASK,EAAAA,GACXP,EAAWQ,KAAK,CACdN,KAAM,WACNpF,QACA0D,SACA2B,OACAC,UAAetH,IAATsH,GAAsBA,GAAQ,EAAIA,OAAOtH,EAC/CuH,aACcvH,IAAZuH,GAAyBA,EAAU,EAC/BhC,EAAAA,GAAegC,QACfvH,IAECoH,IAASO,EAAAA,GAClBT,EAAWQ,KAAK,CACdN,KAAM,YACNpF,QACA0D,SACAkC,UAAWJ,EACXK,cAAeR,IAERD,IAASU,EAAAA,GAClBZ,EAAWQ,KAAK,CACdN,KAAM,WACNpF,QACA0D,SACA8B,QAASA,IAEFJ,IAASW,EAAAA,GAClBb,EAAWQ,KAAK,CACdN,KAAM,WACNpF,QACA0D,SACA8B,QAASA,IAGXN,EAAWQ,KAAK,CACdN,KAAe,IAATA,EAAa,WAAa,OAChCpF,QACA0D,aAKDwB,CACT,CAEAC,eAAAA,CAAgBa,ICzDX,SACLhC,EACAQ,EACAC,EACAwB,EACAX,EACAhE,EACA0E,GAGA,GAAkB,IAAdvB,EAAiB,CACnB,IAAIyB,EAAU,EACd,IAAK,IAAItC,EAAI,EAAGuC,EAAInC,EAAMN,OAAQE,EAAIuC,EAAGvC,IAAK,CAC5C,MAAMwC,EAASpC,EAAMJ,GACfyC,EAAMD,GAAU,EAChBE,EAAc,GAATF,EACN,GAAKE,EAAMpD,EAAAA,GACdgD,GAAWG,EACFC,IAAO3D,EAAAA,GAChBqD,EAASL,EAAAA,GAAgBO,EAAS,EAAG,KAAM,EAAG,EAAGG,GACxCC,IAAO1D,EAAAA,IAChBoD,EAASO,EAAAA,GAAeL,EAASG,EAAK,KAAM,EAAG,EAAG,GAClDH,GAAWG,GACFC,IAAOzD,EAAAA,IAChBmD,EAASQ,EAAAA,EAAWN,EAASG,EAAK,KAAM,EAAG,EAAG,GAC9CH,GAAWG,GACFC,IAAOxD,EAAAA,GAChBkD,EAASF,EAAAA,GAAeI,EAAS,EAAG,IAAIG,KAAQ,EAAG,EAAGA,GAC7CC,IAAOvD,EAAAA,IAChBiD,EAASD,EAAAA,GAAeG,EAAS,EAAG,IAAIG,KAAQ,EAAG,EAAGA,EAE1D,CACA,MACF,CAEA,MAAMI,EAAWR,GAAIvC,QAAU,EACzBgD,IAAYpB,EACZqB,EAAQV,GAAMQ,EAAW,EAE/B,IAAIP,EAAU,EACVU,EAAU,EACVC,EAAQ,EACRC,EAAmB,EAEvB,GAAIH,EACF,KAAOE,EAAQJ,GAAU,CACvB,MAAMM,EAAId,EAAGY,GACb,KAAIE,GAAK,IAAMA,GAAK,IAIlB,MAHAD,EAAsC,GAAnBA,GAAyBC,EAAI,IAChDF,GAIJ,CAGF,IAAK,IAAIjD,EAAI,EAAGuC,EAAInC,EAAMN,OAAQE,EAAIuC,EAAGvC,IAAK,CAC5C,MAAMwC,EAASpC,EAAMJ,GACfyC,EAAMD,GAAU,EAChBE,EAAc,GAATF,EAEX,GAAK,GAAKE,EAAMpD,EAAAA,GAAiB,CAC/B,GAAIyD,EAAO,CACT,IAAIK,EAAYX,EACZY,EAAc,EAElB,KAAOD,EAAY,GACjB,GAAIF,GAAoBE,EACtBF,GAAoBE,EACpBC,GAAeD,EACfA,EAAY,MACP,CAKL,GAJAC,GAAeH,EACfE,GAAaF,EACbA,EAAmB,IAEfD,EAAQJ,GAAYR,EAAGY,IAAW,IAAMZ,EAAGY,IAAW,IA6BxD,MA7B4D,CAC5D,MAAMK,EAASN,EAAUK,EAEnBE,EADK3C,EAAW0C,GAAU,KACR,GAAc,EAATA,IAAgB,GAAM,GAgBnD,IAdAlB,EACEP,EAAAA,GACAS,EAAUe,EACV,EACA7D,EAAAA,GAAO+D,GACPT,EAAUpB,EAAK4B,IAAY,EAC3BjB,EAAGY,GACH,GAGFA,IACAI,IACAD,IACAF,EAAmB,EACZD,EAAQJ,GAAU,CACvB,MAAMM,EAAId,EAAGY,GACb,KAAIE,GAAK,IAAMA,GAAK,IAIlB,MAHAD,EAAsC,GAAnBA,GAAyBC,EAAI,IAChDF,GAIJ,CACF,CAGF,CAEJ,MAAO,GAAIvF,EACT,IAAK,IAAIsD,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMsC,EAASN,EAAUhC,EAEnBuC,EADK3C,EAAW0C,GAAU,KACR,GAAc,EAATA,IAAgB,GAAM,GAC7CE,EAAc/D,EAAAA,GAAuB8D,GACrCE,EAAc/F,EAAIgG,WAAWpB,EAAUtB,GAEzCwC,KAA+B,GAAdC,IACnBrB,EACEP,EAAAA,GACAS,EAAUtB,EACV,EACAxB,EAAAA,GAAO+D,GACPT,EAAUpB,EAAK4B,IAAY,EAC3BG,EACA,EAGN,CAEFT,GAAWP,EACXH,GAAWG,CACb,MAAO,GAAIC,IAAO3D,EAAAA,GAAS,CAEzB,IAAIkD,EACJ,GAAY,IAARQ,EAAW,CAEb,MACMc,EADK3C,EAAWoC,GAAW,KACT,GAAe,EAAVA,IAAiB,GAAM,GACpDf,EAAgBzC,EAAAA,GAAO+D,EACzB,MAAO,GAAY,IAARd,EAAW,CAEpB,MAAMkB,EAAUX,EAEVY,EADMhD,EAAW+C,GAAW,KACR,GAAe,EAAVA,IAAiB,GAAM,GAChDE,EAAUb,EAAU,EAEpBc,EADMlD,EAAWiD,GAAW,KACR,GAAe,EAAVA,IAAiB,GAAM,GACtD5B,EAAgBzC,EAAAA,GAAOoE,GAAYpE,EAAAA,GAAOsE,EAC5C,KAAO,CACL,MAAMC,EAAQ,IAAInE,MAAc6C,GAChC,IAAK,IAAIzB,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMsC,EAASN,EAAUhC,EAEnBuC,EADK3C,EAAW0C,GAAU,KACR,GAAc,EAATA,IAAgB,GAAM,GACnDS,EAAM/C,GAAKxB,EAAAA,GAAO+D,EACpB,CACAtB,EAAgB8B,EAAM7C,KAAK,GAC7B,CACAkB,EAASL,EAAAA,GAAgBO,EAAS,EAAGL,GAAgB,EAAG,EAAGQ,GAC3DO,GAAWP,CACb,MAAO,GAAIC,IAAO1D,EAAAA,GAAS,CAIzB,GAHAoD,EAASO,EAAAA,GAAeL,EAASG,EAAK,KAAM,EAAG,EAAG,GAG9CM,GAASE,EAAQJ,GAA2B,KAAfR,EAAGY,GAAgB,CAElD,IADAA,IACOA,EAAQJ,GAAYR,EAAGY,IAAW,IACvCA,IAGF,IADAC,EAAmB,EACZD,EAAQJ,GAAU,CACvB,MAAMM,EAAId,EAAGY,GACb,KAAIE,GAAK,IAAMA,GAAK,IAIlB,MAHAD,EAAsC,GAAnBA,GAAyBC,EAAI,IAChDF,GAIJ,CACF,CACAX,GAAWG,CACb,MAAO,GAAIC,IAAOzD,EAAAA,GAChBmD,EAASQ,EAAAA,EAAWN,EAASG,EAAK,KAAM,EAAG,EAAG,GAC9CH,GAAWG,OACN,GAAIC,IAAOrD,EAAAA,GAAS,CACzB,IAAK,IAAI2B,EAAI,EAAGA,EAAIyB,EAAKzB,IAAK,CAC5B,MAAMsC,EAASN,EAAUhC,EAEnBuC,EADK3C,EAAW0C,GAAU,KACR,GAAc,EAATA,IAAgB,GAAM,GAEnD,IAAIU,EAAc,EAClB,GAAIjB,EACF,GAAyB,IAArBG,GAA0BD,EAAQJ,GAAYR,EAAGY,IAAW,GAI9D,IAHAe,EAAc3B,EAAGY,GACjBA,IACAC,EAAmB,EACZD,EAAQJ,GAAU,CACvB,MAAMM,EAAId,EAAGY,GACb,KAAIE,GAAK,IAAMA,GAAK,IAIlB,MAHAD,EAAsC,GAAnBA,GAAyBC,EAAI,IAChDF,GAIJ,MACSC,EAAmB,GAC5BA,SAEOxF,IAETsG,EAActG,EAAIgG,WAAWpB,EAAUtB,IAGzCoB,EACEP,EAAAA,GACAS,EAAUtB,EACV,EACAxB,EAAAA,GAAO+D,GACPT,EAAUpB,EAAK4B,IAAY,EAC3BU,EACA,EAEJ,CACAhB,GAAWP,EACXH,GAAWG,CACb,MAAWC,IAAOxD,EAAAA,IAChBkD,EAASF,EAAAA,GAAeI,EAAS,EAAG,IAAIG,KAAQ,EAAG,EAAGA,GACtDO,GAAWP,GACFC,IAAOvD,EAAAA,IAChBiD,EAASD,EAAAA,GAAeG,EAAS,EAAG,IAAIG,KAAQ,EAAG,EAAGA,EAE1D,CACF,CD/KIwB,CACEzK,KAAK0K,cACL1K,KAAK4H,YACL5H,KAAK6H,WACL7H,KAAK4D,WACL5D,KAAKkI,KACLlI,KAAKkE,IACL0E,EAEJ,CAEA,cAAI+B,GACF,OAAO3K,KAAKkI,MAAMR,KAAK,IACzB,CAEA,2BAAIkD,GACF,MAAMhE,EAAQ5G,KAAK0K,cACnB,GAAqB,IAAjB9D,EAAMN,OACR,OAAO,EAET,MAAM0C,GAA0B,IAAjBhJ,KAAK6K,OAAgBjE,EAAMA,EAAMN,OAAS,GAAMM,EAAM,GAC/DsC,EAAc,GAATF,EACX,OAAIE,IAAOxD,EAAAA,IAAWwD,IAAOvD,EAAAA,GACpBqD,GAAU,EAEZ,CACT,CAEA,WAAIrG,GACF,OAAO3C,KAAKuB,QAAQuD,YAAY9E,KAAK8K,OACvC,CACAC,GAAAA,CAAIC,GACF,OAAQA,GACN,IAAK,aACH,OAAOhL,KAAK8H,WACd,IAAK,OACH,OAAO9H,KAAKiE,KACd,IAAK,QACH,OAAOjE,KAAK4C,MACd,IAAK,UACH,OAAO5C,KAAK2C,QACd,IAAK,MACH,OAAO3C,KAAK6C,IACd,IAAK,SACH,OAAO7C,KAAK6K,OACd,IAAK,OACH,OAAO7K,KAAK2K,WACd,IAAK,MACH,OAAO3K,KAAKmH,IACd,IAAK,OACH,OAAOnH,KAAKiL,KACd,IAAK,cACH,OAAOjL,KAAK4H,YACd,IAAK,gBACH,OAAO5H,KAAK0K,cACd,IAAK,QACH,OAAO1K,KAAKkL,MACd,IAAK,eACH,OAAOlL,KAAKkI,KACd,IAAK,aACH,OAAOlI,KAAK4D,WACd,IAAK,aACH,OAAO5D,KAAK6H,WACd,IAAK,QACH,OAAO7H,KAAKmL,MACd,IAAK,mBACH,OAAOnL,KAAKoL,iBACd,IAAK,WACH,OAAOpL,KAAKqL,SACd,IAAK,WACH,OAAOrL,KAAKsL,SACd,IAAK,kBACH,OAAOtL,KAAKuL,gBACd,IAAK,0BACH,OAAOvL,KAAK4K,wBAEd,QACE,OAAO5K,KAAKwL,OAAOR,GAEzB,CAEAS,MAAAA,GAEA,CAEAC,QAAAA,GAEA,CAEA,UAAIF,GAoBF,YAnB2B5K,IAAvBZ,KAAK2L,gBACP3L,KAAK2L,cAAgB,CACnB/I,MAAO5C,KAAK4C,MACZqB,KAAMjE,KAAKiE,KACXpB,IAAK7C,KAAK6C,IACV+I,MAAO5L,KAAK4L,MACZf,OAAQ7K,KAAK6K,OACbU,gBAAiBvL,KAAKuL,gBACtBJ,MAAOnL,KAAKmL,MACZF,KAAMjL,KAAKiL,KACXtI,QAAS3C,KAAK2C,QACdqF,KAAM,QACNoD,iBAAkBpL,KAAKoL,iBACvBC,SAAUrL,KAAKqL,SACfC,SAAUtL,KAAKsL,SACfO,sBAAuB7L,KAAK6L,sBAC5BC,SAAU9L,KAAKiH,OAGZjH,KAAK2L,aACd,CACA,YAAIN,GACF,OAAOrL,KAAK+L,WACR/L,KAAKuB,QAAQuD,YAAY9E,KAAKgM,iBAC9BpL,CACN,CAEA,yBAAIiL,GACF,OAAO7L,KAAK+L,WACR,GAAG/L,KAAKuB,QAAQuD,YAAY9E,KAAKgM,eAAehM,KAAKsL,SAAW,SAChE1K,CACN,CAEAqL,MAAAA,GACE,MAAO,IACFjM,KAAKwL,OACRN,MAAOlL,KAAKkL,MACZ/D,IAAKnH,KAAKmH,IACV8D,MAAMiB,EAAAA,EAAAA,IAAyBlM,KAAKiL,MACpC/C,KAAMlI,KAAK2K,WAEf,E","sources":["../../../plugins/alignments/src/BamAdapter/BamAdapter.ts","../../../plugins/alignments/src/HtsgetBamAdapter/HtsgetBamAdapter.ts","../../../plugins/alignments/src/PileupRenderer/renderers/cigarUtil.ts","../../../plugins/alignments/src/shared/decodeSeq.ts","../../../plugins/alignments/src/BamAdapter/BamSlightlyLazyFeature.ts","../../../plugins/alignments/src/BamAdapter/forEachMismatchNumeric.ts"],"sourcesContent":["import { BamFile } from '@gmod/bam'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature.ts'\nimport { parseSamHeader } from '../shared/util.ts'\n\nimport type { FilterBy } from '../shared/types.ts'\nimport type { ParsedSamHeader } from '../shared/util.ts'\nimport type {\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { Region } from '@jbrowse/core/util/types'\n\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n  public samHeader?: ParsedSamHeader\n\n  private setupP?: Promise<ParsedSamHeader>\n\n  protected configureResult?: { bam: BamFile<BamSlightlyLazyFeature> }\n\n  private sequenceAdapterP?: Promise<BaseSequenceAdapter | undefined>\n\n  protected configure() {\n    if (!this.configureResult) {\n      const bamLocation = this.getConf('bamLocation')\n      const location = this.getConf(['index', 'location'])\n      const indexType = this.getConf(['index', 'indexType'])\n      const csi = indexType === 'CSI'\n      this.configureResult = {\n        bam: new BamFile({\n          bamFilehandle: openLocation(bamLocation, this.pluginManager),\n          csiFilehandle: csi\n            ? openLocation(location, this.pluginManager)\n            : undefined,\n          baiFilehandle: !csi\n            ? openLocation(location, this.pluginManager)\n            : undefined,\n          recordClass: BamSlightlyLazyFeature,\n        }),\n      }\n    }\n    return this.configureResult\n  }\n\n  async getSequenceAdapter() {\n    const config = this.sequenceAdapterConfig\n    if (!config || !this.getSubAdapter) {\n      return undefined\n    }\n    this.sequenceAdapterP ??= this.getSubAdapter(config)\n      .then(r => {\n        const adapter = r.dataAdapter as BaseSequenceAdapter\n        // workaround for ChromSizesAdapter which doesn't have getSequence.\n        // sequence adapter is optional for BAM\n        return 'getSequence' in adapter ? adapter : undefined\n      })\n      .catch((e: unknown) => {\n        this.sequenceAdapterP = undefined\n        throw e\n      })\n    return this.sequenceAdapterP\n  }\n\n  async getHeader(_opts?: BaseOptions) {\n    const { bam } = this.configure()\n    return bam.getHeaderText()\n  }\n\n  private async setup(opts?: BaseOptions) {\n    const { statusCallback } = opts || {}\n    this.setupP ??= updateStatus(\n      'Downloading index',\n      statusCallback,\n      async () => {\n        try {\n          const { bam } = this.configure()\n          const rawHeader = await bam.getHeader()\n          this.samHeader = parseSamHeader(rawHeader ?? [])\n          return this.samHeader\n        } catch (e) {\n          this.setupP = undefined\n          this.configureResult = undefined\n          throw e\n        }\n      },\n    )\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { idToName } = await this.setup(opts)\n    return idToName\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy?: FilterBy\n    },\n  ) {\n    const { refName, start, end, originalRefName } = region\n    const { stopToken, filterBy, statusCallback = () => {} } = opts || {}\n    return ObservableCreate<Feature>(async observer => {\n      const { bam } = this.configure()\n      const sequenceAdapter = await this.getSequenceAdapter()\n      await this.setup(opts)\n      checkStopToken(stopToken)\n      const records = await updateStatus(\n        'Downloading alignments',\n        statusCallback,\n        () => bam.getRecordsForRange(refName, start, end, { filterBy }),\n      )\n      checkStopToken(stopToken)\n\n      await updateStatus('Processing alignments', statusCallback, async () => {\n        const { readName } = filterBy || {}\n\n        // Pre-fetch reference sequence for all records that need it\n        let regionSeq: string | undefined\n        let regionStart = Infinity\n        let regionEnd = 0\n        if (sequenceAdapter) {\n          for (const record of records) {\n            if (!record.NUMERIC_MD) {\n              regionStart = Math.min(regionStart, record.start)\n              regionEnd = Math.max(regionEnd, record.end)\n            }\n          }\n          if (regionEnd > 0) {\n            regionSeq = await sequenceAdapter.getSequence({\n              refName: originalRefName || refName,\n              start: regionStart,\n              end: regionEnd,\n            })\n          }\n        }\n\n        for (const record of records) {\n          if (readName && record.name !== readName) {\n            continue\n          }\n\n          // Set adapter reference for id() and refIdToName()\n          record.adapter = this\n\n          // Only fetch reference sequence if MD tag is missing\n          if (!record.NUMERIC_MD && regionSeq) {\n            record.ref = regionSeq.slice(\n              record.start - regionStart,\n              record.end - regionStart,\n            )\n          }\n\n          observer.next(record)\n        }\n        observer.complete()\n      })\n    })\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { bam } = this.configure()\n    // this is a method to avoid calling on htsget adapters\n    if (bam.index) {\n      const bytes = await bam.estimatedBytesForRegions(regions)\n      const fetchSizeLimit = this.getConf('fetchSizeLimit')\n      return {\n        bytes,\n        fetchSizeLimit,\n      }\n    }\n    return super.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  refIdToName(refId: number) {\n    return this.samHeader?.idToName[refId]\n  }\n}\n","import { HtsgetFile } from '@gmod/bam'\n\nimport BamAdapter from '../BamAdapter/BamAdapter.ts'\nimport BamSlightlyLazyFeature from '../BamAdapter/BamSlightlyLazyFeature.ts'\n\nimport type { BamFile } from '@gmod/bam'\n\nexport default class HtsgetBamAdapter extends BamAdapter {\n  protected configure() {\n    if (!this.configureResult) {\n      const htsgetBase = this.getConf('htsgetBase')\n      const htsgetTrackId = this.getConf('htsgetTrackId')\n      this.configureResult = {\n        bam: new HtsgetFile({\n          baseUrl: htsgetBase,\n          trackId: htsgetTrackId,\n          recordClass: BamSlightlyLazyFeature,\n        }) as unknown as BamFile<BamSlightlyLazyFeature>,\n      }\n    }\n    return this.configureResult\n  }\n}\n","import { parseCigar2 } from '../../MismatchParser/index.ts'\n\n// CIGAR operation indices (from BAM spec) - used in packed Uint32Array format\nexport const CIGAR_M = 0\nexport const CIGAR_I = 1\nexport const CIGAR_D = 2\nexport const CIGAR_N = 3\nexport const CIGAR_S = 4\nexport const CIGAR_H = 5\nexport const CIGAR_P = 6\nexport const CIGAR_EQ = 7\nexport const CIGAR_X = 8\n\n// Bitmasks for CIGAR operation categories (use with: (1 << op) & MASK)\n// Alignment match ops (M=0, ==7) - may contain mismatches, need MD tag\nexport const CIGAR_M_EQ_MASK = 0b10000001 // (1<<0)|(1<<7) = 129\n// Match/mismatch ops that consume both ref and seq (M=0, ==7, X=8)\nexport const CIGAR_MATCH_MASK = 0b110000001 // (1<<0)|(1<<7)|(1<<8) = 385\n// Seq-only ops (S=4, I=1)\nexport const CIGAR_SEQ_ONLY_MASK = 0b10010 // (1<<1)|(1<<4) = 18\n// Ref-skip ops (D=2, N=3)\nexport const CIGAR_REF_SKIP_MASK = 0b1100 // (1<<2)|(1<<3) = 12\n// Ref-consuming ops (M=0, D=2, ==7, X=8)\nexport const CIGAR_REF_CONSUMING_MASK = 0b110000101 // (1<<0)|(1<<2)|(1<<7)|(1<<8) = 389\n\n// BAM 4-bit encoded sequence lookup table\nexport const SEQRET = '=ACMGRSVTWYHKDBN'\n\n// Numeric decoder - returns char codes directly (lowercase for case-insensitive comparison)\n// '=' = 61, 'a' = 97, 'c' = 99, 'm' = 109, 'g' = 103, 'r' = 114, 's' = 115, 'v' = 118,\n// 't' = 116, 'w' = 119, 'y' = 121, 'h' = 104, 'k' = 107, 'd' = 100, 'b' = 98, 'n' = 110\nexport const SEQRET_NUMERIC_DECODER = new Uint8Array([\n  61, 97, 99, 109, 103, 114, 115, 118, 116, 119, 121, 104, 107, 100, 98, 110,\n])\n\n// Pre-computed char lookup for ASCII codes (avoids String.fromCharCode in hot loops)\nexport const CHAR_FROM_CODE: string[] = Array.from({ length: 128 }, (_, i) =>\n  String.fromCharCode(i),\n)\n\n// Helper to ensure we have Uint32Array (packed format)\nexport function getCigarOps(\n  cigar: Uint32Array | string | undefined,\n): ArrayLike<number> {\n  return typeof cigar === 'string' ? parseCigar2(cigar) : cigar || []\n}\n","// Sequence decoder matching @gmod/bam format\nconst SEQRET_DECODER = '=ACMGRSVTWYHKDBN'.split('')\n\n// Decodes packed NUMERIC_SEQ (Uint8Array) to string\n// Each byte encodes 2 bases in 4-bit nibbles\nexport function decodeSeq(numericSeq: Uint8Array, seqLength: number): string {\n  const buf = new Array(seqLength)\n  let i = 0\n  const fullBytes = seqLength >> 1\n\n  for (let j = 0; j < fullBytes; ++j) {\n    const sb = numericSeq[j]!\n    buf[i++] = SEQRET_DECODER[(sb & 0xf0) >> 4]\n    buf[i++] = SEQRET_DECODER[sb & 0x0f]\n  }\n\n  if (i < seqLength) {\n    const sb = numericSeq[fullBytes]!\n    buf[i] = SEQRET_DECODER[(sb & 0xf0) >> 4]\n  }\n\n  return buf.join('')\n}\n\n// Gets a single base at position idx from NUMERIC_SEQ\nexport function seqAt(\n  numericSeq: Uint8Array,\n  idx: number,\n  seqLength: number,\n): string | undefined {\n  if (idx < seqLength) {\n    const byteIndex = idx >> 1\n    const sb = numericSeq[byteIndex]!\n    return idx % 2 === 0\n      ? SEQRET_DECODER[(sb & 0xf0) >> 4]\n      : SEQRET_DECODER[sb & 0x0f]\n  }\n  return undefined\n}\n","import { BamRecord } from '@gmod/bam'\n\nimport { forEachMismatchNumeric } from './forEachMismatchNumeric.ts'\nimport {\n  CHAR_FROM_CODE,\n  CIGAR_H,\n  CIGAR_S,\n} from '../PileupRenderer/renderers/cigarUtil.ts'\nimport { decodeSeq } from '../shared/decodeSeq.ts'\nimport {\n  HARDCLIP_TYPE,\n  INSERTION_TYPE,\n  MISMATCH_TYPE,\n  SOFTCLIP_TYPE,\n} from '../shared/forEachMismatchTypes.ts'\nimport { convertTagsToPlainArrays } from '../shared/util.ts'\n\nimport type BamAdapter from './BamAdapter.ts'\nimport type { MismatchCallback } from '../shared/forEachMismatchTypes.ts'\nimport type { Mismatch } from '../shared/types.ts'\nimport type { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\n\nexport default class BamSlightlyLazyFeature\n  extends BamRecord\n  implements Feature\n{\n  public adapter!: BamAdapter\n  public ref?: string\n  private _cachedFields?: SimpleFeatureSerialized\n\n  id() {\n    return `${this.adapter.id}-${this.fileOffset}`\n  }\n\n  get seq() {\n    return decodeSeq(this.NUMERIC_SEQ, this.seq_length)\n  }\n\n  // performance profiling showed that using forEachMismatch rather than\n  // computing mismatches array up front was faster, so this is no longer the\n  // primary way mismatches are used\n  get mismatches() {\n    const mismatches: Mismatch[] = []\n    this.forEachMismatch(\n      (type, start, length, base, qual, altbase, cliplen) => {\n        if (type === MISMATCH_TYPE) {\n          mismatches.push({\n            type: 'mismatch',\n            start,\n            length,\n            base,\n            qual: qual !== undefined && qual >= 0 ? qual : undefined,\n            altbase:\n              altbase !== undefined && altbase > 0\n                ? CHAR_FROM_CODE[altbase]\n                : undefined,\n          })\n        } else if (type === INSERTION_TYPE) {\n          mismatches.push({\n            type: 'insertion',\n            start,\n            length,\n            insertlen: cliplen!,\n            insertedBases: base,\n          })\n        } else if (type === SOFTCLIP_TYPE) {\n          mismatches.push({\n            type: 'softclip',\n            start,\n            length,\n            cliplen: cliplen!,\n          })\n        } else if (type === HARDCLIP_TYPE) {\n          mismatches.push({\n            type: 'hardclip',\n            start,\n            length,\n            cliplen: cliplen!,\n          })\n        } else {\n          mismatches.push({\n            type: type === 2 ? 'deletion' : 'skip',\n            start,\n            length,\n          })\n        }\n      },\n    )\n    return mismatches\n  }\n\n  forEachMismatch(callback: MismatchCallback) {\n    forEachMismatchNumeric(\n      this.NUMERIC_CIGAR,\n      this.NUMERIC_SEQ,\n      this.seq_length,\n      this.NUMERIC_MD,\n      this.qual,\n      this.ref,\n      callback,\n    )\n  }\n\n  get qualString() {\n    return this.qual?.join(' ')\n  }\n\n  get clipLengthAtStartOfRead() {\n    const cigar = this.NUMERIC_CIGAR\n    if (cigar.length === 0) {\n      return 0\n    }\n    const packed = this.strand === -1 ? cigar[cigar.length - 1]! : cigar[0]!\n    const op = packed & 0xf\n    if (op === CIGAR_S || op === CIGAR_H) {\n      return packed >> 4\n    }\n    return 0\n  }\n\n  get refName() {\n    return this.adapter.refIdToName(this.ref_id)!\n  }\n  get(field: string): any {\n    switch (field) {\n      case 'mismatches':\n        return this.mismatches\n      case 'name':\n        return this.name\n      case 'start':\n        return this.start\n      case 'refName':\n        return this.refName\n      case 'end':\n        return this.end\n      case 'strand':\n        return this.strand\n      case 'qual':\n        return this.qualString\n      case 'seq':\n        return this.seq\n      case 'tags':\n        return this.tags\n      case 'NUMERIC_SEQ':\n        return this.NUMERIC_SEQ\n      case 'NUMERIC_CIGAR':\n        return this.NUMERIC_CIGAR\n      case 'CIGAR':\n        return this.CIGAR\n      case 'NUMERIC_QUAL':\n        return this.qual\n      case 'NUMERIC_MD':\n        return this.NUMERIC_MD\n      case 'seq_length':\n        return this.seq_length\n      case 'flags':\n        return this.flags\n      case 'pair_orientation':\n        return this.pair_orientation\n      case 'next_ref':\n        return this.next_ref\n      case 'next_pos':\n        return this.next_pos\n      case 'template_length':\n        return this.template_length\n      case 'clipLengthAtStartOfRead':\n        return this.clipLengthAtStartOfRead\n\n      default:\n        return this.fields[field]\n    }\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  get fields(): SimpleFeatureSerialized {\n    if (this._cachedFields === undefined) {\n      this._cachedFields = {\n        start: this.start,\n        name: this.name,\n        end: this.end,\n        score: this.score,\n        strand: this.strand,\n        template_length: this.template_length,\n        flags: this.flags,\n        tags: this.tags,\n        refName: this.refName,\n        type: 'match',\n        pair_orientation: this.pair_orientation,\n        next_ref: this.next_ref,\n        next_pos: this.next_pos,\n        next_segment_position: this.next_segment_position,\n        uniqueId: this.id(),\n      }\n    }\n    return this._cachedFields\n  }\n  get next_ref() {\n    return this.isPaired()\n      ? this.adapter.refIdToName(this.next_refid)\n      : undefined\n  }\n\n  get next_segment_position() {\n    return this.isPaired()\n      ? `${this.adapter.refIdToName(this.next_refid)}:${this.next_pos + 1}`\n      : undefined\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...this.fields,\n      CIGAR: this.CIGAR,\n      seq: this.seq,\n      tags: convertTagsToPlainArrays(this.tags),\n      qual: this.qualString,\n    }\n  }\n}\n","import {\n  CIGAR_D,\n  CIGAR_H,\n  CIGAR_I,\n  CIGAR_M_EQ_MASK,\n  CIGAR_N,\n  CIGAR_S,\n  CIGAR_X,\n  SEQRET,\n  SEQRET_NUMERIC_DECODER,\n} from '../PileupRenderer/renderers/cigarUtil.ts'\nimport {\n  DELETION_TYPE,\n  HARDCLIP_TYPE,\n  INSERTION_TYPE,\n  MISMATCH_TYPE,\n  SKIP_TYPE,\n  SOFTCLIP_TYPE,\n} from '../shared/forEachMismatchTypes.ts'\n\nimport type { MismatchCallback } from '../shared/forEachMismatchTypes.ts'\n\n/**\n * Core mismatch iteration logic for BAM records.\n * Extracted as standalone function for testability.\n *\n * @param cigar - Packed CIGAR operations (Uint32Array)\n * @param numericSeq - Packed sequence (Uint8Array, 4-bit per base)\n * @param seqLength - Length of sequence\n * @param md - MD tag as byte array (or undefined)\n * @param qual - Quality scores (or undefined)\n * @param ref - Reference sequence for comparison when no MD tag\n * @param callback - Called for each mismatch/indel/clip\n */\nexport function forEachMismatchNumeric(\n  cigar: ArrayLike<number>,\n  numericSeq: ArrayLike<number>,\n  seqLength: number,\n  md: ArrayLike<number> | undefined,\n  qual: ArrayLike<number> | null | undefined,\n  ref: string | undefined,\n  callback: MismatchCallback,\n) {\n  // Fast path for reads with no sequence (e.g. secondary alignments with SEQ='*')\n  if (seqLength === 0) {\n    let roffset = 0\n    for (let i = 0, l = cigar.length; i < l; i++) {\n      const packed = cigar[i]!\n      const len = packed >> 4\n      const op = packed & 0xf\n      if ((1 << op) & CIGAR_M_EQ_MASK) {\n        roffset += len\n      } else if (op === CIGAR_I) {\n        callback(INSERTION_TYPE, roffset, 0, '*', -1, 0, len)\n      } else if (op === CIGAR_D) {\n        callback(DELETION_TYPE, roffset, len, '*', -1, 0, 0)\n        roffset += len\n      } else if (op === CIGAR_N) {\n        callback(SKIP_TYPE, roffset, len, 'N', -1, 0, 0)\n        roffset += len\n      } else if (op === CIGAR_S) {\n        callback(SOFTCLIP_TYPE, roffset, 1, `S${len}`, -1, 0, len)\n      } else if (op === CIGAR_H) {\n        callback(HARDCLIP_TYPE, roffset, 1, `H${len}`, -1, 0, len)\n      }\n    }\n    return\n  }\n\n  const mdLength = md?.length ?? 0\n  const hasQual = !!qual\n  const hasMD = md && mdLength > 0\n\n  let roffset = 0\n  let soffset = 0\n  let mdIdx = 0\n  let mdMatchRemaining = 0\n\n  if (hasMD) {\n    while (mdIdx < mdLength) {\n      const c = md[mdIdx]!\n      if (c >= 48 && c <= 57) {\n        mdMatchRemaining = mdMatchRemaining * 10 + (c - 48)\n        mdIdx++\n      } else {\n        break\n      }\n    }\n  }\n\n  for (let i = 0, l = cigar.length; i < l; i++) {\n    const packed = cigar[i]!\n    const len = packed >> 4\n    const op = packed & 0xf\n\n    if ((1 << op) & CIGAR_M_EQ_MASK) {\n      if (hasMD) {\n        let remaining = len\n        let localOffset = 0\n\n        while (remaining > 0) {\n          if (mdMatchRemaining >= remaining) {\n            mdMatchRemaining -= remaining\n            localOffset += remaining\n            remaining = 0\n          } else {\n            localOffset += mdMatchRemaining\n            remaining -= mdMatchRemaining\n            mdMatchRemaining = 0\n\n            if (mdIdx < mdLength && md[mdIdx]! >= 65 && md[mdIdx]! <= 90) {\n              const seqIdx = soffset + localOffset\n              const sb = numericSeq[seqIdx >> 1]!\n              const nibble = (sb >> ((1 - (seqIdx & 1)) << 2)) & 0xf\n\n              callback(\n                MISMATCH_TYPE,\n                roffset + localOffset,\n                1,\n                SEQRET[nibble]!,\n                hasQual ? qual[seqIdx]! : -1,\n                md[mdIdx],\n                0,\n              )\n\n              mdIdx++\n              localOffset++\n              remaining--\n              mdMatchRemaining = 0\n              while (mdIdx < mdLength) {\n                const c = md[mdIdx]!\n                if (c >= 48 && c <= 57) {\n                  mdMatchRemaining = mdMatchRemaining * 10 + (c - 48)\n                  mdIdx++\n                } else {\n                  break\n                }\n              }\n            } else {\n              break\n            }\n          }\n        }\n      } else if (ref) {\n        for (let j = 0; j < len; j++) {\n          const seqIdx = soffset + j\n          const sb = numericSeq[seqIdx >> 1]!\n          const nibble = (sb >> ((1 - (seqIdx & 1)) << 2)) & 0xf\n          const seqBaseCode = SEQRET_NUMERIC_DECODER[nibble]!\n          const refCharCode = ref.charCodeAt(roffset + j)\n          // Compare case-insensitively (| 0x20 converts uppercase to lowercase)\n          if (seqBaseCode !== (refCharCode | 0x20)) {\n            callback(\n              MISMATCH_TYPE,\n              roffset + j,\n              1,\n              SEQRET[nibble]!,\n              hasQual ? qual[seqIdx]! : -1,\n              refCharCode,\n              0,\n            )\n          }\n        }\n      }\n      soffset += len\n      roffset += len\n    } else if (op === CIGAR_I) {\n      // Optimized insertion base extraction - avoid string concat for common cases\n      let insertedBases: string\n      if (len === 1) {\n        // Single base insertion - most common case\n        const sb = numericSeq[soffset >> 1]!\n        const nibble = (sb >> ((1 - (soffset & 1)) << 2)) & 0xf\n        insertedBases = SEQRET[nibble]!\n      } else if (len === 2) {\n        // Two base insertion - second most common\n        const seqIdx0 = soffset\n        const sb0 = numericSeq[seqIdx0 >> 1]!\n        const nibble0 = (sb0 >> ((1 - (seqIdx0 & 1)) << 2)) & 0xf\n        const seqIdx1 = soffset + 1\n        const sb1 = numericSeq[seqIdx1 >> 1]!\n        const nibble1 = (sb1 >> ((1 - (seqIdx1 & 1)) << 2)) & 0xf\n        insertedBases = SEQRET[nibble0]! + SEQRET[nibble1]!\n      } else {\n        const bases = new Array<string>(len)\n        for (let j = 0; j < len; j++) {\n          const seqIdx = soffset + j\n          const sb = numericSeq[seqIdx >> 1]!\n          const nibble = (sb >> ((1 - (seqIdx & 1)) << 2)) & 0xf\n          bases[j] = SEQRET[nibble]!\n        }\n        insertedBases = bases.join('')\n      }\n      callback(INSERTION_TYPE, roffset, 0, insertedBases, -1, 0, len)\n      soffset += len\n    } else if (op === CIGAR_D) {\n      callback(DELETION_TYPE, roffset, len, '*', -1, 0, 0)\n\n      // eslint-disable-next-line @typescript-eslint/no-confusing-non-null-assertion\n      if (hasMD && mdIdx < mdLength && md[mdIdx]! === 94) {\n        mdIdx++\n        while (mdIdx < mdLength && md[mdIdx]! >= 65) {\n          mdIdx++\n        }\n        mdMatchRemaining = 0\n        while (mdIdx < mdLength) {\n          const c = md[mdIdx]!\n          if (c >= 48 && c <= 57) {\n            mdMatchRemaining = mdMatchRemaining * 10 + (c - 48)\n            mdIdx++\n          } else {\n            break\n          }\n        }\n      }\n      roffset += len\n    } else if (op === CIGAR_N) {\n      callback(SKIP_TYPE, roffset, len, 'N', -1, 0, 0)\n      roffset += len\n    } else if (op === CIGAR_X) {\n      for (let j = 0; j < len; j++) {\n        const seqIdx = soffset + j\n        const sb = numericSeq[seqIdx >> 1]!\n        const nibble = (sb >> ((1 - (seqIdx & 1)) << 2)) & 0xf\n\n        let altbaseCode = 0\n        if (hasMD) {\n          if (mdMatchRemaining === 0 && mdIdx < mdLength && md[mdIdx]! >= 65) {\n            altbaseCode = md[mdIdx]!\n            mdIdx++\n            mdMatchRemaining = 0\n            while (mdIdx < mdLength) {\n              const c = md[mdIdx]!\n              if (c >= 48 && c <= 57) {\n                mdMatchRemaining = mdMatchRemaining * 10 + (c - 48)\n                mdIdx++\n              } else {\n                break\n              }\n            }\n          } else if (mdMatchRemaining > 0) {\n            mdMatchRemaining--\n          }\n        } else if (ref) {\n          // No MD tag - get reference base from ref string\n          altbaseCode = ref.charCodeAt(roffset + j)\n        }\n\n        callback(\n          MISMATCH_TYPE,\n          roffset + j,\n          1,\n          SEQRET[nibble]!,\n          hasQual ? qual[seqIdx]! : -1,\n          altbaseCode,\n          0,\n        )\n      }\n      soffset += len\n      roffset += len\n    } else if (op === CIGAR_S) {\n      callback(SOFTCLIP_TYPE, roffset, 1, `S${len}`, -1, 0, len)\n      soffset += len\n    } else if (op === CIGAR_H) {\n      callback(HARDCLIP_TYPE, roffset, 1, `H${len}`, -1, 0, len)\n    }\n  }\n}\n"],"names":["BamAdapter","BaseFeatureDataAdapter","configure","this","configureResult","bamLocation","getConf","location","csi","bam","BamFile","bamFilehandle","openLocation","pluginManager","csiFilehandle","undefined","baiFilehandle","recordClass","BamSlightlyLazyFeature","getSequenceAdapter","config","sequenceAdapterConfig","getSubAdapter","sequenceAdapterP","then","r","adapter","dataAdapter","catch","e","getHeader","_opts","getHeaderText","setup","opts","statusCallback","setupP","updateStatus","async","rawHeader","samHeader","parseSamHeader","getRefNames","idToName","getFeatures","region","refName","start","end","originalRefName","stopToken","filterBy","ObservableCreate","sequenceAdapter","checkStopToken","records","getRecordsForRange","readName","regionSeq","regionStart","Infinity","regionEnd","record","NUMERIC_MD","Math","min","max","getSequence","name","ref","slice","observer","next","complete","getMultiRegionFeatureDensityStats","regions","index","bytes","estimatedBytesForRegions","fetchSizeLimit","super","refIdToName","refId","HtsgetBamAdapter","htsgetBase","htsgetTrackId","HtsgetFile","baseUrl","trackId","CIGAR_M","CIGAR_I","CIGAR_D","CIGAR_N","CIGAR_S","CIGAR_H","CIGAR_EQ","CIGAR_X","CIGAR_M_EQ_MASK","CIGAR_REF_CONSUMING_MASK","SEQRET","SEQRET_NUMERIC_DECODER","Uint8Array","CHAR_FROM_CODE","Array","from","length","_","i","String","fromCharCode","getCigarOps","cigar","parseCigar2","SEQRET_DECODER","split","BamRecord","id","fileOffset","seq","numericSeq","seqLength","buf","fullBytes","j","sb","join","decodeSeq","NUMERIC_SEQ","seq_length","mismatches","forEachMismatch","type","base","qual","altbase","cliplen","MISMATCH_TYPE","push","INSERTION_TYPE","insertlen","insertedBases","SOFTCLIP_TYPE","HARDCLIP_TYPE","callback","md","roffset","l","packed","len","op","DELETION_TYPE","SKIP_TYPE","mdLength","hasQual","hasMD","soffset","mdIdx","mdMatchRemaining","c","remaining","localOffset","seqIdx","nibble","seqBaseCode","refCharCode","charCodeAt","seqIdx0","nibble0","seqIdx1","nibble1","bases","altbaseCode","forEachMismatchNumeric","NUMERIC_CIGAR","qualString","clipLengthAtStartOfRead","strand","ref_id","get","field","tags","CIGAR","flags","pair_orientation","next_ref","next_pos","template_length","fields","parent","children","_cachedFields","score","next_segment_position","uniqueId","isPaired","next_refid","toJSON","convertTagsToPlainArrays"],"ignoreList":[],"sourceRoot":""}