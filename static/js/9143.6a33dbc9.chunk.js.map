{"version":3,"file":"static/js/9143.6a33dbc9.chunk.js","mappings":"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","sources":["../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/components/util.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawRef.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/afterAttach.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawCigarClickMap.ts","../../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawMouseover.ts"],"sourcesContent":["import type React from 'react'\n\nimport {\n  assembleLocString,\n  doesIntersect2,\n  getContainingTrack,\n  getContainingView,\n  getSession,\n  isSessionModelWithWidgets,\n  toLocale,\n} from '@jbrowse/core/util'\n\nimport { MAX_COLOR_RANGE, getId } from '../drawSynteny.ts'\n\nimport type { LinearSyntenyDisplayModel } from '../model.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface Pos {\n  offsetPx: number\n}\n\nexport interface ClickCoord {\n  clientX: number\n  clientY: number\n  feature: { f: Feature }\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\nexport function drawMatchSimple({\n  feature,\n  ctx,\n  offsets,\n  level,\n  cb,\n  height,\n  drawCurves,\n  oobLimit,\n  viewWidth,\n  hideTiny,\n}: {\n  feature: FeatPos\n  ctx: CanvasRenderingContext2D\n  offsets: number[]\n  level: number\n  oobLimit: number\n  viewWidth: number\n  cb: (ctx: CanvasRenderingContext2D) => void\n  height: number\n  drawCurves?: boolean\n  hideTiny?: boolean\n}) {\n  const { p11, p12, p21, p22 } = feature\n\n  const x11 = p11.offsetPx - offsets[level]!\n  const x12 = p12.offsetPx - offsets[level]!\n  const x21 = p21.offsetPx - offsets[level + 1]!\n  const x22 = p22.offsetPx - offsets[level + 1]!\n\n  const l1 = Math.abs(x12 - x11)\n  const l2 = Math.abs(x22 - x21)\n  const y1 = 0\n  const y2 = height\n  const mid = (y2 - y1) / 2\n  const minX = Math.min(x21, x22)\n  const maxX = Math.max(x21, x22)\n\n  if (!doesIntersect2(minX, maxX, -oobLimit, viewWidth + oobLimit)) {\n    return\n  }\n\n  // drawing a line if the results are thin: drawing a line results in much\n  // less pixellation than filling in a thin polygon\n  if (l1 <= 1 && l2 <= 1) {\n    // hideTiny can be used to avoid drawing mouseover for thin lines in this\n    // case\n    if (!hideTiny) {\n      ctx.beginPath()\n      ctx.moveTo(x11, y1)\n      if (drawCurves) {\n        ctx.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        ctx.lineTo(x21, y2)\n      }\n      ctx.stroke()\n    }\n  } else {\n    draw(ctx, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n    cb(ctx)\n  }\n}\n\nexport function draw(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n  drawCurves?: boolean,\n) {\n  if (drawCurves) {\n    drawBezierBox(ctx, x1, x2, y1, x3, x4, y2, mid)\n  } else {\n    drawBox(ctx, x1, x2, y1, x3, x4, y2)\n  }\n}\n\nexport function drawLocationMarkers(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n  bpPerPx1: number,\n  bpPerPx2: number,\n  drawCurves?: boolean,\n) {\n  const width1 = Math.abs(x2 - x1)\n  const width2 = Math.abs(x4 - x3)\n  const averageWidth = (width1 + width2) / 2\n\n  // Only draw markers for sufficiently large matches (wider than ~30 pixels)\n  if (averageWidth < 30) {\n    return\n  }\n\n  // Aim for markers at consistent pixel spacing for even visual density\n  // Target spacing of ~20 pixels between markers regardless of feature size\n  const targetPixelSpacing = 20\n  const numMarkers = Math.max(\n    2,\n    Math.floor(averageWidth / targetPixelSpacing) + 1,\n  )\n\n  const prevStrokeStyle = ctx.strokeStyle\n  const prevLineWidth = ctx.lineWidth\n\n  ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)' // Dark semi-transparent line\n  ctx.lineWidth = 0.5\n\n  // Create single path for all markers\n  ctx.beginPath()\n  if (drawCurves) {\n    for (let step = 0; step < numMarkers; step++) {\n      const t = step / numMarkers\n      const topX = x1 + (x2 - x1) * t\n      const bottomX = x4 + (x3 - x4) * t\n      ctx.moveTo(topX, y1)\n      ctx.bezierCurveTo(topX, mid, bottomX, mid, bottomX, y2)\n    }\n  } else {\n    for (let step = 0; step < numMarkers; step++) {\n      const t = step / numMarkers\n      const topX = x1 + (x2 - x1) * t\n      const bottomX = x4 + (x3 - x4) * t\n      ctx.moveTo(topX, y1)\n      ctx.lineTo(bottomX, y2)\n    }\n  }\n  ctx.stroke()\n\n  ctx.strokeStyle = prevStrokeStyle\n  ctx.lineWidth = prevLineWidth\n}\n\nexport function drawBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n) {\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.lineTo(x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.closePath()\n}\n\nexport function drawBezierBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n) {\n  const len1 = Math.abs(x1 - x2)\n  const len2 = Math.abs(x1 - x2)\n\n  // heuristic to not draw hourglass inversions with bezier curves when they\n  // are thin and far apart because it results in areas that are not drawn well\n  // demo https://codesandbox.io/s/fast-glitter-q3b1or?file=/src/index.js\n  if (len1 < 5 && len2 < 5 && x2 < x1 && Math.abs(x1 - x3) > 100) {\n    const tmp = x1\n    x1 = x2\n    x2 = tmp\n  }\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.bezierCurveTo(x2, mid, x3, mid, x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.bezierCurveTo(x4, mid, x1, mid, x1, y1)\n  ctx.closePath()\n}\n\nexport function getFeatureAtClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n) {\n  const { clickMapCanvas, numFeats, featPositions } = model\n  if (!clickMapCanvas) {\n    return undefined\n  }\n  const ctx = clickMapCanvas.getContext('2d')\n  if (!ctx) {\n    return undefined\n  }\n  const rect = clickMapCanvas.getBoundingClientRect()\n  const x = event.clientX - rect.left\n  const y = event.clientY - rect.top\n  const [r, g, b] = ctx.getImageData(x, y, 1, 1).data\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / numFeats)\n  const id = getId(r!, g!, b!, unitMultiplier)\n  return featPositions[id]\n}\n\nexport function onSynClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n) {\n  const feat = getFeatureAtClick(event, model)\n  if (feat) {\n    const { f } = feat\n    model.setClickId(f.id())\n    const session = getSession(model)\n    if (isSessionModelWithWidgets(session)) {\n      const view = getContainingView(model)\n      const track = getContainingTrack(model)\n      session.showWidget(\n        session.addWidget('SyntenyFeatureWidget', 'syntenyFeature', {\n          view,\n          track,\n          featureData: f.toJSON(),\n          level: model.level,\n        }),\n      )\n    }\n  }\n  return feat\n}\n\nexport function onSynContextClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n  setAnchorEl: (arg: ClickCoord) => void,\n) {\n  event.preventDefault()\n  const feat = getFeatureAtClick(event, model)\n  if (feat) {\n    model.setClickId(feat.f.id())\n    setAnchorEl({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      feature: feat,\n    })\n  }\n}\n\nexport function getTooltip({\n  feature,\n  cigarOp,\n  cigarOpLen,\n}: {\n  feature: Feature\n  cigarOpLen?: string\n  cigarOp?: string\n}) {\n  // @ts-expect-error\n  const f1 = feature.toJSON() as {\n    refName: string\n    start: number\n    end: number\n    strand?: number\n    assemblyName: string\n    identity?: number\n    name?: string\n    mate: {\n      start: number\n      end: number\n      refName: string\n      name: string\n    }\n  }\n  const f2 = f1.mate\n  const l1 = f1.end - f1.start\n  const l2 = f2.end - f2.start\n  const identity = f1.identity\n  const n1 = f1.name\n  const n2 = f2.name\n  return [\n    `Loc1: ${assembleLocString(f1)}`,\n    `Loc2: ${assembleLocString(f2)}`,\n    `Inverted: ${f1.strand === -1}`,\n    `Query len: ${toLocale(l1)}`,\n    `Target len: ${toLocale(l2)}`,\n    identity ? `Identity: ${identity.toPrecision(2)}` : '',\n    cigarOp ? `CIGAR operator: ${toLocale(+cigarOpLen!)}${cigarOp}` : '',\n    n1 ? `Name 1: ${n1}` : '',\n    n2 ? `Name 2: ${n2}` : '',\n  ]\n    .filter(f => !!f)\n    .join('<br/>')\n}\n","import { doesIntersect2, getContainingView } from '@jbrowse/core/util'\n\nimport {\n  draw,\n  drawLocationMarkers,\n  drawMatchSimple,\n} from './components/util.ts'\nimport {\n  MAX_COLOR_RANGE,\n  lineLimit,\n  makeColor,\n  oobLimit,\n} from './drawSyntenyUtils.ts'\n\nimport type { defaultCigarColors } from './drawSyntenyUtils.ts'\nimport type { LinearSyntenyDisplayModel } from './model.ts'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model.ts'\n\n// Constant callback for click map fill - avoids creating new function each iteration\nconst fillCb = (ctx: CanvasRenderingContext2D) => {\n  ctx.fill()\n}\n\nexport function drawRef(\n  model: LinearSyntenyDisplayModel,\n  mainCanvas: CanvasRenderingContext2D,\n) {\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const drawCIGAR = view.drawCIGAR\n  const drawCIGARMatchesOnly = view.drawCIGARMatchesOnly\n  const drawLocationMarkersEnabled = view.drawLocationMarkers\n  const { level, height, featPositions, minAlignmentLength, colorBy } = model\n  const width = view.width\n  const bpPerPxs = view.views.map(v => v.bpPerPx)\n\n  // Use cached colors from model (only recalculated when alpha/colorBy change)\n  const colorMapWithAlpha = model.colorMapWithAlpha\n  const posColorWithAlpha = model.posColorWithAlpha\n  const negColorWithAlpha = model.negColorWithAlpha\n  const getQueryColorWithAlpha = model.queryColorWithAlphaMap\n  const queryTotalLengths = model.queryTotalLengths\n\n  const offsets = view.views.map(v => v.offsetPx)\n  const offsetsL0 = offsets[level]!\n  const offsetsL1 = offsets[level + 1]!\n\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / featPositions.length)\n  const y1 = 0\n  const y2 = height\n  const mid = (y2 - y1) / 2\n\n  // Cache colorBy checks outside loop for performance\n  const useStrandColor = colorBy === 'strand'\n  const useQueryColor = colorBy === 'query'\n\n  // Cache bpPerPx values and reciprocals for division in CIGAR loop\n  const bpPerPx0 = bpPerPxs[level]!\n  const bpPerPx1 = bpPerPxs[level + 1]!\n  const bpPerPxInv0 = 1 / bpPerPx0\n  const bpPerPxInv1 = 1 / bpPerPx1\n\n  // Get click map context once\n  const clickMapCtx = model.clickMapCanvas?.getContext('2d')\n  if (clickMapCtx) {\n    clickMapCtx.imageSmoothingEnabled = false\n    clickMapCtx.clearRect(0, 0, width, height)\n  }\n\n  mainCanvas.fillStyle = colorMapWithAlpha.M\n  mainCanvas.strokeStyle = colorMapWithAlpha.M\n\n  // Single loop over features - draw main canvas and click map together\n  for (const [i, featPosition] of featPositions.entries()) {\n    const feature = featPosition\n    const { p11, p12, p21, p22, f, cigar } = feature\n\n    // Cache feature properties\n    const strand = f.get('strand')\n    const refName = f.get('refName')\n\n    // Filter by minAlignmentLength if enabled\n    if (queryTotalLengths) {\n      const queryName = f.get('name') || f.get('id') || f.id()\n      const totalLength = queryTotalLengths.get(queryName) || 0\n      if (totalLength < minAlignmentLength) {\n        continue\n      }\n    }\n\n    const x11 = p11.offsetPx - offsetsL0\n    const x12 = p12.offsetPx - offsetsL0\n    const x21 = p21.offsetPx - offsetsL1\n    const x22 = p22.offsetPx - offsetsL1\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const minX = Math.min(x21, x22)\n    const maxX = Math.max(x21, x22)\n\n    // Draw thin lines (when both dimensions are small)\n    if (\n      l1 <= lineLimit &&\n      l2 <= lineLimit &&\n      x21 < width + oobLimit &&\n      x21 > -oobLimit\n    ) {\n      // Set color for this line\n      if (useStrandColor) {\n        mainCanvas.strokeStyle =\n          strand === -1 ? negColorWithAlpha : posColorWithAlpha\n      } else if (useQueryColor) {\n        mainCanvas.strokeStyle = getQueryColorWithAlpha(refName)\n      } else {\n        mainCanvas.strokeStyle = colorMapWithAlpha.M\n      }\n\n      mainCanvas.beginPath()\n      mainCanvas.moveTo(x11, y1)\n      if (drawCurves) {\n        mainCanvas.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        mainCanvas.lineTo(x21, y2)\n      }\n      mainCanvas.stroke()\n    }\n    // Draw thick features\n    else if (doesIntersect2(minX, maxX, -oobLimit, view.width + oobLimit)) {\n      const s1 = strand\n      const k1 = s1 === -1 ? x12 : x11\n      const k2 = s1 === -1 ? x11 : x12\n\n      // rev1/rev2 flip the direction of the CIGAR drawing in horizontally flipped\n      // modes. somewhat heuristically determined, but tested for\n      const rev1 = k1 < k2 ? 1 : -1\n      const rev2 = (x21 < x22 ? 1 : -1) * s1\n\n      // cx1/cx2 are the current x positions on top and bottom rows\n      let cx1 = k1\n      let cx2 = s1 === -1 ? x22 : x21\n      if (cigar.length && drawCIGAR) {\n        // continuingFlag skips drawing commands on very small CIGAR features\n        let continuingFlag = false\n\n        // px1/px2 are the previous x positions on the top and bottom rows\n        let px1 = 0\n        let px2 = 0\n\n        for (let j = 0; j < cigar.length; j += 2) {\n          const len = +cigar[j]!\n          const op = cigar[j + 1] as keyof typeof defaultCigarColors\n\n          if (!continuingFlag) {\n            px1 = cx1\n            px2 = cx2\n          }\n\n          const d1 = len * bpPerPxInv0\n          const d2 = len * bpPerPxInv1\n\n          if (op === 'M' || op === '=' || op === 'X') {\n            cx1 += d1 * rev1\n            cx2 += d2 * rev2\n          } else if (op === 'D' || op === 'N') {\n            cx1 += d1 * rev1\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          else if (op === 'I') {\n            cx2 += d2 * rev2\n          }\n\n          // check that we are even drawing in view here, e.g. that all\n          // points are not all less than 0 or greater than width\n          if (\n            !(\n              Math.max(px1, px2, cx1, cx2) < 0 ||\n              Math.min(px1, px2, cx1, cx2) > width\n            )\n          ) {\n            // if it is a small feature and not the last element of the\n            // CIGAR (which could skip rendering it entire if we did turn\n            // it on), then turn on continuing flag\n            const isNotLast = j < cigar.length - 2\n            if (\n              Math.abs(cx1 - px1) <= 1 &&\n              Math.abs(cx2 - px2) <= 1 &&\n              isNotLast\n            ) {\n              continuingFlag = true\n            } else {\n              // allow rendering the dominant color when using continuing\n              // flag if the last element of continuing was a large\n              // feature, else just use match\n              const letter = (continuingFlag && d1 > 1) || d2 > 1 ? op : 'M'\n\n              // Use custom coloring based on colorBy setting\n              // Always keep yellow/blue for insertions/deletions regardless of colorBy\n              const isInsertionOrDeletion =\n                letter === 'I' || letter === 'D' || letter === 'N'\n              if (useStrandColor && !isInsertionOrDeletion) {\n                mainCanvas.fillStyle =\n                  strand === -1 ? negColorWithAlpha : posColorWithAlpha\n              } else if (useQueryColor && !isInsertionOrDeletion) {\n                mainCanvas.fillStyle = getQueryColorWithAlpha(refName)\n              } else {\n                mainCanvas.fillStyle = colorMapWithAlpha[letter]\n              }\n\n              continuingFlag = false\n\n              if (drawCIGARMatchesOnly) {\n                if (letter === 'M') {\n                  draw(mainCanvas, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                  mainCanvas.fill()\n                  if (drawLocationMarkersEnabled) {\n                    drawLocationMarkers(\n                      mainCanvas,\n                      px1,\n                      cx1,\n                      y1,\n                      cx2,\n                      px2,\n                      y2,\n                      mid,\n                      bpPerPx0,\n                      bpPerPx1,\n                      drawCurves,\n                    )\n                  }\n                }\n              } else {\n                draw(mainCanvas, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                mainCanvas.fill()\n                if (drawLocationMarkersEnabled) {\n                  drawLocationMarkers(\n                    mainCanvas,\n                    px1,\n                    cx1,\n                    y1,\n                    cx2,\n                    px2,\n                    y2,\n                    mid,\n                    bpPerPx0,\n                    bpPerPx1,\n                    drawCurves,\n                  )\n                }\n              }\n            }\n          }\n        }\n      } else {\n        // Use custom coloring based on colorBy setting\n        if (useStrandColor) {\n          mainCanvas.fillStyle =\n            strand === -1 ? negColorWithAlpha : posColorWithAlpha\n        } else if (useQueryColor) {\n          mainCanvas.fillStyle = getQueryColorWithAlpha(refName)\n        }\n\n        draw(mainCanvas, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n        mainCanvas.fill()\n\n        // Reset to default color if needed\n        if (useStrandColor || useQueryColor) {\n          mainCanvas.fillStyle = colorMapWithAlpha.M\n        }\n      }\n    }\n\n    // Draw to click map (for all visible features, not just thick ones)\n    if (clickMapCtx) {\n      const idx = i * unitMultiplier + 1\n      clickMapCtx.fillStyle = makeColor(idx)\n\n      drawMatchSimple({\n        cb: fillCb,\n        feature,\n        ctx: clickMapCtx,\n        drawCurves,\n        level,\n        offsets,\n        oobLimit,\n        viewWidth: view.width,\n        hideTiny: true,\n        height,\n      })\n    }\n  }\n}\n","import { getContainingView, getSession } from '@jbrowse/core/util'\nimport { bpToPx } from '@jbrowse/core/util/Base1DUtils'\nimport { addDisposer, getSnapshot } from '@jbrowse/mobx-state-tree'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\nimport { autorun, reaction } from 'mobx'\n\nimport {\n  drawCigarClickMap,\n  drawMouseoverClickMap,\n  drawRef,\n} from './drawSynteny.ts'\n\nimport type { LinearSyntenyDisplayModel } from './model.ts'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface Pos {\n  offsetPx: number\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\ntype LSV = LinearSyntenyViewModel\n\nexport function doAfterAttach(self: LinearSyntenyDisplayModel) {\n  addDisposer(\n    self,\n    autorun(\n      function syntenyDrawAutorun() {\n        if (self.isMinimized) {\n          return\n        }\n        const view = getContainingView(self) as LinearSyntenyViewModel\n        if (\n          !view.initialized ||\n          !view.views.every(a => a.displayedRegions.length > 0 && a.initialized)\n        ) {\n          return\n        }\n\n        const ctx1 = self.mainCanvas?.getContext('2d')\n        const ctx3 = self.cigarClickMapCanvas?.getContext('2d')\n        if (!ctx1 || !ctx3) {\n          return\n        }\n\n        // Access alpha to make autorun react to alpha changes\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { alpha } = self\n        const height = self.height\n        const width = view.width\n        ctx1.clearRect(0, 0, width, height)\n\n        // Draw main canvas immediately\n        drawRef(self, ctx1)\n\n        drawCigarClickMap(self, ctx3)\n      },\n      { name: 'SyntenyDraw' },\n    ),\n  )\n\n  addDisposer(\n    self,\n    autorun(\n      function syntenyMouseoverAutorun() {\n        if (self.isMinimized) {\n          return\n        }\n        const view = getContainingView(self) as LinearSyntenyViewModel\n        if (\n          !view.initialized ||\n          !view.views.every(a => a.displayedRegions.length > 0 && a.initialized)\n        ) {\n          return\n        }\n        // Access reactive properties so autorun is triggered when they change\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { clickId, mouseoverId } = self\n        drawMouseoverClickMap(self)\n      },\n      { name: 'SyntenyMouseover' },\n    ),\n  )\n\n  // this attempts to reduce recalculation of feature positions drawn by the\n  // synteny view\n  //\n  // uses a reaction to say \"we know the positions don't change in any relevant\n  // way unless bpPerPx changes or displayedRegions changes\"\n  addDisposer(\n    self,\n    reaction(\n      () => {\n        if (self.isMinimized) {\n          return { initialized: false }\n        }\n        const view = getContainingView(self) as LSV\n        return {\n          bpPerPx: view.views.map(v => v.bpPerPx),\n\n          // stringifying 'deeply' accesses the displayed regions, see\n          // issue #3456\n          displayedRegions: JSON.stringify(\n            view.views.map(v => v.displayedRegions),\n          ),\n          features: self.features,\n          initialized:\n            view.initialized &&\n            view.views.every(\n              a => a.displayedRegions.length > 0 && a.initialized,\n            ),\n        }\n      },\n      ({ initialized }) => {\n        if (!initialized) {\n          return\n        }\n        const { level } = self\n        const { assemblyManager } = getSession(self)\n        const view = getContainingView(self) as LSV\n        const viewSnaps = view.views.map(view => ({\n          ...getSnapshot(view),\n          width: view.width,\n          staticBlocks: view.staticBlocks,\n          interRegionPaddingWidth: view.interRegionPaddingWidth,\n          minimumBlockWidth: view.minimumBlockWidth,\n        }))\n\n        const map = [] as FeatPos[]\n        const feats = self.features || []\n\n        for (const f of feats) {\n          const mate = f.get('mate')\n          let f1s = f.get('start')\n          let f1e = f.get('end')\n          const f2s = mate.start\n          const f2e = mate.end\n\n          if (f.get('strand') === -1) {\n            ;[f1e, f1s] = [f1s, f1e]\n          }\n          const a1 = assemblyManager.get(f.get('assemblyName'))\n          const a2 = assemblyManager.get(mate.assemblyName)\n          const r1 = f.get('refName')\n          const r2 = mate.refName\n          const ref1 = a1?.getCanonicalRefName(r1) || r1\n          const ref2 = a2?.getCanonicalRefName(r2) || r2\n          const v1 = viewSnaps[level]!\n          const v2 = viewSnaps[level + 1]!\n          const p11 = bpToPx({ self: v1, refName: ref1, coord: f1s })\n          const p12 = bpToPx({ self: v1, refName: ref1, coord: f1e })\n          const p21 = bpToPx({ self: v2, refName: ref2, coord: f2s })\n          const p22 = bpToPx({ self: v2, refName: ref2, coord: f2e })\n\n          if (\n            p11 === undefined ||\n            p12 === undefined ||\n            p21 === undefined ||\n            p22 === undefined\n          ) {\n            continue\n          }\n\n          const cigar = f.get('CIGAR') as string | undefined\n          map.push({\n            p11,\n            p12,\n            p21,\n            p22,\n            f,\n            cigar: MismatchParser.parseCigar(cigar),\n          })\n        }\n\n        self.setFeatPositions(map)\n      },\n      { fireImmediately: true },\n    ),\n  )\n}\n","import { doesIntersect2, getContainingView } from '@jbrowse/core/util'\n\nimport { draw } from './components/util.ts'\nimport {\n  MAX_COLOR_RANGE,\n  lineLimit,\n  makeColor,\n  oobLimit,\n} from './drawSyntenyUtils.ts'\n\nimport type { defaultCigarColors } from './drawSyntenyUtils.ts'\nimport type { LinearSyntenyDisplayModel } from './model.ts'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model.ts'\n\nexport function drawCigarClickMap(\n  model: LinearSyntenyDisplayModel,\n  cigarClickMapCanvas: CanvasRenderingContext2D,\n) {\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const drawCIGAR = view.drawCIGAR\n  const drawCIGARMatchesOnly = view.drawCIGARMatchesOnly\n  const { level, height, featPositions } = model\n  const width = view.width\n  const bpPerPxs = view.views.map(v => v.bpPerPx)\n\n  cigarClickMapCanvas.imageSmoothingEnabled = false\n  cigarClickMapCanvas.clearRect(0, 0, width, height)\n\n  const offsets = view.views.map(v => v.offsetPx)\n\n  // Cache reciprocals for division in CIGAR loop\n  const bpPerPxInv0 = 1 / bpPerPxs[level]!\n  const bpPerPxInv1 = 1 / bpPerPxs[level + 1]!\n\n  for (const { p11, p12, p21, p22, f, cigar } of featPositions) {\n    const x11 = p11.offsetPx - offsets[level]!\n    const x12 = p12.offsetPx - offsets[level]!\n    const x21 = p21.offsetPx - offsets[level + 1]!\n    const x22 = p22.offsetPx - offsets[level + 1]!\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const minX = Math.min(x21, x22)\n    const maxX = Math.max(x21, x22)\n    const y1 = 0\n    const y2 = height\n    const mid = (y2 - y1) / 2\n\n    if (\n      !(l1 <= lineLimit && l2 <= lineLimit) &&\n      doesIntersect2(minX, maxX, -oobLimit, view.width + oobLimit)\n    ) {\n      const s1 = f.get('strand')\n      const k1 = s1 === -1 ? x12 : x11\n      const k2 = s1 === -1 ? x11 : x12\n\n      const rev1 = k1 < k2 ? 1 : -1\n      const rev2 = (x21 < x22 ? 1 : -1) * s1\n\n      let cx1 = k1\n      let cx2 = s1 === -1 ? x22 : x21\n      if (cigar.length && drawCIGAR) {\n        let continuingFlag = false\n        let px1 = 0\n        let px2 = 0\n        const unitMultiplier2 = Math.floor(MAX_COLOR_RANGE / cigar.length)\n\n        for (let j = 0; j < cigar.length; j += 2) {\n          const len = +cigar[j]!\n          const op = cigar[j + 1] as keyof typeof defaultCigarColors\n\n          if (!continuingFlag) {\n            px1 = cx1\n            px2 = cx2\n          }\n\n          const d1 = len * bpPerPxInv0\n          const d2 = len * bpPerPxInv1\n\n          if (op === 'M' || op === '=' || op === 'X') {\n            cx1 += d1 * rev1\n            cx2 += d2 * rev2\n          } else if (op === 'D' || op === 'N') {\n            cx1 += d1 * rev1\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          else if (op === 'I') {\n            cx2 += d2 * rev2\n          }\n\n          if (\n            !(\n              Math.max(px1, px2, cx1, cx2) < 0 ||\n              Math.min(px1, px2, cx1, cx2) > width\n            )\n          ) {\n            const isNotLast = j < cigar.length - 2\n            if (\n              Math.abs(cx1 - px1) <= 1 &&\n              Math.abs(cx2 - px2) <= 1 &&\n              isNotLast\n            ) {\n              continuingFlag = true\n            } else {\n              continuingFlag = false\n              // When drawCIGARMatchesOnly is enabled, only draw match operations (M, =, X)\n              // Skip insertions (I) and deletions (D, N)\n              // Also skip very thin rectangles which tend to be glitchy\n              const shouldDraw =\n                !drawCIGARMatchesOnly ||\n                ((op === 'M' || op === '=' || op === 'X') &&\n                  Math.abs(cx1 - px1) > 1 &&\n                  Math.abs(cx2 - px2) > 1)\n\n              if (shouldDraw) {\n                const idx = j * unitMultiplier2 + 1\n                cigarClickMapCanvas.fillStyle = makeColor(idx)\n                draw(\n                  cigarClickMapCanvas,\n                  px1,\n                  cx1,\n                  y1,\n                  cx2,\n                  px2,\n                  y2,\n                  mid,\n                  drawCurves,\n                )\n                cigarClickMapCanvas.fill()\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { getContainingView } from '@jbrowse/core/util'\n\nimport { drawMatchSimple } from './components/util.ts'\nimport { oobLimit } from './drawSyntenyUtils.ts'\n\nimport type { LinearSyntenyDisplayModel } from './model.ts'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model.ts'\n\nexport function drawMouseoverClickMap(model: LinearSyntenyDisplayModel) {\n  const { level, clickId, mouseoverId } = model\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const height = model.height\n  const width = view.width\n  const ctx = model.mouseoverCanvas?.getContext('2d')\n  const offsets = view.views.map(v => v.offsetPx)\n\n  if (!ctx) {\n    return\n  }\n  ctx.resetTransform()\n  ctx.clearRect(0, 0, width, height)\n  ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)'\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'\n\n  const feature1 = model.featMap[mouseoverId || '']\n  if (feature1) {\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.fill()\n      },\n      feature: feature1,\n      level,\n      ctx,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n\n  const feature2 = model.featMap[clickId || '']\n  if (feature2) {\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.stroke()\n      },\n      feature: feature2,\n      ctx,\n      level,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n}\n"],"names":["drawMatchSimple","feature","ctx","offsets","level","cb","height","drawCurves","oobLimit","viewWidth","hideTiny","p11","p12","p21","p22","x11","offsetPx","x12","x21","x22","l1","Math","abs","l2","y2","mid","minX","min","maxX","max","doesIntersect2","beginPath","moveTo","bezierCurveTo","lineTo","stroke","draw","x1","x2","y1","x3","x4","len1","len2","tmp","closePath","drawBezierBox","drawBox","drawLocationMarkers","bpPerPx1","bpPerPx2","averageWidth","numMarkers","floor","prevStrokeStyle","strokeStyle","prevLineWidth","lineWidth","step","t","topX","bottomX","getFeatureAtClick","event","model","clickMapCanvas","numFeats","featPositions","getContext","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","r","g","b","getImageData","data","unitMultiplier","MAX_COLOR_RANGE","getId","onSynClick","feat","f","setClickId","id","session","getSession","isSessionModelWithWidgets","view","getContainingView","track","getContainingTrack","showWidget","addWidget","featureData","toJSON","onSynContextClick","setAnchorEl","preventDefault","getTooltip","cigarOp","cigarOpLen","f1","f2","mate","end","start","identity","n1","name","n2","assembleLocString","strand","toLocale","toPrecision","filter","join","fillCb","fill","drawRef","mainCanvas","drawCIGAR","drawCIGARMatchesOnly","drawLocationMarkersEnabled","minAlignmentLength","colorBy","width","bpPerPxs","views","map","v","bpPerPx","colorMapWithAlpha","posColorWithAlpha","negColorWithAlpha","getQueryColorWithAlpha","queryColorWithAlphaMap","queryTotalLengths","offsetsL0","offsetsL1","length","useStrandColor","useQueryColor","bpPerPx0","bpPerPxInv0","bpPerPxInv1","clickMapCtx","imageSmoothingEnabled","clearRect","fillStyle","M","i","featPosition","entries","cigar","get","refName","queryName","lineLimit","k1","rev1","rev2","cx1","cx2","continuingFlag","px1","px2","j","len","op","d1","d2","isNotLast","letter","isInsertionOrDeletion","idx","makeColor","doAfterAttach","self","addDisposer","autorun","isMinimized","initialized","every","a","displayedRegions","ctx1","ctx3","cigarClickMapCanvas","alpha","s1","unitMultiplier2","drawCigarClickMap","clickId","mouseoverId","mouseoverCanvas","resetTransform","feature1","featMap","feature2","drawMouseoverClickMap","reaction","JSON","stringify","features","assemblyManager","viewSnaps","getSnapshot","staticBlocks","interRegionPaddingWidth","minimumBlockWidth","feats","f1s","f1e","f2s","f2e","a1","a2","assemblyName","r1","r2","ref1","getCanonicalRefName","ref2","v1","v2","bpToPx","coord","undefined","push","MismatchParser","setFeatPositions","fireImmediately"],"ignoreList":[],"sourceRoot":""}