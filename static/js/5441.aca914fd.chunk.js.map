{"version":3,"file":"static/js/5441.aca914fd.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3TabixAdapter/Gff3TabixAdapter.ts","../../../plugins/gff3/src/featureData.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { doesIntersect2 } from '@jbrowse/core/util/range'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport gff, { GFF3Feature } from '@gmod/gff'\nimport { Observer } from 'rxjs'\nimport {\n  readConfObject,\n  AnyConfigurationModel,\n} from '@jbrowse/core/configuration'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\nimport { featureData } from '../featureData'\n\ninterface LineFeature {\n  start: number\n  end: number\n  lineHash: number\n  fields: string[]\n}\n\nexport default class Gff3TabixAdapter extends BaseFeatureDataAdapter {\n  protected gff: TabixIndexedFile\n\n  protected dontRedispatch: string[]\n\n  public constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const gffGzLocation = readConfObject(config, 'gffGzLocation')\n    const indexType = readConfObject(config, ['index', 'indexType'])\n    const location = readConfObject(config, ['index', 'location'])\n    const dontRedispatch = readConfObject(config, 'dontRedispatch')\n\n    this.dontRedispatch = dontRedispatch || ['chromosome', 'contig', 'region']\n    this.gff = new TabixIndexedFile({\n      filehandle: openLocation(gffGzLocation, this.pluginManager),\n      csiFilehandle:\n        indexType === 'CSI'\n          ? openLocation(location, this.pluginManager)\n          : undefined,\n      tbiFilehandle:\n        indexType !== 'CSI'\n          ? openLocation(location, this.pluginManager)\n          : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n      renameRefSeqs: (n: string) => n,\n    })\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    return this.gff.getReferenceSequenceNames(opts)\n  }\n\n  public async getHeader() {\n    return this.gff.getHeader()\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const metadata = await this.gff.getMetadata()\n      await this.getFeaturesHelper(query, opts, metadata, observer, true)\n    }, opts.signal)\n  }\n\n  private async getFeaturesHelper(\n    query: Region,\n    opts: BaseOptions,\n    metadata: { columnNumbers: { start: number; end: number } },\n    observer: Observer<Feature>,\n    allowRedispatch: boolean,\n    originalQuery = query,\n  ) {\n    try {\n      const lines: LineFeature[] = []\n\n      await this.gff.getLines(\n        query.refName,\n        query.start,\n        query.end,\n        (line: string, fileOffset: number) => {\n          lines.push(this.parseLine(metadata.columnNumbers, line, fileOffset))\n        },\n      )\n      if (allowRedispatch && lines.length) {\n        let minStart = Number.POSITIVE_INFINITY\n        let maxEnd = Number.NEGATIVE_INFINITY\n        lines.forEach(line => {\n          const featureType = line.fields[2]!\n          // only expand redispatch range if feature is not a \"dontRedispatch\"\n          // type skips large regions like chromosome,region\n          if (!this.dontRedispatch.includes(featureType)) {\n            const start = line.start - 1 // gff is 1-based\n            if (start < minStart) {\n              minStart = start\n            }\n            if (line.end > maxEnd) {\n              maxEnd = line.end\n            }\n          }\n        })\n        if (maxEnd > query.end || minStart < query.start) {\n          // make a new feature callback to only return top-level features\n          // in the original query range\n          await this.getFeaturesHelper(\n            { ...query, start: minStart, end: maxEnd },\n            opts,\n            metadata,\n            observer,\n            false,\n            query,\n          )\n          return\n        }\n      }\n\n      const gff3 = lines\n        .map((lineRecord: LineFeature) => {\n          if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n            if (!lineRecord.fields[8].includes('_lineHash')) {\n              lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`\n            }\n          } else {\n            lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`\n          }\n          return lineRecord.fields.join('\\t')\n        })\n        .join('\\n')\n\n      const features = gff.parseStringSync(gff3, {\n        parseFeatures: true,\n        parseComments: false,\n        parseDirectives: false,\n        parseSequences: false,\n        disableDerivesFromReferences: true,\n      })\n\n      features.forEach(featureLocs => {\n        this.formatFeatures(featureLocs).forEach(f => {\n          if (\n            doesIntersect2(\n              f.get('start'),\n              f.get('end'),\n              originalQuery.start,\n              originalQuery.end,\n            )\n          ) {\n            observer.next(f)\n          }\n        })\n      })\n      observer.complete()\n    } catch (e) {\n      observer.error(e)\n    }\n  }\n\n  private parseLine(\n    columnNumbers: { start: number; end: number },\n    line: string,\n    fileOffset: number,\n  ) {\n    const fields = line.split('\\t')\n\n    // note: index column numbers are 1-based\n    return {\n      start: +fields[columnNumbers.start - 1]!,\n      end: +fields[columnNumbers.end - 1]!,\n      lineHash: fileOffset,\n      fields,\n    }\n  }\n\n  private formatFeatures(featureLocs: GFF3Feature) {\n    return featureLocs.map(\n      featureLoc =>\n        new SimpleFeature({\n          data: featureData(featureLoc),\n          id: `${this.id}-offset-${featureLoc.attributes?._lineHash?.[0]}`,\n        }),\n    )\n  }\n\n  public freeResources(/* { region } */) {}\n}\n","import { GFF3FeatureLineWithRefs } from '@gmod/gff'\n\nexport function featureData(data: GFF3FeatureLineWithRefs) {\n  const f: Record<string, unknown> = { ...data }\n  ;(f.start as number) -= 1 // convert to interbase\n  if (data.strand === '+') {\n    f.strand = 1\n  } else if (data.strand === '-') {\n    f.strand = -1\n  } else if (data.strand === '.') {\n    f.strand = 0\n  } else {\n    f.strand = undefined\n  }\n  f.phase = data.phase === null ? undefined : Number(data.phase)\n  f.refName = data.seq_id\n  if (data.score === null) {\n    f.score = undefined\n  }\n\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_id',\n    'score',\n    'type',\n    'source',\n    'phase',\n    'strand',\n  ])\n  const dataAttributes = data.attributes || {}\n  for (const a of Object.keys(dataAttributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (dataAttributes[a]) {\n      let attr: string | string[] | undefined = dataAttributes[a]\n      if (Array.isArray(attr) && attr.length === 1) {\n        ;[attr] = attr\n      }\n      f[b] = attr\n    }\n  }\n  f.refName = f.seq_id\n\n  // the SimpleFeature constructor takes care of recursively inflating\n  // subfeatures\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (data.child_features && data.child_features.length > 0) {\n    f.subfeatures = data.child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    )\n  }\n\n  f.child_features = undefined\n  f.data = undefined\n  // delete f.derived_features\n  f.attributes = undefined\n  f.seq_id = undefined\n  return f\n}\n"],"names":["Gff3TabixAdapter","BaseFeatureDataAdapter","constructor","config","getSubAdapter","pluginManager","super","gffGzLocation","readConfObject","indexType","location","dontRedispatch","this","gff","TabixIndexedFile","filehandle","openLocation","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","renameRefSeqs","n","getRefNames","opts","getReferenceSequenceNames","getHeader","getFeatures","query","ObservableCreate","async","metadata","getMetadata","getFeaturesHelper","observer","signal","allowRedispatch","originalQuery","lines","getLines","refName","start","end","line","fileOffset","push","parseLine","columnNumbers","length","minStart","Number","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","forEach","featureType","fields","includes","gff3","map","lineRecord","lineHash","join","parseStringSync","parseFeatures","parseComments","parseDirectives","parseSequences","disableDerivesFromReferences","featureLocs","formatFeatures","f","doesIntersect2","get","next","complete","e","error","split","featureLoc","SimpleFeature","data","featureData","id","attributes","_lineHash","freeResources","strand","phase","seq_id","score","defaultFields","Set","dataAttributes","a","Object","keys","b","toLowerCase","has","attr","Array","isArray","child_features","subfeatures","flatMap","childLocs","childLoc"],"sourceRoot":""}