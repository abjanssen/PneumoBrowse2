{"version":3,"file":"static/js/6391.79b59360.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/CramAdapter/CramSlightlyLazyFeature.ts","../../../plugins/alignments/src/CramAdapter/util.ts","../../../plugins/alignments/src/CramAdapter/CramAdapter.ts"],"sourcesContent":["import { Feature, SimpleFeatureSerialized } from '@jbrowse/core/util'\nimport { CramRecord } from '@gmod/cram'\n\n// locals\nimport CramAdapter from './CramAdapter'\nimport { readFeaturesToCIGAR, readFeaturesToMismatches } from './util'\nimport { cacheGetter } from '../shared/util'\n\nexport default class CramSlightlyLazyFeature implements Feature {\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(\n    private record: CramRecord,\n    private _store: CramAdapter,\n  ) {}\n\n  get name() {\n    return this.record.readName\n  }\n\n  get start() {\n    return this.record.alignmentStart - 1\n  }\n\n  get end() {\n    return this.start + (this.record.lengthOnRef ?? 1)\n  }\n\n  get score() {\n    return this.record.mappingQuality\n  }\n\n  get flags() {\n    return this.record.flags\n  }\n\n  get strand() {\n    return this.record.isReverseComplemented() ? -1 : 1\n  }\n\n  get qual() {\n    return (this.record.qualityScores || []).join(' ')\n  }\n\n  get qualRaw() {\n    return this.record.qualityScores\n  }\n\n  get refName() {\n    return this._store.refIdToName(this.record.sequenceId)!\n  }\n\n  get pair_orientation() {\n    return this.record.isPaired() ? this.record.getPairOrientation() : undefined\n  }\n\n  get template_length() {\n    return this.record.templateLength || this.record.templateSize\n  }\n\n  get next_ref() {\n    return this.record.mate\n      ? this._store.refIdToName(this.record.mate.sequenceId)\n      : undefined\n  }\n\n  get next_segment_position() {\n    return this.record.mate\n      ? `${this._store.refIdToName(this.record.mate.sequenceId)}:${\n          this.record.mate.alignmentStart\n        }`\n      : undefined\n  }\n\n  get is_paired() {\n    return !!this.record.mate\n  }\n\n  get next_pos() {\n    return this.record.mate?.alignmentStart\n  }\n\n  get tags() {\n    const RG = this._store.samHeader.readGroups?.[this.record.readGroupId]\n    return RG !== undefined ? { ...this.record.tags, RG } : this.record.tags\n  }\n\n  get seq() {\n    return this.record.getReadBases()\n  }\n\n  // generate a CIGAR, based on code from jkbonfield\n  get CIGAR() {\n    return readFeaturesToCIGAR(\n      this.record.readFeatures,\n      this.record.alignmentStart,\n      this.record.readLength,\n      this.record._refRegion,\n    )\n  }\n\n  id() {\n    return `${this._store.id}-${this.record.uniqueId}`\n  }\n\n  get(field: string): any {\n    return field === 'mismatches'\n      ? this.mismatches\n      : field === 'qual'\n        ? this.qual\n        : field === 'CIGAR'\n          ? this.CIGAR\n          : this.fields[field]\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  get mismatches() {\n    return readFeaturesToMismatches(\n      this.record.readFeatures,\n      this.start,\n      this.qualRaw,\n    )\n    // this commented code can try to resolve MD tags, xref https://github.com/galaxyproject/tools-iuc/issues/6523#issuecomment-2462927211 but put on hold\n    // return this.tags.MD && this.seq\n    //   ? mismatches.concat(\n    //       mdToMismatches(\n    //         this.tags.MD,\n    //         parseCigar(this.CIGAR),\n    //         mismatches,\n    //         this.seq,\n    //         this.qualRaw,\n    //       ),\n    //     )\n    //   : mismatches\n  }\n\n  get fields(): SimpleFeatureSerialized {\n    return {\n      start: this.start,\n      name: this.name,\n      end: this.end,\n      score: this.score,\n      strand: this.strand,\n      template_length: this.template_length,\n      flags: this.flags,\n      tags: this.tags,\n      refName: this.refName,\n      seq: this.seq,\n      type: 'match',\n      pair_orientation: this.pair_orientation,\n      next_ref: this.next_ref,\n      next_pos: this.next_pos,\n      next_segment_position: this.next_segment_position,\n      uniqueId: this.id(),\n    }\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...this.fields,\n      // lazy\n      CIGAR: this.CIGAR,\n      // lazy\n      qual: this.qual,\n    }\n  }\n}\n\ncacheGetter(CramSlightlyLazyFeature, 'fields')\ncacheGetter(CramSlightlyLazyFeature, 'CIGAR')\ncacheGetter(CramSlightlyLazyFeature, 'mismatches')\n","import { CramRecord } from '@gmod/cram'\nimport { Mismatch } from '../shared/types'\n\ntype ReadFeatures = CramRecord['readFeatures']\n\nexport function readFeaturesToMismatches(\n  readFeatures: ReadFeatures,\n  start: number,\n  qual?: number[] | null,\n) {\n  if (!readFeatures) {\n    return []\n  }\n  const mismatches: Mismatch[] = new Array(readFeatures.length)\n  let j = 0\n  let insLen = 0\n  let refPos = 0\n  let sublen = 0\n  let lastPos = start\n\n  for (const { refPos: p, code, pos, data, sub, ref } of readFeatures) {\n    sublen = refPos - lastPos\n    lastPos = refPos\n\n    if (sublen && insLen > 0) {\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${insLen}`,\n        length: 0,\n      }\n      insLen = 0\n    }\n    refPos = p - 1 - start\n\n    if (code === 'X') {\n      // substitution\n      mismatches[j++] = {\n        start: refPos,\n        length: 1,\n        base: sub!,\n        qual: qual?.[pos - 1],\n        altbase: ref?.toUpperCase(),\n        type: 'mismatch',\n      }\n    } else if (code === 'I') {\n      // insertion\n      mismatches[j++] = {\n        start: refPos,\n        type: 'insertion',\n        base: `${data.length}`,\n        length: 0,\n      }\n    } else if (code === 'N') {\n      // reference skip\n      mismatches[j++] = {\n        type: 'skip',\n        length: data,\n        start: refPos,\n        base: 'N',\n      }\n    } else if (code === 'S') {\n      // soft clip\n      const len = data.length\n      mismatches[j++] = {\n        start: refPos,\n        type: 'softclip',\n        base: `S${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'P') {\n      // padding\n    } else if (code === 'H') {\n      // hard clip\n      const len = data\n      mismatches[j++] = {\n        start: refPos,\n        type: 'hardclip',\n        base: `H${len}`,\n        cliplen: len,\n        length: 1,\n      }\n    } else if (code === 'D') {\n      // deletion\n      mismatches[j++] = {\n        type: 'deletion',\n        length: data,\n        start: refPos,\n        base: '*',\n      }\n    } else if (code === 'b') {\n      // stretch of bases\n    } else if (code === 'q') {\n      // stretch of qual scores\n    } else if (code === 'B') {\n      // a pair of [base, qual]\n    } else if (code === 'i') {\n      // single-base insertion, we collect these if there are multiple in a row\n      // into a single insertion entry\n      insLen++\n    } else if (code === 'Q') {\n      // single quality value\n    }\n  }\n\n  if (sublen && insLen > 0) {\n    mismatches[j++] = {\n      start: refPos,\n      type: 'insertion',\n      base: `${insLen}`,\n      length: 0,\n    }\n    insLen = 0\n  }\n\n  return mismatches.slice(0, j)\n}\n\nexport function readFeaturesToCIGAR(\n  readFeatures: ReadFeatures,\n  alignmentStart: number,\n  readLen: number,\n  refRegion?: { seq: string; start: number },\n) {\n  let seq = ''\n  let cigar = ''\n  let op = 'M'\n  let oplen = 0\n  if (!refRegion) {\n    return ''\n  }\n\n  // not sure I should access these, but...\n  const ref = refRegion.seq\n  const refStart = refRegion.start\n  let lastPos = alignmentStart\n  let sublen = 0\n  let insLen = 0\n  if (readFeatures !== undefined) {\n    for (const { code, refPos, sub, data } of readFeatures) {\n      sublen = refPos - lastPos\n      seq += ref.slice(lastPos - refStart, refPos - refStart)\n      lastPos = refPos\n\n      if (insLen > 0 && sublen) {\n        cigar += `${insLen}I`\n        insLen = 0\n      }\n      if (oplen && op !== 'M') {\n        cigar += `${oplen}${op}`\n        oplen = 0\n      }\n      if (sublen) {\n        op = 'M'\n        oplen += sublen\n      }\n\n      if (code === 'b') {\n        // An array of bases stored verbatim\n        const ret = data.split(',')\n        const added = String.fromCharCode(...ret)\n        seq += added\n        lastPos += added.length\n        oplen += added.length\n      } else if (code === 'B') {\n        // Single base (+ qual score)\n        seq += sub\n        lastPos++\n        oplen++\n      } else if (code === 'X') {\n        // Substitution\n        seq += sub\n        lastPos++\n        oplen++\n      } else if (code === 'D' || code === 'N') {\n        // Deletion or Ref Skip\n        lastPos += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += data + code\n        oplen = 0\n      } else if (code === 'I' || code === 'S') {\n        // Insertion or soft-clip\n        seq += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += data.length + code\n        oplen = 0\n      } else if (code === 'i') {\n        // Single base insertion\n        // seq += data\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        insLen++\n        seq += data\n        oplen = 0\n      } else if (code === 'P') {\n        // Padding\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += `${data}P`\n      } else if (code === 'H') {\n        // Hard clip\n        if (oplen) {\n          cigar += `${oplen}${op}`\n        }\n        cigar += `${data}H`\n        oplen = 0\n      } // else q or Q\n    }\n  } else {\n    sublen = readLen - seq.length\n  }\n  if (seq.length !== readLen) {\n    sublen = readLen - seq.length\n    seq += ref.slice(lastPos - refStart, lastPos - refStart + sublen)\n\n    if (oplen && op !== 'M') {\n      cigar += `${oplen}${op}`\n      oplen = 0\n    }\n    op = 'M'\n    oplen += sublen\n  }\n  if (sublen && insLen > 0) {\n    cigar += `${insLen}I`\n  }\n  if (oplen) {\n    cigar += `${oplen}${op}`\n  }\n\n  return cigar\n}\n","import { CraiIndex, IndexedCramFile, CramRecord } from '@gmod/cram'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\n// jbrowse\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n  BaseSequenceAdapter,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Region, Feature } from '@jbrowse/core/util'\nimport { checkAbortSignal, updateStatus, toLocale } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\n\n// locals\nimport CramSlightlyLazyFeature from './CramSlightlyLazyFeature'\nimport { FilterBy } from '../shared/types'\n\ninterface Header {\n  idToName?: string[]\n  nameToId?: Record<string, number>\n  readGroups?: (string | undefined)[]\n}\n\nexport default class CramAdapter extends BaseFeatureDataAdapter {\n  samHeader: Header = {}\n\n  private setupP?: Promise<{\n    samHeader: Header\n    cram: IndexedCramFile\n    sequenceAdapter: BaseSequenceAdapter\n  }>\n\n  private configureP?: Promise<{\n    cram: IndexedCramFile\n    sequenceAdapter: BaseSequenceAdapter\n  }>\n\n  // used for avoiding re-creation new BamSlightlyLazyFeatures, keeping\n  // mismatches in cache. at an average of 100kb-300kb, keeping even just 500\n  // of these in memory is fairly intensive but can reduce recomputation on\n  // these objects\n  private ultraLongFeatureCache = new QuickLRU<string, Feature>({\n    maxSize: 500,\n  })\n\n  // maps a refname to an id\n  private seqIdToRefName: string[] | undefined\n\n  // maps a seqId to original refname, passed specially to render args, to a seqid\n  private seqIdToOriginalRefName: string[] = []\n\n  public async configurePre() {\n    const cramLocation = this.getConf('cramLocation')\n    const craiLocation = this.getConf('craiLocation')\n    const pm = this.pluginManager\n\n    const cram = new IndexedCramFile({\n      cramFilehandle: openLocation(cramLocation, pm),\n      index: new CraiIndex({ filehandle: openLocation(craiLocation, pm) }),\n      seqFetch: (...args) => this.seqFetch(...args),\n      checkSequenceMD5: false,\n    })\n\n    if (!this.getSubAdapter) {\n      throw new Error('Error getting subadapter')\n    }\n\n    const seqConf = this.getConf('sequenceAdapter')\n    if (!seqConf) {\n      throw new Error('no sequenceAdapter supplied to CramAdapter config')\n    }\n    const subadapter = await this.getSubAdapter(seqConf)\n\n    return {\n      cram,\n      sequenceAdapter: subadapter.dataAdapter as BaseSequenceAdapter,\n    }\n  }\n\n  public async configure() {\n    if (!this.configureP) {\n      this.configureP = this.configurePre().catch((e: unknown) => {\n        this.configureP = undefined\n        throw e\n      })\n    }\n    return this.configureP\n  }\n\n  async getHeader(_opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    return cram.cram.getHeaderText()\n  }\n\n  private async seqFetch(\n    seqId: number,\n    start: number,\n    end: number,\n  ): Promise<string> {\n    start -= 1 // convert from 1-based closed to interbase\n\n    const { sequenceAdapter } = await this.configure()\n    const refName = this.refIdToOriginalName(seqId) || this.refIdToName(seqId)\n    if (!refName) {\n      throw new Error('unknown')\n    }\n\n    const seqChunks = await firstValueFrom(\n      sequenceAdapter\n        .getFeatures({\n          refName,\n          start,\n          end,\n          assemblyName: '',\n        })\n        .pipe(toArray()),\n    )\n\n    const sequence = seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .map(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        return chunkSeq.slice(trimStart, trimStart + trimLength)\n      })\n      .join('')\n\n    const qlen = end - start\n    if (sequence.length !== qlen) {\n      throw new Error(\n        `fetching ${refName}:${toLocale(\n          start - 1,\n        )}-${toLocale(end)} returned ${toLocale(sequence.length)} bases, should have returned ${toLocale(\n          qlen,\n        )}`,\n      )\n    }\n    return sequence\n  }\n\n  private async setupPre(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, async () => {\n      const conf = await this.configure()\n      const { cram } = conf\n      const samHeader = await cram.cram.getSamHeader()\n\n      // use the @SQ lines in the header to figure out the\n      // mapping between ref ID numbers and names\n      const idToName: string[] = []\n      const nameToId: Record<string, number> = {}\n      samHeader\n        .filter(l => l.tag === 'SQ')\n        .forEach((sqLine, refId) => {\n          const SN = sqLine.data.find(item => item.tag === 'SN')\n          if (SN) {\n            const refName = SN.value\n            nameToId[refName] = refId\n            idToName[refId] = refName\n          }\n        })\n\n      const readGroups = samHeader\n        .filter(l => l.tag === 'RG')\n        .map(rgLine => rgLine.data.find(item => item.tag === 'ID')?.value)\n\n      const data = { idToName, nameToId, readGroups }\n      this.samHeader = data\n      return { samHeader: data, ...conf }\n    })\n  }\n\n  private async setup(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { samHeader } = await this.setup(opts)\n    if (!samHeader.idToName) {\n      throw new Error('CRAM file has no header lines')\n    }\n    return samHeader.idToName\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refNameToId(refName: string) {\n    if (this.samHeader.nameToId) {\n      return this.samHeader.nameToId[refName]\n    }\n    if (this.seqIdToRefName) {\n      return this.seqIdToRefName.indexOf(refName)\n    }\n    return undefined\n  }\n\n  // use info from the SAM header if possible, but fall back to using\n  // the ref seq order from when the browser's refseqs were loaded\n  refIdToName(refId: number) {\n    return this.samHeader.idToName?.[refId] || this.seqIdToRefName?.[refId]\n  }\n\n  refIdToOriginalName(refId: number) {\n    return this.seqIdToOriginalRefName[refId]\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: FilterBy\n    },\n  ) {\n    const { signal, filterBy, statusCallback = () => {} } = opts || {}\n    const { refName, start, end, originalRefName } = region\n\n    return ObservableCreate<Feature>(async observer => {\n      const { cram, samHeader } = await this.setup(opts)\n\n      const refId = this.refNameToId(refName)\n      if (refId === undefined) {\n        console.warn('Unknown refName', refName)\n        observer.complete()\n        return\n      }\n\n      if (originalRefName) {\n        this.seqIdToOriginalRefName[refId] = originalRefName\n      }\n      const records = await updateStatus(\n        'Downloading alignments',\n        statusCallback,\n        () => cram.getRecordsForRange(refId, start, end),\n      )\n      checkAbortSignal(signal)\n      await updateStatus('Processing alignments', statusCallback, () => {\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n        } = filterBy || {}\n\n        for (const record of records) {\n          const flags = record.flags\n          if ((flags & flagInclude) !== flagInclude && !(flags & flagExclude)) {\n            continue\n          }\n\n          if (tagFilter) {\n            const readVal =\n              tagFilter.tag === 'RG'\n                ? samHeader.readGroups?.[record.readGroupId]\n                : record.tags[tagFilter.tag]\n            const filterVal = tagFilter.value\n            if (\n              filterVal === '*'\n                ? readVal === undefined\n                : `${readVal}` !== `${filterVal}`\n            ) {\n              continue\n            }\n          }\n\n          if (readName && record.readName !== readName) {\n            continue\n          }\n\n          const ret = this.ultraLongFeatureCache.get(`${record.uniqueId}`)\n          if (!ret) {\n            const elt = this.cramRecordToFeature(record)\n            this.ultraLongFeatureCache.set(`${record.uniqueId}`, elt)\n            observer.next(elt)\n          } else {\n            observer.next(ret)\n          }\n        }\n\n        observer.complete()\n      })\n    }, signal)\n  }\n\n  freeResources(/* { region } */): void {}\n\n  cramRecordToFeature(record: CramRecord) {\n    return new CramSlightlyLazyFeature(record, this)\n  }\n\n  // we return the configured fetchSizeLimit, and the bytes for the region\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const bytes = await this.bytesForRegions(regions, opts)\n    const fetchSizeLimit = this.getConf('fetchSizeLimit')\n    return {\n      bytes,\n      fetchSizeLimit,\n    }\n  }\n\n  /**\n   * get the approximate number of bytes queried from the file for the given\n   * query regions\n   * @param regions - list of query regions\n   */\n  private async bytesForRegions(regions: Region[], _opts?: BaseOptions) {\n    const { cram } = await this.configure()\n    const blockResults = await Promise.all(\n      regions.map(region => {\n        const { refName, start, end } = region\n        const chrId = this.refNameToId(refName)\n        return chrId !== undefined\n          ? cram.index.getEntriesForRange(chrId, start, end)\n          : [{ sliceBytes: 0 }]\n      }),\n    )\n\n    return blockResults.flat().reduce((a, b) => a + b.sliceBytes, 0)\n  }\n}\n"],"names":["CramSlightlyLazyFeature","constructor","record","_store","name","this","readName","start","alignmentStart","end","lengthOnRef","score","mappingQuality","flags","strand","isReverseComplemented","qual","qualityScores","join","qualRaw","refName","refIdToName","sequenceId","pair_orientation","isPaired","getPairOrientation","undefined","template_length","templateLength","templateSize","next_ref","mate","next_segment_position","is_paired","next_pos","tags","RG","samHeader","readGroups","readGroupId","seq","getReadBases","CIGAR","readFeatures","readLen","refRegion","cigar","op","oplen","ref","refStart","lastPos","sublen","insLen","code","refPos","sub","data","slice","ret","split","added","String","fromCharCode","length","readFeaturesToCIGAR","readLength","_refRegion","id","uniqueId","get","field","mismatches","fields","parent","children","Array","j","p","pos","type","base","altbase","toUpperCase","len","cliplen","readFeaturesToMismatches","toJSON","cacheGetter","CramAdapter","BaseFeatureDataAdapter","ultraLongFeatureCache","QuickLRU","maxSize","seqIdToOriginalRefName","configurePre","cramLocation","getConf","craiLocation","pm","pluginManager","cram","IndexedCramFile","cramFilehandle","openLocation","index","CraiIndex","filehandle","seqFetch","args","checkSequenceMD5","getSubAdapter","Error","seqConf","sequenceAdapter","dataAdapter","configure","configureP","catch","e","getHeader","_opts","getHeaderText","seqId","refIdToOriginalName","sequence","firstValueFrom","getFeatures","assemblyName","pipe","toArray","sort","a","b","map","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","qlen","toLocale","setupPre","opts","statusCallback","updateStatus","async","conf","getSamHeader","idToName","nameToId","filter","l","tag","forEach","sqLine","refId","SN","find","item","value","rgLine","setup","setupP","getRefNames","refNameToId","seqIdToRefName","indexOf","region","signal","filterBy","originalRefName","ObservableCreate","console","warn","observer","complete","records","getRecordsForRange","checkAbortSignal","flagInclude","flagExclude","tagFilter","readVal","filterVal","next","elt","cramRecordToFeature","set","freeResources","getMultiRegionFeatureDensityStats","regions","bytes","bytesForRegions","fetchSizeLimit","Promise","all","chrId","getEntriesForRange","sliceBytes","flat","reduce"],"sourceRoot":""}