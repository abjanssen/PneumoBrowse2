{"version":3,"file":"static/js/9409.6512672c.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/MCScanSimpleAnchorsAdapter/MCScanSimpleAnchorsAdapter.ts","../../../plugins/comparative-adapters/src/util.ts","../../../node_modules/@gmod/bgzf-filehandle/src/unzip-pako.ts","../../../node_modules/@gmod/bgzf-filehandle/src/gziIndex.ts","../../../node_modules/@gmod/bgzf-filehandle/src/bgzFilehandle.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { doesIntersect2 } from '@jbrowse/core/util'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { readFile, parseBed } from '../util'\n\ninterface BareFeature {\n  refName: string\n  start: number\n  end: number\n  score: number\n  name: string\n}\n\ntype Row = [\n  BareFeature,\n  BareFeature,\n  BareFeature,\n  BareFeature,\n  number,\n  number,\n  number,\n]\n\nexport default class MCScanAnchorsAdapter extends BaseFeatureDataAdapter {\n  private setupP?: Promise<{\n    assemblyNames: string[]\n    feats: Row[]\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  async setup(opts: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n  async setupPre(opts: BaseOptions) {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    const pm = this.pluginManager\n    const bed1 = openLocation(this.getConf('bed1Location'), pm)\n    const bed2 = openLocation(this.getConf('bed2Location'), pm)\n    const mcscan = openLocation(this.getConf('mcscanSimpleAnchorsLocation'), pm)\n    const [bed1text, bed2text, mcscantext] = await Promise.all(\n      [bed1, bed2, mcscan].map(r => readFile(r, opts)),\n    )\n    const bed1Map = parseBed(bed1text!)\n    const bed2Map = parseBed(bed2text!)\n    const feats = mcscantext!\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f && f !== '###')\n      .map((line, index) => {\n        const [n11, n12, n21, n22, score, strand] = line.split('\\t')\n        const r11 = bed1Map.get(n11)\n        const r12 = bed1Map.get(n12)\n        const r21 = bed2Map.get(n21)\n        const r22 = bed2Map.get(n22)\n        if (!r11 || !r12 || !r21 || !r22) {\n          throw new Error(\n            `feature not found, ${n11} ${n12} ${n21} ${n22} ${r11} ${r12} ${r21} ${r22}`,\n          )\n        }\n        return [\n          r11,\n          r12,\n          r21,\n          r22,\n          +score!,\n          strand === '-' ? -1 : 1,\n          index,\n        ] as Row\n      })\n\n    return {\n      assemblyNames,\n      feats,\n    }\n  }\n\n  async hasDataForRefName() {\n    // determining this properly is basically a call to getFeatures\n    // so is not really that important, and has to be true or else\n    // getFeatures is never called (BaseFeatureDataAdapter filters it out)\n    return true\n  }\n\n  getAssemblyNames() {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    return assemblyNames\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    // @ts-expect-error\n    const r1 = opts.regions?.[0].assemblyName\n    const { feats } = await this.setup(opts)\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    if (idx !== -1) {\n      const set = new Set<string>()\n      for (const feat of feats) {\n        if (idx === 0) {\n          set.add(feat[0].refName)\n          set.add(feat[1].refName)\n        } else {\n          set.add(feat[2].refName)\n          set.add(feat[3].refName)\n        }\n      }\n      return [...set]\n    }\n    console.warn('Unable to do ref renaming on adapter')\n    return []\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { assemblyNames, feats } = await this.setup(opts)\n\n      // The index of the assembly name in the region list corresponds to\n      // the adapter in the subadapters list\n      const index = assemblyNames.indexOf(region.assemblyName)\n      if (index !== -1) {\n        const flip = index === 0\n        feats.forEach(f => {\n          const [f11, f12, f21, f22, score, strand, rowNum] = f\n          let r1 = {\n            refName: f11.refName,\n            start: Math.min(f11.start, f12.start),\n            end: Math.max(f11.end, f12.end),\n          }\n          let r2 = {\n            refName: f21.refName,\n            start: Math.min(f21.start, f22.start),\n            end: Math.max(f21.end, f22.end),\n          }\n          if (!flip) {\n            ;[r2, r1] = [r1, r2]\n          }\n          if (\n            r1.refName === region.refName &&\n            doesIntersect2(r1.start, r1.end, region.start, region.end)\n          ) {\n            observer.next(\n              new SimpleFeature({\n                ...r1,\n                uniqueId: `${rowNum}`,\n                syntenyId: rowNum,\n                assemblyName: assemblyNames[+!flip],\n                score,\n                strand,\n                mate: {\n                  ...r2,\n                  assemblyName: assemblyNames[+flip],\n                },\n              }),\n            )\n          }\n        })\n      }\n\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n  freeResources(/* { region } */): void {}\n}\n","import { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport { isGzip } from '@jbrowse/core/util'\nimport type { Buffer } from 'buffer'\n\nimport { PAFRecord } from './PAFAdapter/util'\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f || f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start!,\n            end: +end!,\n            score: +score!,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  const buffer = (await file.readFile(opts)) as Buffer\n  return new TextDecoder('utf8', { fatal: true }).decode(\n    isGzip(buffer) ? await unzip(buffer) : buffer,\n  )\n}\n\nexport function zip(a: number[], b: number[]) {\n  return a.map((e, i) => [e, b[i]] as [number, number])\n}\n\nconst decoder =\n  typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined\n\nexport function parseLineByLine(\n  buffer: Buffer,\n  cb: (line: string) => PAFRecord,\n) {\n  let blockStart = 0\n  const entries = []\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf('\\n', blockStart)\n    if (n === -1) {\n      break\n    }\n    const b = buffer.subarray(blockStart, n)\n    const line = (decoder?.decode(b) || b.toString()).trim()\n    if (line) {\n      entries.push(cb(line))\n    }\n\n    blockStart = n + 1\n  }\n  return entries\n}\n\nexport function parsePAFLine(line: string) {\n  const [\n    qname,\n    ,\n    qstart,\n    qend,\n    strand,\n    tname,\n    ,\n    tstart,\n    tend,\n    numMatches,\n    blockLen,\n    mappingQual,\n    ...fields\n  ] = line.split('\\t')\n\n  const rest = Object.fromEntries(\n    fields.map(field => {\n      const r = field.indexOf(':')\n      const fieldName = field.slice(0, r)\n      const fieldValue = field.slice(r + 3)\n      return [fieldName, fieldValue]\n    }),\n  )\n\n  return {\n    tname,\n    tstart: +tstart!,\n    tend: +tend!,\n    qname,\n    qstart: +qstart!,\n    qend: +qend!,\n    strand: strand === '-' ? -1 : 1,\n    extra: {\n      numMatches: +numMatches!,\n      blockLen: +blockLen!,\n      mappingQual: +mappingQual!,\n      ...rest,\n    },\n  } as PAFRecord\n}\n\nexport function flipCigar(cigar: string[]) {\n  const arr = []\n  for (let i = cigar.length - 2; i >= 0; i -= 2) {\n    arr.push(cigar[i])\n    const op = cigar[i + 1]\n    if (op === 'D') {\n      arr.push('I')\n    } else if (op === 'I') {\n      arr.push('D')\n    } else {\n      arr.push(op)\n    }\n  }\n  return arr\n}\n\nexport function swapIndelCigar(cigar: string) {\n  return cigar.replaceAll('D', 'K').replaceAll('I', 'D').replaceAll('K', 'I')\n}\n","import { Buffer } from 'buffer'\n//@ts-ignore\nimport { Z_SYNC_FLUSH, Inflate } from 'pako'\n\ninterface VirtualOffset {\n  blockPosition: number\n  dataPosition: number\n}\ninterface Chunk {\n  minv: VirtualOffset\n  maxv: VirtualOffset\n}\n\n// browserify-zlib, which is the zlib shim used by default in webpacked code,\n// does not properly uncompress bgzf chunks that contain more than\n// one bgzf block, so export an unzip function that uses pako directly\n// if we are running in a browser.\nasync function unzip(inputData: Buffer) {\n  try {\n    let strm\n    let pos = 0\n    let i = 0\n    const chunks = []\n    let totalSize = 0\n    let inflator\n    do {\n      const remainingInput = inputData.subarray(pos)\n      inflator = new Inflate()\n      //@ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      pos += strm.next_in\n      chunks[i] = inflator.result as Uint8Array\n      totalSize += chunks[i].length\n      i += 1\n    } while (strm.avail_in)\n\n    const result = new Uint8Array(totalSize)\n    for (let i = 0, offset = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset)\n      offset += chunks[i].length\n    }\n    return Buffer.from(result)\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\n// similar to pakounzip, except it does extra counting\n// to return the positions of compressed and decompressed\n// data offsets\nasync function unzipChunk(inputData: Buffer) {\n  try {\n    let strm\n    let cpos = 0\n    let dpos = 0\n    const blocks = []\n    const cpositions = []\n    const dpositions = []\n    do {\n      const remainingInput = inputData.slice(cpos)\n      const inflator = new Inflate()\n      // @ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      const buffer = Buffer.from(inflator.result)\n      blocks.push(buffer)\n\n      cpositions.push(cpos)\n      dpositions.push(dpos)\n\n      cpos += strm.next_in\n      dpos += buffer.length\n    } while (strm.avail_in)\n\n    const buffer = Buffer.concat(blocks)\n    return { buffer, cpositions, dpositions }\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\n// similar to unzipChunk above but slices (0,minv.dataPosition) and\n// (maxv.dataPosition,end) off\nasync function unzipChunkSlice(inputData: Buffer, chunk: Chunk) {\n  try {\n    let strm\n    const { minv, maxv } = chunk\n    let cpos = minv.blockPosition\n    let dpos = minv.dataPosition\n    const chunks = []\n    const cpositions = []\n    const dpositions = []\n\n    let totalSize = 0\n    let i = 0\n    do {\n      const remainingInput = inputData.subarray(cpos - minv.blockPosition)\n      const inflator = new Inflate()\n      // @ts-ignore\n      ;({ strm } = inflator)\n      inflator.push(remainingInput, Z_SYNC_FLUSH)\n      if (inflator.err) {\n        throw new Error(inflator.msg)\n      }\n\n      const buffer = inflator.result\n      chunks.push(buffer as Uint8Array)\n      let len = buffer.length\n\n      cpositions.push(cpos)\n      dpositions.push(dpos)\n      if (chunks.length === 1 && minv.dataPosition) {\n        // this is the first chunk, trim it\n        chunks[0] = chunks[0].subarray(minv.dataPosition)\n        len = chunks[0].length\n      }\n      const origCpos = cpos\n      cpos += strm.next_in\n      dpos += len\n\n      if (origCpos >= maxv.blockPosition) {\n        // this is the last chunk, trim it and stop decompressing\n        // note if it is the same block is minv it subtracts that already\n        // trimmed part of the slice length\n\n        chunks[i] = chunks[i].subarray(\n          0,\n          maxv.blockPosition === minv.blockPosition\n            ? maxv.dataPosition - minv.dataPosition + 1\n            : maxv.dataPosition + 1,\n        )\n\n        cpositions.push(cpos)\n        dpositions.push(dpos)\n        totalSize += chunks[i].length\n        break\n      }\n      totalSize += chunks[i].length\n      i++\n    } while (strm.avail_in)\n\n    const result = new Uint8Array(totalSize)\n    for (let i = 0, offset = 0; i < chunks.length; i++) {\n      result.set(chunks[i], offset)\n      offset += chunks[i].length\n    }\n    const buffer = Buffer.from(result)\n\n    return { buffer, cpositions, dpositions }\n  } catch (e) {\n    //cleanup error message\n    if (`${e}`.match(/incorrect header check/)) {\n      throw new Error(\n        'problem decompressing block: incorrect gzip header check',\n      )\n    }\n    throw e\n  }\n}\n\nfunction nodeUnzip() {\n  throw new Error('nodeUnzip not implemented.')\n}\n\nexport { unzip, unzipChunk, unzipChunkSlice, unzip as pakoUnzip, nodeUnzip }\n","import Long from 'long'\nimport { Buffer } from 'buffer'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\n// const COMPRESSED_POSITION = 0\nconst UNCOMPRESSED_POSITION = 1\n\nexport default class GziIndex {\n  filehandle: GenericFilehandle\n\n  index?: any\n\n  constructor({\n    filehandle,\n    path,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('either filehandle or path must be defined')\n    }\n  }\n\n  _readLongWithOverflow(buf: Buffer, offset = 0, unsigned = true) {\n    //@ts-ignore\n    const long = Long.fromBytesLE(buf.slice(offset, offset + 8), unsigned)\n    if (\n      long.greaterThan(Number.MAX_SAFE_INTEGER) ||\n      long.lessThan(Number.MIN_SAFE_INTEGER)\n    ) {\n      throw new TypeError('integer overflow')\n    }\n\n    return long.toNumber()\n  }\n\n  _getIndex() {\n    if (!this.index) {\n      this.index = this._readIndex()\n    }\n    return this.index\n  }\n\n  async _readIndex() {\n    let buf = Buffer.allocUnsafe(8)\n    await this.filehandle.read(buf, 0, 8, 0)\n    const numEntries = this._readLongWithOverflow(buf, 0, true)\n    if (!numEntries) {\n      return [[0, 0]]\n    }\n\n    const entries = new Array(numEntries + 1)\n    entries[0] = [0, 0]\n\n    // TODO rewrite this to make an index-index that stays in memory\n    const bufSize = 8 * 2 * numEntries\n    if (bufSize > Number.MAX_SAFE_INTEGER) {\n      throw new TypeError('integer overflow')\n    }\n    buf = Buffer.allocUnsafe(bufSize)\n    await this.filehandle.read(buf, 0, bufSize, 8)\n    for (let entryNumber = 0; entryNumber < numEntries; entryNumber += 1) {\n      const compressedPosition = this._readLongWithOverflow(\n        buf,\n        entryNumber * 16,\n      )\n      const uncompressedPosition = this._readLongWithOverflow(\n        buf,\n        entryNumber * 16 + 8,\n      )\n      entries[entryNumber + 1] = [compressedPosition, uncompressedPosition]\n    }\n\n    return entries\n  }\n\n  async getLastBlock() {\n    const entries = await this._getIndex()\n    if (!entries.length) {\n      return undefined\n    }\n    return entries[entries.length - 1]\n  }\n\n  async getRelevantBlocksForRead(length: number, position: number) {\n    const endPosition = position + length\n    if (length === 0) {\n      return []\n    }\n    const entries = await this._getIndex()\n    const relevant = []\n\n    // binary search to find the block that the\n    // read starts in and extend forward from that\n    const compare = (entry: any, nextEntry: any) => {\n      const uncompressedPosition = entry[UNCOMPRESSED_POSITION]\n      const nextUncompressedPosition = nextEntry\n        ? nextEntry[UNCOMPRESSED_POSITION]\n        : Infinity\n      // block overlaps read start\n      if (\n        uncompressedPosition <= position &&\n        nextUncompressedPosition > position\n      ) {\n        return 0\n        // block is before read start\n      }\n      if (uncompressedPosition < position) {\n        return -1\n      }\n      // block is after read start\n      return 1\n    }\n\n    let lowerBound = 0\n    let upperBound = entries.length - 1\n    let searchPosition = Math.floor(entries.length / 2)\n\n    let comparison = compare(\n      entries[searchPosition],\n      entries[searchPosition + 1],\n    )\n    while (comparison !== 0) {\n      if (comparison > 0) {\n        upperBound = searchPosition - 1\n      } else if (comparison < 0) {\n        lowerBound = searchPosition + 1\n      }\n      searchPosition = Math.ceil((upperBound - lowerBound) / 2) + lowerBound\n      comparison = compare(entries[searchPosition], entries[searchPosition + 1])\n    }\n\n    // here's where we read forward\n    relevant.push(entries[searchPosition])\n    let i = searchPosition + 1\n    for (; i < entries.length; i += 1) {\n      relevant.push(entries[i])\n      if (entries[i][UNCOMPRESSED_POSITION] >= endPosition) {\n        break\n      }\n    }\n    if (relevant[relevant.length - 1][UNCOMPRESSED_POSITION] < endPosition) {\n      relevant.push([])\n    }\n    return relevant\n  }\n}\n","import { Buffer } from 'buffer'\nimport { LocalFile, GenericFilehandle } from 'generic-filehandle'\n\n// locals\nimport { unzip } from './unzip'\nimport GziIndex from './gziIndex'\n\nexport default class BgzFilehandle {\n  filehandle: GenericFilehandle\n  gzi: GziIndex\n\n  constructor({\n    filehandle,\n    path,\n    gziFilehandle,\n    gziPath,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n    gziFilehandle?: GenericFilehandle\n    gziPath?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new TypeError('either filehandle or path must be defined')\n    }\n\n    if (!gziFilehandle && !gziPath && !path) {\n      throw new TypeError('either gziFilehandle or gziPath must be defined')\n    }\n\n    this.gzi = new GziIndex({\n      filehandle: gziFilehandle,\n      path: !gziFilehandle && !gziPath && path ? gziPath : `${path}.gzi`,\n    })\n  }\n\n  async stat() {\n    const compressedStat = await this.filehandle.stat()\n    return Object.assign(compressedStat, {\n      size: await this.getUncompressedFileSize(),\n      blocks: undefined,\n      blksize: undefined,\n    })\n  }\n\n  async getUncompressedFileSize() {\n    // read the last block's ISIZE (see gzip RFC),\n    // and add it to its uncompressedPosition\n    const [, uncompressedPosition] = await this.gzi.getLastBlock()\n\n    const { size } = await this.filehandle.stat()\n\n    const buf = Buffer.allocUnsafe(4)\n    // note: there should be a 28-byte EOF marker (an empty block) at\n    // the end of the file, so we skip backward past that\n    const { bytesRead } = await this.filehandle.read(buf, 0, 4, size - 28 - 4)\n    if (bytesRead !== 4) {\n      throw new Error('read error')\n    }\n    const lastBlockUncompressedSize = buf.readUInt32LE(0)\n    return uncompressedPosition + lastBlockUncompressedSize\n  }\n\n  async _readAndUncompressBlock(\n    blockBuffer: Buffer,\n    [compressedPosition]: [number],\n    [nextCompressedPosition]: [number],\n  ) {\n    let next = nextCompressedPosition\n    if (!next) {\n      next = (await this.filehandle.stat()).size\n    }\n\n    // read the compressed data into the block buffer\n    const blockCompressedLength = next - compressedPosition\n\n    await this.filehandle.read(\n      blockBuffer,\n      0,\n      blockCompressedLength,\n      compressedPosition,\n    )\n\n    // uncompress it\n    const unzippedBuffer = await unzip(\n      blockBuffer.slice(0, blockCompressedLength),\n    )\n\n    return unzippedBuffer as Buffer\n  }\n\n  async read(buf: Buffer, offset: number, length: number, position: number) {\n    // get the block positions for this read\n    const blockPositions = await this.gzi.getRelevantBlocksForRead(\n      length,\n      position,\n    )\n    const blockBuffer = Buffer.allocUnsafe(32768 * 2)\n    // uncompress the blocks and read from them one at a time to keep memory usage down\n    let destinationOffset = offset\n    let bytesRead = 0\n    for (\n      let blockNum = 0;\n      blockNum < blockPositions.length - 1;\n      blockNum += 1\n    ) {\n      // eslint-disable-next-line no-await-in-loop\n      const uncompressedBuffer = await this._readAndUncompressBlock(\n        blockBuffer,\n        blockPositions[blockNum],\n        blockPositions[blockNum + 1],\n      )\n      const [, uncompressedPosition] = blockPositions[blockNum]\n      const sourceOffset =\n        uncompressedPosition >= position ? 0 : position - uncompressedPosition\n      const sourceEnd =\n        Math.min(\n          position + length,\n          uncompressedPosition + uncompressedBuffer.length,\n        ) - uncompressedPosition\n      if (sourceOffset >= 0 && sourceOffset < uncompressedBuffer.length) {\n        uncompressedBuffer.copy(buf, destinationOffset, sourceOffset, sourceEnd)\n        destinationOffset += sourceEnd - sourceOffset\n        bytesRead += sourceEnd - sourceOffset\n      }\n    }\n\n    return { bytesRead, buffer: buf }\n  }\n}\n"],"names":["MCScanAnchorsAdapter","BaseFeatureDataAdapter","setup","opts","this","setupP","setupPre","catch","e","undefined","assemblyNames","getConf","pm","pluginManager","bed1","openLocation","bed2","mcscan","bed1text","bed2text","mcscantext","Promise","all","map","r","readFile","bed1Map","parseBed","bed2Map","feats","split","filter","f","line","index","n11","n12","n21","n22","score","strand","r11","get","r12","r21","r22","Error","hasDataForRefName","getAssemblyNames","getRefNames","r1","regions","assemblyName","idx","indexOf","set","Set","feat","add","refName","console","warn","getFeatures","region","ObservableCreate","async","flip","forEach","f11","f12","f21","f22","rowNum","start","Math","min","end","max","r2","doesIntersect2","observer","next","SimpleFeature","uniqueId","syntenyId","mate","complete","freeResources","text","Map","startsWith","name","file","buffer","TextDecoder","fatal","decode","isGzip","unzip","zip","a","b","i","decoder","parseLineByLine","cb","blockStart","entries","length","n","subarray","toString","trim","push","parsePAFLine","qname","qstart","qend","tname","tstart","tend","numMatches","blockLen","mappingQual","fields","extra","Object","fromEntries","field","slice","flipCigar","cigar","arr","op","swapIndelCigar","replaceAll","inputData","strm","pos","chunks","inflator","totalSize","remainingInput","Inflate","Z_SYNC_FLUSH","err","msg","next_in","result","avail_in","Uint8Array","offset","from","match","unzipChunkSlice","chunk","minv","maxv","cpos","blockPosition","dpos","dataPosition","cpositions","dpositions","len","origCpos","GziIndex","constructor","filehandle","path","TypeError","_readLongWithOverflow","buf","unsigned","long","greaterThan","Number","MAX_SAFE_INTEGER","lessThan","MIN_SAFE_INTEGER","toNumber","_getIndex","_readIndex","allocUnsafe","read","numEntries","Array","bufSize","entryNumber","compressedPosition","uncompressedPosition","getLastBlock","getRelevantBlocksForRead","position","endPosition","relevant","compare","entry","nextEntry","nextUncompressedPosition","Infinity","lowerBound","upperBound","searchPosition","floor","comparison","ceil","BgzFilehandle","gziFilehandle","gziPath","gzi","stat","compressedStat","assign","size","getUncompressedFileSize","blocks","blksize","bytesRead","readUInt32LE","_readAndUncompressBlock","blockBuffer","nextCompressedPosition","blockCompressedLength","blockPositions","destinationOffset","blockNum","uncompressedBuffer","sourceOffset","sourceEnd","copy"],"sourceRoot":""}