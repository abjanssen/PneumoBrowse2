{"version":3,"file":"static/js/6918.d9d9142c.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/wiggle/src/MultiLineRenderer/renderMultiLine.ts","webpack://@jbrowse/web/../../plugins/wiggle/src/drawLine.ts"],"sourcesContent":["import {\n  groupBy,\n  renderToAbstractCanvas,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\nimport { createStopTokenChecker } from '@jbrowse/core/util/stopToken'\n\nimport { drawLine } from '../drawLine.ts'\nimport { serializeWiggleFeature } from '../util.ts'\n\nimport type { MultiRenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderMultiLine(\n  renderProps: MultiRenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    sources,\n    height,\n    regions,\n    bpPerPx,\n    stopToken,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const lastCheck = createStopTokenChecker(stopToken)\n\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx => {\n        const groups = groupBy(features, f => f.get('source'))\n        let feats: Feature[] = []\n        for (const source of sources) {\n          const { reducedFeatures } = drawLine(ctx, {\n            ...renderProps,\n            features: groups[source.name] || [],\n            staticColor: source.color || 'blue',\n            colorCallback: () => '', // unused when staticColor is set\n            lastCheck,\n          })\n          feats = feats.concat(reducedFeatures)\n        }\n        return { reducedFeatures: feats }\n      }),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp } from '@jbrowse/core/util'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { WIGGLE_CLIP_HEIGHT, WIGGLE_FUDGE_FACTOR, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type {\n  Feature,\n  LastStopTokenCheck,\n  Region,\n  StopToken,\n} from '@jbrowse/core/util'\n\nexport function drawLine(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    regions: Region[]\n    bpPerPx: number\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    displayCrossHatches: boolean\n    colorCallback: (f: Feature, score: number) => string\n    config: AnyConfigurationModel\n    offset?: number\n    stopToken?: StopToken\n    lastCheck?: LastStopTokenCheck\n    // when color is static (e.g. in Multi renderers), set strokeStyle once and skip callback\n    staticColor?: string\n  },\n) {\n  const {\n    features,\n    regions,\n    bpPerPx,\n    scaleOpts,\n    height: unadjustedHeight,\n    ticks: { values },\n    displayCrossHatches,\n    colorCallback,\n    config,\n    offset = 0,\n    staticColor,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const regionStart = region.start\n  const regionEnd = region.end\n  const reversed = region.reversed\n  const invBpPerPx = 1 / bpPerPx\n  const width = (regionEnd - regionStart) * invBpPerPx\n\n  const height = unadjustedHeight - offset * 2\n  const clipColor = readConfObject(config, 'clipColor')\n\n  // Use d3-scale only to get the \"niced\" domain, then use simple arithmetic\n  const scale = getScale({ ...scaleOpts, range: [0, height] })\n  const domain = scale.domain() as [number, number]\n  const niceMin = domain[0]\n  const niceMax = domain[1]\n  const domainSpan = niceMax - niceMin\n  const isLog = scaleOpts.scaleType === 'log'\n\n  // Precompute values for linear scale\n  const linearRatio = domainSpan !== 0 ? height / domainSpan : 0\n\n  // Precompute values for log scale (base 2)\n  const log2 = Math.log(2)\n  const logMin = Math.log(niceMin) / log2\n  const logMax = Math.log(niceMax) / log2\n  const logSpan = logMax - logMin\n  const logRatio = logSpan !== 0 ? height / logSpan : 0\n\n  // Simple arithmetic scale function - avoid d3-scale overhead in hot path\n  const toY = isLog\n    ? (n: number) =>\n        clamp(height - (Math.log(n) / log2 - logMin) * logRatio, 0, height) +\n        offset\n    : (n: number) =>\n        clamp(height - (n - niceMin) * linearRatio, 0, height) + offset\n\n  let lastVal: number | undefined\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n\n  // when staticColor is set, batch all path operations into a single stroke\n  if (staticColor) {\n    ctx.beginPath()\n    ctx.strokeStyle = staticColor\n    const clippingFeatures: { leftPx: number; w: number; high: boolean }[] = []\n\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = reversed\n        ? (regionEnd - fEnd) * invBpPerPx\n        : (fStart - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - fStart) * invBpPerPx\n        : (fEnd - regionStart) * invBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      // bitwise OR is faster than Math.floor for positive numbers\n      if ((leftPx | 0) !== (prevLeftPx | 0) || rightPx - leftPx > 1) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      const score = feature.get('score')\n      const scoreY = toY(score)\n\n      // track clipping\n      if (score > niceMax) {\n        clippingFeatures.push({\n          leftPx,\n          w: rightPx - leftPx + WIGGLE_FUDGE_FACTOR,\n          high: true,\n        })\n      } else if (score < niceMin && !isLog) {\n        clippingFeatures.push({\n          leftPx,\n          w: rightPx - leftPx + WIGGLE_FUDGE_FACTOR,\n          high: false,\n        })\n      }\n\n      const startY = lastVal !== undefined ? toY(lastVal) : scoreY\n      if (!reversed) {\n        ctx.moveTo(leftPx, startY)\n        ctx.lineTo(leftPx, scoreY)\n        ctx.lineTo(rightPx, scoreY)\n      } else {\n        ctx.moveTo(rightPx, startY)\n        ctx.lineTo(rightPx, scoreY)\n        ctx.lineTo(leftPx, scoreY)\n      }\n      lastVal = score\n    }\n    // single stroke for entire path\n    ctx.stroke()\n\n    // draw clipping indicators\n    if (clippingFeatures.length > 0) {\n      ctx.fillStyle = clipColor\n      for (const { leftPx, w, high } of clippingFeatures) {\n        if (high) {\n          ctx.fillRect(leftPx, offset, w, WIGGLE_CLIP_HEIGHT)\n        } else {\n          ctx.fillRect(\n            leftPx,\n            height - WIGGLE_CLIP_HEIGHT,\n            w,\n            WIGGLE_CLIP_HEIGHT,\n          )\n        }\n      }\n    }\n  } else {\n    // non-static color: stroke per feature (original behavior)\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = reversed\n        ? (regionEnd - fEnd) * invBpPerPx\n        : (fStart - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - fStart) * invBpPerPx\n        : (fEnd - regionStart) * invBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      // bitwise OR is faster than Math.floor for positive numbers\n      if ((leftPx | 0) !== (prevLeftPx | 0) || rightPx - leftPx > 1) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      const score = feature.get('score')\n      const scoreY = toY(score)\n      const w = rightPx - leftPx + WIGGLE_FUDGE_FACTOR\n\n      const c = colorCallback(feature, score)\n\n      ctx.beginPath()\n      ctx.strokeStyle = c\n      const startY = lastVal !== undefined ? toY(lastVal) : scoreY\n      if (!reversed) {\n        ctx.moveTo(leftPx, startY)\n        ctx.lineTo(leftPx, scoreY)\n        ctx.lineTo(rightPx, scoreY)\n      } else {\n        ctx.moveTo(rightPx, startY)\n        ctx.lineTo(rightPx, scoreY)\n        ctx.lineTo(leftPx, scoreY)\n      }\n      ctx.stroke()\n      lastVal = score\n\n      if (score > niceMax) {\n        ctx.fillStyle = clipColor\n        ctx.fillRect(leftPx, offset, w, WIGGLE_CLIP_HEIGHT)\n      } else if (score < niceMin && !isLog) {\n        ctx.fillStyle = clipColor\n        ctx.fillRect(leftPx, height - WIGGLE_CLIP_HEIGHT, w, WIGGLE_CLIP_HEIGHT)\n      }\n    }\n  }\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    for (const tick of values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n  return {\n    reducedFeatures,\n  }\n}\n"],"names":["async","renderMultiLine","renderProps","features","sources","height","regions","bpPerPx","stopToken","statusCallback","region","width","end","start","lastCheck","createStopTokenChecker","reducedFeatures","rest","updateStatus","renderToAbstractCanvas","ctx","groups","groupBy","f","get","feats","source","drawLine","name","staticColor","color","colorCallback","concat","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables","props","scaleOpts","unadjustedHeight","ticks","values","displayCrossHatches","config","offset","regionStart","regionEnd","reversed","invBpPerPx","clipColor","readConfObject","domain","getScale","range","niceMin","niceMax","domainSpan","isLog","scaleType","linearRatio","log2","Math","log","logMin","logSpan","logRatio","toY","n","clamp","lastVal","prevLeftPx","Number","NEGATIVE_INFINITY","beginPath","strokeStyle","clippingFeatures","feature","checkStopToken2","fStart","fEnd","leftPx","rightPx","push","score","scoreY","w","WIGGLE_FUDGE_FACTOR","high","startY","undefined","moveTo","lineTo","stroke","length","fillStyle","fillRect","WIGGLE_CLIP_HEIGHT","c","lineWidth","tick","round"],"sourceRoot":""}