{"version":3,"file":"static/js/5222.7f81ba7f.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/variants/src/VcfFeature/index.ts","webpack://@jbrowse/web/../../plugins/variants/src/VcfFeature/util.ts","webpack://@jbrowse/web/../../plugins/variants/src/VcfTabixAdapter/VcfTabixAdapter.ts"],"sourcesContent":["import { type Feature, max } from '@jbrowse/core/util'\n\nimport { getSOTermAndDescription } from './util.ts'\n\nimport type VCFParser from '@gmod/vcf'\nimport type { GenotypeCallback, Variant } from '@gmod/vcf'\n\ntype FeatureData = ReturnType<typeof dataFromVariant>\n\nfunction dataFromVariant(variant: Variant, parser: VCFParser) {\n  const { REF = '', ALT, POS, CHROM, ID } = variant\n  const start = POS - 1\n  const [type, description] = getSOTermAndDescription(REF, ALT, parser)\n\n  return {\n    refName: CHROM,\n    start,\n    end: getEnd(variant),\n    description,\n    type,\n    name: ID?.join(','),\n  }\n}\nfunction getEnd(variant: Variant) {\n  const { POS, REF = '', ALT = [] } = variant\n  const start = POS - 1\n  let isTRA = false\n  let isSymbolic = false\n  for (const a of ALT) {\n    if (a.includes('<')) {\n      isSymbolic = true\n      if (a === '<TRA>') {\n        isTRA = true\n        break\n      }\n    }\n  }\n  if (isSymbolic) {\n    const info = variant.INFO\n    if (info.END && !isTRA) {\n      return +(info.END as string[])[0]!\n    }\n    const lens = []\n    if (info.SVLEN && !isTRA) {\n      const svlens = info.SVLEN as string[]\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let i = 0; i < svlens.length; i++) {\n        const svlen = svlens[i]!\n        if (ALT[i]?.startsWith('<INS')) {\n          lens.push(1)\n        } else {\n          lens.push(Math.abs(+svlen))\n        }\n      }\n      return start + max(lens)\n    }\n  }\n  return start + REF.length\n}\n\nexport default class VCFFeature implements Feature {\n  private variant: Variant\n\n  private parser: VCFParser\n\n  private data: FeatureData\n\n  private _id: string\n\n  constructor(args: { variant: Variant; parser: VCFParser; id: string }) {\n    this.variant = args.variant\n    this.parser = args.parser\n    this.data = dataFromVariant(this.variant, this.parser)\n    this._id = args.id\n  }\n\n  get(field: string): any {\n    return field === 'samples'\n      ? this.variant.SAMPLES()\n      : field === 'genotypes'\n        ? this.variant.GENOTYPES()\n        : (this.data[field as keyof typeof this.data] ??\n          this.variant[field as keyof typeof this.variant])\n  }\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  id() {\n    return this._id\n  }\n\n  processGenotypes(callback: GenotypeCallback) {\n    this.variant.processGenotypes(callback)\n  }\n\n  toJSON(): any {\n    return {\n      uniqueId: this._id,\n      ...this.variant.toJSON(),\n      ...this.data,\n      samples: this.variant.SAMPLES(),\n    }\n  }\n}\n","import { parseBreakend } from '@gmod/vcf'\nimport { getBpDisplayStr } from '@jbrowse/core/util'\n\nimport type VCF from '@gmod/vcf'\n\nconst genotypeDelimRegex = /[/|]/\n\nfunction isBreakend(alt: string) {\n  return (\n    alt.includes('[') ||\n    alt.includes(']') ||\n    alt.startsWith('.') ||\n    alt.endsWith('.')\n  )\n}\n\nfunction isSymbolic(alt: string) {\n  return alt.startsWith('<') || isBreakend(alt)\n}\n\nfunction isInversion(ref: string, alt: string) {\n  return ref.split('').reverse().join('') === alt\n}\n\nconst altTypeToSO: Record<string, string> = {\n  '<DEL>': 'deletion',\n  '<INS>': 'insertion',\n  '<DUP>': 'duplication',\n  '<INV>': 'inversion',\n  '<INVDUP>': 'inverted_duplication',\n  '<CNV>': 'copy_number_variation',\n  '<TRA>': 'translocation',\n  '<DUP:TANDEM>': 'tandem_duplication',\n  '<NON_REF>': 'sequence_variant',\n  '<*>': 'sequence_variant',\n}\n\nexport function getSOTermAndDescription(\n  ref: string,\n  alt: string[] | undefined,\n  parser: VCF,\n): string[] {\n  if (!alt || alt.length === 0) {\n    return ['remark', 'no alternative alleles']\n  }\n\n  const soTerms = alt.map(a => getSOTerm(a, ref, parser))\n  const uniqueSoTerms = [...new Set(soTerms)]\n  const description = formatGroupDescription(ref, alt)\n\n  return [uniqueSoTerms.join(','), description]\n}\n\nfunction getSOTerm(alt: string, ref: string, parser: VCF): string {\n  // Symbolic alleles\n  if (alt.startsWith('<')) {\n    return findSOTerm(alt, parser) ?? 'variant'\n  }\n\n  // Breakends\n  if (isBreakend(alt) && parseBreakend(alt)) {\n    return 'breakend'\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n\n  if (lenRef === 1 && lenAlt === 1) {\n    return 'SNV'\n  } else if (lenRef === lenAlt) {\n    return isInversion(ref, alt) ? 'inversion' : 'substitution'\n  } else {\n    return lenRef < lenAlt ? 'insertion' : 'deletion'\n  }\n}\n\nfunction formatGroupDescription(ref: string, alts: string[]): string {\n  if (alts.every(isSymbolic)) {\n    return alts.join(',')\n  }\n\n  const lenRef = ref.length\n\n  return `${ref.length > 10 ? getBpDisplayStr(lenRef) : ref} -> ${alts.map(a => (a.length > 10 ? getBpDisplayStr(a.length) : a)).join(',')}`\n}\n\nfunction findSOTerm(alt: string, parser: VCF): string | undefined {\n  if (altTypeToSO[alt]) {\n    return altTypeToSO[alt]\n  }\n  if (parser.getMetadata('ALT', alt)) {\n    return 'sequence_variant'\n  }\n  // Try parent term by stripping last component, e.g. '<INS:ME>' -> '<INS>'\n  const parts = alt.slice(1, -1).split(':')\n  return parts.length > 1\n    ? findSOTerm(`<${parts.slice(0, -1).join(':')}>`, parser)\n    : undefined\n}\n\nexport function getSOAndDescFromAltDefs(alt: string, parser: VCF): string[] {\n  if (!alt.startsWith('<')) {\n    return []\n  }\n\n  const soTerm = findSOTerm(alt, parser)\n  return [soTerm ?? 'variant', alt]\n}\n\nexport function getMinimalDesc(ref: string, alt: string) {\n  if (isSymbolic(alt) || (ref.length === 1 && alt.length === 1)) {\n    return alt\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n  const isLong = lenRef > 5 || lenAlt > 5\n\n  return isLong\n    ? `${getBpDisplayStr(lenRef)} -> ${getBpDisplayStr(lenAlt)}`\n    : `${ref} -> ${alt}`\n}\n\nexport function makeSimpleAltString(\n  genotype: string,\n  ref: string,\n  alt: string[],\n) {\n  return genotype\n    .split(genotypeDelimRegex)\n    .map(r =>\n      r === '.'\n        ? '.'\n        : +r === 0\n          ? `ref(${ref.length < 10 ? ref : getBpDisplayStr(ref.length)})`\n          : getMinimalDesc(ref, alt[+r - 1] || ''),\n    )\n    .join(genotype.includes('|') ? '|' : '/')\n}\n","import { TabixIndexedFile } from '@gmod/tabix'\nimport VcfParser from '@gmod/vcf'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  fetchAndMaybeUnzipText,\n  shorten2,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport VcfFeature from '../VcfFeature/index.ts'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { NoAssemblyRegion } from '@jbrowse/core/util/types'\n\nexport default class VcfTabixAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames', 'exportData']\n\n  private configured?: Promise<{\n    vcf: TabixIndexedFile\n    parser: VcfParser\n  }>\n\n  private async configurePre(_opts?: BaseOptions) {\n    const vcfGzLocation = this.getConf('vcfGzLocation')\n    const location = this.getConf(['index', 'location'])\n    const indexType = this.getConf(['index', 'indexType'])\n\n    const filehandle = openLocation(vcfGzLocation, this.pluginManager)\n    const isCSI = indexType === 'CSI'\n    const vcf = new TabixIndexedFile({\n      filehandle,\n      csiFilehandle: isCSI\n        ? openLocation(location, this.pluginManager)\n        : undefined,\n      tbiFilehandle: !isCSI\n        ? openLocation(location, this.pluginManager)\n        : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n\n    return {\n      vcf,\n      parser: new VcfParser({\n        header: await vcf.getHeader(),\n      }),\n    }\n  }\n\n  protected async configurePre2() {\n    if (!this.configured) {\n      this.configured = this.configurePre().catch((e: unknown) => {\n        this.configured = undefined\n        throw e\n      })\n    }\n    return this.configured\n  }\n\n  async configure(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, () =>\n      this.configurePre2(),\n    )\n  }\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { vcf } = await this.configure(opts)\n    return vcf.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { vcf } = await this.configure(opts)\n    return vcf.getHeader()\n  }\n\n  async getMetadata(opts?: BaseOptions) {\n    const { parser } = await this.configure(opts)\n    return parser.getMetadata()\n  }\n\n  public async getExportData(\n    regions: NoAssemblyRegion[],\n    formatType: string,\n    opts?: BaseOptions,\n  ): Promise<string | undefined> {\n    if (formatType !== 'vcf') {\n      return undefined\n    }\n\n    const { statusCallback = () => {} } = opts || {}\n    const { vcf } = await this.configure(opts)\n    const headerText = await vcf.getHeader()\n    const exportLines: string[] = headerText.split('\\n').filter(Boolean)\n\n    for (const region of regions) {\n      const { refName, start, end } = region\n      const regionLines: string[] = []\n\n      await updateStatus('Exporting variants', statusCallback, () =>\n        vcf.getLines(refName, start, end, {\n          lineCallback: (line: string) => {\n            regionLines.push(line)\n          },\n          ...opts,\n        }),\n      )\n\n      for (const line of regionLines) {\n        exportLines.push(line)\n      }\n    }\n\n    return exportLines.join('\\n')\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { refName, start, end } = query\n      const { statusCallback = () => {} } = opts\n      const { vcf, parser } = await this.configure(opts)\n\n      await updateStatus('Downloading variants', statusCallback, () =>\n        vcf.getLines(refName, start, end, {\n          lineCallback: (line, fileOffset) => {\n            observer.next(\n              new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-vcf-${fileOffset}`,\n              }),\n            )\n          },\n          ...opts,\n        }),\n      )\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  async getSources() {\n    const conf = this.getConf('samplesTsvLocation')\n    if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n      const { parser } = await this.configure()\n      return parser.samples.map(name => ({\n        name,\n      }))\n    } else {\n      const txt = await fetchAndMaybeUnzipText(\n        openLocation(conf, this.pluginManager),\n      )\n      const lines = txt.split(/\\n|\\r\\n|\\r/)\n      const header = lines[0]!.split('\\t')\n      const { parser } = await this.configure()\n      const metadataLines = lines\n        .slice(1)\n        .filter(Boolean)\n        .map(line => {\n          const [name, ...rest] = line.split('\\t')\n          return {\n            ...Object.fromEntries(\n              // force col 0 to be called name\n              header.slice(1).map((c, idx) => [c, rest[idx] || ''] as const),\n            ),\n            name: name!,\n          }\n        })\n      const vcfSampleSet = new Set(parser.samples)\n      const metadataSet = new Set(metadataLines.map(r => r.name))\n      const metadataNotInVcfSamples = [...metadataSet].filter(\n        f => !vcfSampleSet.has(f),\n      )\n      const vcfSamplesNotInMetadata = [...vcfSampleSet].filter(\n        f => !metadataSet.has(f),\n      )\n      if (metadataNotInVcfSamples.length) {\n        console.warn(\n          `There are ${metadataNotInVcfSamples.length} samples in metadata file (${metadataLines.length} lines) not in VCF (${parser.samples.length} samples):`,\n          shorten2(metadataNotInVcfSamples.join(',')),\n        )\n      }\n      if (vcfSamplesNotInMetadata.length) {\n        console.warn(\n          `There are ${vcfSamplesNotInMetadata.length} samples in VCF file (${parser.samples.length} samples) not in metadata file (${metadataLines.length} lines):`,\n          shorten2(vcfSamplesNotInMetadata.join(',')),\n        )\n      }\n      return metadataLines.filter(f => vcfSampleSet.has(f.name))\n    }\n  }\n}\n"],"names":["getEnd","variant","POS","REF","ALT","start","isTRA","isSymbolic","a","includes","info","INFO","END","lens","SVLEN","svlens","i","length","svlen","startsWith","push","Math","abs","max","VCFFeature","constructor","args","this","parser","data","CHROM","ID","type","description","getSOTermAndDescription","refName","end","name","join","dataFromVariant","_id","id","get","field","SAMPLES","GENOTYPES","parent","children","processGenotypes","callback","toJSON","uniqueId","samples","genotypeDelimRegex","isBreakend","alt","endsWith","altTypeToSO","ref","soTerms","map","findSOTerm","parseBreakend","lenRef","lenAlt","split","reverse","isInversion","getSOTerm","uniqueSoTerms","Set","alts","every","getBpDisplayStr","formatGroupDescription","getMetadata","parts","slice","undefined","getMinimalDesc","makeSimpleAltString","genotype","r","VcfTabixAdapter","BaseFeatureDataAdapter","configurePre","_opts","vcfGzLocation","getConf","location","indexType","filehandle","openLocation","pluginManager","isCSI","vcf","TabixIndexedFile","csiFilehandle","tbiFilehandle","chunkCacheSize","VcfParser","header","getHeader","configurePre2","configured","catch","e","configure","opts","statusCallback","updateStatus","getRefNames","getReferenceSequenceNames","getExportData","regions","formatType","exportLines","filter","Boolean","region","regionLines","getLines","lineCallback","line","getFeatures","query","ObservableCreate","async","fileOffset","observer","next","VcfFeature","parseLine","complete","stopToken","getSources","conf","uri","lines","fetchAndMaybeUnzipText","metadataLines","rest","Object","fromEntries","c","idx","vcfSampleSet","metadataSet","metadataNotInVcfSamples","f","has","vcfSamplesNotInMetadata","console","warn","shorten2"],"sourceRoot":""}