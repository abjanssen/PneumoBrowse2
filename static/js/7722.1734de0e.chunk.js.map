{"version":3,"file":"static/js/7722.1734de0e.chunk.js","mappings":"sOAYO,SAASA,EAA4BC,IAW1CC,EAAAA,EAAAA,aACED,GACAE,EAAAA,EAAAA,UACEC,UACE,IACE,MAAMC,GAAOC,EAAAA,EAAAA,mBAAkBL,GACzBM,EAAU,IAAIC,gBAGpB,GAFAP,EAAKQ,gBAAgBF,IAEhBN,EAAKS,uBACR,OAGF,MAAMC,EAAcC,KAAKC,UAAUR,EAAKS,eAClCC,QC3BTX,eACLH,EAMAe,GAOA,MAAM,WAAEC,IAAeC,EAAAA,EAAAA,YAAWjB,GAC5BkB,GAAYC,EAAAA,EAAAA,SAAQnB,EAAM,cAAgB,GAC1C,cAAEoB,EAAa,cAAEC,GAAkBrB,EACnCsB,GAAYC,EAAAA,EAAAA,iBAAgBvB,IAC5B,iBAAEwB,GAAqBT,EACvBU,EAAS,CACbH,YACAF,gBACAM,eAAiBC,KACXC,EAAAA,EAAAA,SAAQ5B,IACVA,EAAK6B,WAAWF,EAClB,KAECZ,GAGL,GAAsB,WAAlBM,GAAgD,aAAlBA,EAA8B,CAC9D,MAAMS,QAAiBd,EAAWe,KAChCT,EACA,mCACAG,IAEI,SAAEO,EAAQ,UAAEC,EAAS,YAAEC,GAAgBJ,EAK7C,MAAyB,aAAlBT,EACH,IACKS,EACHE,SAAUA,GAAY,EAAI,EAAIC,EAAYf,EAAYgB,EACtDC,SAAUF,EAAYf,EAAYgB,EAClCV,oBAEF,IACKM,EACHN,mBAER,CACA,GAAsB,UAAlBH,GAA+C,YAAlBA,EAA6B,CAC5D,MAAM,cAAER,EAAa,QAAEuB,IAAY/B,EAAAA,EAAAA,mBAAkBL,GAC/C8B,QAAiBd,EAAWe,KAChCT,EACA,wCACA,IACKG,EACHY,QAASxB,EAAcyB,cAAcC,KAAIC,IACvC,MAAM,MAAEC,EAAK,IAAEC,GAAQF,EACvB,MAAO,IACF7B,KAAKgC,MAAMhC,KAAKC,UAAU4B,IAC7BC,MAAOG,KAAKC,MAAMJ,GAClBC,IAAKE,KAAKE,KAAKJ,GAChB,IAEHN,aAGE,SAAEJ,EAAQ,UAAEC,EAAS,YAAEC,GAAgBJ,EAK7C,MAAyB,YAAlBT,EACH,IACKS,EACHE,SAAUA,GAAY,EAAI,EAAIC,EAAYf,EAAYgB,EACtDC,SAAUF,EAAYf,EAAYgB,EAClCV,oBAEF,IACKM,EACHN,mBAER,CACA,GAAsB,WAAlBH,EACF,OAAOL,EAAWe,KAChBT,EACA,mCACAG,GAGJ,MAAM,IAAIsB,MAAM,0BAA0B1B,KAC5C,CDrEoC2B,CAAqBhD,EAAM,CACnDiD,OAAQ3C,EAAQ2C,OAChBC,QAAS,GACT1B,iBAAkBpB,EAAKgC,WACpBpC,EAAKmD,kBAGNvB,EAAAA,EAAAA,SAAQ5B,IACVA,EAAKoD,wBAAwBtC,EAAaJ,EAE9C,CAAE,MAAO2C,GACPC,QAAQC,MAAMF,KACTG,EAAAA,EAAAA,kBAAiBH,KAAMzB,EAAAA,EAAAA,SAAQ5B,IAClCA,EAAKyD,SAASJ,EAElB,IAEF,CAAEK,MAAO,MAGf,C","sources":["../../../plugins/wiggle/src/getQuantitativeStatsAutorun.ts","../../../plugins/wiggle/src/getQuantitativeStats.ts"],"sourcesContent":["import { autorun } from 'mobx'\nimport { addDisposer, isAlive } from 'mobx-state-tree'\n// jbrowse\nimport { isAbortException, getContainingView } from '@jbrowse/core/util'\nimport { QuantitativeStats } from '@jbrowse/core/util/stats'\nimport { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration'\n// locals\nimport { getQuantitativeStats } from './getQuantitativeStats'\n\ntype LGV = LinearGenomeViewModel\n\nexport function getQuantitativeStatsAutorun(self: {\n  quantitativeStatsReady: boolean\n  configuration: AnyConfigurationModel\n  adapterConfig: AnyConfigurationModel\n  autoscaleType: string\n  adapterProps: () => Record<string, unknown>\n  setStatsLoading: (aborter: AbortController) => void\n  setError: (error: unknown) => void\n  setMessage: (str: string) => void\n  updateQuantitativeStats: (stats: QuantitativeStats, region: string) => void\n}) {\n  addDisposer(\n    self,\n    autorun(\n      async () => {\n        try {\n          const view = getContainingView(self) as LGV\n          const aborter = new AbortController()\n          self.setStatsLoading(aborter)\n\n          if (!self.quantitativeStatsReady) {\n            return\n          }\n\n          const statsRegion = JSON.stringify(view.dynamicBlocks)\n          const wiggleStats = await getQuantitativeStats(self, {\n            signal: aborter.signal,\n            filters: [],\n            currStatsBpPerPx: view.bpPerPx,\n            ...self.adapterProps(),\n          })\n\n          if (isAlive(self)) {\n            self.updateQuantitativeStats(wiggleStats, statsRegion)\n          }\n        } catch (e) {\n          console.error(e)\n          if (!isAbortException(e) && isAlive(self)) {\n            self.setError(e)\n          }\n        }\n      },\n      { delay: 1000 },\n    ),\n  )\n}\n","import { isAlive } from 'mobx-state-tree'\n// jbrowse\nimport { getSession, getContainingView } from '@jbrowse/core/util'\nimport { QuantitativeStats } from '@jbrowse/core/util/stats'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\nimport { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\nimport { AnyConfigurationModel, getConf } from '@jbrowse/core/configuration'\n\ntype LGV = LinearGenomeViewModel\n\nexport async function getQuantitativeStats(\n  self: {\n    adapterConfig: AnyConfigurationModel\n    configuration: AnyConfigurationModel\n    autoscaleType: string\n    setMessage: (str: string) => void\n  },\n  opts: {\n    headers?: Record<string, string>\n    signal?: AbortSignal\n    filters: string[]\n    currStatsBpPerPx: number\n  },\n): Promise<QuantitativeStats> {\n  const { rpcManager } = getSession(self)\n  const numStdDev = getConf(self, 'numStdDev') || 3\n  const { adapterConfig, autoscaleType } = self\n  const sessionId = getRpcSessionId(self)\n  const { currStatsBpPerPx } = opts\n  const params = {\n    sessionId,\n    adapterConfig,\n    statusCallback: (message: string) => {\n      if (isAlive(self)) {\n        self.setMessage(message)\n      }\n    },\n    ...opts,\n  }\n\n  if (autoscaleType === 'global' || autoscaleType === 'globalsd') {\n    const results = (await rpcManager.call(\n      sessionId,\n      'WiggleGetGlobalQuantitativeStats',\n      params,\n    )) as QuantitativeStats\n    const { scoreMin, scoreMean, scoreStdDev } = results\n    // globalsd uses heuristic to avoid unnecessary scoreMin<0\n    //\n    // if the scoreMin is never less than 0 helps with most coverage bigwigs\n    // just being >0\n    return autoscaleType === 'globalsd'\n      ? {\n          ...results,\n          scoreMin: scoreMin >= 0 ? 0 : scoreMean - numStdDev * scoreStdDev,\n          scoreMax: scoreMean + numStdDev * scoreStdDev,\n          currStatsBpPerPx,\n        }\n      : {\n          ...results,\n          currStatsBpPerPx,\n        }\n  }\n  if (autoscaleType === 'local' || autoscaleType === 'localsd') {\n    const { dynamicBlocks, bpPerPx } = getContainingView(self) as LGV\n    const results = (await rpcManager.call(\n      sessionId,\n      'WiggleGetMultiRegionQuantitativeStats',\n      {\n        ...params,\n        regions: dynamicBlocks.contentBlocks.map(region => {\n          const { start, end } = region\n          return {\n            ...JSON.parse(JSON.stringify(region)),\n            start: Math.floor(start),\n            end: Math.ceil(end),\n          }\n        }),\n        bpPerPx,\n      },\n    )) as QuantitativeStats\n    const { scoreMin, scoreMean, scoreStdDev } = results\n\n    // localsd uses heuristic to avoid unnecessary scoreMin<0 if the\n    // scoreMin is never less than 0 helps with most coverage bigwigs\n    // just being >0\n    return autoscaleType === 'localsd'\n      ? {\n          ...results,\n          scoreMin: scoreMin >= 0 ? 0 : scoreMean - numStdDev * scoreStdDev,\n          scoreMax: scoreMean + numStdDev * scoreStdDev,\n          currStatsBpPerPx,\n        }\n      : {\n          ...results,\n          currStatsBpPerPx,\n        }\n  }\n  if (autoscaleType === 'zscale') {\n    return rpcManager.call(\n      sessionId,\n      'WiggleGetGlobalQuantitativeStats',\n      params,\n    ) as Promise<QuantitativeStats>\n  }\n  throw new Error(`invalid autoscaleType '${autoscaleType}'`)\n}\n"],"names":["getQuantitativeStatsAutorun","self","addDisposer","autorun","async","view","getContainingView","aborter","AbortController","setStatsLoading","quantitativeStatsReady","statsRegion","JSON","stringify","dynamicBlocks","wiggleStats","opts","rpcManager","getSession","numStdDev","getConf","adapterConfig","autoscaleType","sessionId","getRpcSessionId","currStatsBpPerPx","params","statusCallback","message","isAlive","setMessage","results","call","scoreMin","scoreMean","scoreStdDev","scoreMax","bpPerPx","regions","contentBlocks","map","region","start","end","parse","Math","floor","ceil","Error","getQuantitativeStats","signal","filters","adapterProps","updateQuantitativeStats","e","console","error","isAbortException","setError","delay"],"sourceRoot":""}