{"version":3,"file":"static/js/8937.fde3f3a5.chunk.js","mappings":"0OAsDO,SAASA,GAGd,KAAEC,EAAI,cAAEC,EAAa,aAAEC,EAAY,SAAEC,IACrC,OAAOC,UACL,MAAMC,GAAOC,EAAAA,EAAAA,mBAAkBN,GAE/B,IACGK,EAAKE,aACNP,EAAKQ,QACJR,EAAKS,6CAEN,OAGF,MAAM,QAAEC,GAAYL,EAEpB,IACE,MAAMM,GAAUC,EAAAA,EAAAA,YAAWZ,IACrB,WAAEa,EAAU,gBAAEC,GAAoBH,EAClCI,EAAeV,EAAKW,cAAc,GACxC,IAAKD,EACH,OAGF,MAAME,EAAWH,EAAgBI,IAAIH,GAC/BI,EAAwBF,GAAUG,eAAeC,UAAUC,QAC3DC,EAAkBJ,GACpBK,EAAAA,EAAAA,aAAYL,QACZM,EAEEC,GAAgBC,EAAAA,EAAAA,WAAU,IAAM3B,EAAK4B,oBACvCF,IACFG,EAAAA,EAAAA,IAAcH,GAGhB,MAAMI,GAAYC,EAAAA,EAAAA,MAClB/B,EAAKgC,sBAAsBF,GAC3B9B,EAAKiC,YAAW,GAChBjC,EAAKkC,kBAAiB,GAEtB,MAAMC,EAAe,CACnBC,iBAAkBC,gBAAgBhC,EAAK+B,kBACvC1B,QAASL,EAAKK,QACd4B,SAAUjC,EAAKiC,SACfC,wBAAyBlC,EAAKkC,wBAC9BC,kBAAmBnC,EAAKmC,kBACxBC,MAAOpC,EAAKoC,OAGRC,GAAYC,EAAAA,EAAAA,iBAAgB3C,GAC5B4C,EAAgB5C,EAAK4C,cACrBC,GAASrB,EAAAA,EAAAA,aAAYxB,EAAKoB,eAC1B0B,QAAgBjC,EAAWkC,KAAKL,EAAWzC,EAAe,CAC9DyC,YACArC,KAAM8B,EACNS,gBACArB,kBACAsB,SACAG,eAAiBC,KACXC,EAAAA,EAAAA,SAAQlD,IACVA,EAAKmD,mBAAmBF,IAG5BnB,eACG5B,EAAa,CAAEG,OAAMM,UAASY,kBAAiBO,gBAGhDgB,EAAOM,YACTpD,EAAKqD,sBAAsBP,EAAOM,gBACV3B,IAApBqB,EAAOR,UACTtC,EAAKsD,qBAAqBR,EAAOR,UAEnCnC,EAAS2C,IAGX9C,EAAKuD,oBAAoB7C,EAC3B,CAAE,MAAOF,IACFgD,EAAAA,EAAAA,IAAiBhD,KACpBiD,QAAQjD,MAAMA,GACdR,EAAK0D,SAASlD,GAElB,CAAE,QACAR,EAAKgC,2BAAsBP,GAC3BzB,EAAKiC,YAAW,EAClB,EAEJ,CAEO,SAAS0B,EACd3D,IAEA4D,EAAAA,EAAAA,IACE5D,EACAI,UACE,MAAMyD,GAAUC,EAAAA,EAAAA,IAAoB9D,EAAK+D,IAAK/D,EAAKgE,qBAC/Cd,EAAAA,EAAAA,SAAQlD,IACVA,EAAKkC,iBAAiB2B,IAG1B,CACEI,KAAM,uBAGZ,C,oFCpJO,SAASC,EAAiBlE,GAC/B,MAAMmE,GAAgBpE,EAAAA,EAAAA,GAAwB,CAC5CC,OACAC,cAAe,8BACfC,aAAcA,IAAMF,EAAKoE,cACzBjE,SAAUA,UAGZyD,EAAAA,EAAAA,IACE5D,EACAI,WACO8C,EAAAA,EAAAA,SAAQlD,IAIbmE,KAEF,CACEE,MAAO,IACPJ,KAAM,mBAIVN,EAAAA,EAAAA,GAA4B3D,EAC9B,C","sources":["../../../plugins/alignments/src/shared/createRPCRenderingSetup.ts","../../../plugins/alignments/src/LinearReadArcsDisplay/afterAttachRPC.tsx"],"sourcesContent":["import {\n  getContainingView,\n  getSession,\n  isAbortException,\n} from '@jbrowse/core/util'\nimport { createStopToken, stopStopToken } from '@jbrowse/core/util/stopToken'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\nimport { getSnapshot, isAlive } from '@jbrowse/mobx-state-tree'\nimport { drawCanvasImageData } from '@jbrowse/plugin-linear-genome-view'\nimport { untracked } from 'mobx'\n\nimport { createAutorun } from '../util.ts'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface RPCRenderableModel {\n  id: string\n  error: unknown\n  featureDensityStatsReadyAndRegionNotTooLarge: boolean\n  effectiveRpcDriverName: string\n  adapterConfig: unknown\n  configuration: AnyConfigurationModel\n  renderingStopToken?: StopToken\n  setRenderingStopToken: (token?: StopToken) => void\n  setLoading: (loading: boolean) => void\n  setError: (error: unknown) => void\n  setRenderingImageData: (imageData: ImageBitmap | undefined) => void\n  setLastDrawnOffsetPx: (offsetPx: number) => void\n  setLastDrawnBpPerPx: (bpPerPx: number) => void\n  ref: HTMLCanvasElement | null\n  renderingImageData?: ImageBitmap\n  setStatusMessage?: (msg: string) => void\n  setCanvasDrawn?: (drawn: boolean) => void\n}\n\nexport interface RPCRenderSetupParams<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n> {\n  self: T\n  rpcMethodName: string\n  getRPCParams: (params: {\n    view: LGV\n    session: ReturnType<typeof getSession>\n    sequenceAdapter: unknown\n    stopToken: StopToken\n  }) => Record<string, unknown>\n  onResult: (result: R) => void\n}\n\nexport function createRPCRenderFunction<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n>({ self, rpcMethodName, getRPCParams, onResult }: RPCRenderSetupParams<T, R>) {\n  return async () => {\n    const view = getContainingView(self) as LGV\n\n    if (\n      !view.initialized ||\n      self.error ||\n      !self.featureDensityStatsReadyAndRegionNotTooLarge\n    ) {\n      return\n    }\n\n    const { bpPerPx } = view\n\n    try {\n      const session = getSession(self)\n      const { rpcManager, assemblyManager } = session\n      const assemblyName = view.assemblyNames[0]\n      if (!assemblyName) {\n        return\n      }\n\n      const assembly = assemblyManager.get(assemblyName)\n      const sequenceAdapterConfig = assembly?.configuration?.sequence?.adapter\n      const sequenceAdapter = sequenceAdapterConfig\n        ? getSnapshot(sequenceAdapterConfig)\n        : undefined\n\n      const previousToken = untracked(() => self.renderingStopToken)\n      if (previousToken) {\n        stopStopToken(previousToken)\n      }\n\n      const stopToken = createStopToken()\n      self.setRenderingStopToken(stopToken)\n      self.setLoading(true)\n      self.setCanvasDrawn?.(false)\n\n      const viewSnapshot = {\n        displayedRegions: structuredClone(view.displayedRegions),\n        bpPerPx: view.bpPerPx,\n        offsetPx: view.offsetPx,\n        interRegionPaddingWidth: view.interRegionPaddingWidth,\n        minimumBlockWidth: view.minimumBlockWidth,\n        width: view.width,\n      }\n\n      const sessionId = getRpcSessionId(self)\n      const adapterConfig = self.adapterConfig\n      const config = getSnapshot(self.configuration)\n      const result = (await rpcManager.call(sessionId, rpcMethodName, {\n        sessionId,\n        view: viewSnapshot,\n        adapterConfig,\n        sequenceAdapter,\n        config,\n        statusCallback: (msg: string) => {\n          if (isAlive(self)) {\n            self.setStatusMessage?.(msg)\n          }\n        },\n        stopToken,\n        ...getRPCParams({ view, session, sequenceAdapter, stopToken }),\n      })) as R & { imageData?: ImageBitmap; offsetPx?: number }\n\n      if (result.imageData) {\n        self.setRenderingImageData(result.imageData)\n        if (result.offsetPx !== undefined) {\n          self.setLastDrawnOffsetPx(result.offsetPx)\n        }\n        onResult(result)\n      }\n\n      self.setLastDrawnBpPerPx(bpPerPx)\n    } catch (error) {\n      if (!isAbortException(error)) {\n        console.error(error)\n        self.setError(error)\n      }\n    } finally {\n      self.setRenderingStopToken(undefined)\n      self.setLoading(false)\n    }\n  }\n}\n\nexport function setupCanvasRenderingAutorun<T extends RPCRenderableModel>(\n  self: T,\n) {\n  createAutorun(\n    self,\n    async () => {\n      const success = drawCanvasImageData(self.ref, self.renderingImageData)\n      if (isAlive(self)) {\n        self.setCanvasDrawn?.(success)\n      }\n    },\n    {\n      name: 'CanvasRenderAutorun',\n    },\n  )\n}\n","import { isAlive } from '@jbrowse/mobx-state-tree'\n\nimport {\n  createRPCRenderFunction,\n  setupCanvasRenderingAutorun,\n} from '../shared/createRPCRenderingSetup.ts'\nimport { createAutorun } from '../util.ts'\n\nimport type { LinearReadArcsDisplayModel } from './model.ts'\n\nexport function doAfterAttachRPC(self: LinearReadArcsDisplayModel) {\n  const performRender = createRPCRenderFunction({\n    self,\n    rpcMethodName: 'RenderLinearReadArcsDisplay',\n    getRPCParams: () => self.renderProps(),\n    onResult: () => {},\n  })\n\n  createAutorun(\n    self,\n    async () => {\n      if (!isAlive(self)) {\n        return\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      performRender()\n    },\n    {\n      delay: 1000,\n      name: 'PerformRender',\n    },\n  )\n\n  setupCanvasRenderingAutorun(self)\n}\n"],"names":["createRPCRenderFunction","self","rpcMethodName","getRPCParams","onResult","async","view","getContainingView","initialized","error","featureDensityStatsReadyAndRegionNotTooLarge","bpPerPx","session","getSession","rpcManager","assemblyManager","assemblyName","assemblyNames","assembly","get","sequenceAdapterConfig","configuration","sequence","adapter","sequenceAdapter","getSnapshot","undefined","previousToken","untracked","renderingStopToken","stopStopToken","stopToken","createStopToken","setRenderingStopToken","setLoading","setCanvasDrawn","viewSnapshot","displayedRegions","structuredClone","offsetPx","interRegionPaddingWidth","minimumBlockWidth","width","sessionId","getRpcSessionId","adapterConfig","config","result","call","statusCallback","msg","isAlive","setStatusMessage","imageData","setRenderingImageData","setLastDrawnOffsetPx","setLastDrawnBpPerPx","isAbortException","console","setError","setupCanvasRenderingAutorun","createAutorun","success","drawCanvasImageData","ref","renderingImageData","name","doAfterAttachRPC","performRender","renderProps","delay"],"ignoreList":[],"sourceRoot":""}