{"version":3,"file":"static/js/2645.4b79a04c.chunk.js","mappings":"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","sources":["../../../node_modules/gff-nostream/src/util.ts","../../../node_modules/gff-nostream/src/parse.ts","../../../node_modules/gff-nostream/src/api.ts"],"sourcesContent":["// Fast, low-level functions for parsing and formatting GFF3.\n// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n\n/**\n * Unescape a string value used in a GFF3 attribute.\n *\n * @param stringVal - Escaped GFF3 string value\n * @returns An unescaped string value\n */\nexport function unescape(stringVal: string): string {\n  return stringVal.replaceAll(/%([0-9A-Fa-f]{2})/g, (_match, seq) =>\n    String.fromCharCode(parseInt(seq, 16)),\n  )\n}\n\nfunction _escape(regex: RegExp, s: string | number) {\n  return String(s).replace(regex, ch => {\n    const hex = ch.charCodeAt(0).toString(16).toUpperCase().padStart(2, '0')\n    return `%${hex}`\n  })\n}\n\n/**\n * Escape a value for use in a GFF3 attribute value.\n *\n * @param rawVal - Raw GFF3 attribute value\n * @returns An escaped string value\n */\nexport function escape(rawVal: string | number): string {\n  return _escape(/[\\n;\\r\\t=%&,\\u0000-\\u001f\\u007f-\\u00ff]/g, rawVal)\n}\n\n/**\n * Escape a value for use in a GFF3 column value.\n *\n * @param rawVal - Raw GFF3 column value\n * @returns An escaped column value\n */\nexport function escapeColumn(rawVal: string | number): string {\n  return _escape(/[\\n\\r\\t%\\u0000-\\u001f\\u007f-\\u00ff]/g, rawVal)\n}\n\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributes(attrString: string): GFF3Attributes {\n  if (!attrString.length || attrString === '.') {\n    return {}\n  }\n\n  const attrs: GFF3Attributes = {}\n\n  attrString\n    .replace(/\\r?\\n$/, '')\n    .split(';')\n    .forEach(a => {\n      const nv = a.split('=', 2)\n      if (!nv[1]?.length) {\n        return\n      }\n\n      nv[0] = nv[0].trim()\n      let arec = attrs[nv[0].trim()]\n      if (!arec) {\n        arec = []\n        attrs[nv[0]] = arec\n      }\n\n      arec.push(\n        ...nv[1]\n          .split(',')\n          .map(s => s.trim())\n          .map(unescape),\n      )\n    })\n  return attrs\n}\n\n/**\n * Parse a GFF3 feature line\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeature(line: string): GFF3FeatureLine {\n  // split the line into columns and replace '.' with null in each column\n  const f = line.split('\\t').map(a => (a === '.' || a === '' ? null : a))\n\n  // unescape only the ref, source, and type columns\n  const parsed: GFF3FeatureLine = {\n    seq_id: f[0] && unescape(f[0]),\n    source: f[1] && unescape(f[1]),\n    type: f[2] && unescape(f[2]),\n    start: f[3] === null ? null : parseInt(f[3], 10),\n    end: f[4] === null ? null : parseInt(f[4], 10),\n    score: f[5] === null ? null : parseFloat(f[5]),\n    strand: f[6],\n    phase: f[7],\n    attributes: f[8] === null ? null : parseAttributes(f[8]),\n  }\n  return parsed\n}\n\n/**\n * Parse a GFF3 directive line.\n *\n * @param line - GFF3 directive line\n * @returns The parsed directive\n */\nexport function parseDirective(\n  line: string,\n):\n  | GFF3Directive\n  | GFF3SequenceRegionDirective\n  | GFF3GenomeBuildDirective\n  | null {\n  const match = /^\\s*##\\s*(\\S+)\\s*(.*)/.exec(line)\n  if (!match) {\n    return null\n  }\n\n  const [, name] = match\n  let [, , contents] = match\n\n  const parsed: GFF3Directive = { directive: name }\n  if (contents.length) {\n    contents = contents.replace(/\\r?\\n$/, '')\n    parsed.value = contents\n  }\n\n  // do a little additional parsing for sequence-region and genome-build directives\n  if (name === 'sequence-region') {\n    const c = contents.split(/\\s+/, 3)\n    return {\n      ...parsed,\n      seq_id: c[0],\n      start: c[1]?.replaceAll(/\\D/g, ''),\n      end: c[2]?.replaceAll(/\\D/g, ''),\n    } as GFF3SequenceRegionDirective\n  } else if (name === 'genome-build') {\n    const [source, buildName] = contents.split(/\\s+/, 2)\n    return {\n      ...parsed,\n      source,\n      buildName,\n    } as GFF3GenomeBuildDirective\n  }\n\n  return parsed\n}\n\n/**\n * Format an attributes object into a string suitable for the 9th column of GFF3.\n *\n * @param attrs - Attributes\n * @returns GFF3 9th column string\n */\nexport function formatAttributes(attrs: GFF3Attributes): string {\n  const attrOrder: string[] = []\n  Object.entries(attrs).forEach(([tag, val]) => {\n    if (!val) {\n      return\n    }\n    let valstring\n    if (val.hasOwnProperty('toString')) {\n      valstring = escape(val.toString())\n      // } else if (Array.isArray(val.values)) {\n      //   valstring = val.values.map(escape).join(',')\n    } else if (Array.isArray(val)) {\n      valstring = val.map(escape).join(',')\n    } else {\n      valstring = escape(val)\n    }\n    attrOrder.push(`${escape(tag)}=${valstring}`)\n  })\n  return attrOrder.length ? attrOrder.join(';') : '.'\n}\n\nfunction _formatSingleFeature(\n  f: GFF3FeatureLine | GFF3FeatureLineWithRefs,\n  seenFeature: Record<string, boolean | undefined>,\n) {\n  const attrString =\n    f.attributes === null || f.attributes === undefined\n      ? '.'\n      : formatAttributes(f.attributes)\n\n  const fields = [\n    f.seq_id === null ? '.' : escapeColumn(f.seq_id),\n    f.source === null ? '.' : escapeColumn(f.source),\n    f.type === null ? '.' : escapeColumn(f.type),\n    f.start === null ? '.' : escapeColumn(f.start),\n    f.end === null ? '.' : escapeColumn(f.end),\n    f.score === null ? '.' : escapeColumn(f.score),\n    f.strand === null ? '.' : escapeColumn(f.strand),\n    f.phase === null ? '.' : escapeColumn(f.phase),\n    attrString,\n  ]\n\n  const formattedString = `${fields.join('\\t')}\\n`\n\n  // if we have already output this exact feature, skip it\n  if (seenFeature[formattedString]) {\n    return ''\n  }\n\n  seenFeature[formattedString] = true\n  return formattedString\n}\n\nfunction _formatFeature(\n  feature:\n    | GFF3FeatureLine\n    | GFF3FeatureLineWithRefs\n    | (GFF3FeatureLine | GFF3FeatureLineWithRefs)[],\n  seenFeature: Record<string, boolean | undefined>,\n): string {\n  if (Array.isArray(feature)) {\n    return feature.map(f => _formatFeature(f, seenFeature)).join('')\n  }\n\n  const strings = [_formatSingleFeature(feature, seenFeature)]\n  if (_isFeatureLineWithRefs(feature)) {\n    strings.push(\n      ...feature.child_features.map(f => _formatFeature(f, seenFeature)),\n      ...feature.derived_features.map(f => _formatFeature(f, seenFeature)),\n    )\n  }\n  return strings.join('')\n}\n\n/**\n * Format a feature object or array of feature objects into one or more lines of\n * GFF3.\n *\n * @param featureOrFeatures - A feature object or array of feature objects\n * @returns A string of one or more GFF3 lines\n */\nexport function formatFeature(\n  featureOrFeatures:\n    | GFF3FeatureLine\n    | GFF3FeatureLineWithRefs\n    | (GFF3FeatureLine | GFF3FeatureLineWithRefs)[],\n): string {\n  const seen = {}\n  return _formatFeature(featureOrFeatures, seen)\n}\n\n/**\n * Format a directive into a line of GFF3.\n *\n * @param directive - A directive object\n * @returns A directive line string\n */\nexport function formatDirective(directive: GFF3Directive): string {\n  let str = `##${directive.directive}`\n  if (directive.value) {\n    str += ` ${directive.value}`\n  }\n  str += '\\n'\n  return str\n}\n\n/**\n * Format a comment into a GFF3 comment.\n * Yes I know this is just adding a # and a newline.\n *\n * @param comment - A comment object\n * @returns A comment line string\n */\nexport function formatComment(comment: GFF3Comment): string {\n  return `# ${comment.comment}\\n`\n}\n\n/**\n * Format a sequence object as FASTA\n *\n * @param seq - A sequence object\n * @returns Formatted single FASTA sequence string\n */\nexport function formatSequence(seq: GFF3Sequence): string {\n  return `>${seq.id}${seq.description ? ` ${seq.description}` : ''}\\n${\n    seq.sequence\n  }\\n`\n}\n\n/**\n * Format a directive, comment, sequence, or feature, or array of such items,\n * into one or more lines of GFF3.\n *\n * @param itemOrItems - A comment, sequence, or feature, or array of such items\n * @returns A formatted string or array of strings\n */\nexport function formatItem(\n  itemOrItems:\n    | GFF3FeatureLineWithRefs\n    | GFF3Directive\n    | GFF3Comment\n    | GFF3Sequence\n    | (GFF3FeatureLineWithRefs | GFF3Directive | GFF3Comment | GFF3Sequence)[],\n): string | string[] {\n  function formatSingleItem(\n    item: GFF3FeatureLineWithRefs | GFF3Directive | GFF3Comment | GFF3Sequence,\n  ) {\n    if ('attributes' in item) {\n      return formatFeature(item)\n    }\n    if ('directive' in item) {\n      return formatDirective(item)\n    }\n    if ('sequence' in item) {\n      return formatSequence(item)\n    }\n    if ('comment' in item) {\n      return formatComment(item)\n    }\n    return '# (invalid item found during format)\\n'\n  }\n\n  if (Array.isArray(itemOrItems)) {\n    return itemOrItems.map(formatSingleItem)\n  }\n  return formatSingleItem(itemOrItems)\n}\n\n/** A record of GFF3 attribute identifiers and the values of those identifiers */\nexport type GFF3Attributes = Record<string, string[] | undefined>\n\n/** A representation of a single line of a GFF3 file */\nexport interface GFF3FeatureLine {\n  /** The ID of the landmark used to establish the coordinate system for the current feature */\n  seq_id: string | null\n  /** A free text qualifier intended to describe the algorithm or operating procedure that generated this feature */\n  source: string | null\n  /** The type of the feature */\n  type: string | null\n  /** The start coordinates of the feature */\n  start: number | null\n  /** The end coordinates of the feature */\n  end: number | null\n  /** The score of the feature */\n  score: number | null\n  /** The strand of the feature */\n  strand: string | null\n  /** For features of type \"CDS\", the phase indicates where the next codon begins relative to the 5' end of the current CDS feature */\n  phase: string | null\n  /** Feature attributes */\n  attributes: GFF3Attributes | null\n}\n\n/**\n * A GFF3 Feature line that includes references to other features defined in\n * their \"Parent\" or \"Derives_from\" attributes\n */\nexport interface GFF3FeatureLineWithRefs extends GFF3FeatureLine {\n  /** An array of child features */\n  child_features: GFF3Feature[]\n  /** An array of features derived from this feature */\n  derived_features: GFF3Feature[]\n}\n\nfunction _isFeatureLineWithRefs(\n  featureLine: GFF3FeatureLine | GFF3FeatureLineWithRefs,\n): featureLine is GFF3FeatureLineWithRefs {\n  return (\n    (featureLine as GFF3FeatureLineWithRefs).child_features !== undefined &&\n    (featureLine as GFF3FeatureLineWithRefs).derived_features !== undefined\n  )\n}\n\n/**\n * A GFF3 feature, which may include multiple individual feature lines\n */\nexport type GFF3Feature = GFF3FeatureLineWithRefs[]\n\n/** A GFF3 directive */\nexport interface GFF3Directive {\n  /** The name of the directive */\n  directive: string\n  /** The string value of the directive */\n  value?: string\n}\n\n/** A GFF3 sequence-region directive */\nexport interface GFF3SequenceRegionDirective extends GFF3Directive {\n  /** The string value of the directive */\n  value: string\n  /** The sequence ID parsed from the directive */\n  seq_id: string\n  /** The sequence start parsed from the directive */\n  start: string\n  /** The sequence end parsed from the directive */\n  end: string\n}\n\n/** A GFF3 genome-build directive */\nexport interface GFF3GenomeBuildDirective extends GFF3Directive {\n  /** The string value of the directive */\n  value: string\n  /** The genome build source parsed from the directive */\n  source: string\n  /** The genome build name parsed from the directive */\n  buildName: string\n}\n\n/** A GFF3 comment */\nexport interface GFF3Comment {\n  /** The text of the comment */\n  comment: string\n}\n\n/** A GFF3 FASTA single sequence */\nexport interface GFF3Sequence {\n  /** The ID of the sequence */\n  id: string\n  /** The description of the sequence */\n  description?: string\n  /** The sequence */\n  sequence: string\n}\n\nexport type GFF3Item = GFF3Feature | GFF3Directive | GFF3Comment | GFF3Sequence\n","import * as GFF3 from './util'\n\nconst containerAttributes = {\n  Parent: 'child_features' as const,\n  Derives_from: 'derived_features' as const,\n}\n\nexport class FASTAParser {\n  seqCallback: (sequence: GFF3.GFF3Sequence) => void\n  currentSequence:\n    | { id: string; sequence: string; description?: string }\n    | undefined\n\n  constructor(seqCallback: (sequence: GFF3.GFF3Sequence) => void) {\n    this.seqCallback = seqCallback\n    this.currentSequence = undefined\n  }\n\n  addLine(line: string): void {\n    const defMatch = /^>\\s*(\\S+)\\s*(.*)/.exec(line)\n    if (defMatch) {\n      this._flush()\n      this.currentSequence = { id: defMatch[1], sequence: '' }\n      if (defMatch[2]) {\n        this.currentSequence.description = defMatch[2].trim()\n      }\n    } else if (this.currentSequence && /\\S/.test(line)) {\n      this.currentSequence.sequence += line.replaceAll(/\\s/g, '')\n    }\n  }\n\n  private _flush() {\n    if (this.currentSequence) {\n      this.seqCallback(this.currentSequence)\n    }\n  }\n\n  finish(): void {\n    this._flush()\n  }\n}\n\ninterface ParserArgs {\n  featureCallback?(feature: GFF3.GFF3Feature): void\n  endCallback?(): void\n  commentCallback?(comment: GFF3.GFF3Comment): void\n  errorCallback?(error: string): void\n  directiveCallback?(directive: GFF3.GFF3Directive): void\n  sequenceCallback?(sequence: GFF3.GFF3Sequence): void\n  bufferSize?: number\n  disableDerivesFromReferences?: boolean\n}\n\ninterface References {\n  Parent: GFF3.GFF3Feature[]\n  Derives_from: GFF3.GFF3Feature[]\n}\n\nexport default class Parser {\n  featureCallback: (feature: GFF3.GFF3Feature) => void\n  endCallback: () => void\n  commentCallback: (comment: GFF3.GFF3Comment) => void\n  errorCallback: (error: string) => void\n  disableDerivesFromReferences: boolean\n  directiveCallback: (directive: GFF3.GFF3Directive) => void\n  sequenceCallback: (sequence: GFF3.GFF3Sequence) => void\n  bufferSize: number\n  fastaParser: FASTAParser | undefined = undefined\n  // if this is true, the parser ignores the\n  // rest of the lines in the file.  currently\n  // set when the file switches over to FASTA\n  eof = false\n  lineNumber = 0\n  // features that we have to keep on hand for now because they\n  // might be referenced by something else\n  private _underConstructionTopLevel: GFF3.GFF3Feature[] = []\n  // index of the above by ID\n  private _underConstructionById: Record<string, GFF3.GFF3Feature | undefined> =\n    {}\n  private _completedReferences: Record<\n    string,\n    Record<string, boolean | undefined> | undefined\n  > = {}\n  // features that reference something we have not seen yet\n  // structured as:\n  // {  'some_id' : {\n  //     'Parent' : [ orphans that have a Parent attr referencing it ],\n  //     'Derives_from' : [ orphans that have a Derives_from attr referencing it ],\n  //    }\n  // }\n  private _underConstructionOrphans: Record<string, References | undefined> = {}\n\n  constructor(args: ParserArgs) {\n    // eslint-disable-next-line @typescript-eslint/no-empty-function\n    const nullFunc = () => {}\n\n    this.featureCallback = args.featureCallback || nullFunc\n    this.endCallback = args.endCallback || nullFunc\n    this.commentCallback = args.commentCallback || nullFunc\n    this.errorCallback = args.errorCallback || nullFunc\n    this.directiveCallback = args.directiveCallback || nullFunc\n    this.sequenceCallback = args.sequenceCallback || nullFunc\n    this.disableDerivesFromReferences =\n      args.disableDerivesFromReferences || false\n\n    // number of lines to buffer\n    this.bufferSize = args.bufferSize === undefined ? 1000 : args.bufferSize\n  }\n\n  addLine(line: string): void {\n    // if we have transitioned to a fasta section, just delegate to that parser\n    if (this.fastaParser) {\n      this.fastaParser.addLine(line)\n      return\n    }\n    if (this.eof) {\n      // otherwise, if we are done, ignore this line\n      return\n    }\n\n    this.lineNumber += 1\n\n    if (/^\\s*[^#\\s>]/.test(line)) {\n      // feature line, most common case\n      this._bufferLine(line)\n      return\n    }\n\n    const match = /^\\s*(#+)(.*)/.exec(line)\n    if (match) {\n      // directive or comment\n      const [, hashsigns] = match\n      let [, , contents] = match\n\n      if (hashsigns.length === 3) {\n        // sync directive, all forward-references are resolved.\n        this._emitAllUnderConstructionFeatures()\n      } else if (hashsigns.length === 2) {\n        const directive = GFF3.parseDirective(line)\n        if (directive) {\n          if (directive.directive === 'FASTA') {\n            this._emitAllUnderConstructionFeatures()\n            this.eof = true\n            this.fastaParser = new FASTAParser(this.sequenceCallback)\n          } else {\n            this._emitItem(directive)\n          }\n        }\n      } else {\n        contents = contents.replace(/\\s*/, '')\n        this._emitItem({ comment: contents })\n      }\n    } else if (/^\\s*$/.test(line)) {\n      // blank line, do nothing\n    } else if (/^\\s*>/.test(line)) {\n      // implicit beginning of a FASTA section\n      this._emitAllUnderConstructionFeatures()\n      this.eof = true\n      this.fastaParser = new FASTAParser(this.sequenceCallback)\n      this.fastaParser.addLine(line)\n    } else {\n      // it's a parse error\n      const errLine = line.replaceAll(/\\r?\\n?$/g, '')\n      throw new Error(`GFF3 parse error.  Cannot parse '${errLine}'.`)\n    }\n  }\n\n  finish(): void {\n    this._emitAllUnderConstructionFeatures()\n    if (this.fastaParser) {\n      this.fastaParser.finish()\n    }\n    this.endCallback()\n  }\n\n  private _emitItem(\n    i: GFF3.GFF3Feature | GFF3.GFF3Directive | GFF3.GFF3Comment,\n  ) {\n    if (Array.isArray(i)) {\n      this.featureCallback(i)\n    } else if ('directive' in i) {\n      this.directiveCallback(i)\n    } else if ('comment' in i) {\n      this.commentCallback(i)\n    }\n  }\n\n  private _enforceBufferSizeLimit(additionalItemCount = 0) {\n    const _unbufferItem = (item?: GFF3.GFF3Feature) => {\n      if (item && Array.isArray(item) && item[0].attributes?.ID?.[0]) {\n        const ids = item[0].attributes.ID\n        ids.forEach(id => {\n          delete this._underConstructionById[id]\n          delete this._completedReferences[id]\n        })\n        item.forEach(i => {\n          if (i.child_features) {\n            i.child_features.forEach(c => _unbufferItem(c))\n          }\n          if (i.derived_features) {\n            i.derived_features.forEach(d => _unbufferItem(d))\n          }\n        })\n      }\n    }\n\n    while (\n      this._underConstructionTopLevel.length + additionalItemCount >\n      this.bufferSize\n    ) {\n      const item = this._underConstructionTopLevel.shift()\n      if (item) {\n        this._emitItem(item)\n        _unbufferItem(item)\n      }\n    }\n  }\n\n  /**\n   * return all under-construction features, called when we know\n   * there will be no additional data to attach to them\n   */\n  private _emitAllUnderConstructionFeatures() {\n    this._underConstructionTopLevel.forEach(this._emitItem.bind(this))\n\n    this._underConstructionTopLevel = []\n    this._underConstructionById = {}\n    this._completedReferences = {}\n\n    // if we have any orphans hanging around still, this is a\n    // problem. die with a parse error\n    if (Array.from(Object.values(this._underConstructionOrphans)).length) {\n      throw new Error(\n        `some features reference other features that do not exist in the file (or in the same '###' scope). ${Object.keys(\n          this._underConstructionOrphans,\n        ).join(',')}`,\n      )\n    }\n  }\n\n  // do the right thing with a newly-parsed feature line\n  private _bufferLine(line: string) {\n    const rawFeatureLine = GFF3.parseFeature(line)\n    const featureLine: GFF3.GFF3FeatureLineWithRefs = {\n      ...rawFeatureLine,\n      child_features: [],\n      derived_features: [],\n    }\n    // featureLine._lineNumber = this.lineNumber //< debugging aid\n\n    // NOTE: a feature is an arrayref of one or more feature lines.\n    const ids = featureLine.attributes?.ID || []\n    const parents = featureLine.attributes?.Parent || []\n    const derives = this.disableDerivesFromReferences\n      ? []\n      : featureLine.attributes?.Derives_from || []\n\n    if (!ids.length && !parents.length && !derives.length) {\n      // if it has no IDs and does not refer to anything, we can just\n      // output it\n      this._emitItem([featureLine])\n      return\n    }\n\n    let feature: GFF3.GFF3Feature | undefined = undefined\n    ids.forEach(id => {\n      const existing = this._underConstructionById[id]\n      if (existing) {\n        // another location of the same feature\n        if (existing[existing.length - 1].type !== featureLine.type) {\n          this._parseError(\n            `multi-line feature \"${id}\" has inconsistent types: \"${\n              featureLine.type\n            }\", \"${existing[existing.length - 1].type}\"`,\n          )\n        }\n        existing.push(featureLine)\n        feature = existing\n      } else {\n        // haven't seen it yet, so buffer it so we can attach\n        // child features to it\n        feature = [featureLine]\n\n        this._enforceBufferSizeLimit(1)\n        if (!parents.length && !derives.length) {\n          this._underConstructionTopLevel.push(feature)\n        }\n        this._underConstructionById[id] = feature\n\n        // see if we have anything buffered that refers to it\n        this._resolveReferencesTo(feature, id)\n      }\n    })\n\n    // try to resolve all its references\n    this._resolveReferencesFrom(\n      feature || [featureLine],\n      { Parent: parents, Derives_from: derives },\n      ids,\n    )\n  }\n\n  private _resolveReferencesTo(feature: GFF3.GFF3Feature, id: string) {\n    const references = this._underConstructionOrphans[id]\n    //   references is of the form\n    //   {\n    //     'Parent' : [ orphans that have a Parent attr referencing this feature ],\n    //     'Derives_from' : [ orphans that have a Derives_from attr referencing this feature ],\n    //    }\n    if (!references) {\n      return\n    }\n    feature.forEach(loc => {\n      loc.child_features.push(...references.Parent)\n    })\n    feature.forEach(loc => {\n      loc.derived_features.push(...references.Derives_from)\n    })\n    delete this._underConstructionOrphans[id]\n  }\n\n  private _parseError(message: string) {\n    this.eof = true\n    this.errorCallback(`${this.lineNumber}: ${message}`)\n  }\n\n  private _resolveReferencesFrom(\n    feature: GFF3.GFF3Feature,\n    references: { Parent: string[]; Derives_from: string[] },\n    ids: string[],\n  ) {\n    // this is all a bit more awkward in javascript than it was in perl\n    function postSet(\n      obj: Record<string, Record<string, boolean | undefined> | undefined>,\n      slot1: string,\n      slot2: string,\n    ) {\n      let subObj = obj[slot1]\n      if (!subObj) {\n        subObj = {}\n        obj[slot1] = subObj\n      }\n      const returnVal = subObj[slot2] || false\n      subObj[slot2] = true\n      return returnVal\n    }\n\n    references.Parent.forEach(toId => {\n      const otherFeature = this._underConstructionById[toId]\n      if (otherFeature) {\n        const pname = containerAttributes.Parent\n        if (\n          !ids.filter(id =>\n            postSet(this._completedReferences, id, `Parent,${toId}`),\n          ).length\n        ) {\n          otherFeature.forEach(location => {\n            location[pname].push(feature)\n          })\n        }\n      } else {\n        let ref = this._underConstructionOrphans[toId]\n        if (!ref) {\n          ref = {\n            Parent: [],\n            Derives_from: [],\n          }\n          this._underConstructionOrphans[toId] = ref\n        }\n        ref.Parent.push(feature)\n      }\n    })\n\n    references.Derives_from.forEach(toId => {\n      const otherFeature = this._underConstructionById[toId]\n      if (otherFeature) {\n        const pname = containerAttributes.Derives_from\n        if (\n          !ids.filter(id =>\n            postSet(this._completedReferences, id, `Derives_from,${toId}`),\n          ).length\n        ) {\n          otherFeature.forEach(location => {\n            location[pname].push(feature)\n          })\n        }\n      } else {\n        let ref = this._underConstructionOrphans[toId]\n        if (!ref) {\n          ref = {\n            Parent: [],\n            Derives_from: [],\n          }\n          this._underConstructionOrphans[toId] = ref\n        }\n        ref.Derives_from.push(feature)\n      }\n    })\n  }\n}\n","import Parser from './parse'\nimport { GFF3Feature } from './util'\n\n/**\n * Synchronously parse a string containing GFF3 and return an array of the\n * parsed items.\n *\n * @param str - GFF3 string\n * @param inputOptions - Parsing options\n * @returns array of parsed features, directives, comments and/or sequences\n */\nexport function parseStringSync(str: string): GFF3Feature[] {\n  const items: GFF3Feature[] = []\n  const parser = new Parser({\n    featureCallback: arg => items.push(arg),\n    disableDerivesFromReferences: true,\n    errorCallback: err => {\n      throw err\n    },\n  })\n\n  for (const line of str.split(/\\r?\\n/)) {\n    parser.addLine(line)\n  }\n  parser.finish()\n\n  return items\n}\n\nexport {\n  type GFF3FeatureLine,\n  type GFF3Comment,\n  type GFF3FeatureLineWithRefs,\n  type GFF3Directive,\n  type GFF3Sequence,\n  type GFF3Feature,\n  type GFF3Item,\n} from './util'\n"],"names":["stringVal","replaceAll","_match","seq","String","fromCharCode","parseInt","parseAttributes","attrString","length","attrs","replace","split","forEach","a","nv","trim","arec","push","map","s","FASTAParser","constructor","seqCallback","this","currentSequence","undefined","addLine","line","defMatch","exec","_flush","id","sequence","description","test","finish","Parser","args","fastaParser","eof","lineNumber","_underConstructionTopLevel","_underConstructionById","_completedReferences","_underConstructionOrphans","nullFunc","featureCallback","endCallback","commentCallback","errorCallback","directiveCallback","sequenceCallback","disableDerivesFromReferences","bufferSize","_bufferLine","match","hashsigns","contents","_emitAllUnderConstructionFeatures","directive","name","parsed","value","c","seq_id","start","end","source","buildName","_emitItem","comment","errLine","Error","i","Array","isArray","_enforceBufferSizeLimit","additionalItemCount","_unbufferItem","item","attributes","ID","child_features","derived_features","d","shift","bind","from","Object","values","keys","join","rawFeatureLine","f","type","score","parseFloat","strand","phase","featureLine","ids","parents","Parent","derives","Derives_from","feature","existing","_parseError","_resolveReferencesTo","_resolveReferencesFrom","references","loc","message","postSet","obj","slot1","slot2","subObj","returnVal","toId","otherFeature","pname","filter","location","ref","parseStringSync","str","items","parser","arg","err"],"sourceRoot":""}