{"version":3,"file":"static/js/7192.abed1105.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/SNPCoverageRenderer/makeImage.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\nimport {\n  bpSpanPx,\n  featureSpanPx,\n  forEachWithStopTokenCheck,\n} from '@jbrowse/core/util'\nimport {\n  YSCALEBAR_LABEL_OFFSET,\n  getOrigin,\n  getScale,\n} from '@jbrowse/plugin-wiggle'\n\nimport { alphaColor } from '../shared/util'\n\nimport type { RenderArgsDeserializedWithFeatures } from './types'\nimport type { BaseCoverageBin } from '../shared/types'\n\n// width/height of the triangle above e.g. insertion indicators\nconst INTERBASE_INDICATOR_WIDTH = 7\nconst INTERBASE_INDICATOR_HEIGHT = 4.5\n\n// minimum read depth to draw the insertion indicators, below this the\n// 'statistical significance' is low\nconst MINIMUM_INTERBASE_INDICATOR_READ_DEPTH = 7\n\nconst complementBase = {\n  C: 'G',\n  G: 'C',\n  A: 'T',\n  T: 'A',\n}\n\nconst fudgeFactor = 0.6\n\nexport async function makeImage(\n  ctx: CanvasRenderingContext2D,\n  props: RenderArgsDeserializedWithFeatures,\n) {\n  const {\n    features,\n    regions,\n    bpPerPx,\n    colorBy,\n    displayCrossHatches,\n    visibleModifications = {},\n    scaleOpts,\n    height: unadjustedHeight,\n    theme: configTheme,\n    config: cfg,\n    ticks,\n    stopToken,\n  } = props\n  const theme = createJBrowseTheme(configTheme)\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the\n  // wiggle display, and makes the height of the actual drawn area add\n  // \"padding\" to the top and bottom of the display\n  const offset = YSCALEBAR_LABEL_OFFSET\n  const height = unadjustedHeight - offset * 2\n\n  const opts = { ...scaleOpts, range: [0, height] }\n  const viewScale = getScale(opts)\n\n  // clipping and insertion indicators, uses a smaller height/2 scale\n  const indicatorViewScale = getScale({\n    ...opts,\n    range: [0, height / 2],\n    scaleType: 'linear',\n  })\n  const originY = getOrigin(scaleOpts.scaleType)\n  const originLinear = getOrigin('linear')\n\n  const indicatorThreshold = readConfObject(cfg, 'indicatorThreshold')\n  const showInterbaseCounts = readConfObject(cfg, 'showInterbaseCounts')\n  const showArcs = readConfObject(cfg, 'showArcs')\n  const showInterbaseIndicators = readConfObject(cfg, 'showInterbaseIndicators')\n\n  // get the y coordinate that we are plotting at, this can be log scale\n  const toY = (n: number) => height - (viewScale(n) || 0) + offset\n  const toHeight = (n: number) => toY(originY) - toY(n)\n  // used specifically for indicator\n  const toY2 = (n: number) => height - (indicatorViewScale(n) || 0) + offset\n  const toHeight2 = (n: number) => toY2(originLinear) - toY2(n)\n\n  const { bases, softclip, hardclip, insertion } = theme.palette\n  const colorMap: Record<string, string> = {\n    A: bases.A.main,\n    C: bases.C.main,\n    G: bases.G.main,\n    T: bases.T.main,\n    insertion,\n    softclip,\n    hardclip,\n    total: readConfObject(cfg, 'color'),\n    mod_NONE: 'blue',\n    cpg_meth: 'red',\n    cpg_unmeth: 'blue',\n  }\n\n  // Use two pass rendering, which helps in visualizing the SNPs at higher\n  // bpPerPx First pass: draw the gray background\n  ctx.fillStyle = colorMap.total!\n  forEachWithStopTokenCheck(features.values(), stopToken, feature => {\n    if (feature.get('type') === 'skip') {\n      return\n    }\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n    const w = rightPx - leftPx + fudgeFactor\n    const score = feature.get('score') as number\n    ctx.fillRect(leftPx, toY(score), w, toHeight(score))\n  })\n\n  // Keep track of previous total which we will use it to draw the interbase\n  // indicator (if there is a sudden clip, there will be no read coverage but\n  // there will be \"clip\" coverage) at that position beyond the read.\n  //\n  // if the clip is right at a block boundary then prevTotal will not be\n  // available, so this is a best attempt to plot interbase indicator at the\n  // \"cliffs\"\n  let prevTotal = 0\n\n  // extraHorizontallyFlippedOffset is used to draw interbase items, which\n  // are located to the left when forward and right when reversed\n  const extraHorizontallyFlippedOffset = region.reversed ? 1 / bpPerPx : 0\n\n  const drawingModifications = colorBy.type === 'modifications'\n  const drawingMethylation = colorBy.type === 'methylation'\n  const isolatedModification = colorBy.modifications?.isolatedModification\n\n  // Second pass: draw the SNP data, and add a minimum feature width of 1px\n  // which can be wider than the actual bpPerPx This reduces overdrawing of\n  // the grey background over the SNPs\n  forEachWithStopTokenCheck(features.values(), stopToken, feature => {\n    if (feature.get('type') === 'skip') {\n      return\n    }\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n    const snpinfo = feature.get('snpinfo') as BaseCoverageBin\n    const w = Math.max(rightPx - leftPx, 1)\n    const score0 = feature.get('score')\n    if (drawingModifications) {\n      let curr = 0\n      const refbase = snpinfo.refbase?.toUpperCase()\n      const { nonmods, mods, snps, ref } = snpinfo\n      for (const m of Object.keys(nonmods).sort().reverse()) {\n        const mod =\n          visibleModifications[m.replace('nonmod_', '')] ||\n          visibleModifications[m.replace('mod_', '')]\n        if (!mod) {\n          console.warn(`${m} not known yet`)\n          continue\n        }\n        if (isolatedModification && mod.type !== isolatedModification) {\n          continue\n        }\n        const cmp = complementBase[mod.base as keyof typeof complementBase]\n\n        // this approach is inspired from the 'simplex' approach in igv\n        // https://github.com/igvteam/igv/blob/af07c3b1be8806cfd77343ee04982aeff17d2beb/src/main/java/org/broad/igv/sam/mods/BaseModificationCoverageRenderer.java#L51\n        const detectable =\n          mod.base === 'N'\n            ? score0\n            : (snps[mod.base]?.entryDepth || 0) +\n              (snps[cmp]?.entryDepth || 0) +\n              (refbase === mod.base ? ref['1'] : 0) +\n              (refbase === cmp ? ref['-1'] : 0)\n\n        const modifiable =\n          mod.base === 'N'\n            ? score0\n            : (snps[mod.base]?.entryDepth || 0) +\n              (snps[cmp]?.entryDepth || 0) +\n              (refbase === mod.base ? ref.entryDepth : 0) +\n              (refbase === cmp ? ref.entryDepth : 0)\n\n        const { entryDepth, avgProbability = 0 } = snpinfo.nonmods[m]!\n        const modFraction = (modifiable / score0) * (entryDepth / detectable)\n        const nonModColor = 'blue'\n        const c = alphaColor(nonModColor, avgProbability)\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n\n        ctx.fillStyle = c\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - (curr + modFraction * height),\n          w,\n          modFraction * height,\n        )\n        curr += modFraction * height\n      }\n      for (const m of Object.keys(mods).sort().reverse()) {\n        const mod = visibleModifications[m.replace('mod_', '')]\n        if (!mod) {\n          console.warn(`${m} not known yet`)\n          continue\n        }\n        if (isolatedModification && mod.type !== isolatedModification) {\n          continue\n        }\n        const cmp = complementBase[mod.base as keyof typeof complementBase]\n\n        // this approach is inspired from the 'simplex' approach in igv\n        // https://github.com/igvteam/igv/blob/af07c3b1be8806cfd77343ee04982aeff17d2beb/src/main/java/org/broad/igv/sam/mods/BaseModificationCoverageRenderer.java#L51\n        const detectable =\n          mod.base === 'N'\n            ? score0\n            : (snps[mod.base]?.entryDepth || 0) +\n              (snps[cmp]?.entryDepth || 0) +\n              (refbase === mod.base ? ref['1'] : 0) +\n              (refbase === cmp ? ref['-1'] : 0)\n\n        const modifiable =\n          mod.base === 'N'\n            ? score0\n            : (snps[mod.base]?.entryDepth || 0) +\n              (snps[cmp]?.entryDepth || 0) +\n              (refbase === mod.base ? ref.entryDepth : 0) +\n              (refbase === cmp ? ref.entryDepth : 0)\n\n        const { entryDepth, avgProbability = 0 } = mods[m]!\n        const modFraction = (modifiable / score0) * (entryDepth / detectable)\n        const baseColor = mod.color || 'black'\n        const c = alphaColor(baseColor, avgProbability)\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n\n        ctx.fillStyle = c\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - (curr + modFraction * height),\n          w,\n          modFraction * height,\n        )\n        curr += modFraction * height\n      }\n    } else if (drawingMethylation) {\n      const { depth, nonmods, mods } = snpinfo\n      let curr = 0\n\n      for (const base of Object.keys(mods).sort().reverse()) {\n        const { entryDepth } = mods[base]!\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n        ctx.fillStyle = colorMap[base] || 'black'\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - ((entryDepth + curr) / depth) * height,\n          w,\n          (entryDepth / depth) * height,\n        )\n        curr += entryDepth\n      }\n      for (const base of Object.keys(nonmods).sort().reverse()) {\n        const { entryDepth } = nonmods[base]!\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n        ctx.fillStyle = colorMap[base] || 'black'\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - ((entryDepth + curr) / depth) * height,\n          w,\n          (entryDepth / depth) * height,\n        )\n        curr += entryDepth\n      }\n    } else {\n      const { depth, snps } = snpinfo\n      let curr = 0\n      for (const base of Object.keys(snps).sort().reverse()) {\n        const { entryDepth } = snps[base]!\n        const height = toHeight(score0)\n        const bottom = toY(score0) + height\n        ctx.fillStyle = colorMap[base] || 'black'\n        ctx.fillRect(\n          Math.round(leftPx),\n          bottom - ((entryDepth + curr) / depth) * height,\n          w,\n          (entryDepth / depth) * height,\n        )\n        curr += entryDepth\n      }\n    }\n\n    const interbaseEvents = Object.keys(snpinfo.noncov)\n    if (showInterbaseCounts) {\n      let curr = 0\n      for (const base of interbaseEvents) {\n        const { entryDepth } = snpinfo.noncov[base]!\n        const r = 0.6\n        ctx.fillStyle = colorMap[base]!\n        ctx.fillRect(\n          leftPx - r + extraHorizontallyFlippedOffset,\n          INTERBASE_INDICATOR_HEIGHT + toHeight2(curr),\n          r * 2,\n          toHeight2(entryDepth),\n        )\n        curr += entryDepth\n      }\n    }\n\n    if (showInterbaseIndicators) {\n      let accum = 0\n      let max = 0\n      let maxBase = ''\n      for (const base of interbaseEvents) {\n        const { entryDepth } = snpinfo.noncov[base]!\n        accum += entryDepth\n        if (entryDepth > max) {\n          max = entryDepth\n          maxBase = base\n        }\n      }\n\n      // avoid drawing a bunch of indicators if coverage is very low. note:\n      // also uses the prev total in the case of the \"cliff\"\n      const indicatorComparatorScore = Math.max(score0, prevTotal)\n      if (\n        accum > indicatorComparatorScore * indicatorThreshold &&\n        indicatorComparatorScore > MINIMUM_INTERBASE_INDICATOR_READ_DEPTH\n      ) {\n        ctx.fillStyle = colorMap[maxBase]!\n        ctx.beginPath()\n        const l = leftPx + extraHorizontallyFlippedOffset\n        ctx.moveTo(l - INTERBASE_INDICATOR_WIDTH / 2, 0)\n        ctx.lineTo(l + INTERBASE_INDICATOR_WIDTH / 2, 0)\n        ctx.lineTo(l, INTERBASE_INDICATOR_HEIGHT)\n        ctx.fill()\n      }\n    }\n    prevTotal = score0\n  })\n\n  if (showArcs) {\n    forEachWithStopTokenCheck(features.values(), stopToken, feature => {\n      if (feature.get('type') !== 'skip') {\n        return\n      }\n      const s = feature.get('start')\n      const e = feature.get('end')\n      const [left, right] = bpSpanPx(s, e, region, bpPerPx)\n\n      ctx.beginPath()\n      const effectiveStrand = feature.get('effectiveStrand')\n      const pos = 'rgba(255,200,200,0.7)'\n      const neg = 'rgba(200,200,255,0.7)'\n      const neutral = 'rgba(200,200,200,0.7)'\n\n      if (effectiveStrand === 1) {\n        ctx.strokeStyle = pos\n      } else if (effectiveStrand === -1) {\n        ctx.strokeStyle = neg\n      } else {\n        ctx.strokeStyle = neutral\n      }\n\n      ctx.lineWidth = Math.log(feature.get('score') + 1)\n      ctx.moveTo(left, height - offset * 2)\n      ctx.bezierCurveTo(left, 0, right, 0, right, height - offset * 2)\n      ctx.stroke()\n    })\n  }\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(140,140,140,0.8)'\n    for (const tick of ticks.values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n}\n"],"names":["INTERBASE_INDICATOR_WIDTH","INTERBASE_INDICATOR_HEIGHT","MINIMUM_INTERBASE_INDICATOR_READ_DEPTH","complementBase","C","G","A","T","fudgeFactor","async","makeImage","ctx","props","features","regions","bpPerPx","colorBy","displayCrossHatches","visibleModifications","scaleOpts","height","unadjustedHeight","theme","configTheme","config","cfg","ticks","stopToken","createJBrowseTheme","region","width","end","start","offset","YSCALEBAR_LABEL_OFFSET","opts","range","viewScale","getScale","indicatorViewScale","scaleType","originY","getOrigin","originLinear","indicatorThreshold","readConfObject","showInterbaseCounts","showArcs","showInterbaseIndicators","toY","n","toHeight","toY2","toHeight2","bases","softclip","hardclip","insertion","palette","colorMap","main","total","mod_NONE","cpg_meth","cpg_unmeth","fillStyle","forEachWithStopTokenCheck","values","feature","get","leftPx","rightPx","featureSpanPx","w","score","fillRect","prevTotal","extraHorizontallyFlippedOffset","reversed","drawingModifications","type","drawingMethylation","isolatedModification","modifications","snpinfo","Math","max","score0","curr","refbase","toUpperCase","nonmods","mods","snps","ref","m","Object","keys","sort","reverse","mod","replace","console","warn","cmp","base","detectable","entryDepth","modifiable","avgProbability","modFraction","nonModColor","c","alphaColor","bottom","round","baseColor","color","depth","interbaseEvents","noncov","r","accum","maxBase","indicatorComparatorScore","beginPath","l","moveTo","lineTo","fill","s","e","left","right","bpSpanPx","effectiveStrand","strokeStyle","lineWidth","log","bezierCurveTo","stroke","tick"],"sourceRoot":""}