{"version":3,"file":"static/js/583.36390dc7.chunk.js","mappings":"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","sources":["../../../plugins/data-management/src/JB2TrackHubConnection/addRelativeUris.ts","../../../plugins/data-management/src/JB2TrackHubConnection/doConnect.ts","../../../plugins/data-management/src/JB2TrackHubConnection/util.ts","../../../node_modules/@gmod/ucsc-hub/src/raStanza.ts","../../../node_modules/@gmod/ucsc-hub/src/raFile.ts","../../../node_modules/@gmod/ucsc-hub/src/util.ts","../../../node_modules/@gmod/ucsc-hub/src/trackDbFile.ts","../../../node_modules/@gmod/ucsc-hub/src/genomesFile.ts","../../../node_modules/@gmod/ucsc-hub/src/hubFile.ts","../../../node_modules/@gmod/ucsc-hub/src/singleFileHub.ts"],"sourcesContent":["export function addRelativeUris(\n  config: Record<string, unknown> | null,\n  base: URL,\n) {\n  if (typeof config === 'object' && config !== null) {\n    for (const key of Object.keys(config)) {\n      if (typeof config[key] === 'object' && config[key] !== null) {\n        addRelativeUris(config[key] as Record<string, unknown>, base)\n      } else if (key === 'uri') {\n        config.baseUri = base.href\n      }\n    }\n  }\n}\n","import { getConf } from '@jbrowse/core/configuration'\nimport { getSession } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\n\nimport { addRelativeUris } from './addRelativeUris'\nimport { resolve } from './util'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { FileLocation } from '@jbrowse/core/util'\n\nexport async function doConnect(self: {\n  configuration: AnyConfigurationModel\n  addTrackConfs: (arg: Record<string, unknown>[]) => void\n}) {\n  const session = getSession(self)\n  try {\n    const configJsonLocation = getConf(\n      self,\n      'configJsonLocation',\n    ) as FileLocation\n\n    const configJson = JSON.parse(\n      await openLocation(configJsonLocation).readFile('utf8'),\n    )\n    const configUri = resolve(\n      // @ts-expect-error\n      configJsonLocation.uri,\n      // @ts-expect-error\n      configJsonLocation.baseUri,\n    )\n    addRelativeUris(configJson, new URL(configUri))\n    if (configJson.assemblies) {\n      for (const assembly of configJson.assemblies) {\n        if (!session.assemblyManager.get(assembly.name)) {\n          // @ts-expect-error\n          session.addSessionAssembly(assembly)\n        }\n      }\n    }\n\n    if (configJson.tracks) {\n      self.addTrackConfs(configJson.tracks)\n    }\n    session.notify('Successfully loaded', 'success')\n  } catch (e) {\n    console.error(e)\n    session.notifyError(`${getConf(self, 'name')}: \"${e}\"`, e)\n    session.breakConnection?.(self.configuration)\n  }\n}\n","import { GenomesFile, TrackDbFile } from '@gmod/ucsc-hub'\nimport { openLocation } from '@jbrowse/core/util/io'\n\nimport type { FileLocation } from '@jbrowse/core/util'\n\nexport async function fetchGenomesFile(genomesLoc: FileLocation) {\n  const genomesFileText = await openLocation(genomesLoc).readFile('utf8')\n  return new GenomesFile(genomesFileText)\n}\n\nexport async function fetchTrackDbFile(trackDbLoc: FileLocation) {\n  const text = await openLocation(trackDbLoc).readFile('utf8')\n  return new TrackDbFile(text)\n}\n\nexport function makeLoc(\n  first: string,\n  base: { uri: string; baseUri?: string },\n) {\n  return {\n    uri: new URL(first, new URL(base.uri, base.baseUri)).href,\n    locationType: 'UriLocation',\n  }\n}\n\nexport function makeLocAlt(first: string, alt: string, base: { uri: string }) {\n  return first ? makeLoc(first, base) : makeLoc(alt, base)\n}\n\nexport function makeLoc2(first: string, alt?: string) {\n  return first\n    ? {\n        uri: first,\n        locationType: 'LocalPath',\n      }\n    : {\n        uri: alt,\n        locationType: 'UriLocation',\n      }\n}\n\nexport function resolve(uri: string, baseUri: string) {\n  return new URL(uri, baseUri).href\n}\n","/**\n * Class representing an ra file stanza. Each stanza line is split into its key\n * and value and stored as a Map, so the usual Map methods can be used on the\n * stanza.\n */\nexport default class RaStanza {\n  data: Record<string, string> = {}\n\n  name?: string\n\n  nameKey?: string\n\n  constructor(\n    stanza: string | string[] = [],\n    options?: { checkIndent?: boolean; skipValidation?: boolean },\n  ) {\n    const { checkIndent = true, skipValidation = false } = options ?? {}\n    const stanzaLines =\n      typeof stanza === 'string' ? stanza.trimEnd().split(/\\r?\\n/) : stanza\n\n    let currentIndent: string | undefined\n\n    let continuedLine: string | undefined\n    for (const line of stanzaLines) {\n      if (line === '') {\n        throw new Error('Invalid stanza, contained blank lines')\n      }\n      if (line.trim().startsWith('#')) {\n        continue\n      }\n      if (line.trimEnd().endsWith('\\\\')) {\n        const trimmedLine = line.trimEnd().slice(0, -1)\n        if (continuedLine) {\n          continuedLine += trimmedLine.trimStart()\n        } else {\n          continuedLine = trimmedLine\n        }\n        continue\n      }\n      let combinedLine = line\n      if (continuedLine) {\n        combinedLine = continuedLine + combinedLine.trimStart()\n        continuedLine = undefined\n      }\n      if (currentIndent ?? checkIndent) {\n        const indent = /^([ \\t]+)/.exec(combinedLine)\n        if (currentIndent === undefined) {\n          if (indent) {\n            ;[, currentIndent] = indent\n          } else {\n            currentIndent = ''\n          }\n        } else if (\n          (currentIndent === '' && indent !== null) ||\n          (currentIndent && indent && currentIndent !== indent[1])\n        ) {\n          throw new Error('Inconsistent indentation of stanza')\n        }\n      } else {\n        currentIndent = ''\n      }\n      const trimmedLine = combinedLine.trim()\n      const sep = trimmedLine.indexOf(' ')\n      if (sep === -1) {\n        if (!this.nameKey) {\n          throw new Error(\n            'First line in a stanza must have both a key and a value',\n          )\n        }\n        // Adding a key that already exists and has no value is a no-op\n        if (this.data[trimmedLine]) {\n          continue\n        }\n        this.data[trimmedLine] = ''\n        continue\n      }\n      const key = trimmedLine.slice(0, sep)\n      const value = trimmedLine.slice(sep + 1)\n      if (this.data[key] && value !== this.data[key]) {\n        throw new Error(\n          'Got duplicate key with a different value in stanza: ' +\n            `\"${key}\" key has both ${this.data[key]} and ${value}`,\n        )\n      }\n      if (!this.nameKey) {\n        this.nameKey = key\n        this.name = trimmedLine.slice(sep + 1)\n      }\n      this.data[key] = value\n    }\n\n    if (!skipValidation) {\n      this.validate()\n    }\n  }\n\n  protected validate() {}\n}\n","import RaStanza from './raStanza.ts'\n\n/**\n * Class representing an ra file. Each file is composed of multiple stanzas, and\n * each stanza is separated by one or more blank lines. Each stanza is stored in\n * a Map with the key being the value of the first key-value pair in the stanza.\n * The usual Map methods can be used on the file. An additional method `add()`\n * is available to take a raw line of text and break it up into a key and value\n * and add them to the class. This should be favored over `set()` when possible,\n * as it performs more validity checks than using `set()`.\n * @property {undefined|string} nameKey - The key of the first line of all the\n * stanzas (`undefined` if the stanza has no lines yet).\n * @throws {Error} Throws if an empty stanza is added, if the key in the first\n * key-value pair of each stanze isn't the same, or if two stanzas have the same\n * value for the key-value pair in their first lines.\n * @param {(string|string[])} [raFile=[]] - An ra file, either as a single\n * string or an array of strings with one stanza per entry. Supports both LF\n * and CRLF line terminators.\n * @param {object} options\n * @param {boolean} options.checkIndent [true] - Check if a the stanzas within\n * the file are indented consistently and keep track of the indentation\n */\nexport default class RaFile {\n  data: Record<string, RaStanza> = {}\n\n  nameKey?: string\n\n  constructor(\n    raFile: string | string[] = [],\n    options?: { checkIndent?: boolean; skipValidation?: boolean },\n  ) {\n    const { checkIndent = true, skipValidation = false } = options ?? {}\n    const stanzas =\n      typeof raFile === 'string'\n        ? raFile.trimEnd().split(/(?:[\\t ]*\\r?\\n){2,}/)\n        : raFile\n    for (const stanza of stanzas) {\n      if (stanza === '') {\n        throw new Error('Invalid stanza, was empty')\n      }\n      if (stanza.startsWith('include')) {\n        continue\n      }\n      if (stanza.trim().startsWith('#')) {\n        const stanzaLines = stanza\n          .trimEnd()\n          .split(/\\r?\\n/)\n          .map(line => line.trim())\n        if (stanzaLines.every(line => line.startsWith('#'))) {\n          continue\n        }\n      }\n      const raStanza = new RaStanza(stanza, { checkIndent })\n      if (!this.nameKey) {\n        this.nameKey = raStanza.nameKey\n      } else if (raStanza.nameKey !== this.nameKey) {\n        throw new Error(\n          'The first line in each stanza must have the same key. ' +\n            `Saw both ${this.nameKey} and ${raStanza.nameKey}`,\n        )\n      }\n      if (!raStanza.name) {\n        throw new Error(`No stanza name: ${raStanza.name}`)\n      }\n      if (this.data[raStanza.name]) {\n        throw new Error(`Got duplicate stanza name: ${raStanza.name}`)\n      }\n\n      this.data[raStanza.name] = raStanza\n    }\n\n    if (!skipValidation) {\n      this.validate()\n    }\n  }\n\n  protected validate() {}\n}\n","import RaStanza from './raStanza.ts'\n\n// validate that all required fields are present in the map\nexport function validateRequiredFieldsArePresent(\n  map: RaStanza,\n  requiredFields: string[],\n  description = '',\n) {\n  const missingFields: string[] = []\n  for (const field of requiredFields) {\n    if (!map.data[field]) {\n      missingFields.push(field)\n    }\n  }\n  if (missingFields.length > 0) {\n    throw new Error(\n      `${description} is missing required entr${\n        missingFields.length === 1 ? 'y' : 'ies'\n      }: ${missingFields.join(', ')}`,\n    )\n  }\n}\n","import RaFile from './raFile.ts'\nimport { validateRequiredFieldsArePresent } from './util.ts'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [trackDbFile=[]] - A trackDb.txt file as a string\n * @throws {Error} Throws if \"track\" is not the first key in each track or if a\n * track is missing required keys\n */\nexport default class TrackDbFile extends RaFile {\n  constructor(\n    trackDbFile: string,\n    options?: ConstructorParameters<typeof RaFile>[1],\n  ) {\n    super(trackDbFile, { ...options, checkIndent: false })\n  }\n\n  protected validate() {\n    if (this.nameKey !== 'track') {\n      throw new Error(\n        `trackDb has \"${this.nameKey}\" instead of \"track\" as the first line in each track`,\n      )\n    }\n    for (const [trackName, track] of Object.entries(this.data)) {\n      const trackKeys = Object.keys(track.data)\n      validateRequiredFieldsArePresent(\n        track,\n        ['track', 'shortLabel'],\n        `Track ${trackName}`,\n      )\n\n      const parentTrackKeys = new Set([\n        'superTrack',\n        'compositeTrack',\n        'container',\n        'view',\n      ])\n      if (!trackKeys.some(key => parentTrackKeys.has(key))) {\n        if (!trackKeys.includes('bigDataUrl')) {\n          throw new Error(\n            `Track ${trackName} is missing required key \"bigDataUrl\"`,\n          )\n        }\n        if (!trackKeys.includes('type')) {\n          const settingsKeys = Object.keys(this.settings(trackName))\n          if (!settingsKeys.includes('type')) {\n            throw new Error(\n              `Neither track ${trackName} nor any of its parent tracks have the required key \"type\"`,\n            )\n          }\n        }\n      }\n      let currentTrackName: string | undefined = trackName\n      do {\n        // @ts-expect-error\n        currentTrackName = this.data[currentTrackName]?.parent as\n          | string\n          | undefined\n        if (currentTrackName) {\n          ;[currentTrackName] = currentTrackName.split(' ')\n        }\n      } while (currentTrackName)\n      const currentTrack = this.data[trackName]\n      if (currentTrack) {\n        this.data[trackName] = currentTrack\n      }\n    }\n  }\n\n  /**\n   * Gets all track entries including those of parent tracks, with closer\n   * entries overriding more distant ones\n   * @param {string} trackName The name of a track\n   * @throws {Error} Throws if track name does not exist in the trackDb\n   */\n  settings(trackName: string) {\n    if (!this.data[trackName]) {\n      throw new Error(`Track ${trackName} does not exist`)\n    }\n    const parentTracks = [trackName]\n    let currentTrackName: string | undefined = trackName\n    do {\n      // @ts-expect-error\n      currentTrackName = this.data[currentTrackName]?.parent as\n        | string\n        | undefined\n      if (currentTrackName) {\n        parentTracks.push(currentTrackName)\n      }\n    } while (currentTrackName)\n    const settings = {} as Record<string, unknown>\n    parentTracks.reverse()\n    for (const parentTrack of parentTracks) {\n      const ret = this.data[parentTrack]\n      if (ret) {\n        for (const [key, value] of Object.entries(ret)) {\n          settings[key] = value\n        }\n      }\n    }\n    return settings\n  }\n}\n","import RaFile from './raFile.ts'\nimport { validateRequiredFieldsArePresent } from './util.ts'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [genomesFile=[]] - A genomes.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"genome <genome_name>\" or if it has invalid entries\n */\nexport default class GenomesFile extends RaFile {\n  public validate(requiredFields = ['genome', 'trackDb']) {\n    // TODO: check if genome is hosted by UCSC and if not, require twoBitPath and groups\n\n    if (this.nameKey !== 'genome') {\n      throw new Error(\n        'Genomes file must begin with a line like \"genome <genome_name>\"',\n      )\n    }\n\n    for (const [genomeName, genome] of Object.entries(this.data)) {\n      validateRequiredFieldsArePresent(\n        genome,\n        requiredFields,\n        `genome ${genomeName}`,\n      )\n    }\n  }\n}\n","import RaStanza from './raStanza.ts'\nimport { validateRequiredFieldsArePresent } from './util.ts'\n\n/**\n * Class representing a hub.txt file.\n * @extends RaStanza\n * @param {(string|string[])} [hubFile=[]] - A hub.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"hub <hub_name>\", if it has invalid entries, or is missing required\n * entries\n */\nexport default class HubFile extends RaStanza {\n  protected validate() {\n    validateRequiredFieldsArePresent(\n      this,\n      ['hub', 'shortLabel', 'longLabel', 'genomesFile', 'email'],\n      'Hub file',\n    )\n  }\n}\n","import RaStanza from './raStanza.ts'\nimport TrackDbFile from './trackDbFile.ts'\nimport { validateRequiredFieldsArePresent } from './util.ts'\n\n/**\n * Class representing a \"single-file\" hub.txt file that contains all the\n * sections of a hub in a single file.\n */\nexport default class SingleFileHub {\n  public genome: RaStanza\n\n  public tracks: TrackDbFile\n\n  public hubData: RaStanza\n\n  constructor(hubText: string) {\n    const [hubSection, genomeSection, ...trackSections] = hubText\n      .trimEnd()\n      .split(/(?:[\\t ]*\\r?\\n){2,}/)\n    this.hubData = new RaStanza(hubSection)\n    this.validateHub()\n\n    this.genome = new RaStanza(genomeSection)\n    this.validateGenomeSection()\n\n    this.tracks = new TrackDbFile(trackSections.join('\\n\\n'), {\n      skipValidation: false,\n    })\n  }\n\n  protected validateHub() {\n    if (this.hubData.nameKey !== 'hub') {\n      throw new Error('Hub file must begin with a line like \"hub <hub_name>\"')\n    }\n\n    validateRequiredFieldsArePresent(this.hubData, [\n      'hub',\n      'shortLabel',\n      'longLabel',\n      'email',\n      // 'descriptionUrl', mpxvRivers has a typo\n    ])\n  }\n\n  protected validateGenomeSection() {\n    if (this.genome.nameKey !== 'genome') {\n      throw new Error(\n        'Genomes file must begin with a line like \"genome <genome_name>\"',\n      )\n    }\n  }\n}\n"],"names":["addRelativeUris","config","base","key","Object","keys","baseUri","href","async","doConnect","self","session","getSession","configJsonLocation","getConf","configJson","JSON","parse","openLocation","readFile","configUri","uri","URL","assemblies","assembly","assemblyManager","get","name","addSessionAssembly","tracks","addTrackConfs","notify","e","console","error","notifyError","breakConnection","configuration","RaStanza","constructor","stanza","options","data","checkIndent","skipValidation","stanzaLines","trimEnd","split","currentIndent","continuedLine","line","Error","trim","startsWith","endsWith","trimmedLine","slice","trimStart","combinedLine","undefined","indent","exec","sep","indexOf","this","nameKey","value","validate","RaFile","raFile","stanzas","map","every","raStanza","validateRequiredFieldsArePresent","requiredFields","description","missingFields","field","push","length","join","TrackDbFile","trackDbFile","super","trackName","track","entries","trackKeys","parentTrackKeys","Set","some","has","includes","settings","currentTrackName","parent","currentTrack","parentTracks","reverse","parentTrack","ret","GenomesFile","genomeName","genome","HubFile","SingleFileHub","hubText","hubSection","genomeSection","trackSections","hubData","validateHub","validateGenomeSection"],"sourceRoot":""}