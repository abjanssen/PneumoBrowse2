{"version":3,"file":"static/js/4613.eee21849.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/afterAttach.ts","webpack://@jbrowse/web/../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawCigarClickMap.ts","webpack://@jbrowse/web/../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawMouseover.ts","webpack://@jbrowse/web/../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/components/util.ts","webpack://@jbrowse/web/../../plugins/linear-comparative-view/src/LinearSyntenyDisplay/drawRef.ts"],"sourcesContent":["import { getContainingView, getSession } from '@jbrowse/core/util'\nimport { bpToPx } from '@jbrowse/core/util/Base1DUtils'\nimport { addDisposer, getSnapshot } from '@jbrowse/mobx-state-tree'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\nimport { autorun, reaction } from 'mobx'\n\nimport {\n  drawCigarClickMap,\n  drawMouseoverClickMap,\n  drawRef,\n} from './drawSynteny.ts'\n\nimport type { LinearSyntenyDisplayModel } from './model.ts'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface Pos {\n  offsetPx: number\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\ntype LSV = LinearSyntenyViewModel\n\nexport function doAfterAttach(self: LinearSyntenyDisplayModel) {\n  addDisposer(\n    self,\n    autorun(\n      function syntenyDrawAutorun() {\n        if (self.isMinimized) {\n          return\n        }\n        const view = getContainingView(self) as LinearSyntenyViewModel\n        if (\n          !view.initialized ||\n          !view.views.every(a => a.displayedRegions.length > 0 && a.initialized)\n        ) {\n          return\n        }\n\n        const ctx1 = self.mainCanvas?.getContext('2d')\n        const ctx3 = self.cigarClickMapCanvas?.getContext('2d')\n        if (!ctx1 || !ctx3) {\n          return\n        }\n\n        // Access alpha to make autorun react to alpha changes\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { alpha } = self\n        const height = self.height\n        const width = view.width\n        ctx1.clearRect(0, 0, width, height)\n\n        // Draw main canvas immediately\n        drawRef(self, ctx1)\n\n        drawCigarClickMap(self, ctx3)\n      },\n      { name: 'SyntenyDraw' },\n    ),\n  )\n\n  addDisposer(\n    self,\n    autorun(\n      function syntenyMouseoverAutorun() {\n        if (self.isMinimized) {\n          return\n        }\n        const view = getContainingView(self) as LinearSyntenyViewModel\n        if (\n          !view.initialized ||\n          !view.views.every(a => a.displayedRegions.length > 0 && a.initialized)\n        ) {\n          return\n        }\n        // Access reactive properties so autorun is triggered when they change\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\n        const { clickId, mouseoverId } = self\n        drawMouseoverClickMap(self)\n      },\n      { name: 'SyntenyMouseover' },\n    ),\n  )\n\n  // this attempts to reduce recalculation of feature positions drawn by the\n  // synteny view\n  //\n  // uses a reaction to say \"we know the positions don't change in any relevant\n  // way unless bpPerPx changes or displayedRegions changes\"\n  addDisposer(\n    self,\n    reaction(\n      () => {\n        if (self.isMinimized) {\n          return { initialized: false }\n        }\n        const view = getContainingView(self) as LSV\n        return {\n          bpPerPx: view.views.map(v => v.bpPerPx),\n\n          // stringifying 'deeply' accesses the displayed regions, see\n          // issue #3456\n          displayedRegions: JSON.stringify(\n            view.views.map(v => v.displayedRegions),\n          ),\n          features: self.features,\n          initialized:\n            view.initialized &&\n            view.views.every(\n              a => a.displayedRegions.length > 0 && a.initialized,\n            ),\n        }\n      },\n      ({ initialized }) => {\n        if (!initialized) {\n          return\n        }\n        const { level } = self\n        const { assemblyManager } = getSession(self)\n        const view = getContainingView(self) as LSV\n        const viewSnaps = view.views.map(view => ({\n          ...getSnapshot(view),\n          width: view.width,\n          staticBlocks: view.staticBlocks,\n          interRegionPaddingWidth: view.interRegionPaddingWidth,\n          minimumBlockWidth: view.minimumBlockWidth,\n        }))\n\n        const map = [] as FeatPos[]\n        const feats = self.features || []\n\n        for (const f of feats) {\n          const mate = f.get('mate')\n          let f1s = f.get('start')\n          let f1e = f.get('end')\n          const f2s = mate.start\n          const f2e = mate.end\n\n          if (f.get('strand') === -1) {\n            ;[f1e, f1s] = [f1s, f1e]\n          }\n          const a1 = assemblyManager.get(f.get('assemblyName'))\n          const a2 = assemblyManager.get(mate.assemblyName)\n          const r1 = f.get('refName')\n          const r2 = mate.refName\n          const ref1 = a1?.getCanonicalRefName(r1) || r1\n          const ref2 = a2?.getCanonicalRefName(r2) || r2\n          const v1 = viewSnaps[level]!\n          const v2 = viewSnaps[level + 1]!\n          const p11 = bpToPx({ self: v1, refName: ref1, coord: f1s })\n          const p12 = bpToPx({ self: v1, refName: ref1, coord: f1e })\n          const p21 = bpToPx({ self: v2, refName: ref2, coord: f2s })\n          const p22 = bpToPx({ self: v2, refName: ref2, coord: f2e })\n\n          if (\n            p11 === undefined ||\n            p12 === undefined ||\n            p21 === undefined ||\n            p22 === undefined\n          ) {\n            continue\n          }\n\n          const cigar = f.get('CIGAR') as string | undefined\n          map.push({\n            p11,\n            p12,\n            p21,\n            p22,\n            f,\n            cigar: MismatchParser.parseCigar(cigar),\n          })\n        }\n\n        self.setFeatPositions(map)\n      },\n      { fireImmediately: true },\n    ),\n  )\n}\n","import { doesIntersect2, getContainingView } from '@jbrowse/core/util'\n\nimport { draw } from './components/util.ts'\nimport {\n  MAX_COLOR_RANGE,\n  lineLimit,\n  makeColor,\n  oobLimit,\n} from './drawSyntenyUtils.ts'\n\nimport type { defaultCigarColors } from './drawSyntenyUtils.ts'\nimport type { LinearSyntenyDisplayModel } from './model.ts'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model.ts'\n\nexport function drawCigarClickMap(\n  model: LinearSyntenyDisplayModel,\n  cigarClickMapCanvas: CanvasRenderingContext2D,\n) {\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const drawCIGAR = view.drawCIGAR\n  const drawCIGARMatchesOnly = view.drawCIGARMatchesOnly\n  const { level, height, featPositions } = model\n  const width = view.width\n  const bpPerPxs = view.views.map(v => v.bpPerPx)\n\n  cigarClickMapCanvas.imageSmoothingEnabled = false\n  cigarClickMapCanvas.clearRect(0, 0, width, height)\n\n  const offsets = view.views.map(v => v.offsetPx)\n\n  // Cache reciprocals for division in CIGAR loop\n  const bpPerPxInv0 = 1 / bpPerPxs[level]!\n  const bpPerPxInv1 = 1 / bpPerPxs[level + 1]!\n\n  for (const { p11, p12, p21, p22, f, cigar } of featPositions) {\n    const x11 = p11.offsetPx - offsets[level]!\n    const x12 = p12.offsetPx - offsets[level]!\n    const x21 = p21.offsetPx - offsets[level + 1]!\n    const x22 = p22.offsetPx - offsets[level + 1]!\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const minX = Math.min(x21, x22)\n    const maxX = Math.max(x21, x22)\n    const y1 = 0\n    const y2 = height\n    const mid = (y2 - y1) / 2\n\n    if (\n      !(l1 <= lineLimit && l2 <= lineLimit) &&\n      doesIntersect2(minX, maxX, -oobLimit, view.width + oobLimit)\n    ) {\n      const s1 = f.get('strand')\n      const k1 = s1 === -1 ? x12 : x11\n      const k2 = s1 === -1 ? x11 : x12\n\n      const rev1 = k1 < k2 ? 1 : -1\n      const rev2 = (x21 < x22 ? 1 : -1) * s1\n\n      let cx1 = k1\n      let cx2 = s1 === -1 ? x22 : x21\n      if (cigar.length && drawCIGAR) {\n        let continuingFlag = false\n        let px1 = 0\n        let px2 = 0\n        const unitMultiplier2 = Math.floor(MAX_COLOR_RANGE / cigar.length)\n\n        for (let j = 0; j < cigar.length; j += 2) {\n          const len = +cigar[j]!\n          const op = cigar[j + 1] as keyof typeof defaultCigarColors\n\n          if (!continuingFlag) {\n            px1 = cx1\n            px2 = cx2\n          }\n\n          const d1 = len * bpPerPxInv0\n          const d2 = len * bpPerPxInv1\n\n          if (op === 'M' || op === '=' || op === 'X') {\n            cx1 += d1 * rev1\n            cx2 += d2 * rev2\n          } else if (op === 'D' || op === 'N') {\n            cx1 += d1 * rev1\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          else if (op === 'I') {\n            cx2 += d2 * rev2\n          }\n\n          if (\n            !(\n              Math.max(px1, px2, cx1, cx2) < 0 ||\n              Math.min(px1, px2, cx1, cx2) > width\n            )\n          ) {\n            const isNotLast = j < cigar.length - 2\n            if (\n              Math.abs(cx1 - px1) <= 1 &&\n              Math.abs(cx2 - px2) <= 1 &&\n              isNotLast\n            ) {\n              continuingFlag = true\n            } else {\n              continuingFlag = false\n              // When drawCIGARMatchesOnly is enabled, only draw match operations (M, =, X)\n              // Skip insertions (I) and deletions (D, N)\n              // Also skip very thin rectangles which tend to be glitchy\n              const shouldDraw =\n                !drawCIGARMatchesOnly ||\n                ((op === 'M' || op === '=' || op === 'X') &&\n                  Math.abs(cx1 - px1) > 1 &&\n                  Math.abs(cx2 - px2) > 1)\n\n              if (shouldDraw) {\n                const idx = j * unitMultiplier2 + 1\n                cigarClickMapCanvas.fillStyle = makeColor(idx)\n                draw(\n                  cigarClickMapCanvas,\n                  px1,\n                  cx1,\n                  y1,\n                  cx2,\n                  px2,\n                  y2,\n                  mid,\n                  drawCurves,\n                )\n                cigarClickMapCanvas.fill()\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { getContainingView } from '@jbrowse/core/util'\n\nimport { drawMatchSimple } from './components/util.ts'\nimport { oobLimit } from './drawSyntenyUtils.ts'\n\nimport type { LinearSyntenyDisplayModel } from './model.ts'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model.ts'\n\nexport function drawMouseoverClickMap(model: LinearSyntenyDisplayModel) {\n  const { level, clickId, mouseoverId } = model\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const height = model.height\n  const width = view.width\n  const ctx = model.mouseoverCanvas?.getContext('2d')\n  const offsets = view.views.map(v => v.offsetPx)\n\n  if (!ctx) {\n    return\n  }\n  ctx.resetTransform()\n  ctx.clearRect(0, 0, width, height)\n  ctx.strokeStyle = 'rgba(0, 0, 0, 0.9)'\n  ctx.fillStyle = 'rgba(0, 0, 0, 0.1)'\n\n  const feature1 = model.featMap[mouseoverId || '']\n  if (feature1) {\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.fill()\n      },\n      feature: feature1,\n      level,\n      ctx,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n\n  const feature2 = model.featMap[clickId || '']\n  if (feature2) {\n    drawMatchSimple({\n      cb: ctx => {\n        ctx.stroke()\n      },\n      feature: feature2,\n      ctx,\n      level,\n      oobLimit,\n      viewWidth: view.width,\n      drawCurves,\n      offsets,\n      height,\n    })\n  }\n}\n","import type React from 'react'\n\nimport {\n  assembleLocString,\n  doesIntersect2,\n  getContainingTrack,\n  getContainingView,\n  getSession,\n  isSessionModelWithWidgets,\n  toLocale,\n} from '@jbrowse/core/util'\n\nimport { MAX_COLOR_RANGE, getId } from '../drawSynteny.ts'\n\nimport type { LinearSyntenyDisplayModel } from '../model.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface Pos {\n  offsetPx: number\n}\n\nexport interface ClickCoord {\n  clientX: number\n  clientY: number\n  feature: { f: Feature }\n}\n\ninterface FeatPos {\n  p11: Pos\n  p12: Pos\n  p21: Pos\n  p22: Pos\n  f: Feature\n  cigar: string[]\n}\n\nexport function drawMatchSimple({\n  feature,\n  ctx,\n  offsets,\n  level,\n  cb,\n  height,\n  drawCurves,\n  oobLimit,\n  viewWidth,\n  hideTiny,\n}: {\n  feature: FeatPos\n  ctx: CanvasRenderingContext2D\n  offsets: number[]\n  level: number\n  oobLimit: number\n  viewWidth: number\n  cb: (ctx: CanvasRenderingContext2D) => void\n  height: number\n  drawCurves?: boolean\n  hideTiny?: boolean\n}) {\n  const { p11, p12, p21, p22 } = feature\n\n  const x11 = p11.offsetPx - offsets[level]!\n  const x12 = p12.offsetPx - offsets[level]!\n  const x21 = p21.offsetPx - offsets[level + 1]!\n  const x22 = p22.offsetPx - offsets[level + 1]!\n\n  const l1 = Math.abs(x12 - x11)\n  const l2 = Math.abs(x22 - x21)\n  const y1 = 0\n  const y2 = height\n  const mid = (y2 - y1) / 2\n  const minX = Math.min(x21, x22)\n  const maxX = Math.max(x21, x22)\n\n  if (!doesIntersect2(minX, maxX, -oobLimit, viewWidth + oobLimit)) {\n    return\n  }\n\n  // drawing a line if the results are thin: drawing a line results in much\n  // less pixellation than filling in a thin polygon\n  if (l1 <= 1 && l2 <= 1) {\n    // hideTiny can be used to avoid drawing mouseover for thin lines in this\n    // case\n    if (!hideTiny) {\n      ctx.beginPath()\n      ctx.moveTo(x11, y1)\n      if (drawCurves) {\n        ctx.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        ctx.lineTo(x21, y2)\n      }\n      ctx.stroke()\n    }\n  } else {\n    draw(ctx, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n    cb(ctx)\n  }\n}\n\nexport function draw(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n  drawCurves?: boolean,\n) {\n  if (drawCurves) {\n    drawBezierBox(ctx, x1, x2, y1, x3, x4, y2, mid)\n  } else {\n    drawBox(ctx, x1, x2, y1, x3, x4, y2)\n  }\n}\n\nexport function drawLocationMarkers(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n  bpPerPx1: number,\n  bpPerPx2: number,\n  drawCurves?: boolean,\n) {\n  const width1 = Math.abs(x2 - x1)\n  const width2 = Math.abs(x4 - x3)\n  const averageWidth = (width1 + width2) / 2\n\n  // Only draw markers for sufficiently large matches (wider than ~30 pixels)\n  if (averageWidth < 30) {\n    return\n  }\n\n  // Aim for markers at consistent pixel spacing for even visual density\n  // Target spacing of ~20 pixels between markers regardless of feature size\n  const targetPixelSpacing = 20\n  const numMarkers = Math.max(\n    2,\n    Math.floor(averageWidth / targetPixelSpacing) + 1,\n  )\n\n  const prevStrokeStyle = ctx.strokeStyle\n  const prevLineWidth = ctx.lineWidth\n\n  ctx.strokeStyle = 'rgba(0, 0, 0, 0.25)' // Dark semi-transparent line\n  ctx.lineWidth = 0.5\n\n  // Create single path for all markers\n  ctx.beginPath()\n  if (drawCurves) {\n    for (let step = 0; step < numMarkers; step++) {\n      const t = step / numMarkers\n      const topX = x1 + (x2 - x1) * t\n      const bottomX = x4 + (x3 - x4) * t\n      ctx.moveTo(topX, y1)\n      ctx.bezierCurveTo(topX, mid, bottomX, mid, bottomX, y2)\n    }\n  } else {\n    for (let step = 0; step < numMarkers; step++) {\n      const t = step / numMarkers\n      const topX = x1 + (x2 - x1) * t\n      const bottomX = x4 + (x3 - x4) * t\n      ctx.moveTo(topX, y1)\n      ctx.lineTo(bottomX, y2)\n    }\n  }\n  ctx.stroke()\n\n  ctx.strokeStyle = prevStrokeStyle\n  ctx.lineWidth = prevLineWidth\n}\n\nexport function drawBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n) {\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.lineTo(x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.closePath()\n}\n\nexport function drawBezierBox(\n  ctx: CanvasRenderingContext2D,\n  x1: number,\n  x2: number,\n  y1: number,\n  x3: number,\n  x4: number,\n  y2: number,\n  mid: number,\n) {\n  const len1 = Math.abs(x1 - x2)\n  const len2 = Math.abs(x1 - x2)\n\n  // heuristic to not draw hourglass inversions with bezier curves when they\n  // are thin and far apart because it results in areas that are not drawn well\n  // demo https://codesandbox.io/s/fast-glitter-q3b1or?file=/src/index.js\n  if (len1 < 5 && len2 < 5 && x2 < x1 && Math.abs(x1 - x3) > 100) {\n    const tmp = x1\n    x1 = x2\n    x2 = tmp\n  }\n  ctx.beginPath()\n  ctx.moveTo(x1, y1)\n  ctx.lineTo(x2, y1)\n  ctx.bezierCurveTo(x2, mid, x3, mid, x3, y2)\n  ctx.lineTo(x4, y2)\n  ctx.bezierCurveTo(x4, mid, x1, mid, x1, y1)\n  ctx.closePath()\n}\n\nexport function getFeatureAtClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n) {\n  const { clickMapCanvas, numFeats, featPositions } = model\n  if (!clickMapCanvas) {\n    return undefined\n  }\n  const ctx = clickMapCanvas.getContext('2d')\n  if (!ctx) {\n    return undefined\n  }\n  const rect = clickMapCanvas.getBoundingClientRect()\n  const x = event.clientX - rect.left\n  const y = event.clientY - rect.top\n  const [r, g, b] = ctx.getImageData(x, y, 1, 1).data\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / numFeats)\n  const id = getId(r!, g!, b!, unitMultiplier)\n  return featPositions[id]\n}\n\nexport function onSynClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n) {\n  const feat = getFeatureAtClick(event, model)\n  if (feat) {\n    const { f } = feat\n    model.setClickId(f.id())\n    const session = getSession(model)\n    if (isSessionModelWithWidgets(session)) {\n      const view = getContainingView(model)\n      const track = getContainingTrack(model)\n      session.showWidget(\n        session.addWidget('SyntenyFeatureWidget', 'syntenyFeature', {\n          view,\n          track,\n          featureData: f.toJSON(),\n          level: model.level,\n        }),\n      )\n    }\n  }\n  return feat\n}\n\nexport function onSynContextClick(\n  event: React.MouseEvent,\n  model: LinearSyntenyDisplayModel,\n  setAnchorEl: (arg: ClickCoord) => void,\n) {\n  event.preventDefault()\n  const feat = getFeatureAtClick(event, model)\n  if (feat) {\n    model.setClickId(feat.f.id())\n    setAnchorEl({\n      clientX: event.clientX,\n      clientY: event.clientY,\n      feature: feat,\n    })\n  }\n}\n\nexport function getTooltip({\n  feature,\n  cigarOp,\n  cigarOpLen,\n}: {\n  feature: Feature\n  cigarOpLen?: string\n  cigarOp?: string\n}) {\n  // @ts-expect-error\n  const f1 = feature.toJSON() as {\n    refName: string\n    start: number\n    end: number\n    strand?: number\n    assemblyName: string\n    identity?: number\n    name?: string\n    mate: {\n      start: number\n      end: number\n      refName: string\n      name: string\n    }\n  }\n  const f2 = f1.mate\n  const l1 = f1.end - f1.start\n  const l2 = f2.end - f2.start\n  const identity = f1.identity\n  const n1 = f1.name\n  const n2 = f2.name\n  return [\n    `Loc1: ${assembleLocString(f1)}`,\n    `Loc2: ${assembleLocString(f2)}`,\n    `Inverted: ${f1.strand === -1}`,\n    `Query len: ${toLocale(l1)}`,\n    `Target len: ${toLocale(l2)}`,\n    identity ? `Identity: ${identity.toPrecision(2)}` : '',\n    cigarOp ? `CIGAR operator: ${toLocale(+cigarOpLen!)}${cigarOp}` : '',\n    n1 ? `Name 1: ${n1}` : '',\n    n2 ? `Name 2: ${n2}` : '',\n  ]\n    .filter(f => !!f)\n    .join('<br/>')\n}\n","import { doesIntersect2, getContainingView } from '@jbrowse/core/util'\n\nimport {\n  draw,\n  drawLocationMarkers,\n  drawMatchSimple,\n} from './components/util.ts'\nimport {\n  MAX_COLOR_RANGE,\n  lineLimit,\n  makeColor,\n  oobLimit,\n} from './drawSyntenyUtils.ts'\n\nimport type { defaultCigarColors } from './drawSyntenyUtils.ts'\nimport type { LinearSyntenyDisplayModel } from './model.ts'\nimport type { LinearSyntenyViewModel } from '../LinearSyntenyView/model.ts'\n\n// Constant callback for click map fill - avoids creating new function each iteration\nconst fillCb = (ctx: CanvasRenderingContext2D) => {\n  ctx.fill()\n}\n\nexport function drawRef(\n  model: LinearSyntenyDisplayModel,\n  mainCanvas: CanvasRenderingContext2D,\n) {\n  const view = getContainingView(model) as LinearSyntenyViewModel\n  const drawCurves = view.drawCurves\n  const drawCIGAR = view.drawCIGAR\n  const drawCIGARMatchesOnly = view.drawCIGARMatchesOnly\n  const drawLocationMarkersEnabled = view.drawLocationMarkers\n  const { level, height, featPositions, minAlignmentLength, colorBy } = model\n  const width = view.width\n  const bpPerPxs = view.views.map(v => v.bpPerPx)\n\n  // Use cached colors from model (only recalculated when alpha/colorBy change)\n  const colorMapWithAlpha = model.colorMapWithAlpha\n  const posColorWithAlpha = model.posColorWithAlpha\n  const negColorWithAlpha = model.negColorWithAlpha\n  const getQueryColorWithAlpha = model.queryColorWithAlphaMap\n  const queryTotalLengths = model.queryTotalLengths\n\n  const offsets = view.views.map(v => v.offsetPx)\n  const offsetsL0 = offsets[level]!\n  const offsetsL1 = offsets[level + 1]!\n\n  const unitMultiplier = Math.floor(MAX_COLOR_RANGE / featPositions.length)\n  const y1 = 0\n  const y2 = height\n  const mid = (y2 - y1) / 2\n\n  // Cache colorBy checks outside loop for performance\n  const useStrandColor = colorBy === 'strand'\n  const useQueryColor = colorBy === 'query'\n\n  // Cache bpPerPx values and reciprocals for division in CIGAR loop\n  const bpPerPx0 = bpPerPxs[level]!\n  const bpPerPx1 = bpPerPxs[level + 1]!\n  const bpPerPxInv0 = 1 / bpPerPx0\n  const bpPerPxInv1 = 1 / bpPerPx1\n\n  // Get click map context once\n  const clickMapCtx = model.clickMapCanvas?.getContext('2d')\n  if (clickMapCtx) {\n    clickMapCtx.imageSmoothingEnabled = false\n    clickMapCtx.clearRect(0, 0, width, height)\n  }\n\n  mainCanvas.fillStyle = colorMapWithAlpha.M\n  mainCanvas.strokeStyle = colorMapWithAlpha.M\n\n  // Single loop over features - draw main canvas and click map together\n  for (const [i, featPosition] of featPositions.entries()) {\n    const feature = featPosition\n    const { p11, p12, p21, p22, f, cigar } = feature\n\n    // Cache feature properties\n    const strand = f.get('strand')\n    const refName = f.get('refName')\n\n    // Filter by minAlignmentLength if enabled\n    if (queryTotalLengths) {\n      const queryName = f.get('name') || f.get('id') || f.id()\n      const totalLength = queryTotalLengths.get(queryName) || 0\n      if (totalLength < minAlignmentLength) {\n        continue\n      }\n    }\n\n    const x11 = p11.offsetPx - offsetsL0\n    const x12 = p12.offsetPx - offsetsL0\n    const x21 = p21.offsetPx - offsetsL1\n    const x22 = p22.offsetPx - offsetsL1\n    const l1 = Math.abs(x12 - x11)\n    const l2 = Math.abs(x22 - x21)\n    const minX = Math.min(x21, x22)\n    const maxX = Math.max(x21, x22)\n\n    // Draw thin lines (when both dimensions are small)\n    if (\n      l1 <= lineLimit &&\n      l2 <= lineLimit &&\n      x21 < width + oobLimit &&\n      x21 > -oobLimit\n    ) {\n      // Set color for this line\n      if (useStrandColor) {\n        mainCanvas.strokeStyle =\n          strand === -1 ? negColorWithAlpha : posColorWithAlpha\n      } else if (useQueryColor) {\n        mainCanvas.strokeStyle = getQueryColorWithAlpha(refName)\n      } else {\n        mainCanvas.strokeStyle = colorMapWithAlpha.M\n      }\n\n      mainCanvas.beginPath()\n      mainCanvas.moveTo(x11, y1)\n      if (drawCurves) {\n        mainCanvas.bezierCurveTo(x11, mid, x21, mid, x21, y2)\n      } else {\n        mainCanvas.lineTo(x21, y2)\n      }\n      mainCanvas.stroke()\n    }\n    // Draw thick features\n    else if (doesIntersect2(minX, maxX, -oobLimit, view.width + oobLimit)) {\n      const s1 = strand\n      const k1 = s1 === -1 ? x12 : x11\n      const k2 = s1 === -1 ? x11 : x12\n\n      // rev1/rev2 flip the direction of the CIGAR drawing in horizontally flipped\n      // modes. somewhat heuristically determined, but tested for\n      const rev1 = k1 < k2 ? 1 : -1\n      const rev2 = (x21 < x22 ? 1 : -1) * s1\n\n      // cx1/cx2 are the current x positions on top and bottom rows\n      let cx1 = k1\n      let cx2 = s1 === -1 ? x22 : x21\n      if (cigar.length && drawCIGAR) {\n        // continuingFlag skips drawing commands on very small CIGAR features\n        let continuingFlag = false\n\n        // px1/px2 are the previous x positions on the top and bottom rows\n        let px1 = 0\n        let px2 = 0\n\n        for (let j = 0; j < cigar.length; j += 2) {\n          const len = +cigar[j]!\n          const op = cigar[j + 1] as keyof typeof defaultCigarColors\n\n          if (!continuingFlag) {\n            px1 = cx1\n            px2 = cx2\n          }\n\n          const d1 = len * bpPerPxInv0\n          const d2 = len * bpPerPxInv1\n\n          if (op === 'M' || op === '=' || op === 'X') {\n            cx1 += d1 * rev1\n            cx2 += d2 * rev2\n          } else if (op === 'D' || op === 'N') {\n            cx1 += d1 * rev1\n          }\n          // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n          else if (op === 'I') {\n            cx2 += d2 * rev2\n          }\n\n          // check that we are even drawing in view here, e.g. that all\n          // points are not all less than 0 or greater than width\n          if (\n            !(\n              Math.max(px1, px2, cx1, cx2) < 0 ||\n              Math.min(px1, px2, cx1, cx2) > width\n            )\n          ) {\n            // if it is a small feature and not the last element of the\n            // CIGAR (which could skip rendering it entire if we did turn\n            // it on), then turn on continuing flag\n            const isNotLast = j < cigar.length - 2\n            if (\n              Math.abs(cx1 - px1) <= 1 &&\n              Math.abs(cx2 - px2) <= 1 &&\n              isNotLast\n            ) {\n              continuingFlag = true\n            } else {\n              // allow rendering the dominant color when using continuing\n              // flag if the last element of continuing was a large\n              // feature, else just use match\n              const letter = (continuingFlag && d1 > 1) || d2 > 1 ? op : 'M'\n\n              // Use custom coloring based on colorBy setting\n              // Always keep yellow/blue for insertions/deletions regardless of colorBy\n              const isInsertionOrDeletion =\n                letter === 'I' || letter === 'D' || letter === 'N'\n              if (useStrandColor && !isInsertionOrDeletion) {\n                mainCanvas.fillStyle =\n                  strand === -1 ? negColorWithAlpha : posColorWithAlpha\n              } else if (useQueryColor && !isInsertionOrDeletion) {\n                mainCanvas.fillStyle = getQueryColorWithAlpha(refName)\n              } else {\n                mainCanvas.fillStyle = colorMapWithAlpha[letter]\n              }\n\n              continuingFlag = false\n\n              if (drawCIGARMatchesOnly) {\n                if (letter === 'M') {\n                  draw(mainCanvas, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                  mainCanvas.fill()\n                  if (drawLocationMarkersEnabled) {\n                    drawLocationMarkers(\n                      mainCanvas,\n                      px1,\n                      cx1,\n                      y1,\n                      cx2,\n                      px2,\n                      y2,\n                      mid,\n                      bpPerPx0,\n                      bpPerPx1,\n                      drawCurves,\n                    )\n                  }\n                }\n              } else {\n                draw(mainCanvas, px1, cx1, y1, cx2, px2, y2, mid, drawCurves)\n                mainCanvas.fill()\n                if (drawLocationMarkersEnabled) {\n                  drawLocationMarkers(\n                    mainCanvas,\n                    px1,\n                    cx1,\n                    y1,\n                    cx2,\n                    px2,\n                    y2,\n                    mid,\n                    bpPerPx0,\n                    bpPerPx1,\n                    drawCurves,\n                  )\n                }\n              }\n            }\n          }\n        }\n      } else {\n        // Use custom coloring based on colorBy setting\n        if (useStrandColor) {\n          mainCanvas.fillStyle =\n            strand === -1 ? negColorWithAlpha : posColorWithAlpha\n        } else if (useQueryColor) {\n          mainCanvas.fillStyle = getQueryColorWithAlpha(refName)\n        }\n\n        draw(mainCanvas, x11, x12, y1, x22, x21, y2, mid, drawCurves)\n        mainCanvas.fill()\n\n        // Reset to default color if needed\n        if (useStrandColor || useQueryColor) {\n          mainCanvas.fillStyle = colorMapWithAlpha.M\n        }\n      }\n    }\n\n    // Draw to click map (for all visible features, not just thick ones)\n    if (clickMapCtx) {\n      const idx = i * unitMultiplier + 1\n      clickMapCtx.fillStyle = makeColor(idx)\n\n      drawMatchSimple({\n        cb: fillCb,\n        feature,\n        ctx: clickMapCtx,\n        drawCurves,\n        level,\n        offsets,\n        oobLimit,\n        viewWidth: view.width,\n        hideTiny: true,\n        height,\n      })\n    }\n  }\n}\n"],"names":["doAfterAttach","self","addDisposer","autorun","isMinimized","view","getContainingView","initialized","views","every","a","displayedRegions","length","ctx1","mainCanvas","getContext","ctx3","cigarClickMapCanvas","alpha","height","width","clearRect","drawRef","model","drawCurves","drawCIGAR","drawCIGARMatchesOnly","level","featPositions","bpPerPxs","map","v","bpPerPx","imageSmoothingEnabled","offsets","offsetPx","bpPerPxInv0","bpPerPxInv1","p11","p12","p21","p22","f","cigar","x11","x12","x21","x22","l1","Math","abs","l2","minX","min","maxX","max","y1","y2","mid","lineLimit","doesIntersect2","oobLimit","s1","get","k1","rev1","rev2","cx1","cx2","continuingFlag","px1","px2","unitMultiplier2","floor","MAX_COLOR_RANGE","j","len","op","d1","d2","isNotLast","idx","fillStyle","makeColor","draw","fill","drawCigarClickMap","name","clickId","mouseoverId","ctx","mouseoverCanvas","resetTransform","strokeStyle","feature1","featMap","drawMatchSimple","cb","feature","viewWidth","feature2","stroke","drawMouseoverClickMap","reaction","JSON","stringify","features","assemblyManager","getSession","viewSnaps","getSnapshot","staticBlocks","interRegionPaddingWidth","minimumBlockWidth","feats","mate","f1s","f1e","f2s","start","f2e","end","a1","a2","assemblyName","r1","r2","refName","ref1","getCanonicalRefName","ref2","v1","v2","bpToPx","coord","undefined","push","MismatchParser","setFeatPositions","fireImmediately","hideTiny","beginPath","moveTo","bezierCurveTo","lineTo","x1","x2","x3","x4","len1","len2","tmp","closePath","drawBezierBox","drawBox","drawLocationMarkers","bpPerPx1","bpPerPx2","averageWidth","numMarkers","prevStrokeStyle","prevLineWidth","lineWidth","step","t","topX","bottomX","getFeatureAtClick","event","clickMapCanvas","numFeats","rect","getBoundingClientRect","x","clientX","left","y","clientY","top","r","g","b","getImageData","data","unitMultiplier","getId","onSynClick","feat","setClickId","id","session","isSessionModelWithWidgets","track","getContainingTrack","showWidget","addWidget","featureData","toJSON","onSynContextClick","setAnchorEl","preventDefault","getTooltip","cigarOp","cigarOpLen","f1","f2","identity","n1","n2","assembleLocString","strand","toLocale","toPrecision","filter","join","fillCb","drawLocationMarkersEnabled","minAlignmentLength","colorBy","colorMapWithAlpha","posColorWithAlpha","negColorWithAlpha","getQueryColorWithAlpha","queryColorWithAlphaMap","queryTotalLengths","offsetsL0","offsetsL1","useStrandColor","useQueryColor","bpPerPx0","clickMapCtx","M","i","featPosition","entries","queryName","letter","isInsertionOrDeletion"],"sourceRoot":""}