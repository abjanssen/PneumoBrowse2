{"version":3,"file":"static/js/208.bbc64e03.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+vcf@7.0.0/node_modules/@gmod/vcf/src/Variant.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+vcf@7.0.0/node_modules/@gmod/vcf/src/parseGenotypesOnly.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+vcf@7.0.0/node_modules/@gmod/vcf/src/processGenotypes.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+vcf@7.0.0/node_modules/@gmod/vcf/src/parseMetaString.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+vcf@7.0.0/node_modules/@gmod/vcf/src/vcfReserved.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+vcf@7.0.0/node_modules/@gmod/vcf/src/parse.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+vcf@7.0.0/node_modules/@gmod/vcf/src/parseBreakend.ts"],"sourcesContent":["import { parseGenotypesOnly } from './parseGenotypesOnly.ts'\nimport { processGenotypes } from './processGenotypes.ts'\n\nimport type { GenotypeCallback } from './processGenotypes.ts'\n\nfunction decodeURIComponentNoThrow(uri: string) {\n  try {\n    return decodeURIComponent(uri)\n  } catch (_e) {\n    // avoid throwing exception on a failure to decode URI component\n    return uri\n  }\n}\n\nexport class Variant {\n  CHROM: string | undefined\n  POS: number\n  ID: string[] | undefined\n  REF: string | undefined\n  ALT: string[] | undefined\n  QUAL: number | undefined\n  FILTER: string | string[] | undefined\n  INFO: Record<string, unknown>\n  FORMAT: string | undefined\n\n  private formatMeta: Record<string, { Type?: string }>\n  private rest: string\n  private sampleNames: string[]\n\n  constructor(\n    line: string,\n    infoMeta: Record<string, { Type?: string }>,\n    formatMeta: Record<string, { Type?: string }>,\n    sampleNames: string[],\n    strict: boolean,\n  ) {\n    let currChar = 0\n    let tabCount = 0\n    while (currChar < line.length && tabCount < 9) {\n      if (line[currChar] === '\\t') {\n        tabCount += 1\n      }\n      currChar += 1\n    }\n    const splitPos = tabCount === 9 ? currChar - 1 : currChar\n    const fields = line.slice(0, splitPos).split('\\t')\n    const rest = line.slice(splitPos + 1)\n    const [CHROM, POS, ID, REF, ALT, QUAL, FILTER] = fields\n    const filter = FILTER === '.' ? undefined : FILTER!.split(';')\n\n    if (strict && !fields[7]) {\n      throw new Error(\n        \"no INFO field specified, must contain at least a '.' (turn off strict mode to allow)\",\n      )\n    }\n\n    this.CHROM = CHROM\n    this.POS = +POS!\n    this.ID = ID === '.' ? undefined : ID!.split(';')\n    this.REF = REF\n    this.ALT = ALT === '.' ? undefined : ALT!.split(',')\n    this.QUAL = QUAL === '.' ? undefined : +QUAL!\n    this.FILTER = filter?.length === 1 && filter[0] === 'PASS' ? 'PASS' : filter\n    this.INFO =\n      fields[7] === undefined || fields[7] === '.'\n        ? {}\n        : this.parseInfo(fields[7], infoMeta)\n    this.FORMAT = fields[8]\n\n    this.formatMeta = formatMeta\n    this.rest = rest\n    this.sampleNames = sampleNames\n  }\n\n  private parseInfo(\n    infoStr: string,\n    infoMeta: Record<string, { Type?: string }>,\n  ) {\n    const result: Record<string, unknown> = {}\n    const hasDecode = infoStr.includes('%')\n    const infoPairs = infoStr.split(';')\n    const pairsLen = infoPairs.length\n\n    for (let i = 0; i < pairsLen; i++) {\n      const pair = infoPairs[i]!\n      const eqIdx = pair.indexOf('=')\n      const key = eqIdx === -1 ? pair : pair.slice(0, eqIdx)\n      const val = eqIdx === -1 ? undefined : pair.slice(eqIdx + 1)\n      const itemType = infoMeta[key]?.Type\n\n      if (itemType === 'Flag') {\n        result[key] = true\n      } else if (!val) {\n        result[key] = true\n      } else {\n        const isNumber = itemType === 'Integer' || itemType === 'Float'\n        const rawItems = val.split(',')\n        const itemsLen = rawItems.length\n\n        if (hasDecode) {\n          const items: (string | number | undefined)[] = []\n          for (let j = 0; j < itemsLen; j++) {\n            const v = rawItems[j]!\n            if (v === '.') {\n              items.push(undefined)\n            } else {\n              const decoded = decodeURIComponentNoThrow(v)\n              items.push(isNumber ? Number(decoded) : decoded)\n            }\n          }\n          result[key] = items\n        } else {\n          const items: (string | number | undefined)[] = []\n          for (let j = 0; j < itemsLen; j++) {\n            const v = rawItems[j]!\n            if (v === '.') {\n              items.push(undefined)\n            } else {\n              items.push(isNumber ? Number(v) : v)\n            }\n          }\n          result[key] = items\n        }\n      }\n    }\n    return result\n  }\n\n  SAMPLES() {\n    const genotypes = {} as Record<\n      string,\n      Record<string, (string | number | undefined)[] | undefined>\n    >\n    const format = this.FORMAT\n    if (format) {\n      const rest = this.rest.split('\\t')\n      const formatKeys = format.split(':')\n      const isNumberType: boolean[] = []\n      for (let i = 0; i < formatKeys.length; i++) {\n        const r = this.formatMeta[formatKeys[i]!]?.Type\n        isNumberType.push(r === 'Integer' || r === 'Float')\n      }\n      const numKeys = formatKeys.length\n      const samplesLen = this.sampleNames.length\n      for (let i = 0; i < samplesLen; i++) {\n        const sample = this.sampleNames[i]!\n        const sampleData: Record<\n          string,\n          (string | number | undefined)[] | undefined\n        > = {}\n        const sampleStr = rest[i]!\n        const sampleStrLen = sampleStr.length\n        let colStart = 0\n        let colIdx = 0\n\n        for (let j = 0; j <= sampleStrLen; j++) {\n          if (j === sampleStrLen || sampleStr[j] === ':') {\n            const val = sampleStr.slice(colStart, j)\n            if (val === '' || val === '.') {\n              sampleData[formatKeys[colIdx]!] = undefined\n            } else {\n              const items = val.split(',')\n              const result: (string | number | undefined)[] = []\n              if (isNumberType[colIdx]) {\n                for (let k = 0; k < items.length; k++) {\n                  const ent = items[k]!\n                  result.push(ent === '.' ? undefined : +ent)\n                }\n              } else {\n                for (let k = 0; k < items.length; k++) {\n                  const ent = items[k]!\n                  result.push(ent === '.' ? undefined : ent)\n                }\n              }\n              sampleData[formatKeys[colIdx]!] = result\n            }\n            colStart = j + 1\n            colIdx += 1\n            if (colIdx >= numKeys) {\n              break\n            }\n          }\n        }\n        genotypes[sample] = sampleData\n      }\n    }\n    return genotypes\n  }\n\n  GENOTYPES() {\n    return parseGenotypesOnly(this.FORMAT ?? '', this.rest, this.sampleNames)\n  }\n\n  processGenotypes(callback: GenotypeCallback) {\n    processGenotypes(\n      this.FORMAT ?? '',\n      this.rest,\n      this.sampleNames.length,\n      callback,\n    )\n  }\n\n  toJSON() {\n    return {\n      CHROM: this.CHROM,\n      POS: this.POS,\n      ID: this.ID,\n      REF: this.REF,\n      ALT: this.ALT,\n      QUAL: this.QUAL,\n      FILTER: this.FILTER,\n      INFO: this.INFO,\n      FORMAT: this.FORMAT,\n    }\n  }\n}\n","/**\n * Extracts genotype (GT) values from VCF sample data.\n */\nexport function parseGenotypesOnly(\n  format: string,\n  prerest: string,\n  samples: string[],\n) {\n  const genotypes = Object.create(null) as Record<string, string>\n\n  const samplesLen = samples.length\n  const prerestLen = prerest.length\n  const TAB = 9\n  const COLON = 58\n  let pos = 0\n\n  // Fast path: format is exactly \"GT\"\n  if (format === 'GT') {\n    for (let idx = 0; idx < samplesLen; idx++) {\n      const start = pos\n      while (pos < prerestLen && prerest.charCodeAt(pos) !== TAB) {\n        pos++\n      }\n      genotypes[samples[idx]!] = prerest.slice(start, pos)\n      pos++\n    }\n    return genotypes\n  }\n\n  // Check if GT field exists\n  const gtIdx = format.indexOf('GT')\n  if (gtIdx === -1) {\n    return genotypes\n  }\n\n  // GT is first field but not only field\n  if (gtIdx === 0) {\n    for (let idx = 0; idx < samplesLen; idx++) {\n      const start = pos\n      while (\n        pos < prerestLen &&\n        prerest.charCodeAt(pos) !== COLON &&\n        prerest.charCodeAt(pos) !== TAB\n      ) {\n        pos++\n      }\n      genotypes[samples[idx]!] = prerest.slice(start, pos)\n      while (pos < prerestLen && prerest.charCodeAt(pos) !== TAB) {\n        pos++\n      }\n      pos++\n    }\n    return genotypes\n  }\n\n  // GT is not first field\n  let colonCount = 0\n  for (let j = 0; j < gtIdx; j++) {\n    if (format.charCodeAt(j) === COLON) {\n      colonCount++\n    }\n  }\n  for (let idx = 0; idx < samplesLen; idx++) {\n    const sampleStart = pos\n    let tabIdx = pos\n    while (tabIdx < prerestLen && prerest.charCodeAt(tabIdx) !== TAB) {\n      tabIdx++\n    }\n\n    let colons = 0\n    let fieldStart = sampleStart\n    for (let j = sampleStart; j <= tabIdx; j++) {\n      if (j === tabIdx || prerest.charCodeAt(j) === COLON) {\n        if (colons === colonCount) {\n          genotypes[samples[idx]!] = prerest.slice(fieldStart, j)\n          break\n        }\n        colons++\n        fieldStart = j + 1\n      }\n    }\n    pos = tabIdx + 1\n  }\n\n  return genotypes\n}\n","/**\n * Callback type for processGenotypes - receives the raw string and\n * start/end indices to avoid string allocation\n */\nexport type GenotypeCallback = (str: string, start: number, end: number) => any\n\n/**\n * Process genotypes by calling a callback for each one, avoiding intermediate\n * object/string allocation. This is useful for operations like counting alleles\n * where you don't need to build the full genotypes object.\n *\n * @param format - The FORMAT field from the VCF line\n * @param prerest - The sample data portion of the VCF line (after FORMAT)\n * @param samplesLen - Number of samples\n * @param callback - Called for each genotype with (string, startIndex, endIndex)\n */\nexport function processGenotypes(\n  format: string,\n  prerest: string,\n  samplesLen: number,\n  callback: GenotypeCallback,\n) {\n  const prerestLen = prerest.length\n  const TAB = 9\n  const COLON = 58\n  let pos = 0\n\n  // Fast path: format is exactly \"GT\"\n  if (format === 'GT') {\n    for (let idx = 0; idx < samplesLen; idx++) {\n      const start = pos\n      while (pos < prerestLen && prerest.charCodeAt(pos) !== TAB) {\n        pos++\n      }\n      callback(prerest, start, pos)\n      pos++\n    }\n    return\n  }\n\n  // Check if GT field exists\n  const gtIdx = format.indexOf('GT')\n  if (gtIdx === -1) {\n    return\n  }\n\n  // GT is first field but not only field\n  if (gtIdx === 0) {\n    for (let idx = 0; idx < samplesLen; idx++) {\n      const start = pos\n      while (\n        pos < prerestLen &&\n        prerest.charCodeAt(pos) !== COLON &&\n        prerest.charCodeAt(pos) !== TAB\n      ) {\n        pos++\n      }\n      callback(prerest, start, pos)\n      while (pos < prerestLen && prerest.charCodeAt(pos) !== TAB) {\n        pos++\n      }\n      pos++\n    }\n    return\n  }\n\n  // GT is not first field - need to skip to the right column\n  let colonCount = 0\n  for (let j = 0; j < gtIdx; j++) {\n    if (format.charCodeAt(j) === COLON) {\n      colonCount++\n    }\n  }\n\n  for (let idx = 0; idx < samplesLen; idx++) {\n    const sampleStart = pos\n    let tabIdx = pos\n    while (tabIdx < prerestLen && prerest.charCodeAt(tabIdx) !== TAB) {\n      tabIdx++\n    }\n\n    let colons = 0\n    let fieldStart = sampleStart\n    for (let j = sampleStart; j <= tabIdx; j++) {\n      if (j === tabIdx || prerest.charCodeAt(j) === COLON) {\n        if (colons === colonCount) {\n          callback(prerest, fieldStart, j)\n          break\n        }\n        colons++\n        fieldStart = j + 1\n      }\n    }\n    pos = tabIdx + 1\n  }\n}\n","// constructed with the assistance of claude AI\n//\n// I first prompted it with a regex that splits a comma separated string with\n// awareness of quotation from this stackoverflow question\n// https://stackoverflow.com/a/18893443/2129219, and asked it to add support\n// for square brackets\n//\n// it undid the regex into serial logic and the result was this function\nfunction customSplit(str: string) {\n  const result = []\n  const chars = []\n  let inQuotes = false\n  let inBrackets = false\n  const strLen = str.length\n\n  for (let i = 0; i < strLen; i++) {\n    const char = str[i]!\n    if (char === '\"') {\n      inQuotes = !inQuotes\n      chars.push(char)\n    } else if (char === '[') {\n      inBrackets = true\n      chars.push(char)\n    } else if (char === ']') {\n      inBrackets = false\n      chars.push(char)\n    } else if (char === ',' && !inQuotes && !inBrackets) {\n      result.push(chars.join('').trim())\n      chars.length = 0\n    } else {\n      chars.push(char)\n    }\n  }\n\n  if (chars.length > 0) {\n    result.push(chars.join('').trim())\n  }\n\n  return result\n}\n\nfunction splitFirst(str: string, split: string) {\n  const index = str.indexOf(split)\n  return [str.slice(0, index), str.slice(index + 1)]\n}\n\nexport function parseMetaString(metaString: string) {\n  const inside = metaString.slice(1, -1)\n  const parts = customSplit(inside)\n  const entries: [string, any][] = []\n  for (let i = 0; i < parts.length; i++) {\n    const f = parts[i]!\n    const [key, val] = splitFirst(f, '=')\n    if (val && val.startsWith('[') && val.endsWith(']')) {\n      const items = val.slice(1, -1).split(',')\n      for (let j = 0; j < items.length; j++) {\n        items[j] = items[j]!.trim()\n      }\n      entries.push([key!, items])\n    } else if (val && val.startsWith('\"') && val.endsWith('\"')) {\n      entries.push([key!, val.slice(1, -1)])\n    } else {\n      entries.push([key!, val])\n    }\n  }\n  return Object.fromEntries(entries)\n}\n","export default {\n  // INFO fields\n  InfoFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AA: { Number: 1, Type: 'String', Description: 'Ancestral allele' },\n    AC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description:\n        'Allele count in genotypes, for each ALT allele, in the same order as listed',\n    },\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Total read depth for each allele',\n    },\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand',\n    },\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand',\n    },\n    AF: {\n      Number: 'A',\n      Type: 'Float',\n      Description:\n        'Allele frequency for each ALT allele in the same order as listed (estimated from primary data, not called genotypes)',\n    },\n    AN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Total number of alleles in called genotypes',\n    },\n    BQ: {\n      Number: 1,\n      Type: 'Float',\n      Description: 'RMS base quality',\n    },\n    CIGAR: {\n      Number: 1,\n      Type: 'Float',\n      Description:\n        'Cigar string describing how to align an alternate allele to the reference allele',\n    },\n    DB: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'dbSNP membership',\n    },\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'combined depth across samples',\n    },\n    END: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'End position (for use with symbolic alleles)',\n    },\n    H2: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap2 membership',\n    },\n    H3: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'HapMap3 membership',\n    },\n    MQ: {\n      Number: 1,\n      Type: null,\n      Description: 'RMS mapping quality',\n    },\n    MQ0: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of MAPQ == 0 reads',\n    },\n    NS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Number of samples with data',\n    },\n    SB: {\n      Number: 4,\n      Type: 'Integer',\n      Description: 'Strand bias',\n    },\n    SOMATIC: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Somatic mutation (for cancer genomics)',\n    },\n    VALIDATED: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Validated by follow-up experiment',\n    },\n    '1000G': {\n      Number: 0,\n      Type: 'Flag',\n      Description: '1000 Genomes membership',\n    },\n    // specifically for structural variants\n    IMPRECISE: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Imprecise structural variation',\n    },\n    NOVEL: {\n      Number: 0,\n      Type: 'Flag',\n      Description: 'Indicates a novel structural variation',\n    },\n    // For precise variants, END is POS + length of REF allele - 1,\n    // and the for imprecise variants the corresponding best estimate.\n    SVTYPE: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Type of structural variant',\n    },\n    // Value should be one of DEL, INS, DUP, INV, CNV, BND. This key can\n    // be derived from the REF/ALT fields but is useful for filtering.\n    SVLEN: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Difference in length between REF and ALT alleles',\n    },\n    // One value for each ALT allele. Longer ALT alleles (e.g. insertions)\n    // have positive values, shorter ALT alleles (e.g. deletions)\n    // have negative values.\n    CIPOS: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around POS for imprecise variants',\n    },\n    CIEND: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around END for imprecise variants',\n    },\n    HOMLEN: {\n      Type: 'Integer',\n      Description:\n        'Length of base pair identical micro-homology at event breakpoints',\n    },\n    HOMSEQ: {\n      Type: 'String',\n      Description:\n        'Sequence of base pair identical micro-homology at event breakpoints',\n    },\n    BKPTID: {\n      Type: 'String',\n      Description: 'ID of the assembled alternate allele in the assembly file',\n    },\n    // For precise variants, the consensus sequence the alternate allele assembly\n    // is derivable from the REF and ALT fields. However, the alternate allele\n    // assembly file may contain additional information about the characteristics\n    // of the alt allele contigs.\n    MEINFO: {\n      Number: 4,\n      Type: 'String',\n      Description: 'Mobile element info of the form NAME,START,END,POLARITY',\n    },\n    METRANS: {\n      Number: 4,\n      Type: 'String',\n      Description:\n        'Mobile element transduction info of the form CHR,START,END,POLARITY',\n    },\n    DGVID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in Database of Genomic Variation',\n    },\n    DBVARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBVAR',\n    },\n    DBRIPID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of this element in DBRIP',\n    },\n    MATEID: {\n      Number: null,\n      Type: 'String',\n      Description: 'ID of mate breakends',\n    },\n    PARID: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of partner breakend',\n    },\n    EVENT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'ID of event associated to breakend',\n    },\n    CILEN: {\n      Number: 2,\n      Type: 'Integer',\n      Description:\n        'Confidence interval around the inserted material between breakend',\n    },\n    DPADJ: { Type: 'Integer', Description: 'Read Depth of adjacency' },\n    CN: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Copy number of segment containing breakend',\n    },\n    CNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Copy number of adjacency',\n    },\n    CICN: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the segment',\n    },\n    CICNADJ: {\n      Number: null,\n      Type: 'Integer',\n      Description: 'Confidence interval around copy number for the adjacency',\n    },\n  },\n\n  // FORMAT fields\n  GenotypeFields: {\n    // from the VCF4.3 spec, https://samtools.github.io/hts-specs/VCFv4.3.pdf\n    AD: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele',\n    },\n    ADF: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the forward strand',\n    },\n    ADR: {\n      Number: 'R',\n      Type: 'Integer',\n      Description: 'Read depth for each allele on the reverse strand',\n    },\n    DP: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Read depth',\n    },\n    EC: {\n      Number: 'A',\n      Type: 'Integer',\n      Description: 'Expected alternate allele counts',\n    },\n    FT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Filter indicating if this genotype was \"called\"',\n    },\n    GL: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype likelihoods',\n    },\n    GP: {\n      Number: 'G',\n      Type: 'Float',\n      Description: 'Genotype posterior probabilities',\n    },\n    GQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Conditional genotype quality',\n    },\n    GT: {\n      Number: 1,\n      Type: 'String',\n      Description: 'Genotype',\n    },\n    HQ: {\n      Number: 2,\n      Type: 'Integer',\n      Description: 'Haplotype quality',\n    },\n    MQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'RMS mapping quality',\n    },\n    PL: {\n      Number: 'G',\n      Type: 'Integer',\n      Description:\n        'Phred-scaled genotype likelihoods rounded to the closest integer',\n    },\n    PQ: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phasing quality',\n    },\n    PS: {\n      Number: 1,\n      Type: 'Integer',\n      Description: 'Phase set',\n    },\n  },\n\n  // ALT fields\n  AltTypes: {\n    DEL: {\n      Description: 'Deletion relative to the reference',\n    },\n    INS: {\n      Description: 'Insertion of novel sequence relative to the reference',\n    },\n    DUP: {\n      Description: 'Region of elevated copy number relative to the reference',\n    },\n    INV: {\n      Description: 'Inversion of reference sequence',\n    },\n    CNV: {\n      Description:\n        'Copy number variable region (may be both deletion and duplication)',\n    },\n    'DUP:TANDEM': {\n      Description: 'Tandem duplication',\n    },\n    'DEL:ME': {\n      Description: 'Deletion of mobile element relative to the reference',\n    },\n    'INS:ME': {\n      Description: 'Insertion of a mobile element relative to the reference',\n    },\n    NON_REF: {\n      Description:\n        'Represents any possible alternative allele at this location',\n    },\n    '*': {\n      Description:\n        'Represents any possible alternative allele at this location',\n    },\n  },\n\n  // FILTER fields\n  FilterTypes: {\n    PASS: {\n      Description: 'Passed all filters',\n    },\n  },\n}\n","import { Variant } from './Variant.ts'\nimport { parseMetaString } from './parseMetaString.ts'\nimport vcfReserved from './vcfReserved.ts'\n\nexport { Variant } from './Variant.ts'\n\n/**\n * Class representing a VCF parser, instantiated with the VCF header.\n *\n * @param {object} args\n *\n * @param {string} args.header - The VCF header. Supports both LF and CRLF\n * newlines.\n *\n * @param {boolean} args.strict - Whether to parse in strict mode or not\n * (default true)\n */\nexport default class VCFParser {\n  private metadata: Record<string, unknown>\n  public strict: boolean\n  public samples: string[]\n\n  constructor({ header, strict = true }: { header: string; strict?: boolean }) {\n    if (!header.length) {\n      throw new Error('empty header received')\n    }\n    const headerLines = header.split(/[\\r\\n]+/).filter(Boolean)\n    if (!headerLines.length) {\n      throw new Error('no non-empty header lines specified')\n    }\n\n    this.strict = strict\n    this.metadata = {\n      INFO: { ...vcfReserved.InfoFields },\n      FORMAT: { ...vcfReserved.GenotypeFields },\n      ALT: { ...vcfReserved.AltTypes },\n      FILTER: { ...vcfReserved.FilterTypes },\n    }\n\n    let lastLine: string | undefined\n    for (let i = 0; i < headerLines.length; i++) {\n      const line = headerLines[i]!\n      if (!line.startsWith('#')) {\n        throw new Error(`Bad line in header:\\n${line}`)\n      } else if (line.startsWith('##')) {\n        this.parseMetadata(line)\n      } else {\n        lastLine = line\n      }\n    }\n\n    if (!lastLine) {\n      throw new Error('No format line found in header')\n    }\n    const fields = lastLine.trim().split('\\t')\n    const thisHeader = fields.slice(0, 8)\n    const correctHeader = [\n      '#CHROM',\n      'POS',\n      'ID',\n      'REF',\n      'ALT',\n      'QUAL',\n      'FILTER',\n      'INFO',\n    ]\n    if (fields.length < 8) {\n      throw new Error(`VCF header missing columns:\\n${lastLine}`)\n    } else if (\n      thisHeader.length !== correctHeader.length ||\n      !thisHeader.every((value, index) => value === correctHeader[index])\n    ) {\n      throw new Error(`VCF column headers not correct:\\n${lastLine}`)\n    }\n    this.samples = fields.slice(9)\n  }\n\n  /**\n   * Parse a VCF metadata line (i.e. a line that starts with \"##\") and add its\n   * properties to the object.\n   *\n   * @param {string} line - A line from the VCF. Supports both LF and CRLF\n   * newlines.\n   */\n  private parseMetadata(line: string) {\n    const match = /^##(.+?)=(.*)/.exec(line.trim())\n    if (!match) {\n      throw new Error(`Line is not a valid metadata line: ${line}`)\n    }\n    const [metaKey, metaVal] = match.slice(1, 3)\n\n    const r = metaKey!\n    if (metaVal?.startsWith('<')) {\n      if (!(r in this.metadata)) {\n        this.metadata[r] = {}\n      }\n      const [id, keyVals] = this.parseStructuredMetaVal(metaVal)\n      if (id) {\n        // if there is an ID field in the <> metadata\n        // e.g. ##INFO=<ID=AF_ESP,...>\n        ;(this.metadata[r] as Record<string, unknown>)[id] = keyVals\n      } else {\n        // if there is not an ID field in the <> metadata\n        // e.g. ##ID=<Description=\"ClinVar Variation ID\">\n        this.metadata[r] = keyVals\n      }\n    } else {\n      this.metadata[r] = metaVal\n    }\n  }\n\n  /**\n   * Parse a VCF header structured meta string (i.e. a meta value that starts\n   * with \"<ID=...\")\n   *\n   * @param {string} metaVal - The VCF metadata value\n   *\n   * @returns {Array} - Array with two entries, 1) a string of the metadata ID\n   * and 2) an object with the other key-value pairs in the metadata\n   */\n  private parseStructuredMetaVal(metaVal: string) {\n    const keyVals = parseMetaString(metaVal)\n    const id = keyVals.ID!\n    delete keyVals.ID\n    if ('Number' in keyVals) {\n      if (!Number.isNaN(Number(keyVals.Number))) {\n        keyVals.Number = Number(keyVals.Number)\n      }\n    }\n    return [id, keyVals] as const\n  }\n\n  /**\n   * Get metadata filtered by the elements in args. For example, can pass\n   * ('INFO', 'DP') to only get info on an metadata tag that was like\n   * \"##INFO=<ID=DP,...>\"\n   *\n   * @param  {...string} args - List of metadata filter strings.\n   *\n   * @returns {any} An object, string, or number, depending on the filtering\n   */\n  getMetadata(...args: string[]) {\n    let filteredMetadata: any = this.metadata\n    const argsLen = args.length\n    for (let i = 0; i < argsLen; i++) {\n      filteredMetadata = filteredMetadata[args[i]!]\n      if (!filteredMetadata) {\n        return filteredMetadata\n      }\n    }\n    return filteredMetadata\n  }\n\n  /**\n   * Parse a VCF line into a Variant object.\n   *\n   * The returned Variant has SAMPLES() and GENOTYPES() methods which are\n   * lazily evaluated to avoid parsing the potentially long list of samples from\n   * e.g. 1000 genotypes data unless requested.\n   *\n   * @param {string} line - A string of a line from a VCF\n   */\n  parseLine(line: string) {\n    return new Variant(\n      line,\n      this.metadata.INFO as Record<string, { Type?: string }>,\n      this.metadata.FORMAT as Record<string, { Type?: string }>,\n      this.samples,\n      this.strict,\n    )\n  }\n}\n","export interface Breakend {\n  Join: string\n  Replacement: string\n  MatePosition?: string\n  MateDirection?: string\n  SingleBreakend?: boolean\n}\n\nconst ANGLE_BRACKET_START_REGEX = /<(.*)>(.*)/\nconst ANGLE_BRACKET_END_REGEX = /(.*)<(.*)>/\n\nexport function parseBreakend(breakendString: string): Breakend | undefined {\n  const firstChar = breakendString[0]\n  const lastChar = breakendString[breakendString.length - 1]\n\n  if (\n    firstChar === '[' ||\n    firstChar === ']' ||\n    lastChar === '[' ||\n    lastChar === ']'\n  ) {\n    const tokens = breakendString.split(/[[\\]]/)\n    const MateDirection = breakendString.includes('[') ? 'right' : 'left'\n    let Join\n    let Replacement\n    let MatePosition\n    const tokensLen = tokens.length\n    for (let i = 0; i < tokensLen; i++) {\n      const tok = tokens[i]!\n      if (tok) {\n        if (tok.includes(':')) {\n          MatePosition = tok\n          Join = Replacement ? 'right' : 'left'\n        } else {\n          Replacement = tok\n        }\n      }\n    }\n    if (!(MatePosition && Join && Replacement)) {\n      throw new Error(`Invalid breakend: ${breakendString}`)\n    }\n    return { MatePosition, Join, Replacement, MateDirection }\n  }\n\n  if (firstChar === '.') {\n    return {\n      Join: 'left',\n      SingleBreakend: true,\n      Replacement: breakendString.slice(1),\n    }\n  }\n\n  if (lastChar === '.') {\n    return {\n      Join: 'right',\n      SingleBreakend: true,\n      Replacement: breakendString.slice(0, -1),\n    }\n  }\n\n  if (firstChar === '<') {\n    const res = ANGLE_BRACKET_START_REGEX.exec(breakendString)\n    if (!res) {\n      throw new Error(`failed to parse ${breakendString}`)\n    }\n    const Replacement = res[2]\n    return Replacement\n      ? {\n          Join: 'left',\n          Replacement,\n          MateDirection: 'right',\n          MatePosition: `<${res[1]!}>:1`,\n        }\n      : undefined\n  }\n\n  if (breakendString.includes('<')) {\n    const res = ANGLE_BRACKET_END_REGEX.exec(breakendString)\n    if (!res) {\n      throw new Error(`failed to parse ${breakendString}`)\n    }\n    const Replacement = res[1]\n    return Replacement\n      ? {\n          Join: 'right',\n          Replacement,\n          MateDirection: 'right',\n          MatePosition: `<${res[2]!}>:1`,\n        }\n      : undefined\n  }\n\n  return undefined\n}\n"],"names":["decodeURIComponentNoThrow","uri","decodeURIComponent","_e","Variant","constructor","line","infoMeta","formatMeta","sampleNames","strict","currChar","tabCount","length","splitPos","fields","slice","split","rest","CHROM","POS","ID","REF","ALT","QUAL","FILTER","filter","undefined","Error","this","INFO","parseInfo","FORMAT","infoStr","result","hasDecode","includes","infoPairs","pairsLen","i","pair","eqIdx","indexOf","key","val","itemType","Type","isNumber","rawItems","itemsLen","items","j","v","push","decoded","Number","SAMPLES","genotypes","format","formatKeys","isNumberType","r","numKeys","samplesLen","sample","sampleData","sampleStr","sampleStrLen","colStart","colIdx","k","ent","GENOTYPES","prerest","samples","Object","create","prerestLen","pos","idx","start","charCodeAt","gtIdx","colonCount","sampleStart","tabIdx","colons","fieldStart","parseGenotypesOnly","processGenotypes","callback","toJSON","splitFirst","str","index","AA","Description","AC","AD","ADF","ADR","AF","AN","BQ","CIGAR","DB","DP","END","H2","H3","MQ","MQ0","NS","SB","SOMATIC","VALIDATED","IMPRECISE","NOVEL","SVTYPE","SVLEN","CIPOS","CIEND","HOMLEN","HOMSEQ","BKPTID","MEINFO","METRANS","DGVID","DBVARID","DBRIPID","MATEID","PARID","EVENT","CILEN","DPADJ","CN","CNADJ","CICN","CICNADJ","EC","FT","GL","GP","GQ","GT","HQ","PL","PQ","PS","DEL","INS","DUP","INV","CNV","NON_REF","PASS","VCFParser","header","headerLines","Boolean","lastLine","metadata","vcfReserved","startsWith","parseMetadata","trim","thisHeader","correctHeader","every","value","match","exec","metaKey","metaVal","id","keyVals","parseStructuredMetaVal","metaString","parts","chars","inQuotes","inBrackets","strLen","char","join","customSplit","entries","f","endsWith","fromEntries","parseMetaString","isNaN","getMetadata","args","filteredMetadata","argsLen","parseLine","ANGLE_BRACKET_START_REGEX","ANGLE_BRACKET_END_REGEX","parseBreakend","breakendString","firstChar","lastChar","tokens","MateDirection","Join","Replacement","MatePosition","tokensLen","tok","SingleBreakend","res"],"sourceRoot":""}