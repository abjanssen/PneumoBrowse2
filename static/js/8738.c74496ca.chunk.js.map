{"version":3,"file":"static/js/8738.c74496ca.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedpeAdapter/util.ts","../../../plugins/bed/src/BedpeAdapter/BedpeAdapter.ts"],"sourcesContent":["import { SimpleFeature } from '@jbrowse/core/util'\n\nconst svTypes = new Set(['DUP', 'TRA', 'INV', 'CNV', 'DEL'])\n\nexport function featureData(\n  line: string,\n  uniqueId: string,\n  flip: boolean,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const ref1 = l[flip ? 3 : 0]!\n  const start1 = +l[flip ? 4 : 1]!\n  const end1 = +l[flip ? 5 : 2]!\n  const ref2 = l[!flip ? 3 : 0]!\n  const start2 = +l[!flip ? 4 : 1]!\n  const end2 = +l[!flip ? 5 : 2]!\n  const name = l[6]!\n  const score = +l[7]!\n  const strand1 = parseStrand(l[8]!)\n  const strand2 = parseStrand(l[9]!)\n  const extra = l.slice(10)\n  const rest = names\n    ? Object.fromEntries(names.slice(10).map((n, idx) => [n, extra[idx]]))\n    : {}\n  const ALT = svTypes.has(extra[0]!) ? `<${extra[0]}>` : undefined\n\n  return new SimpleFeature({\n    ...rest,\n    start: start1,\n    end: end1,\n    type: 'paired_feature',\n    refName: ref1,\n    strand: strand1,\n    name,\n    score,\n    uniqueId,\n    mate: {\n      refName: ref2,\n      start: start2,\n      end: end2,\n      strand: strand2,\n    },\n    ...(ALT ? { ALT: [ALT] } : {}), // ALT is an array in VCF\n  })\n}\n\nfunction parseStrand(strand: string) {\n  if (strand === '+') {\n    return 1\n  } else if (strand === '-') {\n    return -1\n  } else if (strand === '.') {\n    return 0\n  } else {\n    return undefined\n  }\n}\n","import IntervalTree from '@flatten-js/interval-tree'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { fetchAndMaybeUnzipText } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport { featureData } from './util'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nexport default class BedpeAdapter extends BaseFeatureDataAdapter {\n  protected bedpeFeatures?: Promise<{\n    header: string\n    feats1: Record<string, string[]>\n    feats2: Record<string, string[]>\n    columnNames: string[]\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree | undefined> | undefined\n  > = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts?: BaseOptions) {\n    const data = await fetchAndMaybeUnzipText(\n      openLocation(this.getConf('bedpeLocation'), this.pluginManager),\n      opts,\n    )\n\n    const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const headerLines = []\n    let i = 0\n    for (; i < lines.length && lines[i]!.startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n    const feats1 = {} as Record<string, string[]>\n    const feats2 = {} as Record<string, string[]>\n    for (; i < lines.length; i++) {\n      const line = lines[i]!\n      const cols = line.split('\\t')\n      const r1 = cols[0]!\n      const r2 = cols[3]!\n      if (!feats1[r1]) {\n        feats1[r1] = []\n      }\n      if (!feats2[r2]) {\n        feats2[r2] = []\n      }\n      feats1[r1].push(line)\n      feats2[r2].push(line)\n    }\n    const columnNames = this.getConf('columnNames')\n\n    return {\n      header,\n      feats1,\n      feats2,\n      columnNames,\n    }\n  }\n\n  private async loadData(opts: BaseOptions = {}) {\n    if (!this.bedpeFeatures) {\n      this.bedpeFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedpeFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedpeFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { feats1, feats2 } = await this.loadData(opts)\n    return [...new Set([...Object.keys(feats1), ...Object.keys(feats2)])]\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureTreeP(refName: string) {\n    const { feats1, feats2 } = await this.loadData()\n    const names = await this.getNames()\n    const intervalTree = new IntervalTree()\n    const ret1 =\n      feats1[refName]?.map((f, i) =>\n        featureData(f, `${this.id}-${refName}-${i}-r1`, false, names),\n      ) ?? []\n    const ret2 =\n      feats2[refName]?.map((f, i) =>\n        featureData(f, `${this.id}-${refName}-${i}-r2`, true, names),\n      ) ?? []\n\n    for (const obj of [...ret1, ...ret2]) {\n      intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n    }\n\n    return intervalTree\n  }\n\n  private async loadFeatureTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureTreeP(refName).catch(\n        (e: unknown) => {\n          this.intervalTrees[refName] = undefined\n          throw e\n        },\n      )\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureTree(refName)\n      for (const f of intervalTree?.search([start, end]) || []) {\n        observer.next(f)\n      }\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["svTypes","Set","featureData","line","uniqueId","flip","names","l","split","ref1","start1","end1","ref2","start2","end2","name","score","strand1","parseStrand","strand2","extra","slice","rest","Object","fromEntries","map","n","idx","ALT","has","undefined","SimpleFeature","start","end","type","refName","strand","mate","BedpeAdapter","BaseFeatureDataAdapter","intervalTrees","loadDataP","opts","lines","fetchAndMaybeUnzipText","openLocation","this","getConf","pluginManager","filter","f","headerLines","i","length","startsWith","push","header","join","feats1","feats2","cols","r1","r2","columnNames","loadData","bedpeFeatures","catch","e","getRefNames","keys","getHeader","getNames","defline","at","includes","field","trim","loadFeatureTreeP","intervalTree","IntervalTree","ret1","id","ret2","obj","insert","get","loadFeatureTree","getFeatures","query","ObservableCreate","async","search","observer","next","complete","stopToken","freeResources"],"sourceRoot":""}