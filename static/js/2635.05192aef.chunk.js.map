{"version":3,"file":"static/js/2635.05192aef.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts","../../../plugins/gff3/src/Gff3Adapter/gffParser.ts","../../../packages/core/util/parseLineByLine.ts","../../../plugins/gff3/src/featureData.ts"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { parseStringSync } from 'gff-nostream'\n\nimport { featureData } from '../featureData'\nimport { parseGffBuffer } from './gffParser'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { NoAssemblyRegion } from '@jbrowse/core/util/types'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  gffFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  private async loadDataP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const buffer = await fetchAndMaybeUnzip(\n      openLocation(this.getConf('gffLocation'), this.pluginManager),\n      opts,\n    )\n\n    const { header, featureMap } = parseGffBuffer(buffer, statusCallback)\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing GFF data')\n            const intervalTree = new IntervalTree()\n            for (const obj of parseStringSync(lines)\n              .flat()\n              .map(\n                (f, i) =>\n                  new SimpleFeature({\n                    data: featureData(f),\n                    id: `${this.id}-${refName}-${i}`,\n                  }),\n              )) {\n              intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n            }\n\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header,\n      intervalTreeMap,\n    }\n  }\n\n  private async loadData(opts: BaseOptions) {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.loadData(opts)\n    return Object.keys(intervalTreeMap)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTreeMap } = await this.loadData(opts)\n        for (const f of intervalTreeMap[refName]?.(opts.statusCallback).search([\n          start,\n          end,\n        ]) || []) {\n          observer.next(f)\n        }\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n}\n","import { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\n\nimport type { StatusCallback } from '@jbrowse/core/util/parseLineByLine'\n\ninterface GffParseResult {\n  header: string\n  featureMap: Record<string, string>\n}\n\n/**\n * Parse GFF3 buffer into header lines and feature map organized by reference name\n * @param buffer - The GFF3 file buffer\n * @param statusCallback - Optional callback for progress updates\n * @returns Object containing header lines and feature map\n */\nexport function parseGffBuffer(\n  buffer: Uint8Array,\n  statusCallback: StatusCallback = () => {},\n): GffParseResult {\n  const headerLines: string[] = []\n  const featureMap: Record<string, string> = {}\n\n  parseLineByLine(\n    buffer,\n    line => {\n      if (line.startsWith('#')) {\n        headerLines.push(line)\n      } else if (line.startsWith('>')) {\n        return false // Stop parsing at FASTA section\n      } else {\n        const ret = line.indexOf('\\t')\n        const refName = line.slice(0, ret)\n        if (!featureMap[refName]) {\n          featureMap[refName] = ''\n        }\n        featureMap[refName] += `${line}\\n`\n      }\n      return true\n    },\n    statusCallback,\n  )\n\n  return {\n    header: headerLines.join('\\n'),\n    featureMap,\n  }\n}\n","import { getProgressDisplayStr } from './index'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n","import type { GFF3FeatureLineWithRefs } from 'gff-nostream'\n\ninterface GFF3Feature {\n  start: number\n  end: number\n  strand?: number\n  type: string | null\n  source: string | null\n  refName: string\n  derived_features: unknown[] | null\n  phase?: number\n  score?: number\n  subfeatures: GFF3Feature[] | undefined\n  [key: string]: unknown\n}\n\nexport function featureData(data: GFF3FeatureLineWithRefs): GFF3Feature {\n  const {\n    end,\n    start,\n    child_features,\n    derived_features,\n    attributes,\n    type,\n    source,\n    phase,\n    seq_id,\n    score,\n    strand,\n  } = data\n\n  let strand2: number | undefined\n  if (strand === '+') {\n    strand2 = 1\n  } else if (strand === '-') {\n    strand2 = -1\n  } else if (strand === '.') {\n    strand2 = 0\n  }\n\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_id',\n    'score',\n    'type',\n    'source',\n    'phase',\n    'strand',\n  ])\n  const dataAttributes = attributes || {}\n  const resultAttributes = {} as Record<string, unknown>\n  for (const a of Object.keys(dataAttributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (dataAttributes[a] && a !== '_lineHash') {\n      let attr: string | string[] | undefined = dataAttributes[a]\n      if (Array.isArray(attr) && attr.length === 1) {\n        ;[attr] = attr\n      }\n      resultAttributes[b] = attr\n    }\n  }\n\n  return {\n    ...resultAttributes,\n    start: start! - 1,\n    end: end!,\n    strand: strand2,\n    type,\n    source,\n    refName: seq_id!,\n    derived_features,\n    phase: phase === null ? undefined : Number(phase),\n    score: score === null ? undefined : score,\n    subfeatures: child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    ),\n  }\n}\n"],"names":["Gff3Adapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","loadDataP","opts","statusCallback","buffer","fetchAndMaybeUnzip","openLocation","this","getConf","pluginManager","header","featureMap","headerLines","parseLineByLine","line","startsWith","push","ret","indexOf","refName","slice","join","parseGffBuffer","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","intervalTree","IntervalTree","obj","parseStringSync","flat","f","i","SimpleFeature","data","featureData","id","insert","get","loadData","gffFeatures","catch","e","undefined","getRefNames","keys","getHeader","getFeatures","query","ObservableCreate","async","start","end","search","observer","next","complete","error","stopToken","lineCallback","decoder","TextDecoder","blockStart","length","n","lineEnd","b","subarray","decode","trim","getProgressDisplayStr","child_features","derived_features","attributes","type","source","phase","seq_id","score","strand","strand2","defaultFields","Set","dataAttributes","resultAttributes","a","toLowerCase","has","attr","Array","isArray","Number","subfeatures","flatMap","childLocs","childLoc"],"sourceRoot":""}