{"version":3,"file":"static/js/8857.697c3748.chunk.js","mappings":"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","sources":["../../../plugins/wiggle/src/drawLine.ts","../../../plugins/wiggle/src/LinePlotRenderer/renderLinePlot.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp } from '@jbrowse/core/util'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { WIGGLE_CLIP_HEIGHT, WIGGLE_FUDGE_FACTOR, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type {\n  Feature,\n  LastStopTokenCheck,\n  Region,\n  StopToken,\n} from '@jbrowse/core/util'\n\nexport function drawLine(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    regions: Region[]\n    bpPerPx: number\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    displayCrossHatches: boolean\n    colorCallback: (f: Feature, score: number) => string\n    config: AnyConfigurationModel\n    offset?: number\n    stopToken?: StopToken\n    lastCheck?: LastStopTokenCheck\n    // when color is static (e.g. in Multi renderers), set strokeStyle once and skip callback\n    staticColor?: string\n  },\n) {\n  const {\n    features,\n    regions,\n    bpPerPx,\n    scaleOpts,\n    height: unadjustedHeight,\n    ticks: { values },\n    displayCrossHatches,\n    colorCallback,\n    config,\n    offset = 0,\n    staticColor,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const regionStart = region.start\n  const regionEnd = region.end\n  const reversed = region.reversed\n  const invBpPerPx = 1 / bpPerPx\n  const width = (regionEnd - regionStart) * invBpPerPx\n\n  const height = unadjustedHeight - offset * 2\n  const clipColor = readConfObject(config, 'clipColor')\n\n  // Use d3-scale only to get the \"niced\" domain, then use simple arithmetic\n  const scale = getScale({ ...scaleOpts, range: [0, height] })\n  const domain = scale.domain() as [number, number]\n  const niceMin = domain[0]\n  const niceMax = domain[1]\n  const domainSpan = niceMax - niceMin\n  const isLog = scaleOpts.scaleType === 'log'\n\n  // Precompute values for linear scale\n  const linearRatio = domainSpan !== 0 ? height / domainSpan : 0\n\n  // Precompute values for log scale (base 2)\n  const log2 = Math.log(2)\n  const logMin = Math.log(niceMin) / log2\n  const logMax = Math.log(niceMax) / log2\n  const logSpan = logMax - logMin\n  const logRatio = logSpan !== 0 ? height / logSpan : 0\n\n  // Simple arithmetic scale function - avoid d3-scale overhead in hot path\n  const toY = isLog\n    ? (n: number) =>\n        clamp(height - (Math.log(n) / log2 - logMin) * logRatio, 0, height) +\n        offset\n    : (n: number) =>\n        clamp(height - (n - niceMin) * linearRatio, 0, height) + offset\n\n  let lastVal: number | undefined\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n\n  // when staticColor is set, batch all path operations into a single stroke\n  if (staticColor) {\n    ctx.beginPath()\n    ctx.strokeStyle = staticColor\n    const clippingFeatures: { leftPx: number; w: number; high: boolean }[] = []\n\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = reversed\n        ? (regionEnd - fEnd) * invBpPerPx\n        : (fStart - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - fStart) * invBpPerPx\n        : (fEnd - regionStart) * invBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      // bitwise OR is faster than Math.floor for positive numbers\n      if ((leftPx | 0) !== (prevLeftPx | 0) || rightPx - leftPx > 1) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      const score = feature.get('score')\n      const scoreY = toY(score)\n\n      // track clipping\n      if (score > niceMax) {\n        clippingFeatures.push({\n          leftPx,\n          w: rightPx - leftPx + WIGGLE_FUDGE_FACTOR,\n          high: true,\n        })\n      } else if (score < niceMin && !isLog) {\n        clippingFeatures.push({\n          leftPx,\n          w: rightPx - leftPx + WIGGLE_FUDGE_FACTOR,\n          high: false,\n        })\n      }\n\n      const startY = lastVal !== undefined ? toY(lastVal) : scoreY\n      if (!reversed) {\n        ctx.moveTo(leftPx, startY)\n        ctx.lineTo(leftPx, scoreY)\n        ctx.lineTo(rightPx, scoreY)\n      } else {\n        ctx.moveTo(rightPx, startY)\n        ctx.lineTo(rightPx, scoreY)\n        ctx.lineTo(leftPx, scoreY)\n      }\n      lastVal = score\n    }\n    // single stroke for entire path\n    ctx.stroke()\n\n    // draw clipping indicators\n    if (clippingFeatures.length > 0) {\n      ctx.fillStyle = clipColor\n      for (const { leftPx, w, high } of clippingFeatures) {\n        if (high) {\n          ctx.fillRect(leftPx, offset, w, WIGGLE_CLIP_HEIGHT)\n        } else {\n          ctx.fillRect(\n            leftPx,\n            height - WIGGLE_CLIP_HEIGHT,\n            w,\n            WIGGLE_CLIP_HEIGHT,\n          )\n        }\n      }\n    }\n  } else {\n    // non-static color: stroke per feature (original behavior)\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = reversed\n        ? (regionEnd - fEnd) * invBpPerPx\n        : (fStart - regionStart) * invBpPerPx\n      const rightPx = reversed\n        ? (regionEnd - fStart) * invBpPerPx\n        : (fEnd - regionStart) * invBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      // bitwise OR is faster than Math.floor for positive numbers\n      if ((leftPx | 0) !== (prevLeftPx | 0) || rightPx - leftPx > 1) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      const score = feature.get('score')\n      const scoreY = toY(score)\n      const w = rightPx - leftPx + WIGGLE_FUDGE_FACTOR\n\n      const c = colorCallback(feature, score)\n\n      ctx.beginPath()\n      ctx.strokeStyle = c\n      const startY = lastVal !== undefined ? toY(lastVal) : scoreY\n      if (!reversed) {\n        ctx.moveTo(leftPx, startY)\n        ctx.lineTo(leftPx, scoreY)\n        ctx.lineTo(rightPx, scoreY)\n      } else {\n        ctx.moveTo(rightPx, startY)\n        ctx.lineTo(rightPx, scoreY)\n        ctx.lineTo(leftPx, scoreY)\n      }\n      ctx.stroke()\n      lastVal = score\n\n      if (score > niceMax) {\n        ctx.fillStyle = clipColor\n        ctx.fillRect(leftPx, offset, w, WIGGLE_CLIP_HEIGHT)\n      } else if (score < niceMin && !isLog) {\n        ctx.fillStyle = clipColor\n        ctx.fillRect(leftPx, height - WIGGLE_CLIP_HEIGHT, w, WIGGLE_CLIP_HEIGHT)\n      }\n    }\n  }\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    for (const tick of values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n  return {\n    reducedFeatures,\n  }\n}\n","import { renderToAbstractCanvas, updateStatus } from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\n\nimport { drawLine } from '../drawLine.ts'\nimport { getColorCallback, serializeWiggleFeature } from '../util.ts'\n\nimport type { RenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderLinePlot(\n  renderProps: RenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    config,\n    height,\n    regions,\n    bpPerPx,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const colorCallback = getColorCallback(config, { defaultColor: 'grey' })\n\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx =>\n        drawLine(ctx, {\n          ...renderProps,\n          features,\n          colorCallback,\n        }),\n      ),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n"],"names":["drawLine","ctx","props","features","regions","bpPerPx","scaleOpts","height","unadjustedHeight","ticks","values","displayCrossHatches","colorCallback","config","offset","staticColor","stopToken","lastCheck","createStopTokenChecker","region","regionStart","start","regionEnd","end","reversed","invBpPerPx","width","clipColor","readConfObject","domain","getScale","range","niceMin","niceMax","domainSpan","isLog","scaleType","linearRatio","log2","Math","log","logMin","logSpan","logRatio","toY","n","clamp","lastVal","prevLeftPx","Number","NEGATIVE_INFINITY","reducedFeatures","beginPath","strokeStyle","clippingFeatures","feature","checkStopToken2","fStart","get","fEnd","leftPx","rightPx","push","score","scoreY","w","WIGGLE_FUDGE_FACTOR","high","startY","undefined","moveTo","lineTo","stroke","length","fillStyle","fillRect","WIGGLE_CLIP_HEIGHT","c","lineWidth","tick","round","async","renderLinePlot","renderProps","statusCallback","getColorCallback","defaultColor","rest","updateStatus","renderToAbstractCanvas","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables"],"ignoreList":[],"sourceRoot":""}