{"version":3,"file":"static/js/2367.6ff9a878.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/shared/drawAlleleCount.ts","../../../plugins/variants/src/MultiLinearVariantMatrixRenderer/makeImageData.ts","../../../plugins/variants/src/shared/constants.ts","../../../plugins/variants/src/shared/drawPhased.ts","../../../plugins/variants/src/shared/util.ts"],"sourcesContent":["import { colord } from '@jbrowse/core/util/colord'\n\nimport { f2 } from './constants'\n\nexport function getColorAlleleCount(\n  ref: number,\n  alt: number,\n  alt2: number,\n  uncalled: number,\n  total: number,\n  drawReference = true,\n) {\n  if (ref === total) {\n    // empty string is not defined, but signals no draw\n    return drawReference ? '#ccc' : ''\n  } else {\n    let a1\n    if (alt) {\n      a1 = colord(`hsl(200,50%,${80 - (alt / total) * 50}%)`)\n    }\n    if (alt2) {\n      const l = `hsla(0,100%,20%,${alt2 / total})`\n      // @ts-ignore\n      a1 = a1 ? a1.mix(l) : colord(l)\n    }\n    if (uncalled) {\n      const l = `hsl(50,50%,50%,${uncalled / total})`\n      // @ts-ignore\n      a1 = a1 ? a1.mix(l) : colord(l)\n    }\n    return a1?.toHex() || 'black'\n  }\n}\n\nexport function drawColorAlleleCount(\n  c: string,\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  featureType = '',\n  featureStrand?: number,\n  alpha = 1,\n) {\n  ctx.fillStyle = alpha !== 1 ? colord(c).alpha(alpha).toHex() : c\n  if (featureType === 'inversion') {\n    // draw triangle pointing to the right\n    if (featureStrand === 1) {\n      ctx.beginPath()\n      ctx.moveTo(x - f2, y - f2) // left top\n      ctx.lineTo(x - f2, y + h + f2) // left bottom\n      ctx.lineTo(x + w + f2, y + h / 2) // right middle\n      ctx.closePath()\n      ctx.fill()\n    } else {\n      // draw triangle pointing to the left\n      ctx.beginPath()\n      ctx.moveTo(x + w + f2, y - f2) // right top\n      ctx.lineTo(x + w + f2, y + h + f2) // right bottom\n      ctx.lineTo(x - f2, y + h / 2) // left middle\n      ctx.closePath()\n      ctx.fill()\n    }\n  } else {\n    ctx.fillRect(x - f2, y - f2, w + f2, h + f2)\n  }\n}\n","import { forEachWithStopTokenCheck, updateStatus } from '@jbrowse/core/util'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport { f2 } from '../shared/constants'\nimport {\n  drawColorAlleleCount,\n  getColorAlleleCount,\n} from '../shared/drawAlleleCount'\nimport { drawPhased } from '../shared/drawPhased'\nimport { getFeaturesThatPassMinorAlleleFrequencyFilter } from '../shared/minorAlleleFrequencyUtils'\n\nimport type { RenderArgsDeserialized } from './types'\n\ntype SampleGenotype = Record<string, string[]>\n\nexport async function makeImageData({\n  ctx,\n  canvasWidth,\n  canvasHeight,\n  renderArgs,\n}: {\n  ctx: CanvasRenderingContext2D\n  canvasWidth: number\n  canvasHeight: number\n  renderArgs: RenderArgsDeserialized\n}) {\n  const {\n    renderingMode,\n    minorAlleleFrequencyFilter,\n    sources,\n    features,\n    stopToken,\n    lengthCutoffFilter,\n  } = renderArgs\n\n  const { statusCallback = () => {} } = renderArgs\n  const h = canvasHeight / sources.length\n  checkStopToken(stopToken)\n  const mafs = await updateStatus('Calculating stats', statusCallback, () =>\n    getFeaturesThatPassMinorAlleleFrequencyFilter({\n      stopToken,\n      features: features.values(),\n      minorAlleleFrequencyFilter,\n      lengthCutoffFilter,\n    }),\n  )\n  checkStopToken(stopToken)\n  const arr = [] as string[][]\n  const m = mafs.length\n  const w = canvasWidth / m\n\n  await updateStatus('Drawing variant matrix', statusCallback, () => {\n    const colorCache = {} as Record<string, string | undefined>\n    forEachWithStopTokenCheck(\n      mafs,\n      stopToken,\n      ({ feature, mostFrequentAlt }, idx) => {\n        const arr2 = [] as string[]\n        const hasPhaseSet = (\n          feature.get('FORMAT') as string | undefined\n        )?.includes('PS')\n        if (hasPhaseSet) {\n          const samp = feature.get('samples') as Record<string, SampleGenotype>\n          const x = (idx / mafs.length) * canvasWidth\n          const sln = sources.length\n          for (let j = 0; j < sln; j++) {\n            const y = (j / sln) * canvasHeight\n            const { name, HP } = sources[j]!\n            const s = samp[name]\n            if (s) {\n              const genotype = s.GT?.[0]\n              if (genotype) {\n                arr2.push(genotype)\n                const isPhased = genotype.includes('|')\n                if (renderingMode === 'phased') {\n                  if (isPhased) {\n                    const PS = s.PS?.[0]\n                    const alleles = genotype.split('|')\n                    drawPhased(alleles, ctx, x, y, w, h, HP!, PS)\n                  } else {\n                    ctx.fillStyle = 'black'\n                    ctx.fillRect(x - f2, y - f2, w + f2, h + f2)\n                  }\n                } else {\n                  const cacheKey = `${genotype}:${mostFrequentAlt}`\n                  let c = colorCache[cacheKey]\n                  if (c === undefined) {\n                    let alt = 0\n                    let uncalled = 0\n                    let alt2 = 0\n                    let ref = 0\n                    const alleles = genotype.split(/[/|]/)\n                    const total = alleles.length\n\n                    for (let i = 0; i < total; i++) {\n                      const allele = alleles[i]!\n                      if (allele === mostFrequentAlt) {\n                        alt++\n                      } else if (allele === '0') {\n                        ref++\n                      } else if (allele === '.') {\n                        uncalled++\n                      } else {\n                        alt2++\n                      }\n                    }\n                    c = getColorAlleleCount(\n                      ref,\n                      alt,\n                      alt2,\n                      uncalled,\n                      total,\n                      true,\n                    )\n                    colorCache[cacheKey] = c\n                  }\n                  if (c) {\n                    drawColorAlleleCount(c, ctx, x, y, w, h)\n                  }\n                }\n              }\n            }\n          }\n        } else {\n          const samp = feature.get('genotypes') as Record<string, string>\n          const x = (idx / mafs.length) * canvasWidth\n          const sln = sources.length\n          for (let j = 0; j < sln; j++) {\n            const y = (j / sln) * canvasHeight\n            const { name, HP } = sources[j]!\n            const genotype = samp[name]\n            if (genotype) {\n              arr2.push(genotype)\n              const isPhased = genotype.includes('|')\n              if (renderingMode === 'phased') {\n                if (isPhased) {\n                  const alleles = genotype.split('|')\n                  drawPhased(alleles, ctx, x, y, w, h, HP!)\n                } else {\n                  ctx.fillStyle = 'black'\n                  ctx.fillRect(x - f2, y - f2, w + f2, h + f2)\n                }\n              } else {\n                const cacheKey = `${genotype}:${mostFrequentAlt}`\n                let c = colorCache[cacheKey]\n                if (c === undefined) {\n                  let alt = 0\n                  let uncalled = 0\n                  let alt2 = 0\n                  let ref = 0\n                  const alleles = genotype.split(/[/|]/)\n                  const total = alleles.length\n\n                  for (let i = 0; i < total; i++) {\n                    const allele = alleles[i]!\n                    if (allele === mostFrequentAlt) {\n                      alt++\n                    } else if (allele === '0') {\n                      ref++\n                    } else if (allele === '.') {\n                      uncalled++\n                    } else {\n                      alt2++\n                    }\n                  }\n                  c = getColorAlleleCount(ref, alt, alt2, uncalled, total, true)\n                  colorCache[cacheKey] = c\n                }\n                if (c) {\n                  drawColorAlleleCount(c, ctx, x, y, w, h)\n                }\n              }\n            }\n          }\n        }\n        arr.push(arr2)\n      },\n    )\n  })\n  return {\n    mafs,\n    arr,\n  }\n}\n","export const fudgeFactor = 0.6\nexport const f2 = fudgeFactor / 2\n","import { set1 } from '@jbrowse/core/ui/colors'\nimport { colord } from '@jbrowse/core/util/colord'\n\nimport { f2 } from './constants'\nimport { colorify } from './util'\n\nfunction getColorPhased(alleles: string[], HP: number, drawReference = true) {\n  const c = +alleles[HP]!\n  return c ? set1[c - 1] || 'black' : drawReference ? '#ccc' : undefined\n}\n\nfunction getColorPhasedWithPhaseSet(\n  alleles: string[],\n  HP: number,\n  PS: string,\n  drawReference = true,\n) {\n  const c = +alleles[HP]!\n  return c ? colorify(+PS) || 'black' : drawReference ? '#ccc' : undefined\n}\n\nexport function drawPhased(\n  alleles: string[],\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  HP: number,\n  PS?: string,\n  drawReference = true,\n  alpha = 1,\n) {\n  const c =\n    PS !== undefined\n      ? getColorPhasedWithPhaseSet(alleles, HP, PS, drawReference)\n      : getColorPhased(alleles, HP, drawReference)\n  if (c) {\n    ctx.fillStyle = alpha !== 1 ? colord(c).alpha(alpha).toHex() : c\n    ctx.fillRect(x - f2, y - f2, w + f2, h + f2)\n  }\n  return c\n}\n","// avoid drawing negative width features for SVG exports\nexport function fillRectCtx(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  ctx: CanvasRenderingContext2D,\n  color?: string,\n) {\n  if (width < 0) {\n    x += width\n    width = -width\n  }\n  if (height < 0) {\n    y += height\n    height = -height\n  }\n\n  if (color) {\n    ctx.fillStyle = color\n  }\n  ctx.fillRect(x, y, width, height)\n}\n\nexport function colorify(n: number) {\n  return `hsl(${n % 255}, 50%, 50%)`\n}\n"],"names":["getColorAlleleCount","ref","alt","alt2","uncalled","total","drawReference","a1","colord","l","mix","toHex","drawColorAlleleCount","c","ctx","x","y","w","h","featureType","featureStrand","alpha","fillStyle","beginPath","moveTo","f2","lineTo","closePath","fill","fillRect","async","makeImageData","canvasWidth","canvasHeight","renderArgs","renderingMode","minorAlleleFrequencyFilter","sources","features","stopToken","lengthCutoffFilter","statusCallback","length","checkStopToken","mafs","updateStatus","getFeaturesThatPassMinorAlleleFrequencyFilter","values","arr","m","colorCache","forEachWithStopTokenCheck","feature","mostFrequentAlt","idx","arr2","hasPhaseSet","get","includes","samp","sln","j","name","HP","s","genotype","GT","push","isPhased","PS","alleles","split","drawPhased","cacheKey","undefined","i","allele","fudgeFactor","getColorPhasedWithPhaseSet","set1","getColorPhased"],"sourceRoot":""}