{"version":3,"file":"static/js/1569.19797c95.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/canvas/src/CanvasFeatureRenderer/CanvasFeatureRendering.tsx"],"sourcesContent":["import { useCallback, useMemo, useRef, useState } from 'react'\n\nimport { PrerenderedCanvas } from '@jbrowse/core/ui'\nimport { getSession } from '@jbrowse/core/util'\nimport Flatbush from '@jbrowse/core/util/flatbush'\nimport { observer } from 'mobx-react'\n\nimport type { FlatbushItem, SubfeatureInfo } from './types.ts'\nimport type { Region } from '@jbrowse/core/util/types'\nimport type { BaseLinearDisplayModel } from '@jbrowse/plugin-linear-genome-view'\n\nconst CanvasFeatureRendering = observer(function CanvasFeatureRendering(props: {\n  blockKey: string\n  displayModel: BaseLinearDisplayModel\n  width: number\n  height: number\n  regions: Region[]\n  bpPerPx: number\n  items: FlatbushItem[]\n  flatbush: ArrayBufferLike\n  subfeatureInfos?: SubfeatureInfo[]\n  subfeatureFlatbush?: ArrayBufferLike\n  onContextMenu?: (e: React.MouseEvent) => void\n}) {\n  const {\n    displayModel,\n    width,\n    height,\n    flatbush,\n    items,\n    subfeatureFlatbush,\n    subfeatureInfos = [],\n    onContextMenu,\n  } = props\n  const flatbush2 = useMemo(() => Flatbush.from(flatbush), [flatbush])\n  const subfeatureFlatbush2 = useMemo(\n    () => (subfeatureFlatbush ? Flatbush.from(subfeatureFlatbush) : null),\n    [subfeatureFlatbush],\n  )\n\n  // Create efficient lookup map for items by feature ID\n  const itemsById = useMemo(() => {\n    const map = new Map<string, FlatbushItem>()\n    for (const item of items) {\n      map.set(item.featureId, item)\n    }\n    return map\n  }, [items])\n\n  const {\n    selectedFeatureId,\n    featureIdUnderMouse,\n    subfeatureIdUnderMouse,\n    contextMenuFeature,\n  } = displayModel\n\n  const ref = useRef<HTMLDivElement>(null)\n  const [mouseIsDown, setMouseIsDown] = useState(false)\n  const [movedDuringLastMouseDown, setMovedDuringLastMouseDown] =\n    useState(false)\n  const mouseDownPos = useRef<{ x: number; y: number } | null>(null)\n\n  // Create lookup map for subfeatureInfos by featureId\n  const subfeatureInfosById = useMemo(() => {\n    const map = new Map<string, SubfeatureInfo>()\n    for (const info of subfeatureInfos) {\n      map.set(info.featureId, info)\n    }\n    return map\n  }, [subfeatureInfos])\n\n  // Hit detection helper - finds feature/subfeature at given coordinates\n  const getFeatureAtPosition = useCallback(\n    (offsetX: number, offsetY: number) => {\n      const search = flatbush2.search(\n        offsetX,\n        offsetY,\n        offsetX + 1,\n        offsetY + 1,\n      )\n      const item = search.length ? items[search[0]!] : undefined\n      if (!item) {\n        return {\n          item: undefined,\n          featureId: undefined,\n          parentFeatureId: undefined,\n        }\n      }\n\n      let featureId = item.featureId\n      let parentFeatureId: string | undefined\n\n      if (subfeatureFlatbush2 && subfeatureInfos.length) {\n        const subSearch = subfeatureFlatbush2.search(\n          offsetX,\n          offsetY,\n          offsetX + 1,\n          offsetY + 1,\n        )\n        if (subSearch.length) {\n          const info = subfeatureInfos[subSearch[0]!]\n          if (info) {\n            featureId = info.featureId\n            parentFeatureId = info.parentFeatureId\n          }\n        }\n      }\n      return { item, featureId, parentFeatureId }\n    },\n    [flatbush2, items, subfeatureFlatbush2, subfeatureInfos],\n  )\n\n  // For selected features, check subfeatures first, then items\n  const selectedSubfeature = selectedFeatureId\n    ? subfeatureInfosById.get(selectedFeatureId)\n    : undefined\n  const selectedItem =\n    selectedFeatureId && !selectedSubfeature\n      ? itemsById.get(selectedFeatureId)\n      : undefined\n\n  // For highlighted features, use subfeature bounds if available\n  const highlightedFeature = featureIdUnderMouse || contextMenuFeature?.id()\n  const highlightedSubfeature = subfeatureIdUnderMouse\n    ? subfeatureInfosById.get(subfeatureIdUnderMouse)\n    : undefined\n  const highlightedItem =\n    highlightedFeature && !highlightedSubfeature\n      ? itemsById.get(highlightedFeature)\n      : undefined\n\n  // Convert pixel bounds to display rectangle\n  function boundsToRect(\n    bounds: {\n      leftPx: number\n      topPx: number\n      rightPx: number\n      bottomPx: number\n    },\n    offset = 2,\n  ) {\n    const rectTop = Math.round(bounds.topPx)\n    const rectHeight = Math.round(bounds.bottomPx - bounds.topPx)\n    return {\n      left: bounds.leftPx - offset,\n      top: rectTop - offset,\n      width: bounds.rightPx - bounds.leftPx,\n      height: rectHeight,\n    }\n  }\n\n  const selected = selectedSubfeature\n    ? boundsToRect(selectedSubfeature)\n    : selectedItem\n      ? boundsToRect(selectedItem)\n      : undefined\n  const highlight = highlightedSubfeature\n    ? boundsToRect(highlightedSubfeature, 0)\n    : highlightedItem\n      ? boundsToRect(highlightedItem, 0)\n      : undefined\n\n  const canvasWidth = Math.ceil(width)\n  return (\n    <div\n      ref={ref}\n      data-testid=\"canvas-feature-overlay\"\n      style={{\n        position: 'relative',\n        width: canvasWidth,\n        height,\n      }}\n      onMouseLeave={() => {\n        displayModel.setFeatureIdUnderMouse(undefined)\n        displayModel.setSubfeatureIdUnderMouse(undefined)\n        displayModel.setMouseoverExtraInformation(undefined)\n      }}\n      onMouseDown={(event: React.MouseEvent) => {\n        setMouseIsDown(true)\n        setMovedDuringLastMouseDown(false)\n        if (ref.current) {\n          const rect = ref.current.getBoundingClientRect()\n          const scrollT = ref.current.scrollTop\n          mouseDownPos.current = {\n            x: event.clientX - rect.left,\n            y: event.clientY - rect.top + scrollT,\n          }\n        }\n      }}\n      onMouseUp={() => {\n        setMouseIsDown(false)\n      }}\n      onMouseMove={event => {\n        if (!ref.current) {\n          return\n        }\n        const rect = ref.current.getBoundingClientRect()\n        const scrollT = ref.current.scrollTop\n        const offsetX = event.clientX - rect.left\n        const offsetY = event.clientY - rect.top + scrollT\n\n        // Only set movedDuringLastMouseDown if mouse has moved more than 3px\n        if (mouseIsDown && mouseDownPos.current) {\n          const dx = offsetX - mouseDownPos.current.x\n          const dy = offsetY - mouseDownPos.current.y\n          const distance = Math.sqrt(dx * dx + dy * dy)\n          if (distance > 3) {\n            setMovedDuringLastMouseDown(true)\n          }\n        }\n\n        const { item, featureId, parentFeatureId } = getFeatureAtPosition(\n          offsetX,\n          offsetY,\n        )\n\n        // Build tooltip with subfeature info\n        let extra = item?.tooltip\n        if (extra && parentFeatureId) {\n          const subInfo = subfeatureInfosById.get(featureId)\n          if (subInfo) {\n            const { displayLabel, type } = subInfo\n            extra += `<br/>${displayLabel ? `${displayLabel} (${type})` : type}`\n          }\n        }\n\n        displayModel.setFeatureIdUnderMouse(item?.featureId)\n        displayModel.setSubfeatureIdUnderMouse(\n          parentFeatureId ? featureId : undefined,\n        )\n        displayModel.setMouseoverExtraInformation(extra)\n      }}\n      onClick={event => {\n        if (!movedDuringLastMouseDown && ref.current) {\n          const rect = ref.current.getBoundingClientRect()\n          const scrollT = ref.current.scrollTop\n          const offsetX = event.clientX - rect.left\n          const offsetY = event.clientY - rect.top + scrollT\n\n          const { item, featureId, parentFeatureId } = getFeatureAtPosition(\n            offsetX,\n            offsetY,\n          )\n          if (item) {\n            // Pass the top-level feature ID for RPC lookup since nested\n            // subfeature parents may not be in the layout cache\n            displayModel\n              .selectFeatureById(featureId, parentFeatureId, item.featureId)\n              .catch((e: unknown) => {\n                console.error(e)\n                getSession(displayModel).notifyError(`${e}`, e)\n              })\n          } else {\n            displayModel.clearFeatureSelection()\n          }\n        }\n      }}\n      onContextMenu={event => {\n        if (ref.current) {\n          const rect = ref.current.getBoundingClientRect()\n          const scrollT = ref.current.scrollTop\n          const offsetX = event.clientX - rect.left\n          const offsetY = event.clientY - rect.top + scrollT\n\n          const { item, featureId, parentFeatureId } = getFeatureAtPosition(\n            offsetX,\n            offsetY,\n          )\n          if (item) {\n            displayModel\n              .setContextMenuFeatureById(\n                featureId,\n                parentFeatureId,\n                item.featureId,\n              )\n              .catch((e: unknown) => {\n                console.error(e)\n                getSession(displayModel).notifyError(`${e}`, e)\n              })\n          } else {\n            onContextMenu?.(event)\n          }\n        } else {\n          onContextMenu?.(event)\n        }\n      }}\n    >\n      <PrerenderedCanvas\n        {...props}\n        style={{ position: 'absolute', left: 0, top: 0 }}\n      />\n      {highlight ? (\n        <div\n          style={{\n            position: 'absolute',\n            backgroundColor: '#00000033',\n            pointerEvents: 'none',\n            zIndex: 10,\n            ...highlight,\n          }}\n        />\n      ) : null}\n      {selected ? (\n        <div\n          style={{\n            position: 'absolute',\n            border: '2px solid #00b8ff',\n            boxSizing: 'content-box',\n            pointerEvents: 'none',\n            ...selected,\n          }}\n        />\n      ) : null}\n    </div>\n  )\n})\n\nexport default CanvasFeatureRendering\n"],"names":["observer","props","displayModel","width","height","flatbush","items","subfeatureFlatbush","subfeatureInfos","onContextMenu","flatbush2","useMemo","Flatbush","from","subfeatureFlatbush2","itemsById","map","Map","item","set","featureId","selectedFeatureId","featureIdUnderMouse","subfeatureIdUnderMouse","contextMenuFeature","ref","useRef","mouseIsDown","setMouseIsDown","useState","movedDuringLastMouseDown","setMovedDuringLastMouseDown","mouseDownPos","subfeatureInfosById","info","getFeatureAtPosition","useCallback","offsetX","offsetY","search","length","undefined","parentFeatureId","subSearch","selectedSubfeature","get","selectedItem","highlightedFeature","id","highlightedSubfeature","highlightedItem","boundsToRect","bounds","offset","rectTop","Math","round","topPx","rectHeight","bottomPx","left","leftPx","top","rightPx","selected","highlight","canvasWidth","ceil","_jsxs","style","position","onMouseLeave","setFeatureIdUnderMouse","setSubfeatureIdUnderMouse","setMouseoverExtraInformation","onMouseDown","event","current","rect","getBoundingClientRect","scrollT","scrollTop","x","clientX","y","clientY","onMouseUp","onMouseMove","dx","dy","sqrt","extra","tooltip","subInfo","displayLabel","type","onClick","selectFeatureById","catch","e","console","error","getSession","notifyError","clearFeatureSelection","setContextMenuFeatureById","children","_jsx","PrerenderedCanvas","backgroundColor","pointerEvents","zIndex","border","boxSizing"],"sourceRoot":""}