"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[9280],{79280:(e,t,n)=>{n.r(t),n.d(t,{default:()=>b});var s=n(46377),i=n(99834),a=n(66885),r=n(6434);const o=BigInt(32);"getBigInt64"in DataView||(DataView.prototype.getBigInt64=function(e,t){return function(e,t,n){const s=Number(!!n),i=Number(!n);return BigInt(e.getInt32(t,n)*i+e.getInt32(t+4,n)*s)<<o|BigInt(e.getUint32(t,n)*s+e.getUint32(t+4,n)*i)}(this,e,t)}),"getBigUint64"in DataView||(DataView.prototype.getBigUint64=function(e,t){return function(e,t,n){const s=e.getUint32(t,n),i=e.getUint32(t+4,n),a=Number(!!n),r=Number(!n);return BigInt(s*r+i*a)<<o|BigInt(s*a+i*r)}(this,e,t)});var c=n(45834),l=n(35451);const f=440477507;function h(e,t){const n=e.prototype[t],s=`_memo_${t}`;e.prototype[t]=function(){return s in this||(this[s]=n.call(this)),this[s]}}const u=["T","C","A","G"],g=[];for(let e=0;e<256;e++)g.push(u[e>>6&3]+u[e>>4&3]+u[e>>2&3]+u[3&e]);const d=g.map((e=>e.toLowerCase()));class w{constructor({filehandle:e,path:t}){if(e)this.filehandle=e;else{if(!t)throw new Error("must supply path or filehandle");this.filehandle=new c.EY(t)}}async _detectEndianness(){const e=await this.filehandle.read(l.hp.allocUnsafe(8),0,8,0),{buffer:t}=e;if(t.readInt32LE(0)!==f)throw t.readInt32BE(0)===f?new Error("big endian not supported"):new Error("not a 2bit file");this.version=t.readInt32LE(4)}async getHeader(){await this._detectEndianness();const{buffer:e}=await this.filehandle.read(l.hp.allocUnsafe(16),0,16,0),t=e,n=!0,s=new DataView(t.buffer,t.byteOffset,t.length);let i=0;const a=s.getInt32(i,n);if(i+=4,440477507!==a)throw new Error(`Wrong magic number ${a}`);const r=s.getInt32(i,n);i+=4;const o=s.getUint32(i,n);return i+=4,{version:r,magic:a,sequenceCount:o,reserved:s.getUint32(i,n)}}async getIndex(){const e=await this.getHeader(),t=8+e.sequenceCount*(257+(1===this.version?8:4)),{buffer:n}=await this.filehandle.read(l.hp.allocUnsafe(t),0,t,8),s=!0,i=n,a=new DataView(i.buffer,i.byteOffset,i.length);let r=0;const o=a.getUint32(r,s);r+=4,r+=4;const c=[];for(let t=0;t<o;t++){const t=a.getUint8(r);r+=1;const i=n.subarray(r,r+t).toString();if(r+=t,1===e.version){const e=Number(a.getBigUint64(r,s));r+=8,c.push({offset:e,name:i})}else{const e=a.getUint32(r,s);r+=4,c.push({offset:e,name:i})}}return Object.fromEntries(c.map((({name:e,offset:t})=>[e,t])))}async getSequenceNames(){const e=await this.getIndex();return Object.keys(e)}async getSequenceSizes(){const e=await this.getIndex(),t=Object.keys(e),n=Object.values(e).map((e=>this._getSequenceSize(e))),s=await Promise.all(n),i={};for(const[e,n]of t.entries())i[n]=s[e];return i}async getSequenceSize(e){const t=(await this.getIndex())[e];if(t)return this._getSequenceSize(t)}async _getSequenceSize(e){return this._record1(e).then((e=>e.dnaSize))}async _record1(e,t=8){const{buffer:n}=await this.filehandle.read(l.hp.allocUnsafe(t),0,t,e),s=n,i=!0;let a=0;const r=new DataView(s.buffer,s.byteOffset,s.length),o=r.getUint32(a,i);a+=4;const c=r.getUint32(a,i);return a+=4,{dnaSize:o,nBlockCount:c}}async _record2(e,t){const{buffer:n}=await this.filehandle.read(l.hp.allocUnsafe(t),0,t,e),s=n,i=!0;let a=0;const r=new DataView(s.buffer,s.byteOffset,s.length),o=r.getUint32(a,i);a+=4;const c=[];for(let e=0;e<o;e++){const e=r.getUint32(a,i);a+=4,c.push(e)}const f=[];for(let e=0;e<o;e++){const e=r.getUint32(a,i);a+=4,f.push(e)}return{maskBlockCount:r.getUint32(a,i),nBlockSizes:f,nBlockStarts:c}}async _record3(e,t){const{buffer:n}=await this.filehandle.read(l.hp.allocUnsafe(t),0,t,e),s=n,i=!0;let a=0;const r=new DataView(s.buffer,s.byteOffset,s.length),o=r.getUint32(a,i);a+=4;const c=[];for(let e=0;e<o;e++){const e=r.getUint32(a,i);a+=4,c.push(e)}const f=[];for(let e=0;e<o;e++){const e=r.getUint32(a,i);a+=4,f.push(e)}return{maskBlockCount:o,maskBlockSizes:f,maskBlockStarts:c,reserved:r.getInt32(a,i)}}async _getSequenceRecord(e){const t=await this._record1(e),n=8*t.nBlockCount+8,s=await this._record2(e+4,n),i=8*s.maskBlockCount+8,a=await this._record3(e+4+n-4,i);return{dnaSize:t.dnaSize,nBlocks:{starts:s.nBlockStarts,sizes:s.nBlockSizes},maskBlocks:{starts:a.maskBlockStarts,sizes:a.maskBlockSizes},dnaPosition:e+4+n-4+i}}async getSequence(e,t=0,n=Number.POSITIVE_INFINITY){const s=(await this.getIndex())[e];if(!s)return;const i=await this._getSequenceRecord(s);if(t<0)throw new TypeError("regionStart cannot be less than 0");(void 0===n||n>i.dnaSize)&&(n=i.dnaSize);const a=this._getOverlappingBlocks(t,n,i.nBlocks.starts,i.nBlocks.sizes),r=this._getOverlappingBlocks(t,n,i.maskBlocks.starts,i.maskBlocks.sizes),o=l.hp.allocUnsafe(Math.ceil((n-t)/4)+1),c=Math.floor(t/4),{buffer:f}=await this.filehandle.read(o,0,o.length,i.dnaPosition+c);let h="";for(let e=t;e<n;e+=1){for(;r.length>0&&r[0].end<=e;)r.shift();const t=r[0]&&r[0].start<=e&&r[0].end>e;if(a[0]&&e>=a[0].start&&e<a[0].end){const s=a.shift();for(;e<s.end&&e<n;e+=1)h+=t?"n":"N";e-=1}else{const n=e%4,s=f[Math.floor(e/4)-c];h+=t?d[s][n]:g[s][n]}}return h}_getOverlappingBlocks(e,t,n,s){let i,a;for(const[r,o]of n.entries())if(e>=o+s[r]||t<=o){if(void 0!==i){a=r;break}}else void 0===i&&(i=r);if(void 0===i)return[];void 0===a&&(a=n.length);const r=new Array(a-i);for(let e=i;e<a;e+=1)r[e-i]={start:n[e],end:n[e]+s[e],size:s[e]};return r}}h(w,"getIndex"),h(w,"getHeader");var p=n(68584);class b extends s.BaseSequenceAdapter{async initChromSizes(){const e=(0,p.readConfObject)(this.config,"chromSizesLocation");if("/path/to/default.chrom.sizes"!==e.uri&&""!==e.uri){const t=(0,i.openLocation)(e,this.pluginManager),n=await t.readFile("utf8");return Object.fromEntries(n.split(/\n|\r\n|\r/).filter((e=>!!e.trim())).map((e=>{const[t,n]=e.split("\t");return[t,+n]})))}}constructor(e,t,n){super(e,t,n);const s=this.pluginManager;this.chromSizesData=this.initChromSizes(),this.twobit=new w({filehandle:(0,i.openLocation)(this.getConf("twoBitLocation"),s)})}async getRefNames(){const e=await this.chromSizesData;return e?Object.keys(e):this.twobit.getSequenceNames()}async getRegions(){const e=await this.chromSizesData;if(e)return Object.keys(e).map((t=>({refName:t,start:0,end:e[t]})));const t=await this.twobit.getSequenceSizes();return Object.keys(t).map((e=>({refName:e,start:0,end:t[e]})))}getFeatures({refName:e,start:t,end:n}){return(0,a.ObservableCreate)((async s=>{const i=await this.twobit.getSequenceSize(e),a=void 0!==i?Math.min(i,n):n,o=await this.twobit.getSequence(e,t,a);o&&s.next(new r.A({id:`${e} ${t}-${a}`,data:{refName:e,start:t,end:a,seq:o}})),s.complete()}))}freeResources(){}}}}]);
//# sourceMappingURL=9280.6e897b98.chunk.js.map