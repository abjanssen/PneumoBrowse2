{"version":3,"file":"static/js/3498.faf53bd0.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/data-management/src/UCSCTrackHubConnection/util.ts","webpack://@jbrowse/web/../../plugins/data-management/src/UCSCTrackHubConnection/ucscTrackHub.ts","webpack://@jbrowse/web/../../plugins/data-management/src/UCSCTrackHubConnection/doConnect.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+ucsc-hub@2.0.3/node_modules/@gmod/ucsc-hub/src/raStanza.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+ucsc-hub@2.0.3/node_modules/@gmod/ucsc-hub/src/raFile.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+ucsc-hub@2.0.3/node_modules/@gmod/ucsc-hub/src/util.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+ucsc-hub@2.0.3/node_modules/@gmod/ucsc-hub/src/trackDbFile.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+ucsc-hub@2.0.3/node_modules/@gmod/ucsc-hub/src/genomesFile.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+ucsc-hub@2.0.3/node_modules/@gmod/ucsc-hub/src/hubFile.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+ucsc-hub@2.0.3/node_modules/@gmod/ucsc-hub/src/singleFileHub.ts"],"sourcesContent":["import { GenomesFile, TrackDbFile } from '@gmod/ucsc-hub'\nimport { openLocation } from '@jbrowse/core/util/io'\n\nimport type { FileLocation } from '@jbrowse/core/util'\n\nexport async function fetchGenomesFile(genomesLoc: FileLocation) {\n  const genomesFileText = await openLocation(genomesLoc).readFile('utf8')\n  return new GenomesFile(genomesFileText)\n}\n\nexport async function fetchTrackDbFile(trackDbLoc: FileLocation) {\n  const text = await openLocation(trackDbLoc).readFile('utf8')\n  return new TrackDbFile(text)\n}\n\nexport function makeLoc(\n  first: string,\n  base: { uri: string; baseUri?: string },\n) {\n  return {\n    uri: new URL(first, new URL(base.uri, base.baseUri)).href,\n    locationType: 'UriLocation',\n  }\n}\n\nexport function makeLocAlt(first: string, alt: string, base: { uri: string }) {\n  return first ? makeLoc(first, base) : makeLoc(alt, base)\n}\n\nexport function makeLoc2(first: string, alt?: string) {\n  return first\n    ? {\n        uri: first,\n        locationType: 'LocalPath',\n      }\n    : {\n        uri: alt,\n        locationType: 'UriLocation',\n      }\n}\n\nexport function resolve(uri: string, baseUri: string) {\n  return new URL(uri, baseUri).href\n}\n","import { isUriLocation, notEmpty, objectHash } from '@jbrowse/core/util'\nimport { generateUnknownTrackConf } from '@jbrowse/core/util/tracks'\n\nimport { makeLoc2, makeLoc, makeLocAlt, resolve } from './util.ts'\n\nimport type { RaStanza, TrackDbFile } from '@gmod/ucsc-hub'\nimport type { FileLocation } from '@jbrowse/core/util'\n\nexport function generateTracks({\n  trackDb,\n  trackDbLoc,\n  assemblyName,\n  baseUrl,\n}: {\n  trackDb: TrackDbFile\n  trackDbLoc: FileLocation\n  assemblyName: string\n  baseUrl: string\n}) {\n  const parentTrackKeys = new Set([\n    'superTrack',\n    'compositeTrack',\n    'container',\n    'view',\n  ])\n  return Object.entries(trackDb.data)\n    .map(([trackName, track]) => {\n      const { data } = track\n      if (Object.keys(data).some(key => parentTrackKeys.has(key))) {\n        return undefined\n      } else {\n        const parentTracks = []\n        let currentTrackName = trackName\n        do {\n          currentTrackName = trackDb.data[currentTrackName]?.data.parent || ''\n          if (currentTrackName) {\n            currentTrackName = currentTrackName.split(' ')[0]!\n            parentTracks.push(trackDb.data[currentTrackName])\n          }\n        } while (currentTrackName)\n        parentTracks.reverse()\n\n        return {\n          metadata: {\n            ...track.data,\n            ...(track.data.html\n              ? {\n                  html: `<a href=\"${resolve(track.data.html, baseUrl)}\">${track.data.html}</a>`,\n                }\n              : {}),\n          },\n          category: [\n            track.data.group,\n            ...parentTracks\n              .map(p => p?.data.group)\n              .filter((f): f is string => !!f),\n          ].filter(f => !!f),\n          ...makeTrackConfig({\n            track,\n            trackDbLoc,\n            trackDb,\n          }),\n        }\n      }\n    })\n    .filter(notEmpty)\n    .map(r => ({\n      ...r,\n      trackId: `ucsc-trackhub-${objectHash(r)}`,\n      assemblyNames: [assemblyName],\n    }))\n}\n\nfunction makeTrackConfig({\n  track,\n  trackDbLoc,\n  trackDb,\n}: {\n  track: RaStanza\n  trackDbLoc: FileLocation\n  trackDb: TrackDbFile\n}) {\n  const { data } = track\n\n  const parent = data.parent || ''\n  const bigDataUrl = data.bigDataUrl || ''\n  const bigDataIdx = data.bigDataIndex || ''\n  const trackType = data.type || trackDb.data[parent]?.data.type || ''\n  const name =\n    (data.shortLabel || '') + (bigDataUrl.includes('xeno') ? ' (xeno)' : '')\n\n  const isUri = isUriLocation(trackDbLoc)\n  let baseTrackType = trackType.split(' ')[0] || ''\n  if (baseTrackType === 'bam' && bigDataUrl.toLowerCase().endsWith('cram')) {\n    baseTrackType = 'cram'\n  }\n  const bigDataLocation = isUri\n    ? makeLoc(bigDataUrl, trackDbLoc)\n    : makeLoc2(bigDataUrl)\n\n  if (baseTrackType === 'bam') {\n    return {\n      type: 'AlignmentsTrack',\n      name,\n      description: data.longLabel,\n      adapter: {\n        type: 'BamAdapter',\n        bamLocation: bigDataLocation,\n        index: {\n          location: isUri\n            ? makeLocAlt(bigDataIdx, `${bigDataUrl}.bai`, trackDbLoc)\n            : makeLoc2(bigDataIdx, `${bigDataUrl}.bai`),\n        },\n      },\n    }\n  } else if (baseTrackType === 'cram') {\n    return {\n      type: 'AlignmentsTrack',\n      name,\n      description: data.longLabel,\n      adapter: {\n        type: 'CramAdapter',\n        cramLocation: bigDataLocation,\n        craiLocation: isUri\n          ? makeLocAlt(bigDataIdx, `${bigDataUrl}.crai`, trackDbLoc)\n          : makeLoc2(bigDataIdx, `${bigDataUrl}.crai`),\n      },\n    }\n  } else if (baseTrackType === 'bigWig') {\n    return {\n      type: 'QuantitativeTrack',\n      name,\n      description: data.longLabel,\n      adapter: {\n        type: 'BigWigAdapter',\n        bigWigLocation: bigDataLocation,\n      },\n    }\n  } else if (baseTrackType.startsWith('big')) {\n    return {\n      type: 'FeatureTrack',\n      name,\n      description: data.longLabel,\n      adapter: {\n        type: 'BigBedAdapter',\n        bigBedLocation: bigDataLocation,\n      },\n    }\n  } else if (baseTrackType === 'vcfTabix') {\n    return {\n      type: 'VariantTrack',\n      name,\n      description: data.longLabel,\n      adapter: {\n        type: 'VcfTabixAdapter',\n        vcfGzLocation: bigDataLocation,\n        index: {\n          location: isUri\n            ? makeLocAlt(bigDataIdx, `${bigDataUrl}.tbi`, trackDbLoc)\n            : makeLoc2(bigDataIdx, `${bigDataUrl}.tbi`),\n        },\n      },\n    }\n  } else if (baseTrackType === 'hic') {\n    return {\n      type: 'HicTrack',\n      name,\n      description: data.longLabel,\n      adapter: {\n        type: 'HicAdapter',\n        hicLocation: bigDataLocation,\n      },\n    }\n  } else {\n    // unsupported types\n    //     case 'peptideMapping':\n    //     case 'gvf':\n    //     case 'ld2':\n    //     case 'narrowPeak':\n    //     case 'wig':\n    //     case 'wigMaf':\n    //     case 'halSnake':\n    //     case 'bed':\n    //     case 'bed5FloatScore':\n    //     case 'bedGraph':\n    //     case 'bedRnaElements':\n    //     case 'broadPeak':\n    //     case 'coloredExon':\n    return generateUnknownTrackConf(name, baseTrackType)\n  }\n}\n","import { HubFile, SingleFileHub } from '@gmod/ucsc-hub'\nimport { getConf } from '@jbrowse/core/configuration'\nimport { getEnv, getSession } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { createElementId } from '@jbrowse/core/util/types/mst'\n\nimport { generateTracks } from './ucscTrackHub.ts'\nimport { fetchGenomesFile, fetchTrackDbFile, resolve } from './util.ts'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { FileLocation } from '@jbrowse/core/util'\n\nexport async function doConnect(self: {\n  configuration: AnyConfigurationModel\n  addTrackConfs: (arg: Record<string, unknown>[]) => void\n}) {\n  const { pluginManager } = getEnv(self)\n  const session = getSession(self)\n  const notLoadedAssemblies = [] as string[]\n  try {\n    const hubFileLocation = getConf(self, 'hubTxtLocation') as FileLocation\n    const hubFileText = await openLocation(hubFileLocation).readFile('utf8')\n    // @ts-expect-error\n    const hubUri = resolve(hubFileLocation.uri, hubFileLocation.baseUri)\n    const { assemblyManager } = session\n    if (hubFileText.includes('useOneFile on')) {\n      const hub = new SingleFileHub(hubFileText)\n      const { genome, tracks } = hub\n      const genomeName = genome.name!\n      const shortLabel = genome.data.description\n\n      const asm = assemblyManager.get(genomeName)\n      if (!asm) {\n        // @ts-expect-error\n        session.addSessionAssembly({\n          name: genomeName,\n          displayName: shortLabel,\n          sequence: {\n            type: 'ReferenceSequenceTrack',\n            metadata: {\n              ...genome.data,\n              ...(genome.data.htmlPath\n                ? {\n                    htmlPath: `<a href=\"${resolve(genome.data.htmlPath, hubUri)}\">${genome.data.htmlPath}</a>`,\n                  }\n                : {}),\n            },\n            trackId: `${genomeName}-${createElementId()}`,\n            adapter: {\n              type: 'TwoBitAdapter',\n              twoBitLocation: {\n                uri: resolve(genome.data.twoBitPath!, hubUri),\n              },\n              chromSizesLocation: {\n                uri: resolve(genome.data.chromSizes!, hubUri),\n              },\n            },\n          },\n          ...(genome.data.chromAliasBb\n            ? {\n                refNameAliases: {\n                  adapter: {\n                    type: 'BigBedAdapter',\n                    uri: resolve(genome.data.chromAliasBb, hubUri),\n                  },\n                },\n              }\n            : {}),\n        })\n      }\n      const tracksNew = generateTracks({\n        trackDb: tracks,\n        trackDbLoc: hubFileLocation,\n        assemblyName: genomeName,\n        baseUrl: hubUri,\n      })\n      self.addTrackConfs(tracksNew)\n      pluginManager.evaluateExtensionPoint('LaunchView-LinearGenomeView', {\n        session,\n        assembly: genomeName,\n        tracklist: true,\n        loc: genome.data.defaultPos,\n      })\n    } else {\n      const hubFile = new HubFile(hubFileText)\n      const genomeFile = hubFile.data.genomesFile\n      if (!genomeFile) {\n        throw new Error('genomesFile not found on hub')\n      }\n\n      // @ts-expect-error\n      const hubUri = resolve(hubFileLocation.uri, hubFileLocation.baseUri)\n      const genomesFileLocation = hubUri\n        ? {\n            uri: resolve(genomeFile, hubUri),\n            locationType: 'UriLocation' as const,\n          }\n        : {\n            localPath: genomeFile,\n            locationType: 'LocalPathLocation' as const,\n          }\n      const genomesFile = await fetchGenomesFile(genomesFileLocation)\n      const map = {} as Record<string, number>\n      for (const [genomeName, genome] of Object.entries(genomesFile.data)) {\n        const assemblyNames = getConf(self, 'assemblyNames')\n        if (assemblyNames.length > 0 && !assemblyNames.includes(genomeName)) {\n          continue\n        }\n\n        const asm = assemblyManager.get(genomeName)\n        if (!asm) {\n          notLoadedAssemblies.push(genomeName)\n          continue\n        }\n\n        const db = genome.data.trackDb\n        if (!db) {\n          throw new Error('genomesFile not found on hub')\n        }\n        const base = new URL(genomeFile, hubUri)\n        const loc = hubUri\n          ? {\n              uri: new URL(db, base).href,\n              locationType: 'UriLocation' as const,\n            }\n          : {\n              localPath: db,\n              locationType: 'LocalPathLocation' as const,\n            }\n        const trackDb = await fetchTrackDbFile(loc)\n        const tracks = generateTracks({\n          trackDb,\n          trackDbLoc: loc,\n          assemblyName: genomeName,\n          baseUrl: hubUri,\n        })\n        self.addTrackConfs(tracks)\n        map[genomeName] = tracks.length\n      }\n\n      const loadedAssemblies = Object.entries(map)\n      const str1 = loadedAssemblies.length\n        ? `Loaded data from these assemblies: ${loadedAssemblies\n            .map(([key, val]) => `${key} (${val} tracks)`)\n            .join(', ')}`\n        : ''\n      const str2 = notLoadedAssemblies.length\n        ? `Skipped data from these assemblies: ${notLoadedAssemblies.join(\n            ', ',\n          )}`\n        : ''\n      session.notify([str1, str2].filter(f => !!f).join('. '), 'success')\n    }\n  } catch (e) {\n    console.error(e)\n    session.notifyError(`${getConf(self, 'name')}: \"${e}\"`, e)\n    session.breakConnection?.(self.configuration)\n  }\n}\n","/**\n * Class representing an ra file stanza. Each stanza line is split into its key\n * and value and stored as a Map, so the usual Map methods can be used on the\n * stanza.\n */\nexport default class RaStanza {\n  data: Record<string, string> = {}\n\n  name?: string\n\n  nameKey?: string\n\n  constructor(\n    stanza: string | string[] = [],\n    options?: { checkIndent?: boolean; skipValidation?: boolean },\n  ) {\n    const { checkIndent = true, skipValidation = false } = options ?? {}\n    const stanzaLines =\n      typeof stanza === 'string' ? stanza.trimEnd().split(/\\r?\\n/) : stanza\n\n    let currentIndent: string | undefined\n\n    let continuedLine: string | undefined\n    for (const line of stanzaLines) {\n      if (line === '') {\n        throw new Error('Invalid stanza, contained blank lines')\n      }\n      if (line.trim().startsWith('#')) {\n        continue\n      }\n      if (line.trimEnd().endsWith('\\\\')) {\n        const trimmedLine = line.trimEnd().slice(0, -1)\n        if (continuedLine) {\n          continuedLine += trimmedLine.trimStart()\n        } else {\n          continuedLine = trimmedLine\n        }\n        continue\n      }\n      let combinedLine = line\n      if (continuedLine) {\n        combinedLine = continuedLine + combinedLine.trimStart()\n        continuedLine = undefined\n      }\n      if (currentIndent ?? checkIndent) {\n        const indent = /^([ \\t]+)/.exec(combinedLine)\n        if (currentIndent === undefined) {\n          if (indent) {\n            ;[, currentIndent] = indent\n          } else {\n            currentIndent = ''\n          }\n        } else if (\n          (currentIndent === '' && indent !== null) ||\n          (currentIndent && indent && currentIndent !== indent[1])\n        ) {\n          throw new Error('Inconsistent indentation of stanza')\n        }\n      } else {\n        currentIndent = ''\n      }\n      const trimmedLine = combinedLine.trim()\n      const sep = trimmedLine.indexOf(' ')\n      if (sep === -1) {\n        if (!this.nameKey) {\n          throw new Error(\n            'First line in a stanza must have both a key and a value',\n          )\n        }\n        // Adding a key that already exists and has no value is a no-op\n        if (this.data[trimmedLine]) {\n          continue\n        }\n        this.data[trimmedLine] = ''\n        continue\n      }\n      const key = trimmedLine.slice(0, sep)\n      const value = trimmedLine.slice(sep + 1)\n      if (this.data[key] && value !== this.data[key]) {\n        throw new Error(\n          'Got duplicate key with a different value in stanza: ' +\n            `\"${key}\" key has both ${this.data[key]} and ${value}`,\n        )\n      }\n      if (!this.nameKey) {\n        this.nameKey = key\n        this.name = trimmedLine.slice(sep + 1)\n      }\n      this.data[key] = value\n    }\n\n    if (!skipValidation) {\n      this.validate()\n    }\n  }\n\n  protected validate() {}\n}\n","import RaStanza from './raStanza.ts'\n\n/**\n * Class representing an ra file. Each file is composed of multiple stanzas, and\n * each stanza is separated by one or more blank lines. Each stanza is stored in\n * a Map with the key being the value of the first key-value pair in the stanza.\n * The usual Map methods can be used on the file. An additional method `add()`\n * is available to take a raw line of text and break it up into a key and value\n * and add them to the class. This should be favored over `set()` when possible,\n * as it performs more validity checks than using `set()`.\n * @property {undefined|string} nameKey - The key of the first line of all the\n * stanzas (`undefined` if the stanza has no lines yet).\n * @throws {Error} Throws if an empty stanza is added, if the key in the first\n * key-value pair of each stanze isn't the same, or if two stanzas have the same\n * value for the key-value pair in their first lines.\n * @param {(string|string[])} [raFile=[]] - An ra file, either as a single\n * string or an array of strings with one stanza per entry. Supports both LF\n * and CRLF line terminators.\n * @param {object} options\n * @param {boolean} options.checkIndent [true] - Check if a the stanzas within\n * the file are indented consistently and keep track of the indentation\n */\nexport default class RaFile {\n  data: Record<string, RaStanza> = {}\n\n  nameKey?: string\n\n  constructor(\n    raFile: string | string[] = [],\n    options?: { checkIndent?: boolean; skipValidation?: boolean },\n  ) {\n    const { checkIndent = true, skipValidation = false } = options ?? {}\n    const stanzas =\n      typeof raFile === 'string'\n        ? raFile.trimEnd().split(/(?:[\\t ]*\\r?\\n){2,}/)\n        : raFile\n    for (const stanza of stanzas) {\n      if (stanza === '') {\n        throw new Error('Invalid stanza, was empty')\n      }\n      if (stanza.startsWith('include')) {\n        continue\n      }\n      if (stanza.trim().startsWith('#')) {\n        const stanzaLines = stanza\n          .trimEnd()\n          .split(/\\r?\\n/)\n          .map(line => line.trim())\n        if (stanzaLines.every(line => line.startsWith('#'))) {\n          continue\n        }\n      }\n      const raStanza = new RaStanza(stanza, { checkIndent })\n      if (!this.nameKey) {\n        this.nameKey = raStanza.nameKey\n      } else if (raStanza.nameKey !== this.nameKey) {\n        throw new Error(\n          'The first line in each stanza must have the same key. ' +\n            `Saw both ${this.nameKey} and ${raStanza.nameKey}`,\n        )\n      }\n      if (!raStanza.name) {\n        throw new Error(`No stanza name: ${raStanza.name}`)\n      }\n      if (this.data[raStanza.name]) {\n        throw new Error(`Got duplicate stanza name: ${raStanza.name}`)\n      }\n\n      this.data[raStanza.name] = raStanza\n    }\n\n    if (!skipValidation) {\n      this.validate()\n    }\n  }\n\n  protected validate() {}\n}\n","import RaStanza from './raStanza.ts'\n\n// validate that all required fields are present in the map\nexport function validateRequiredFieldsArePresent(\n  map: RaStanza,\n  requiredFields: string[],\n  description = '',\n) {\n  const missingFields: string[] = []\n  for (const field of requiredFields) {\n    if (!map.data[field]) {\n      missingFields.push(field)\n    }\n  }\n  if (missingFields.length > 0) {\n    throw new Error(\n      `${description} is missing required entr${\n        missingFields.length === 1 ? 'y' : 'ies'\n      }: ${missingFields.join(', ')}`,\n    )\n  }\n}\n","import RaFile from './raFile.ts'\nimport { validateRequiredFieldsArePresent } from './util.ts'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [trackDbFile=[]] - A trackDb.txt file as a string\n * @throws {Error} Throws if \"track\" is not the first key in each track or if a\n * track is missing required keys\n */\nexport default class TrackDbFile extends RaFile {\n  constructor(\n    trackDbFile: string,\n    options?: ConstructorParameters<typeof RaFile>[1],\n  ) {\n    super(trackDbFile, { ...options, checkIndent: false })\n  }\n\n  protected validate() {\n    if (this.nameKey !== 'track') {\n      throw new Error(\n        `trackDb has \"${this.nameKey}\" instead of \"track\" as the first line in each track`,\n      )\n    }\n    for (const [trackName, track] of Object.entries(this.data)) {\n      const trackKeys = Object.keys(track.data)\n      validateRequiredFieldsArePresent(\n        track,\n        ['track', 'shortLabel'],\n        `Track ${trackName}`,\n      )\n\n      const parentTrackKeys = new Set([\n        'superTrack',\n        'compositeTrack',\n        'container',\n        'view',\n      ])\n      if (!trackKeys.some(key => parentTrackKeys.has(key))) {\n        if (!trackKeys.includes('bigDataUrl')) {\n          throw new Error(\n            `Track ${trackName} is missing required key \"bigDataUrl\"`,\n          )\n        }\n        if (!trackKeys.includes('type')) {\n          const settingsKeys = Object.keys(this.settings(trackName))\n          if (!settingsKeys.includes('type')) {\n            throw new Error(\n              `Neither track ${trackName} nor any of its parent tracks have the required key \"type\"`,\n            )\n          }\n        }\n      }\n      let currentTrackName: string | undefined = trackName\n      do {\n        // @ts-expect-error\n        currentTrackName = this.data[currentTrackName]?.parent as\n          | string\n          | undefined\n        if (currentTrackName) {\n          ;[currentTrackName] = currentTrackName.split(' ')\n        }\n      } while (currentTrackName)\n      const currentTrack = this.data[trackName]\n      if (currentTrack) {\n        this.data[trackName] = currentTrack\n      }\n    }\n  }\n\n  /**\n   * Gets all track entries including those of parent tracks, with closer\n   * entries overriding more distant ones\n   * @param {string} trackName The name of a track\n   * @throws {Error} Throws if track name does not exist in the trackDb\n   */\n  settings(trackName: string) {\n    if (!this.data[trackName]) {\n      throw new Error(`Track ${trackName} does not exist`)\n    }\n    const parentTracks = [trackName]\n    let currentTrackName: string | undefined = trackName\n    do {\n      // @ts-expect-error\n      currentTrackName = this.data[currentTrackName]?.parent as\n        | string\n        | undefined\n      if (currentTrackName) {\n        parentTracks.push(currentTrackName)\n      }\n    } while (currentTrackName)\n    const settings = {} as Record<string, unknown>\n    parentTracks.reverse()\n    for (const parentTrack of parentTracks) {\n      const ret = this.data[parentTrack]\n      if (ret) {\n        for (const [key, value] of Object.entries(ret)) {\n          settings[key] = value\n        }\n      }\n    }\n    return settings\n  }\n}\n","import RaFile from './raFile.ts'\nimport { validateRequiredFieldsArePresent } from './util.ts'\n\n/**\n * Class representing a genomes.txt file.\n * @extends RaFile\n * @param {(string|string[])} [genomesFile=[]] - A genomes.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"genome <genome_name>\" or if it has invalid entries\n */\nexport default class GenomesFile extends RaFile {\n  public validate(requiredFields = ['genome', 'trackDb']) {\n    // TODO: check if genome is hosted by UCSC and if not, require twoBitPath and groups\n\n    if (this.nameKey !== 'genome') {\n      throw new Error(\n        'Genomes file must begin with a line like \"genome <genome_name>\"',\n      )\n    }\n\n    for (const [genomeName, genome] of Object.entries(this.data)) {\n      validateRequiredFieldsArePresent(\n        genome,\n        requiredFields,\n        `genome ${genomeName}`,\n      )\n    }\n  }\n}\n","import RaStanza from './raStanza.ts'\nimport { validateRequiredFieldsArePresent } from './util.ts'\n\n/**\n * Class representing a hub.txt file.\n * @extends RaStanza\n * @param {(string|string[])} [hubFile=[]] - A hub.txt file as a string\n * @throws {Error} Throws if the first line of the hub.txt file doesn't start\n * with \"hub <hub_name>\", if it has invalid entries, or is missing required\n * entries\n */\nexport default class HubFile extends RaStanza {\n  protected validate() {\n    validateRequiredFieldsArePresent(\n      this,\n      ['hub', 'shortLabel', 'longLabel', 'genomesFile', 'email'],\n      'Hub file',\n    )\n  }\n}\n","import RaStanza from './raStanza.ts'\nimport TrackDbFile from './trackDbFile.ts'\nimport { validateRequiredFieldsArePresent } from './util.ts'\n\n/**\n * Class representing a \"single-file\" hub.txt file that contains all the\n * sections of a hub in a single file.\n */\nexport default class SingleFileHub {\n  public genome: RaStanza\n\n  public tracks: TrackDbFile\n\n  public hubData: RaStanza\n\n  constructor(hubText: string) {\n    const [hubSection, genomeSection, ...trackSections] = hubText\n      .trimEnd()\n      .split(/(?:[\\t ]*\\r?\\n){2,}/)\n    this.hubData = new RaStanza(hubSection)\n    this.validateHub()\n\n    this.genome = new RaStanza(genomeSection)\n    this.validateGenomeSection()\n\n    this.tracks = new TrackDbFile(trackSections.join('\\n\\n'), {\n      skipValidation: false,\n    })\n  }\n\n  protected validateHub() {\n    if (this.hubData.nameKey !== 'hub') {\n      throw new Error('Hub file must begin with a line like \"hub <hub_name>\"')\n    }\n\n    validateRequiredFieldsArePresent(this.hubData, [\n      'hub',\n      'shortLabel',\n      'longLabel',\n      'email',\n      // 'descriptionUrl', mpxvRivers has a typo\n    ])\n  }\n\n  protected validateGenomeSection() {\n    if (this.genome.nameKey !== 'genome') {\n      throw new Error(\n        'Genomes file must begin with a line like \"genome <genome_name>\"',\n      )\n    }\n  }\n}\n"],"names":["async","fetchTrackDbFile","trackDbLoc","text","openLocation","readFile","TrackDbFile","makeLoc","first","base","uri","URL","baseUri","href","locationType","makeLocAlt","alt","makeLoc2","resolve","generateTracks","trackDb","assemblyName","baseUrl","parentTrackKeys","Set","Object","entries","data","map","trackName","track","keys","some","key","has","parentTracks","currentTrackName","parent","split","push","reverse","metadata","html","category","group","p","filter","f","makeTrackConfig","notEmpty","r","trackId","objectHash","assemblyNames","bigDataUrl","bigDataIdx","bigDataIndex","trackType","type","name","shortLabel","includes","isUri","isUriLocation","baseTrackType","toLowerCase","endsWith","bigDataLocation","description","longLabel","adapter","bamLocation","index","location","cramLocation","craiLocation","bigWigLocation","startsWith","bigBedLocation","vcfGzLocation","hicLocation","generateUnknownTrackConf","doConnect","self","pluginManager","getEnv","session","getSession","notLoadedAssemblies","hubFileLocation","getConf","hubFileText","hubUri","assemblyManager","hub","SingleFileHub","genome","tracks","genomeName","get","addSessionAssembly","displayName","sequence","htmlPath","createElementId","twoBitLocation","twoBitPath","chromSizesLocation","chromSizes","chromAliasBb","refNameAliases","tracksNew","addTrackConfs","evaluateExtensionPoint","assembly","tracklist","loc","defaultPos","genomeFile","HubFile","genomesFile","Error","genomesFileLocation","localPath","genomesLoc","genomesFileText","GenomesFile","fetchGenomesFile","length","db","loadedAssemblies","str1","val","join","str2","notify","e","console","error","notifyError","breakConnection","configuration","RaStanza","constructor","stanza","options","checkIndent","skipValidation","stanzaLines","trimEnd","currentIndent","continuedLine","line","trim","trimmedLine","slice","trimStart","combinedLine","undefined","indent","exec","sep","indexOf","this","nameKey","value","validate","RaFile","raFile","stanzas","every","raStanza","validateRequiredFieldsArePresent","requiredFields","missingFields","field","trackDbFile","super","trackKeys","settings","currentTrack","parentTrack","ret","hubText","hubSection","genomeSection","trackSections","hubData","validateHub","validateGenomeSection"],"sourceRoot":""}