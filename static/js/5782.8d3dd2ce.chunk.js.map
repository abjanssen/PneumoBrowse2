{"version":3,"file":"static/js/5782.8d3dd2ce.chunk.js","mappings":"yMAyBO,SAASA,EAAwBC,IAEtCC,EAAAA,EAAAA,aACED,GACAE,EAAAA,EAAAA,SACE,WAEE,KAAKC,EAAAA,EAAAA,SAAQH,IAASA,EAAKI,YACzB,OAEF,MAAM,WACJC,EAAU,UACVC,EAAS,cACTC,EAAa,OACbC,EAAM,UACNC,EAKAC,YAAaC,GACXX,EAEJ,IAAKK,IAAeC,EAClB,OAGF,MAAMM,EAAMP,EAAWQ,WAAW,MAClC,GAAKD,EAAL,CAKAA,EAAIE,iBACJF,EAAIG,MAAM,EAAG,GACbH,EAAII,UAAU,EAAG,EAAGT,EAAeC,GAGnCI,EAAIK,UAAU,GAAIR,GAClBG,EAAIM,YAAc,QAClBN,EAAIO,UAAY,EAGhBP,EAAIQ,YACJ,IAAK,MAAMC,KAAQf,EAAUgB,QAAS,CACpC,MAAM,OAAEC,EAAM,OAAEC,GAAWH,EACrBI,EAAKF,EAAOG,EACZC,EAAKH,EAAOE,EACZE,EAAKJ,EAAOK,EACZC,EAAKP,EAAOM,EAGlBjB,EAAImB,OAAOD,EAAIL,GACfb,EAAIoB,OAAOF,EAAIH,GAGff,EAAImB,OAAOD,EAAIH,GACff,EAAIoB,OAAOJ,EAAID,EACjB,CACAf,EAAIqB,QA7BJ,CA8BF,EACA,CACEC,KAAM,eAMZjC,EAAAA,EAAAA,aACED,GACAE,EAAAA,EAAAA,SACE,WAEE,KAAKC,EAAAA,EAAAA,SAAQH,IAASA,EAAKI,YACzB,OAEF,MAAM,gBACJ+B,EAAe,UACf7B,EAAS,UACT8B,EAAS,gBACTC,EAAe,OACf7B,EAAM,UACNC,EAAS,QACT6B,EAAO,YAKP5B,GACEV,EACJ,IAAKmC,EACH,OAGF,MAAMvB,EAAMuB,EAAgBtB,WAAW,MACvC,IAAKD,EACH,OAGF,MACM2B,GADOC,EAAAA,EAAAA,mBAAkBxC,GACRyC,MAIvB,GAFA7B,EAAII,UAAU,EAAG,EAAGuB,EAAW/B,GAE3BF,GAAa+B,GAAmBC,EAAS,CAE3C1B,EAAI8B,OAGJ9B,EAAIK,UAAU,GAAIR,GAGlBG,EAAI+B,UAAY,sBAChB,MAAMC,EAAgB,IAAIC,IAAIR,EAAgBS,iBAC9C,IAAK,IAAIC,EAAI,EAAGC,EAAIV,EAAQW,OAAQF,EAAIC,EAAGD,IAAK,CAC9C,MAAMxB,EAASe,EAAQS,GACvB,GAAIH,EAAcM,IAAI3B,EAAOW,MAAO,CAClC,MAAML,GAAKkB,EAAI,IAAOX,EACtBxB,EAAIuC,SAAS,EAAGtB,EAAIO,EAAY,EAAGG,EAAWH,EAChD,CACF,CAGA,MAAM,KAAEgB,GAASf,EACjBzB,EAAI+B,UAAY,sBAChB/B,EAAIQ,YACJR,EAAIyC,IAAID,EAAKvB,EAAIuB,EAAK1B,EAAI,EAAG,EAAG,EAAI4B,KAAKC,IACzC3C,EAAI4C,OAGJ5C,EAAIM,YAAc,oBAClBN,EAAIO,UAAY,EAChBP,EAAIqB,SAGJrB,EAAI6C,SACN,CACF,EACA,CAAEvB,KAAM,cAGd,C","sources":["webpack://@jbrowse/web/../../plugins/wiggle/src/MultiLinearWiggleDisplay/treeDrawingAutorun.ts"],"sourcesContent":["import { getContainingView } from '@jbrowse/core/util'\nimport { addDisposer, isAlive } from '@jbrowse/mobx-state-tree'\nimport { autorun } from 'mobx'\n\nimport type { Source } from '../util.ts'\nimport type {\n  ClusterHierarchyNode,\n  HoveredTreeNode,\n} from './components/treeTypes.ts'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ninterface TreeDrawingModel {\n  treeCanvas?: HTMLCanvasElement\n  mouseoverCanvas?: HTMLCanvasElement\n  hierarchy?: ClusterHierarchyNode\n  treeAreaWidth: number\n  height: number\n  scrollTop: number\n  rowHeight: number\n  totalHeight: number\n  hoveredTreeNode?: HoveredTreeNode\n  sources?: Source[]\n  isMinimized: boolean\n}\n\nexport function setupTreeDrawingAutorun(self: TreeDrawingModel) {\n  // Draw tree structure\n  addDisposer(\n    self,\n    autorun(\n      function treeDrawAutorun() {\n        // isAlive check guards against display being destroyed during async import\n        if (!isAlive(self) || self.isMinimized) {\n          return\n        }\n        const {\n          treeCanvas,\n          hierarchy,\n          treeAreaWidth,\n          height,\n          scrollTop,\n          // IMPORTANT: We must access totalHeight for MobX to track it as a dependency.\n          // Without this, the autorun won't re-run when row height changes.\n          // Do not remove - this ensures the tree redraws when row height changes.\n          // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n          totalHeight: _totalHeight,\n        } = self\n\n        if (!treeCanvas || !hierarchy) {\n          return\n        }\n\n        const ctx = treeCanvas.getContext('2d')\n        if (!ctx) {\n          return\n        }\n\n        // Clear the entire canvas\n        ctx.resetTransform()\n        ctx.scale(2, 2)\n        ctx.clearRect(0, 0, treeAreaWidth, height)\n\n        // Translate to simulate scrolling\n        ctx.translate(0, -scrollTop)\n        ctx.strokeStyle = '#0008'\n        ctx.lineWidth = 1\n\n        // Use single path for all tree lines for better performance\n        ctx.beginPath()\n        for (const link of hierarchy.links()) {\n          const { source, target } = link\n          const sy = source.x!\n          const ty = target.x!\n          const tx = target.y!\n          const sx = source.y!\n\n          // Vertical line\n          ctx.moveTo(sx, sy)\n          ctx.lineTo(sx, ty)\n\n          // Horizontal line\n          ctx.moveTo(sx, ty)\n          ctx.lineTo(tx, ty)\n        }\n        ctx.stroke()\n      },\n      {\n        name: 'TreeDraw',\n      },\n    ),\n  )\n\n  // Draw hover highlights\n  addDisposer(\n    self,\n    autorun(\n      function treeHoverAutorun() {\n        // isAlive check guards against display being destroyed during async import\n        if (!isAlive(self) || self.isMinimized) {\n          return\n        }\n        const {\n          mouseoverCanvas,\n          hierarchy,\n          rowHeight,\n          hoveredTreeNode,\n          height,\n          scrollTop,\n          sources,\n          // IMPORTANT: We must access totalHeight for MobX to track it as a dependency.\n          // Without this, the autorun won't re-run when row height changes.\n          // Do not remove - this ensures highlights redraw when row height changes.\n          // eslint-disable-next-line  @typescript-eslint/no-unused-vars\n          totalHeight,\n        } = self\n        if (!mouseoverCanvas) {\n          return\n        }\n\n        const ctx = mouseoverCanvas.getContext('2d')\n        if (!ctx) {\n          return\n        }\n\n        const view = getContainingView(self) as LinearGenomeViewModel\n        const viewWidth = view.width\n\n        ctx.clearRect(0, 0, viewWidth, height)\n\n        if (hierarchy && hoveredTreeNode && sources) {\n          // Save the context state\n          ctx.save()\n\n          // Translate to simulate scrolling\n          ctx.translate(0, -scrollTop)\n\n          // Draw highlight rectangles for descendant leaf rows\n          ctx.fillStyle = 'rgba(255,165,0,0.2)'\n          const descendantSet = new Set(hoveredTreeNode.descendantNames)\n          for (let i = 0, l = sources.length; i < l; i++) {\n            const source = sources[i]!\n            if (descendantSet.has(source.name)) {\n              const y = (i + 0.5) * rowHeight\n              ctx.fillRect(0, y - rowHeight / 2, viewWidth, rowHeight)\n            }\n          }\n\n          // Draw circle at the hovered node\n          const { node } = hoveredTreeNode\n          ctx.fillStyle = 'rgba(255,165,0,0.8)'\n          ctx.beginPath()\n          ctx.arc(node.y!, node.x!, 4, 0, 2 * Math.PI)\n          ctx.fill()\n\n          // Add a border to the circle\n          ctx.strokeStyle = 'rgba(255,140,0,1)'\n          ctx.lineWidth = 1\n          ctx.stroke()\n\n          // Restore the context state\n          ctx.restore()\n        }\n      },\n      { name: 'TreeHover' },\n    ),\n  )\n}\n"],"names":["setupTreeDrawingAutorun","self","addDisposer","autorun","isAlive","isMinimized","treeCanvas","hierarchy","treeAreaWidth","height","scrollTop","totalHeight","_totalHeight","ctx","getContext","resetTransform","scale","clearRect","translate","strokeStyle","lineWidth","beginPath","link","links","source","target","sy","x","ty","tx","y","sx","moveTo","lineTo","stroke","name","mouseoverCanvas","rowHeight","hoveredTreeNode","sources","viewWidth","getContainingView","width","save","fillStyle","descendantSet","Set","descendantNames","i","l","length","has","fillRect","node","arc","Math","PI","fill","restore"],"sourceRoot":""}