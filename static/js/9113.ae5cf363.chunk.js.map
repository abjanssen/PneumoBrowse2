{"version":3,"file":"static/js/9113.ae5cf363.chunk.js","mappings":"sLASA,MAAMA,EAAc,GACdC,EAAa,EAEZ,SAASC,EACdC,EACAC,GAaA,MAAM,SACJC,EAAQ,QACRC,EAAO,QACPC,EAAO,UACPC,EACAC,OAAQC,EACRC,OAAO,OAAEC,GAAQ,oBACjBC,EAAmB,cACnBC,EAAa,OACbC,EAAM,OACNC,EAAS,GACPZ,EACEa,EAASX,EAAQ,GACjBY,GAASD,EAAOE,IAAMF,EAAOG,OAASb,EAKtCE,EAASC,EAA4B,EAATM,EAC5BK,GAAYC,EAAAA,EAAAA,gBAAeP,EAAQ,aACnCQ,GAAQC,EAAAA,EAAAA,UAAS,IAAKhB,EAAWiB,MAAO,CAAC,EAAGhB,KAC5CiB,EAASH,EAAMG,SACfC,EAAUD,EAAO,GACjBE,EAAUF,EAAO,GACjBG,EAAOC,IAAcC,EAAAA,EAAAA,OAAMtB,GAAUc,EAAMO,IAAM,GAAI,EAAGrB,GAAUO,EAExE,IAAIgB,EACAC,EAAaC,OAAOC,kBACxB,MAAMC,EAAkB,GACxB,IAAK,MAAMC,KAAWhC,EAASO,SAAU,CACvC,MAAO0B,EAAQC,IAAWC,EAAAA,EAAAA,eAAcH,EAASpB,EAAQV,GAGrDkC,KAAKC,MAAMJ,KAAYG,KAAKC,MAAMT,KACpCG,EAAgBO,KAAKN,GACrBJ,EAAaK,GAEf,MAAMM,EAAQP,EAAQQ,IAAI,SACpBC,EAAcF,EAAQjB,EACtBoB,EAAeH,EAAQhB,EACvBoB,EAAIT,EAAUD,EAAStC,EAEvBiD,EAAInC,EAAcuB,EAASO,GAEjCzC,EAAI+C,YACJ/C,EAAIgD,YAAcF,EAClB,MAAMG,OAAuBC,IAAZrB,EAAwBA,EAAUY,EAC9C3B,EAAOqC,UAKVnD,EAAIoD,OAAOhB,EAASV,EAAIuB,IACxBjD,EAAIqD,OAAOjB,EAASV,EAAIe,IACxBzC,EAAIqD,OAAOlB,EAAQT,EAAIe,MANvBzC,EAAIoD,OAAOjB,EAAQT,EAAIuB,IACvBjD,EAAIqD,OAAOlB,EAAQT,EAAIe,IACvBzC,EAAIqD,OAAOjB,EAASV,EAAIe,KAM1BzC,EAAIsD,SACJzB,EAAUY,EAENG,GACF5C,EAAIuD,UAAYrC,EAChBlB,EAAIwD,SAASrB,EAAQtB,EAAQgC,EAAG/C,IACvB6C,GAAuC,QAAxBtC,EAAUoD,YAClCzD,EAAIuD,UAAYrC,EAChBlB,EAAIwD,SAASrB,EAAQ7B,EAASR,EAAY+C,EAAGvC,GAEjD,CAYA,OAVII,IACFV,EAAI0D,UAAY,EAChB1D,EAAIgD,YAAc,wBAClBvC,EAAOkD,SAAQC,IACb5D,EAAI+C,YACJ/C,EAAIoD,OAAO,EAAGd,KAAKuB,MAAMnC,EAAIkC,KAC7B5D,EAAIqD,OAAOtC,EAAOuB,KAAKuB,MAAMnC,EAAIkC,KACjC5D,EAAIsD,QAAQ,KAGT,CAAErB,kBACX,C","sources":["../../../plugins/wiggle/src/drawLine.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp, featureSpanPx } from '@jbrowse/core/util'\n\nimport { getScale } from './util'\n\nimport type { ScaleOpts } from './util'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nconst fudgeFactor = 0.3\nconst clipHeight = 2\n\nexport function drawLine(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    regions: Region[]\n    bpPerPx: number\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    displayCrossHatches: boolean\n    colorCallback: (f: Feature, score: number) => string\n    config: AnyConfigurationModel\n    offset?: number\n  },\n) {\n  const {\n    features,\n    regions,\n    bpPerPx,\n    scaleOpts,\n    height: unadjustedHeight,\n    ticks: { values },\n    displayCrossHatches,\n    colorCallback,\n    config,\n    offset = 0,\n  } = props\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the\n  // wiggle display, and makes the height of the actual drawn area add\n  // \"padding\" to the top and bottom of the display\n  const height = unadjustedHeight - offset * 2\n  const clipColor = readConfObject(config, 'clipColor')\n  const scale = getScale({ ...scaleOpts, range: [0, height] })\n  const domain = scale.domain()\n  const niceMin = domain[0]!\n  const niceMax = domain[1]!\n  const toY = (n: number) => clamp(height - (scale(n) || 0), 0, height) + offset\n\n  let lastVal: number | undefined\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n  for (const feature of features.values()) {\n    const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n\n    // create reduced features, avoiding multiple features per px\n    if (Math.floor(leftPx) !== Math.floor(prevLeftPx)) {\n      reducedFeatures.push(feature)\n      prevLeftPx = leftPx\n    }\n    const score = feature.get('score')\n    const lowClipping = score < niceMin\n    const highClipping = score > niceMax\n    const w = rightPx - leftPx + fudgeFactor\n\n    const c = colorCallback(feature, score)\n\n    ctx.beginPath()\n    ctx.strokeStyle = c\n    const startPos = lastVal !== undefined ? lastVal : score\n    if (!region.reversed) {\n      ctx.moveTo(leftPx, toY(startPos))\n      ctx.lineTo(leftPx, toY(score))\n      ctx.lineTo(rightPx, toY(score))\n    } else {\n      ctx.moveTo(rightPx, toY(startPos))\n      ctx.lineTo(rightPx, toY(score))\n      ctx.lineTo(leftPx, toY(score))\n    }\n    ctx.stroke()\n    lastVal = score\n\n    if (highClipping) {\n      ctx.fillStyle = clipColor\n      ctx.fillRect(leftPx, offset, w, clipHeight)\n    } else if (lowClipping && scaleOpts.scaleType !== 'log') {\n      ctx.fillStyle = clipColor\n      ctx.fillRect(leftPx, height - clipHeight, w, height)\n    }\n  }\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    values.forEach(tick => {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    })\n  }\n  return { reducedFeatures }\n}\n"],"names":["fudgeFactor","clipHeight","drawLine","ctx","props","features","regions","bpPerPx","scaleOpts","height","unadjustedHeight","ticks","values","displayCrossHatches","colorCallback","config","offset","region","width","end","start","clipColor","readConfObject","scale","getScale","range","domain","niceMin","niceMax","toY","n","clamp","lastVal","prevLeftPx","Number","NEGATIVE_INFINITY","reducedFeatures","feature","leftPx","rightPx","featureSpanPx","Math","floor","push","score","get","lowClipping","highClipping","w","c","beginPath","strokeStyle","startPos","undefined","reversed","moveTo","lineTo","stroke","fillStyle","fillRect","scaleType","lineWidth","forEach","tick","round"],"sourceRoot":""}