{"version":3,"file":"static/js/2583.18866867.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3TabixAdapter/Gff3TabixAdapter.ts","../../../node_modules/.pnpm/gff-nostream@3.0.2/node_modules/gff-nostream/src/util.ts","../../../node_modules/.pnpm/gff-nostream@3.0.2/node_modules/gff-nostream/src/api.ts"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { doesIntersect2 } from '@jbrowse/core/util/range'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { parseRecordsJBrowse } from 'gff-nostream'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { Region } from '@jbrowse/core/util/types'\nimport type { LineRecord } from 'gff-nostream'\nimport type { Observer } from 'rxjs'\n\nexport default class Gff3TabixAdapter extends BaseFeatureDataAdapter {\n  private configured?: Promise<{\n    gff: TabixIndexedFile\n    dontRedispatchSet: Set<string>\n  }>\n\n  private async configurePre(_opts?: BaseOptions) {\n    const gffGzLocation = this.getConf('gffGzLocation')\n    const indexType = this.getConf(['index', 'indexType'])\n    const loc = this.getConf(['index', 'location'])\n    const dontRedispatch = this.getConf('dontRedispatch') as string[]\n    const gff = new TabixIndexedFile({\n      filehandle: openLocation(gffGzLocation, this.pluginManager),\n      csiFilehandle:\n        indexType === 'CSI' ? openLocation(loc, this.pluginManager) : undefined,\n      tbiFilehandle:\n        indexType !== 'CSI' ? openLocation(loc, this.pluginManager) : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n\n    return {\n      gff,\n      dontRedispatchSet: new Set(dontRedispatch),\n      header: await gff.getHeader(),\n    }\n  }\n\n  protected async configurePre2() {\n    if (!this.configured) {\n      this.configured = this.configurePre().catch((e: unknown) => {\n        this.configured = undefined\n        throw e\n      })\n    }\n    return this.configured\n  }\n\n  async configure(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, () =>\n      this.configurePre2(),\n    )\n  }\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { gff } = await this.configure(opts)\n    return gff.getReferenceSequenceNames(opts)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { gff } = await this.configure(opts)\n    return gff.getHeader()\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { gff } = await this.configure(opts)\n      const metadata = await gff.getMetadata()\n      await this.getFeaturesHelper(query, opts, metadata, observer, true)\n    }, opts.stopToken)\n  }\n\n  private async getFeaturesHelper(\n    query: Region,\n    opts: BaseOptions,\n    metadata: { columnNumbers: { start: number; end: number } },\n    observer: Observer<Feature>,\n    allowRedispatch: boolean,\n    originalQuery = query,\n  ) {\n    const { statusCallback = () => {} } = opts\n    try {\n      const lines: (LineRecord & { type: string })[] = []\n\n      const { dontRedispatchSet, gff } = await this.configure(opts)\n      await updateStatus('Downloading features', statusCallback, () =>\n        gff.getLines(\n          query.refName,\n          query.start,\n          query.end,\n          (line, fileOffset, start, end) => {\n            // Extract type (column 3) without full split - find 2nd and 3rd tabs\n            const t1 = line.indexOf('\\t')\n            const t2 = line.indexOf('\\t', t1 + 1)\n            const t3 = line.indexOf('\\t', t2 + 1)\n            const type = line.slice(t2 + 1, t3)\n\n            lines.push({\n              line,\n              lineHash: fileOffset,\n              start,\n              end,\n              hasEscapes: line.includes('%'),\n              type,\n            })\n          },\n        ),\n      )\n\n      if (allowRedispatch && lines.length) {\n        let minStart = Number.POSITIVE_INFINITY\n        let maxEnd = Number.NEGATIVE_INFINITY\n        for (const rec of lines) {\n          // only expand redispatch range if feature is not a \"dontRedispatch\"\n          // type skips large regions like chromosome,region\n          if (!dontRedispatchSet.has(rec.type)) {\n            const start = rec.start - 1 // gff is 1-based\n            if (start < minStart) {\n              minStart = start\n            }\n            if (rec.end > maxEnd) {\n              maxEnd = rec.end\n            }\n          }\n        }\n        if (maxEnd > query.end || minStart < query.start) {\n          // make a new feature callback to only return top-level features\n          // in the original query range\n          await this.getFeaturesHelper(\n            { ...query, start: minStart, end: maxEnd },\n            opts,\n            metadata,\n            observer,\n            false,\n            query,\n          )\n          return\n        }\n      }\n\n      for (const feature of parseRecordsJBrowse(lines)) {\n        if (\n          doesIntersect2(\n            feature.start,\n            feature.end,\n            originalQuery.start,\n            originalQuery.end,\n          )\n        ) {\n          observer.next(\n            new SimpleFeature({\n              data: feature as unknown as Record<string, unknown>,\n              id: `${this.id}-offset-${feature._lineHash}`,\n            }),\n          )\n        }\n      }\n      observer.complete()\n    } catch (e) {\n      observer.error(e)\n    }\n  }\n}\n","// Fast, low-level functions for parsing and formatting GFF3.\n// JavaScript port of Robert Buels's Bio::GFF3::LowLevel Perl module.\n\nconst escapeRegex = /%([0-9A-Fa-f]{2})/g\nconst directiveRegex = /^\\s*##\\s*(\\S+)\\s*(.*)/\nconst lineEndRegex = /\\r?\\n$/\nconst whitespaceRegex = /\\s+/\nconst nonDigitRegex = /\\D/g\n// eslint-disable-next-line no-control-regex\nconst attrEscapeRegex = /[\\n;\\r\\t=%&,\\u0000-\\u001f\\u007f-\\u00ff]/g\n// eslint-disable-next-line no-control-regex\nconst columnEscapeRegex = /[\\n\\r\\t%\\u0000-\\u001f\\u007f-\\u00ff]/g\n\nconst HEX_LOOKUP: Record<string, string> = {}\nfor (let i = 0; i < 256; i++) {\n  const hex = i.toString(16).toUpperCase().padStart(2, '0')\n  HEX_LOOKUP[hex] = String.fromCharCode(i)\n  HEX_LOOKUP[hex.toLowerCase()] = String.fromCharCode(i)\n}\n\n/**\n * Unescape a string value used in a GFF3 attribute.\n *\n * @param stringVal - Escaped GFF3 string value\n * @returns An unescaped string value\n */\n\nexport function unescape(stringVal: string) {\n  const idx = stringVal.indexOf('%')\n  if (idx === -1) {\n    return stringVal\n  }\n\n  let result = ''\n  let lastIdx = 0\n  let i = idx\n\n  while (i < stringVal.length) {\n    if (stringVal[i] === '%' && i + 2 < stringVal.length) {\n      result += stringVal.slice(lastIdx, i)\n      const hex = stringVal.slice(i + 1, i + 3)\n      const char = HEX_LOOKUP[hex]\n      if (char !== undefined) {\n        result += char\n      } else {\n        result += stringVal.slice(i, i + 3)\n      }\n      i += 3\n      lastIdx = i\n    } else {\n      i++\n    }\n  }\n\n  return result + stringVal.slice(lastIdx)\n}\n\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributes(attrString: string): GFF3Attributes {\n  if (attrString.length === 0 || attrString === '.') {\n    return {}\n  }\n\n  const attrs: GFF3Attributes = {}\n  let len = attrString.length\n\n  if (attrString[len - 1] === '\\n') {\n    len = attrString[len - 2] === '\\r' ? len - 2 : len - 1\n    attrString = attrString.slice(0, len)\n  }\n\n  let start = 0\n  while (start < len) {\n    let semiIdx = attrString.indexOf(';', start)\n    if (semiIdx === -1) {\n      semiIdx = len\n    }\n\n    if (semiIdx > start) {\n      const eqIdx = attrString.indexOf('=', start)\n      if (eqIdx !== -1 && eqIdx < semiIdx && eqIdx + 1 < semiIdx) {\n        const tag = attrString.slice(start, eqIdx)\n        let arec = attrs[tag]\n        if (!arec) {\n          arec = []\n          attrs[tag] = arec\n        }\n\n        let valStart = eqIdx + 1\n        while (valStart < semiIdx) {\n          let commaIdx = attrString.indexOf(',', valStart)\n          if (commaIdx === -1 || commaIdx > semiIdx) {\n            commaIdx = semiIdx\n          }\n          if (commaIdx > valStart) {\n            const val = attrString.slice(valStart, commaIdx)\n            arec.push(unescape(val))\n          }\n          valStart = commaIdx + 1\n        }\n      }\n    }\n    start = semiIdx + 1\n  }\n  return attrs\n}\n\n/**\n * Parse the 9th column (attributes) of a GFF3 feature line without unescaping.\n * Fast path for data known to contain no escaped characters.\n *\n * @param attrString - String of GFF3 9th column\n * @returns Parsed attributes\n */\nexport function parseAttributesNoUnescape(attrString: string): GFF3Attributes {\n  if (attrString.length === 0 || attrString === '.') {\n    return {}\n  }\n\n  const attrs: GFF3Attributes = {}\n  let len = attrString.length\n\n  if (attrString[len - 1] === '\\n') {\n    len = attrString[len - 2] === '\\r' ? len - 2 : len - 1\n    attrString = attrString.slice(0, len)\n  }\n\n  let start = 0\n  while (start < len) {\n    let semiIdx = attrString.indexOf(';', start)\n    if (semiIdx === -1) {\n      semiIdx = len\n    }\n\n    if (semiIdx > start) {\n      const eqIdx = attrString.indexOf('=', start)\n      if (eqIdx !== -1 && eqIdx < semiIdx && eqIdx + 1 < semiIdx) {\n        const tag = attrString.slice(start, eqIdx)\n        let arec = attrs[tag]\n        if (!arec) {\n          arec = []\n          attrs[tag] = arec\n        }\n\n        let valStart = eqIdx + 1\n        while (valStart < semiIdx) {\n          let commaIdx = attrString.indexOf(',', valStart)\n          if (commaIdx === -1 || commaIdx > semiIdx) {\n            commaIdx = semiIdx\n          }\n          if (commaIdx > valStart) {\n            arec.push(attrString.slice(valStart, commaIdx))\n          }\n          valStart = commaIdx + 1\n        }\n      }\n    }\n    start = semiIdx + 1\n  }\n  return attrs\n}\n\nfunction normUnescape(s: string) {\n  return s.length === 0 || s === '.' ? null : unescape(s)\n}\n\nfunction norm(s: string) {\n  return s.length === 0 || s === '.' ? null : s\n}\n\n/**\n * Parse a GFF3 feature line\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeature(line: string): GFF3FeatureLine {\n  const f = line.split('\\t')\n  const seq_id = f[0]!\n  const source = f[1]!\n  const type = f[2]!\n  const startStr = f[3]!\n  const endStr = f[4]!\n  const scoreStr = f[5]!\n  const strand = f[6]!\n  const phase = f[7]!\n  const attrString = f[8]!\n\n  return {\n    seq_id: normUnescape(seq_id),\n    source: normUnescape(source),\n    type: normUnescape(type),\n    start: startStr.length === 0 || startStr === '.' ? null : +startStr,\n    end: endStr.length === 0 || endStr === '.' ? null : +endStr,\n    score: scoreStr.length === 0 || scoreStr === '.' ? null : +scoreStr,\n    strand: norm(strand),\n    phase: norm(phase),\n    attributes: attrString.length === 0 || attrString === '.' ? null : parseAttributes(attrString),\n  }\n}\n\n/**\n * Parse a GFF3 feature line without unescaping.\n * Fast path for data known to contain no escaped characters.\n *\n * @param line - GFF3 feature line\n * @returns The parsed feature\n */\nexport function parseFeatureNoUnescape(line: string): GFF3FeatureLine {\n  const f = line.split('\\t')\n  const seq_id = f[0]!\n  const source = f[1]!\n  const type = f[2]!\n  const startStr = f[3]!\n  const endStr = f[4]!\n  const scoreStr = f[5]!\n  const strand = f[6]!\n  const phase = f[7]!\n  const attrString = f[8]!\n\n  return {\n    seq_id: norm(seq_id),\n    source: norm(source),\n    type: norm(type),\n    start: startStr.length === 0 || startStr === '.' ? null : +startStr,\n    end: endStr.length === 0 || endStr === '.' ? null : +endStr,\n    score: scoreStr.length === 0 || scoreStr === '.' ? null : +scoreStr,\n    strand: norm(strand),\n    phase: norm(phase),\n    attributes: attrString.length === 0 || attrString === '.' ? null : parseAttributesNoUnescape(attrString),\n  }\n}\n\n/**\n * Parse a GFF3 feature from a pre-split fields array\n *\n * @param f - Array of 9 GFF3 column values (use null or '.' for empty values)\n * @returns The parsed feature\n */\nexport function parseFieldsArray(\n  f: (string | null | undefined)[],\n): GFF3FeatureLine {\n  const seq_id = f[0]\n  const source = f[1]\n  const type = f[2]\n  const startStr = f[3]\n  const endStr = f[4]\n  const scoreStr = f[5]\n  const strand = f[6]\n  const phase = f[7]\n  const attrString = f[8]\n\n  return {\n    seq_id: seq_id ? normUnescape(seq_id) : null,\n    source: source ? normUnescape(source) : null,\n    type: type ? normUnescape(type) : null,\n    start: !startStr || startStr === '.' ? null : +startStr,\n    end: !endStr || endStr === '.' ? null : +endStr,\n    score: !scoreStr || scoreStr === '.' ? null : +scoreStr,\n    strand: strand && strand !== '.' ? strand : null,\n    phase: phase && phase !== '.' ? phase : null,\n    attributes: !attrString || attrString === '.' ? null : parseAttributes(attrString),\n  }\n}\n\n/**\n * Parse a GFF3 feature from a pre-split fields array without unescaping.\n * Fast path for data known to contain no escaped characters.\n *\n * @param f - Array of 9 GFF3 column values (use null or '.' for empty values)\n * @returns The parsed feature\n */\nexport function parseFieldsArrayNoUnescape(\n  f: (string | null | undefined)[],\n): GFF3FeatureLine {\n  const seq_id = f[0]\n  const source = f[1]\n  const type = f[2]\n  const startStr = f[3]\n  const endStr = f[4]\n  const scoreStr = f[5]\n  const strand = f[6]\n  const phase = f[7]\n  const attrString = f[8]\n\n  return {\n    seq_id: seq_id && seq_id !== '.' ? seq_id : null,\n    source: source && source !== '.' ? source : null,\n    type: type && type !== '.' ? type : null,\n    start: !startStr || startStr === '.' ? null : +startStr,\n    end: !endStr || endStr === '.' ? null : +endStr,\n    score: !scoreStr || scoreStr === '.' ? null : +scoreStr,\n    strand: strand && strand !== '.' ? strand : null,\n    phase: phase && phase !== '.' ? phase : null,\n    attributes: !attrString || attrString === '.' ? null : parseAttributesNoUnescape(attrString),\n  }\n}\n\n/**\n * Parse a GFF3 directive line.\n *\n * @param line - GFF3 directive line\n * @returns The parsed directive\n */\nexport function parseDirective(\n  line: string,\n):\n  | GFF3Directive\n  | GFF3SequenceRegionDirective\n  | GFF3GenomeBuildDirective\n  | null {\n  const match = directiveRegex.exec(line)\n  if (!match) {\n    return null\n  }\n\n  const [, name] = match\n  let [, , contents] = match\n\n  const parsed: GFF3Directive = { directive: name }\n  if (contents!.length) {\n    contents = contents!.replace(lineEndRegex, '')\n    parsed.value = contents\n  }\n\n  // do a little additional parsing for sequence-region and genome-build directives\n  if (name === 'sequence-region') {\n    const c = contents!.split(whitespaceRegex, 3)\n    return {\n      ...parsed,\n      seq_id: c[0],\n      start: c[1]?.replaceAll(nonDigitRegex, ''),\n      end: c[2]?.replaceAll(nonDigitRegex, ''),\n    } as GFF3SequenceRegionDirective\n  } else if (name === 'genome-build') {\n    const [source, buildName] = contents!.split(whitespaceRegex, 2)\n    return {\n      ...parsed,\n      source,\n      buildName,\n    } as GFF3GenomeBuildDirective\n  }\n\n  return parsed\n}\n\n/** A record of GFF3 attribute identifiers and the values of those identifiers */\nexport type GFF3Attributes = Record<string, string[] | undefined>\n\n/** A representation of a single line of a GFF3 file */\nexport interface GFF3FeatureLine {\n  /** The ID of the landmark used to establish the coordinate system for the current feature */\n  seq_id: string | null\n  /** A free text qualifier intended to describe the algorithm or operating procedure that generated this feature */\n  source: string | null\n  /** The type of the feature */\n  type: string | null\n  /** The start coordinates of the feature */\n  start: number | null\n  /** The end coordinates of the feature */\n  end: number | null\n  /** The score of the feature */\n  score: number | null\n  /** The strand of the feature */\n  strand: string | null\n  /** For features of type \"CDS\", the phase indicates where the next codon begins relative to the 5' end of the current CDS feature */\n  phase: string | null\n  /** Feature attributes */\n  attributes: GFF3Attributes | null\n}\n\n/**\n * A GFF3 Feature line that includes references to other features defined in\n * their \"Parent\" or \"Derives_from\" attributes\n */\nexport interface GFF3FeatureLineWithRefs extends GFF3FeatureLine {\n  /** An array of child features */\n  child_features: GFF3Feature[]\n  /** An array of features derived from this feature */\n  derived_features: GFF3Feature[]\n}\n\n/**\n * A GFF3 feature, which may include multiple individual feature lines\n */\nexport type GFF3Feature = GFF3FeatureLineWithRefs[]\n\n/** A GFF3 directive */\nexport interface GFF3Directive {\n  /** The name of the directive */\n  directive: string\n  /** The string value of the directive */\n  value?: string\n}\n\n/** A GFF3 sequence-region directive */\nexport interface GFF3SequenceRegionDirective extends GFF3Directive {\n  /** The string value of the directive */\n  value: string\n  /** The sequence ID parsed from the directive */\n  seq_id: string\n  /** The sequence start parsed from the directive */\n  start: string\n  /** The sequence end parsed from the directive */\n  end: string\n}\n\n/** A GFF3 genome-build directive */\nexport interface GFF3GenomeBuildDirective extends GFF3Directive {\n  /** The string value of the directive */\n  value: string\n  /** The genome build source parsed from the directive */\n  source: string\n  /** The genome build name parsed from the directive */\n  buildName: string\n}\n\n/** A GFF3 comment */\nexport interface GFF3Comment {\n  /** The text of the comment */\n  comment: string\n}\n\n/** A GFF3 FASTA single sequence */\nexport interface GFF3Sequence {\n  /** The ID of the sequence */\n  id: string\n  /** The description of the sequence */\n  description?: string\n  /** The sequence */\n  sequence: string\n}\n\nexport type GFF3Item = GFF3Feature | GFF3Directive | GFF3Comment | GFF3Sequence\n\n// JBrowse format types and parsing functions\n\nconst JBROWSE_DEFAULT_FIELDS = new Set([\n  'start',\n  'end',\n  'seq_id',\n  'score',\n  'type',\n  'source',\n  'phase',\n  'strand',\n])\n\nexport interface JBrowseFeature {\n  start: number\n  end: number\n  strand?: number\n  type: string | null\n  source: string | null\n  refName: string\n  phase?: number\n  score?: number\n  subfeatures: JBrowseFeature[]\n  [key: string]: unknown\n}\n\nfunction parseStrand(s: string) {\n  if (s === '+') {\n    return 1\n  }\n  if (s === '-') {\n    return -1\n  }\n  if (s === '.') {\n    return 0\n  }\n  return undefined\n}\n\nexport function parseAttributesJBrowse(\n  attrString: string,\n  result: Record<string, unknown>,\n) {\n  if (attrString.length === 0 || attrString === '.') {\n    return\n  }\n\n  let len = attrString.length\n  if (attrString[len - 1] === '\\n') {\n    len = attrString[len - 2] === '\\r' ? len - 2 : len - 1\n    attrString = attrString.slice(0, len)\n  }\n\n  let start = 0\n  while (start < len) {\n    let semiIdx = attrString.indexOf(';', start)\n    if (semiIdx === -1) {\n      semiIdx = len\n    }\n\n    if (semiIdx > start) {\n      const eqIdx = attrString.indexOf('=', start)\n      if (eqIdx !== -1 && eqIdx < semiIdx && eqIdx + 1 < semiIdx) {\n        const tag = attrString.slice(start, eqIdx)\n        if (tag === '_lineHash') {\n          start = semiIdx + 1\n          continue\n        }\n\n        let key = tag.toLowerCase()\n        if (JBROWSE_DEFAULT_FIELDS.has(key)) {\n          key += '2'\n        }\n\n        const values: string[] = []\n        let valStart = eqIdx + 1\n        while (valStart < semiIdx) {\n          let commaIdx = attrString.indexOf(',', valStart)\n          if (commaIdx === -1 || commaIdx > semiIdx) {\n            commaIdx = semiIdx\n          }\n          if (commaIdx > valStart) {\n            const val = attrString.slice(valStart, commaIdx)\n            values.push(unescape(val))\n          }\n          valStart = commaIdx + 1\n        }\n\n        result[key] = values.length === 1 ? values[0] : values\n      }\n    }\n    start = semiIdx + 1\n  }\n}\n\nexport function parseAttributesJBrowseNoUnescape(\n  attrString: string,\n  result: Record<string, unknown>,\n) {\n  if (attrString.length === 0 || attrString === '.') {\n    return\n  }\n\n  let len = attrString.length\n  if (attrString[len - 1] === '\\n') {\n    len = attrString[len - 2] === '\\r' ? len - 2 : len - 1\n    attrString = attrString.slice(0, len)\n  }\n\n  let start = 0\n  while (start < len) {\n    let semiIdx = attrString.indexOf(';', start)\n    if (semiIdx === -1) {\n      semiIdx = len\n    }\n\n    if (semiIdx > start) {\n      const eqIdx = attrString.indexOf('=', start)\n      if (eqIdx !== -1 && eqIdx < semiIdx && eqIdx + 1 < semiIdx) {\n        const tag = attrString.slice(start, eqIdx)\n        if (tag === '_lineHash') {\n          start = semiIdx + 1\n          continue\n        }\n\n        let key = tag.toLowerCase()\n        if (JBROWSE_DEFAULT_FIELDS.has(key)) {\n          key += '2'\n        }\n\n        const values: string[] = []\n        let valStart = eqIdx + 1\n        while (valStart < semiIdx) {\n          let commaIdx = attrString.indexOf(',', valStart)\n          if (commaIdx === -1 || commaIdx > semiIdx) {\n            commaIdx = semiIdx\n          }\n          if (commaIdx > valStart) {\n            values.push(attrString.slice(valStart, commaIdx))\n          }\n          valStart = commaIdx + 1\n        }\n\n        result[key] = values.length === 1 ? values[0] : values\n      }\n    }\n    start = semiIdx + 1\n  }\n}\n\nexport function parseFeatureJBrowse(line: string): JBrowseFeature {\n  const f = line.split('\\t')\n  const seq_id = f[0]!\n  const source = f[1]!\n  const type = f[2]!\n  const startStr = f[3]!\n  const endStr = f[4]!\n  const scoreStr = f[5]!\n  const strand = f[6]!\n  const phase = f[7]!\n  const attrString = f[8]!\n\n  const result: JBrowseFeature = {\n    refName: seq_id.length === 0 || seq_id === '.' ? '' : unescape(seq_id),\n    source: source.length === 0 || source === '.' ? null : unescape(source),\n    type: type.length === 0 || type === '.' ? null : unescape(type),\n    start: startStr.length === 0 || startStr === '.' ? 0 : +startStr - 1,\n    end: endStr.length === 0 || endStr === '.' ? 0 : +endStr,\n    score: scoreStr.length === 0 || scoreStr === '.' ? undefined : +scoreStr,\n    strand: parseStrand(strand),\n    phase: phase.length === 0 || phase === '.' ? undefined : +phase,\n    subfeatures: [],\n  }\n\n  parseAttributesJBrowse(attrString, result)\n  return result\n}\n\nexport function parseFeatureJBrowseNoUnescape(line: string): JBrowseFeature {\n  const f = line.split('\\t')\n  const seq_id = f[0]!\n  const source = f[1]!\n  const type = f[2]!\n  const startStr = f[3]!\n  const endStr = f[4]!\n  const scoreStr = f[5]!\n  const strand = f[6]!\n  const phase = f[7]!\n  const attrString = f[8]!\n\n  const result: JBrowseFeature = {\n    refName: seq_id.length === 0 || seq_id === '.' ? '' : seq_id,\n    source: source.length === 0 || source === '.' ? null : source,\n    type: type.length === 0 || type === '.' ? null : type,\n    start: startStr.length === 0 || startStr === '.' ? 0 : +startStr - 1,\n    end: endStr.length === 0 || endStr === '.' ? 0 : +endStr,\n    score: scoreStr.length === 0 || scoreStr === '.' ? undefined : +scoreStr,\n    strand: parseStrand(strand),\n    phase: phase.length === 0 || phase === '.' ? undefined : +phase,\n    subfeatures: [],\n  }\n\n  parseAttributesJBrowseNoUnescape(attrString, result)\n  return result\n}\n","import {\n  parseFeature,\n  parseFeatureJBrowse,\n  parseFeatureJBrowseNoUnescape,\n  parseFeatureNoUnescape,\n} from './util.ts'\n\nimport type {\n  GFF3Feature,\n  GFF3FeatureLineWithRefs,\n  JBrowseFeature,\n} from './util.ts'\n\nexport interface LineRecord {\n  line: string\n  lineHash?: string | number\n  start: number\n  end: number\n  hasEscapes: boolean\n}\n\n/**\n * Synchronously parse a string containing GFF3 and return an array of the\n * parsed items.\n *\n * @param str - GFF3 string\n * @returns array of parsed features\n */\nexport function parseStringSync(str: string): GFF3Feature[] {\n  return parseRecords(stringToRecords(str))\n}\n\n/**\n * Synchronously parse a string containing GFF3 directly into JBrowse format.\n *\n * @param str - GFF3 string\n * @returns array of JBrowse-format features\n */\nexport function parseStringSyncJBrowse(str: string): JBrowseFeature[] {\n  return parseRecordsJBrowse(stringToRecords(str))\n}\n\nfunction stringToRecords(str: string) {\n  const lines = str.split(/\\r?\\n/)\n  const records: LineRecord[] = []\n  for (let i = 0; i < lines.length; i++) {\n    const line = lines[i]!\n    if (line.length === 0 || line[0] === '#') {\n      if (line.startsWith('##FASTA')) {\n        break\n      }\n      continue\n    }\n    if (line[0] === '>') {\n      break\n    }\n    records.push({\n      line,\n      start: 0,\n      end: 0,\n      hasEscapes: line.includes('%'),\n    })\n  }\n  return records\n}\n\n/**\n * Parse an array of LineRecord objects containing raw GFF3 lines.\n * Supports parent/child relationships.\n *\n * @param records - Array of LineRecord objects with raw line and metadata\n * @returns array of parsed features\n */\nexport function parseRecords(records: LineRecord[]): GFF3Feature[] {\n  const items: GFF3Feature[] = []\n  const byId = new Map<string, GFF3Feature>()\n  const orphans = new Map<string, GFF3Feature[]>()\n\n  for (let i = 0; i < records.length; i++) {\n    const record = records[i]!\n    const featureLine = (\n      record.hasEscapes\n        ? parseFeature(record.line)\n        : parseFeatureNoUnescape(record.line)\n    ) as GFF3FeatureLineWithRefs\n    featureLine.child_features = []\n    featureLine.derived_features = []\n\n    if (record.lineHash !== undefined) {\n      if (!featureLine.attributes) {\n        featureLine.attributes = {}\n      }\n      featureLine.attributes._lineHash = [String(record.lineHash)]\n    }\n\n    const attrs = featureLine.attributes\n    const ids = attrs?.ID\n    const parents = attrs?.Parent\n\n    if (!ids && !parents) {\n      items.push([featureLine])\n      continue\n    }\n\n    let feature: GFF3Feature\n    if (ids) {\n      const id = ids[0]!\n      const existing = byId.get(id)\n      if (existing) {\n        existing.push(featureLine)\n        feature = existing\n      } else {\n        feature = [featureLine]\n        if (!parents) {\n          items.push(feature)\n        }\n        byId.set(id, feature)\n        const waiting = orphans.get(id)\n        if (waiting) {\n          for (let j = 0; j < waiting.length; j++) {\n            featureLine.child_features.push(waiting[j]!)\n          }\n          orphans.delete(id)\n        }\n      }\n    } else {\n      feature = [featureLine]\n    }\n\n    if (parents) {\n      for (let j = 0; j < parents.length; j++) {\n        const parentId = parents[j]!\n        const parent = byId.get(parentId)\n        if (parent) {\n          for (let k = 0; k < parent.length; k++) {\n            parent[k]!.child_features.push(feature)\n          }\n        } else {\n          let arr = orphans.get(parentId)\n          if (!arr) {\n            arr = []\n            orphans.set(parentId, arr)\n          }\n          arr.push(feature)\n        }\n      }\n    }\n  }\n\n  return items\n}\n\n/**\n * Parse an array of LineRecord objects directly into JBrowse feature format.\n * Supports parent/child relationships via subfeatures.\n *\n * @param records - Array of LineRecord objects with raw line and metadata\n * @returns array of JBrowse-format features\n */\nexport function parseRecordsJBrowse(records: LineRecord[]): JBrowseFeature[] {\n  const items: JBrowseFeature[] = []\n  const byId = new Map<string, JBrowseFeature>()\n  const orphans = new Map<string, JBrowseFeature[]>()\n\n  for (let i = 0; i < records.length; i++) {\n    const record = records[i]!\n    const feature = record.hasEscapes\n      ? parseFeatureJBrowse(record.line)\n      : parseFeatureJBrowseNoUnescape(record.line)\n\n    if (record.lineHash !== undefined) {\n      feature._lineHash = String(record.lineHash)\n    }\n\n    const id = feature.id as string | undefined\n    const parent = feature.parent as string | string[] | undefined\n\n    if (!id && !parent) {\n      items.push(feature)\n      continue\n    }\n\n    if (id) {\n      const existing = byId.get(id)\n      if (!existing) {\n        if (!parent) {\n          items.push(feature)\n        }\n        byId.set(id, feature)\n        const waiting = orphans.get(id)\n        if (waiting) {\n          for (let j = 0; j < waiting.length; j++) {\n            feature.subfeatures.push(waiting[j]!)\n          }\n          orphans.delete(id)\n        }\n      }\n    }\n\n    if (parent) {\n      const parents = Array.isArray(parent) ? parent : [parent]\n      for (let j = 0; j < parents.length; j++) {\n        const parentId = parents[j]!\n        const parentFeature = byId.get(parentId)\n        if (parentFeature) {\n          parentFeature.subfeatures.push(feature)\n        } else {\n          let arr = orphans.get(parentId)\n          if (!arr) {\n            arr = []\n            orphans.set(parentId, arr)\n          }\n          arr.push(feature)\n        }\n      }\n    }\n  }\n\n  return items\n}\n\nexport type {\n  GFF3Comment,\n  GFF3Directive,\n  GFF3Feature,\n  GFF3FeatureLine,\n  GFF3FeatureLineWithRefs,\n  GFF3Item,\n  GFF3Sequence,\n  JBrowseFeature,\n} from './util.ts'\n"],"names":["Gff3TabixAdapter","BaseFeatureDataAdapter","configurePre","_opts","gffGzLocation","this","getConf","indexType","loc","dontRedispatch","gff","TabixIndexedFile","filehandle","openLocation","pluginManager","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","dontRedispatchSet","Set","header","getHeader","configurePre2","configured","catch","e","configure","opts","statusCallback","updateStatus","getRefNames","getReferenceSequenceNames","getFeatures","query","ObservableCreate","async","metadata","getMetadata","getFeaturesHelper","observer","stopToken","allowRedispatch","originalQuery","lines","getLines","refName","start","end","line","fileOffset","t1","indexOf","t2","t3","type","slice","push","lineHash","hasEscapes","includes","length","minStart","Number","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","rec","has","feature","parseRecordsJBrowse","doesIntersect2","next","SimpleFeature","data","id","_lineHash","complete","error","HEX_LOOKUP","i","hex","toString","toUpperCase","padStart","String","fromCharCode","toLowerCase","unescape","stringVal","idx","result","lastIdx","char","JBROWSE_DEFAULT_FIELDS","parseStrand","s","parseFeatureJBrowse","f","split","seq_id","source","startStr","endStr","scoreStr","strand","phase","attrString","score","subfeatures","len","semiIdx","eqIdx","tag","key","values","valStart","commaIdx","val","parseAttributesJBrowse","parseFeatureJBrowseNoUnescape","parseAttributesJBrowseNoUnescape","parseStringSyncJBrowse","str","records","startsWith","stringToRecords","items","byId","Map","orphans","record","parent","get","set","waiting","j","delete","parents","Array","isArray","parentId","parentFeature","arr"],"ignoreList":[],"sourceRoot":""}