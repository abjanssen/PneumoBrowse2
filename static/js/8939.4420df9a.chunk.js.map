{"version":3,"file":"static/js/8939.4420df9a.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../packages/core/src/util/parseLineByLine.ts","webpack://@jbrowse/web/../../plugins/variants/src/VcfAdapter/VcfAdapter.ts","webpack://@jbrowse/web/../../plugins/variants/src/VcfAdapter/vcfParser.ts","webpack://@jbrowse/web/../../plugins/variants/src/VcfFeature/index.ts","webpack://@jbrowse/web/../../plugins/variants/src/VcfFeature/util.ts"],"sourcesContent":["import { getProgressDisplayStr } from './index.ts'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n","import VcfParser from '@gmod/vcf'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { IntervalTree, fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport { parseVcfBuffer } from './vcfParser.ts'\nimport VcfFeature from '../VcfFeature/index.ts'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\nimport type { StatusCallback } from '@jbrowse/core/util/parseLineByLine'\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree<Feature>> = {}\n\n  vcfFeatures?: Promise<{\n    header: string\n    parser: VcfParser\n    intervalTreeMap: Record<\n      string,\n      (sc?: StatusCallback) => IntervalTree<Feature>\n    >\n    featureMap: Record<string, string[]>\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames', 'exportData']\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { parser } = await this.setup()\n    return parser.getMetadata()\n  }\n\n  public async setupP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const loc = openLocation(this.getConf('vcfLocation'), this.pluginManager)\n    const buffer = await fetchAndMaybeUnzip(loc, opts)\n\n    const { header, featureMap } = parseVcfBuffer(buffer, statusCallback)\n    const parser = new VcfParser({ header })\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: StatusCallback) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing VCF data')\n            let idx = 0\n            const intervalTree = new IntervalTree<Feature>()\n            for (const line of lines) {\n              const f = new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-${refName}-${idx++}`,\n              })\n              intervalTree.insert([f.get('start'), f.get('end')], f)\n            }\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header,\n      parser,\n      intervalTreeMap,\n      featureMap,\n    }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch((e: unknown) => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.setup()\n    return Object.keys(intervalTreeMap)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = region\n      const { intervalTreeMap } = await this.setup()\n      for (const f of intervalTreeMap[refName]?.(opts.statusCallback).search([\n        start,\n        end,\n      ]) || []) {\n        observer.next(f)\n      }\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  public async getExportData(\n    regions: Region[],\n    formatType: string,\n    _opts?: BaseOptions,\n  ): Promise<string | undefined> {\n    if (formatType !== 'vcf') {\n      return undefined\n    }\n\n    const { header, featureMap } = await this.setup()\n    const exportLines: string[] = [header]\n\n    for (const region of regions) {\n      const { refName, start, end } = region\n      const lines = featureMap[refName] || []\n\n      for (const line of lines) {\n        // VCF format: CHROM POS ID REF ALT QUAL FILTER ...\n        // Extract POS (second field, 1-based)\n        const fields = line.split('\\t')\n        const pos = parseInt(fields[1]!, 10)\n\n        // VCF positions are 1-based, convert to 0-based for comparison\n        // and check if overlaps with region\n        if (pos - 1 >= start && pos - 1 < end) {\n          exportLines.push(line)\n        }\n      }\n    }\n\n    return exportLines.join('\\n')\n  }\n\n  async getSources() {\n    const conf = this.getConf('samplesTsvLocation')\n    if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n      const { parser } = await this.setup()\n      return parser.samples.map(name => ({\n        name,\n      }))\n    } else {\n      const txt = await openLocation(conf).readFile('utf8')\n      const lines = txt.split(/\\n|\\r\\n|\\r/)\n      const header = lines[0]!.split('\\t')\n      const { parser } = await this.setup()\n      const s = new Set(parser.samples)\n      return lines\n        .slice(1)\n        .filter(Boolean)\n        .map(line => {\n          const cols = line.split('\\t')\n          return {\n            name: cols[0]!,\n            ...Object.fromEntries(\n              cols.slice(1).map((c, idx) => [header[idx + 1]!, c] as const),\n            ),\n          }\n        })\n        .filter(f => s.has(f.name))\n    }\n  }\n}\n","import { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\n\nimport type { StatusCallback } from '@jbrowse/core/util/parseLineByLine'\n\ninterface VcfParseResult {\n  header: string\n  featureMap: Record<string, string[]>\n}\n\n/**\n * Parse VCF buffer into header lines and feature map organized by reference name\n * @param buffer - The VCF file buffer\n * @param statusCallback - Optional callback for progress updates\n * @returns Object containing header lines and feature map\n */\nexport function parseVcfBuffer(\n  buffer: Uint8Array,\n  statusCallback: StatusCallback = () => {},\n): VcfParseResult {\n  const headerLines: string[] = []\n  const featureMap: Record<string, string[]> = {}\n\n  parseLineByLine(\n    buffer,\n    line => {\n      if (line.startsWith('#')) {\n        headerLines.push(line)\n      } else {\n        const ret = line.indexOf('\\t')\n        const refName = line.slice(0, ret)\n        if (!featureMap[refName]) {\n          featureMap[refName] = []\n        }\n        featureMap[refName].push(line)\n      }\n      return true\n    },\n    statusCallback,\n  )\n\n  return {\n    header: headerLines.join('\\n'),\n    featureMap,\n  }\n}\n","import { type Feature, max } from '@jbrowse/core/util'\n\nimport { getSOTermAndDescription } from './util.ts'\n\nimport type VCFParser from '@gmod/vcf'\nimport type { GenotypeCallback, Variant } from '@gmod/vcf'\n\ntype FeatureData = ReturnType<typeof dataFromVariant>\n\nfunction dataFromVariant(variant: Variant, parser: VCFParser) {\n  const { REF = '', ALT, POS, CHROM, ID } = variant\n  const start = POS - 1\n  const [type, description] = getSOTermAndDescription(REF, ALT, parser)\n\n  return {\n    refName: CHROM,\n    start,\n    end: getEnd(variant),\n    description,\n    type,\n    name: ID?.join(','),\n  }\n}\nfunction getEnd(variant: Variant) {\n  const { POS, REF = '', ALT = [] } = variant\n  const start = POS - 1\n  let isTRA = false\n  let isSymbolic = false\n  for (const a of ALT) {\n    if (a.includes('<')) {\n      isSymbolic = true\n      if (a === '<TRA>') {\n        isTRA = true\n        break\n      }\n    }\n  }\n  if (isSymbolic) {\n    const info = variant.INFO\n    if (info.END && !isTRA) {\n      return +(info.END as string[])[0]!\n    }\n    const lens = []\n    if (info.SVLEN && !isTRA) {\n      const svlens = info.SVLEN as string[]\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let i = 0; i < svlens.length; i++) {\n        const svlen = svlens[i]!\n        if (ALT[i]?.startsWith('<INS')) {\n          lens.push(1)\n        } else {\n          lens.push(Math.abs(+svlen))\n        }\n      }\n      return start + max(lens)\n    }\n  }\n  return start + REF.length\n}\n\nexport default class VCFFeature implements Feature {\n  private variant: Variant\n\n  private parser: VCFParser\n\n  private data: FeatureData\n\n  private _id: string\n\n  constructor(args: { variant: Variant; parser: VCFParser; id: string }) {\n    this.variant = args.variant\n    this.parser = args.parser\n    this.data = dataFromVariant(this.variant, this.parser)\n    this._id = args.id\n  }\n\n  get(field: string): any {\n    return field === 'samples'\n      ? this.variant.SAMPLES()\n      : field === 'genotypes'\n        ? this.variant.GENOTYPES()\n        : (this.data[field as keyof typeof this.data] ??\n          this.variant[field as keyof typeof this.variant])\n  }\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  id() {\n    return this._id\n  }\n\n  processGenotypes(callback: GenotypeCallback) {\n    this.variant.processGenotypes(callback)\n  }\n\n  toJSON(): any {\n    return {\n      uniqueId: this._id,\n      ...this.variant.toJSON(),\n      ...this.data,\n      samples: this.variant.SAMPLES(),\n    }\n  }\n}\n","import { parseBreakend } from '@gmod/vcf'\nimport { getBpDisplayStr } from '@jbrowse/core/util'\n\nimport type VCF from '@gmod/vcf'\n\nconst genotypeDelimRegex = /[/|]/\n\nfunction isBreakend(alt: string) {\n  return (\n    alt.includes('[') ||\n    alt.includes(']') ||\n    alt.startsWith('.') ||\n    alt.endsWith('.')\n  )\n}\n\nfunction isSymbolic(alt: string) {\n  return alt.startsWith('<') || isBreakend(alt)\n}\n\nfunction isInversion(ref: string, alt: string) {\n  return ref.split('').reverse().join('') === alt\n}\n\nconst altTypeToSO: Record<string, string> = {\n  '<DEL>': 'deletion',\n  '<INS>': 'insertion',\n  '<DUP>': 'duplication',\n  '<INV>': 'inversion',\n  '<INVDUP>': 'inverted_duplication',\n  '<CNV>': 'copy_number_variation',\n  '<TRA>': 'translocation',\n  '<DUP:TANDEM>': 'tandem_duplication',\n  '<NON_REF>': 'sequence_variant',\n  '<*>': 'sequence_variant',\n}\n\nexport function getSOTermAndDescription(\n  ref: string,\n  alt: string[] | undefined,\n  parser: VCF,\n): string[] {\n  if (!alt || alt.length === 0) {\n    return ['remark', 'no alternative alleles']\n  }\n\n  const soTerms = alt.map(a => getSOTerm(a, ref, parser))\n  const uniqueSoTerms = [...new Set(soTerms)]\n  const description = formatGroupDescription(ref, alt)\n\n  return [uniqueSoTerms.join(','), description]\n}\n\nfunction getSOTerm(alt: string, ref: string, parser: VCF): string {\n  // Symbolic alleles\n  if (alt.startsWith('<')) {\n    return findSOTerm(alt, parser) ?? 'variant'\n  }\n\n  // Breakends\n  if (isBreakend(alt) && parseBreakend(alt)) {\n    return 'breakend'\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n\n  if (lenRef === 1 && lenAlt === 1) {\n    return 'SNV'\n  } else if (lenRef === lenAlt) {\n    return isInversion(ref, alt) ? 'inversion' : 'substitution'\n  } else {\n    return lenRef < lenAlt ? 'insertion' : 'deletion'\n  }\n}\n\nfunction formatGroupDescription(ref: string, alts: string[]): string {\n  if (alts.every(isSymbolic)) {\n    return alts.join(',')\n  }\n\n  const lenRef = ref.length\n\n  return `${ref.length > 10 ? getBpDisplayStr(lenRef) : ref} -> ${alts.map(a => (a.length > 10 ? getBpDisplayStr(a.length) : a)).join(',')}`\n}\n\nfunction findSOTerm(alt: string, parser: VCF): string | undefined {\n  if (altTypeToSO[alt]) {\n    return altTypeToSO[alt]\n  }\n  if (parser.getMetadata('ALT', alt)) {\n    return 'sequence_variant'\n  }\n  // Try parent term by stripping last component, e.g. '<INS:ME>' -> '<INS>'\n  const parts = alt.slice(1, -1).split(':')\n  return parts.length > 1\n    ? findSOTerm(`<${parts.slice(0, -1).join(':')}>`, parser)\n    : undefined\n}\n\nexport function getSOAndDescFromAltDefs(alt: string, parser: VCF): string[] {\n  if (!alt.startsWith('<')) {\n    return []\n  }\n\n  const soTerm = findSOTerm(alt, parser)\n  return [soTerm ?? 'variant', alt]\n}\n\nexport function getMinimalDesc(ref: string, alt: string) {\n  if (isSymbolic(alt) || (ref.length === 1 && alt.length === 1)) {\n    return alt\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n  const isLong = lenRef > 5 || lenAlt > 5\n\n  return isLong\n    ? `${getBpDisplayStr(lenRef)} -> ${getBpDisplayStr(lenAlt)}`\n    : `${ref} -> ${alt}`\n}\n\nexport function makeSimpleAltString(\n  genotype: string,\n  ref: string,\n  alt: string[],\n) {\n  return genotype\n    .split(genotypeDelimRegex)\n    .map(r =>\n      r === '.'\n        ? '.'\n        : +r === 0\n          ? `ref(${ref.length < 10 ? ref : getBpDisplayStr(ref.length)})`\n          : getMinimalDesc(ref, alt[+r - 1] || ''),\n    )\n    .join(genotype.includes('|') ? '|' : '/')\n}\n"],"names":["parseLineByLine","buffer","lineCallback","statusCallback","decoder","TextDecoder","blockStart","i","length","n","indexOf","lineEnd","b","subarray","line","decode","trim","getProgressDisplayStr","VcfAdapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","getHeader","header","this","setup","getMetadata","parser","setupP","opts","loc","openLocation","getConf","pluginManager","fetchAndMaybeUnzip","featureMap","headerLines","startsWith","push","ret","refName","slice","join","parseVcfBuffer","VcfParser","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","idx","intervalTree","IntervalTree","f","VcfFeature","variant","parseLine","id","insert","get","vcfFeatures","catch","e","undefined","getRefNames","_","keys","getFeatures","region","ObservableCreate","async","start","end","search","observer","next","complete","stopToken","getExportData","regions","formatType","_opts","exportLines","fields","split","pos","parseInt","getSources","conf","uri","samples","name","readFile","s","Set","filter","Boolean","cols","c","has","getEnd","POS","REF","ALT","isTRA","isSymbolic","a","includes","info","INFO","END","lens","SVLEN","svlens","svlen","Math","abs","max","VCFFeature","constructor","args","data","CHROM","ID","type","description","getSOTermAndDescription","dataFromVariant","_id","field","SAMPLES","GENOTYPES","parent","children","processGenotypes","callback","toJSON","uniqueId","genotypeDelimRegex","isBreakend","alt","endsWith","altTypeToSO","ref","soTerms","findSOTerm","parseBreakend","lenRef","lenAlt","reverse","isInversion","getSOTerm","uniqueSoTerms","alts","every","getBpDisplayStr","formatGroupDescription","parts","getMinimalDesc","makeSimpleAltString","genotype","r"],"sourceRoot":""}