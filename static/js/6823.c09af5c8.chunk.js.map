{"version":3,"file":"static/js/6823.c09af5c8.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/HtsgetBamAdapter/HtsgetBamAdapter.ts","../../../plugins/alignments/src/BamAdapter/BamSlightlyLazyFeature.ts","../../../plugins/alignments/src/BamAdapter/BamAdapter.ts"],"sourcesContent":["import { HtsgetFile } from '@gmod/bam'\n\nimport BamAdapter from '../BamAdapter/BamAdapter'\n\nimport type { BamFile } from '@gmod/bam'\nimport type { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\n\nexport default class HtsgetBamAdapter extends BamAdapter {\n  protected async configurePre() {\n    const htsgetBase = this.getConf('htsgetBase')\n    const htsgetTrackId = this.getConf('htsgetTrackId')\n    const bam = new HtsgetFile({\n      baseUrl: htsgetBase,\n      trackId: htsgetTrackId,\n    }) as unknown as BamFile\n\n    const adapterConfig = this.getConf('sequenceAdapter')\n    if (adapterConfig && this.getSubAdapter) {\n      const adapter = await this.getSubAdapter(adapterConfig)\n      return {\n        bam,\n        sequenceAdapter: adapter.dataAdapter as BaseFeatureDataAdapter,\n      }\n    }\n    return { bam }\n  }\n}\n","import { getMismatches } from '../MismatchParser'\nimport { cacheGetter } from '../shared/util'\n\nimport type BamAdapter from './BamAdapter'\nimport type { BamRecord } from '@gmod/bam'\nimport type {\n  Feature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util/simpleFeature'\n\nexport default class BamSlightlyLazyFeature implements Feature {\n  // uses parameter properties to automatically create fields on the class\n  // https://www.typescriptlang.org/docs/handbook/classes.html#parameter-properties\n  constructor(\n    private record: BamRecord,\n    private adapter: BamAdapter,\n    private ref?: string,\n  ) {}\n\n  id() {\n    return `${this.adapter.id}-${this.record.id}`\n  }\n  get mismatches() {\n    return getMismatches(\n      this.record.CIGAR,\n      this.record.tags.MD as string | undefined,\n      this.record.seq,\n      this.ref,\n      this.record.qual,\n    )\n  }\n\n  get qual() {\n    return this.record.qual?.join(' ')\n  }\n\n  get(field: string): any {\n    return field === 'mismatches'\n      ? this.mismatches\n      : field === 'qual'\n        ? this.qual\n        : this.fields[field]\n  }\n\n  parent() {\n    return undefined\n  }\n\n  children() {\n    return undefined\n  }\n\n  get fields(): SimpleFeatureSerialized {\n    const r = this.record\n    const a = this.adapter\n    const p = r.isPaired()\n    return {\n      start: r.start,\n      name: r.name,\n      end: r.end,\n      score: r.score,\n      strand: r.strand,\n      template_length: r.template_length,\n      flags: r.flags,\n      tags: r.tags,\n      refName: a.refIdToName(r.ref_id)!,\n      CIGAR: r.CIGAR,\n      seq: r.seq,\n      type: 'match',\n      pair_orientation: r.pair_orientation,\n      next_ref: p ? a.refIdToName(r.next_refid) : undefined,\n      next_pos: p ? r.next_pos : undefined,\n      next_segment_position: p\n        ? `${a.refIdToName(r.next_refid)}:${r.next_pos + 1}`\n        : undefined,\n      uniqueId: this.id(),\n    }\n  }\n\n  toJSON(): SimpleFeatureSerialized {\n    return {\n      ...this.fields,\n      qual: this.qual,\n    }\n  }\n}\n\ncacheGetter(BamSlightlyLazyFeature, 'fields')\ncacheGetter(BamSlightlyLazyFeature, 'mismatches')\n","import { BamFile } from '@gmod/bam'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { bytesForRegions, updateStatus } from '@jbrowse/core/util'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport BamSlightlyLazyFeature from './BamSlightlyLazyFeature'\nimport { filterReadFlag, filterTagValue } from '../shared/util'\n\nimport type { FilterBy } from '../shared/types'\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { Region } from '@jbrowse/core/util/types'\n\ninterface Header {\n  idToName: string[]\n  nameToId: Record<string, number>\n}\n\nexport default class BamAdapter extends BaseFeatureDataAdapter {\n  private samHeader?: Header\n\n  private setupP?: Promise<Header>\n\n  // used for avoiding re-creation new BamSlightlyLazyFeatures, keeping\n  // mismatches in cache. at an average of 100kb-300kb, keeping even just 500\n  // of these in memory is memory intensive but can reduce recomputation on\n  // these objects\n  private ultraLongFeatureCache = new QuickLRU<string, Feature>({\n    maxSize: 500,\n  })\n\n  private configureP?: Promise<{\n    bam: BamFile\n    sequenceAdapter?: BaseFeatureDataAdapter\n  }>\n\n  // derived classes may not use the same configuration so a custom configure\n  // method allows derived classes to override this behavior\n  protected async configurePre() {\n    const bamLocation = this.getConf('bamLocation')\n    const location = this.getConf(['index', 'location'])\n    const indexType = this.getConf(['index', 'indexType'])\n    const pm = this.pluginManager\n    const csi = indexType === 'CSI'\n    const bam = new BamFile({\n      bamFilehandle: openLocation(bamLocation, pm),\n      csiFilehandle: csi ? openLocation(location, pm) : undefined,\n      baiFilehandle: !csi ? openLocation(location, pm) : undefined,\n      yieldThreadTime: Number.POSITIVE_INFINITY,\n    })\n\n    const adapterConfig = this.getConf('sequenceAdapter')\n    if (adapterConfig && this.getSubAdapter) {\n      const { dataAdapter } = await this.getSubAdapter(adapterConfig)\n      return {\n        bam,\n        sequenceAdapter: dataAdapter as BaseFeatureDataAdapter,\n      }\n    }\n    return { bam }\n  }\n\n  protected async configure() {\n    if (!this.configureP) {\n      this.configureP = this.configurePre().catch((e: unknown) => {\n        this.configureP = undefined\n        throw e\n      })\n    }\n    return this.configureP\n  }\n\n  async getHeader(_opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    return bam.getHeaderText()\n  }\n\n  private async setupPre(_opts?: BaseOptions) {\n    const { bam } = await this.configure()\n    const samHeader = await bam.getHeader()\n\n    // use the @SQ lines in the header to figure out the\n    // mapping between ref ref ID numbers and names\n    const idToName: string[] = []\n    const nameToId: Record<string, number> = {}\n    samHeader\n      ?.filter(l => l.tag === 'SQ')\n      .forEach((sqLine, refId) => {\n        const SN = sqLine.data.find(item => item.tag === 'SN')\n        if (SN) {\n          // this is the ref name\n          const refName = SN.value\n          nameToId[refName] = refId\n          idToName[refId] = refName\n        }\n      })\n\n    this.samHeader = { idToName, nameToId }\n    return this.samHeader\n  }\n\n  async setupPre2(opts?: BaseOptions) {\n    if (!this.setupP) {\n      this.setupP = this.setupPre(opts).catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  async setup(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, () =>\n      this.setupPre2(opts),\n    )\n  }\n\n  async getRefNames(opts?: BaseOptions) {\n    const { idToName } = await this.setup(opts)\n    return idToName\n  }\n\n  private async seqFetch(refName: string, start: number, end: number) {\n    const { sequenceAdapter } = await this.configure()\n    const refSeqStore = sequenceAdapter\n    if (!refSeqStore) {\n      return undefined\n    }\n    if (!refName) {\n      return undefined\n    }\n\n    const features = refSeqStore.getFeatures({\n      refName,\n      start,\n      end,\n      assemblyName: '',\n    })\n\n    const seqChunks = await firstValueFrom(features.pipe(toArray()))\n\n    let sequence = ''\n    seqChunks\n      .sort((a, b) => a.get('start') - b.get('start'))\n      .forEach(chunk => {\n        const chunkStart = chunk.get('start')\n        const chunkEnd = chunk.get('end')\n        const trimStart = Math.max(start - chunkStart, 0)\n        const trimEnd = Math.min(end - chunkStart, chunkEnd - chunkStart)\n        const trimLength = trimEnd - trimStart\n        const chunkSeq = chunk.get('seq') || chunk.get('residues')\n        sequence += chunkSeq.slice(trimStart, trimStart + trimLength)\n      })\n\n    if (sequence.length !== end - start) {\n      throw new Error(\n        `sequence fetch failed: fetching ${refName}:${(\n          start - 1\n        ).toLocaleString()}-${end.toLocaleString()} returned ${sequence.length.toLocaleString()} bases, but should have returned ${(\n          end - start\n        ).toLocaleString()}`,\n      )\n    }\n    return sequence\n  }\n\n  getFeatures(\n    region: Region & { originalRefName?: string },\n    opts?: BaseOptions & {\n      filterBy: FilterBy\n    },\n  ) {\n    const { refName, start, end, originalRefName } = region\n    const { stopToken, filterBy, statusCallback = () => {} } = opts || {}\n    return ObservableCreate<Feature>(async observer => {\n      const { bam } = await this.configure()\n      await this.setup(opts)\n      checkStopToken(stopToken)\n      const records = await updateStatus(\n        'Downloading alignments',\n        statusCallback,\n        () => bam.getRecordsForRange(refName, start, end),\n      )\n      checkStopToken(stopToken)\n\n      await updateStatus('Processing alignments', statusCallback, async () => {\n        const {\n          flagInclude = 0,\n          flagExclude = 0,\n          tagFilter,\n          readName,\n        } = filterBy || {}\n\n        for (const record of records) {\n          let ref: string | undefined\n          if (!record.tags.MD) {\n            ref = await this.seqFetch(\n              originalRefName || refName,\n              record.start,\n              record.end,\n            )\n          }\n\n          if (filterReadFlag(record.flags, flagInclude, flagExclude)) {\n            continue\n          }\n\n          if (\n            tagFilter &&\n            filterTagValue(record.tags[tagFilter.tag], tagFilter.value)\n          ) {\n            continue\n          }\n\n          if (readName && record.name !== readName) {\n            continue\n          }\n\n          const ret = this.ultraLongFeatureCache.get(`${record.id}`)\n          if (!ret) {\n            const elt = new BamSlightlyLazyFeature(record, this, ref)\n            this.ultraLongFeatureCache.set(`${record.id}`, elt)\n            observer.next(elt)\n          } else {\n            observer.next(ret)\n          }\n        }\n        observer.complete()\n      })\n    })\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { bam } = await this.configure()\n    // this is a method to avoid calling on htsget adapters\n    if (bam.index) {\n      const bytes = await bytesForRegions(regions, bam)\n      const fetchSizeLimit = this.getConf('fetchSizeLimit')\n      return { bytes, fetchSizeLimit }\n    }\n    return super.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  freeResources(/* { region } */): void {}\n\n  // depends on setup being called before the BAM constructor\n  refIdToName(refId: number) {\n    return this.samHeader?.idToName[refId]\n  }\n}\n"],"names":["HtsgetBamAdapter","BamAdapter","configurePre","htsgetBase","this","getConf","htsgetTrackId","bam","HtsgetFile","baseUrl","trackId","adapterConfig","getSubAdapter","sequenceAdapter","dataAdapter","BamSlightlyLazyFeature","constructor","record","adapter","ref","id","mismatches","getMismatches","CIGAR","tags","MD","seq","qual","join","get","field","fields","parent","children","r","a","p","isPaired","start","name","end","score","strand","template_length","flags","refName","refIdToName","ref_id","type","pair_orientation","next_ref","next_refid","undefined","next_pos","next_segment_position","uniqueId","toJSON","cacheGetter","BaseFeatureDataAdapter","ultraLongFeatureCache","QuickLRU","maxSize","bamLocation","location","indexType","pm","pluginManager","csi","BamFile","bamFilehandle","openLocation","csiFilehandle","baiFilehandle","yieldThreadTime","Number","POSITIVE_INFINITY","configure","configureP","catch","e","getHeader","_opts","getHeaderText","setupPre","samHeader","idToName","nameToId","filter","l","tag","forEach","sqLine","refId","SN","data","find","item","value","setupPre2","opts","setupP","setup","statusCallback","updateStatus","getRefNames","seqFetch","features","getFeatures","assemblyName","seqChunks","firstValueFrom","pipe","toArray","sequence","sort","b","chunk","chunkStart","chunkEnd","trimStart","Math","max","trimLength","min","chunkSeq","slice","length","Error","toLocaleString","region","originalRefName","stopToken","filterBy","ObservableCreate","async","checkStopToken","records","getRecordsForRange","flagInclude","flagExclude","tagFilter","readName","filterReadFlag","filterTagValue","ret","observer","next","elt","set","complete","getMultiRegionFeatureDensityStats","regions","index","bytes","bytesForRegions","fetchSizeLimit","super","freeResources"],"sourceRoot":""}