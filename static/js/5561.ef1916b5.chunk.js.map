{"version":3,"file":"static/js/5561.ef1916b5.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/shared/setupModificationsAutorun.ts","../../../plugins/alignments/src/shared/createRPCRenderingSetup.ts","../../../plugins/alignments/src/LinearReadCloudDisplay/afterAttachRPC.tsx"],"sourcesContent":["import { getContainingView } from '@jbrowse/core/util'\nimport { isAlive } from '@jbrowse/mobx-state-tree'\n\nimport { getUniqueModifications } from './getUniqueModifications.ts'\nimport { createAutorun } from '../util.ts'\n\nimport type { ModificationType } from './types.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface ModificationsAutorunModel {\n  adapterConfig: AnyConfigurationModel\n  updateVisibleModifications: (arg: ModificationType[]) => void\n  setSimplexModifications: (arg: string[]) => void\n  setModificationsReady: (arg: boolean) => void\n  setStatusMessage: (arg: string) => void\n  effectiveRpcDriverName?: string\n}\n\nexport function setupModificationsAutorun(\n  model: ModificationsAutorunModel,\n  isReady: () => boolean,\n) {\n  createAutorun(\n    model,\n    async () => {\n      if (!isReady()) {\n        return\n      }\n      const view = getContainingView(model) as LGV\n      const { adapterConfig } = model\n      const { staticBlocks } = view\n      const { modifications, simplexModifications } =\n        await getUniqueModifications({\n          model,\n          adapterConfig,\n          blocks: staticBlocks,\n        })\n      if (isAlive(model)) {\n        model.updateVisibleModifications(modifications)\n        model.setSimplexModifications(simplexModifications)\n        model.setModificationsReady(true)\n      }\n    },\n    {\n      delay: 1000,\n      name: 'GetModInfo',\n    },\n  )\n}\n","import {\n  getContainingView,\n  getSession,\n  isAbortException,\n} from '@jbrowse/core/util'\nimport { createStopToken, stopStopToken } from '@jbrowse/core/util/stopToken'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\nimport { getSnapshot, isAlive } from '@jbrowse/mobx-state-tree'\nimport { drawCanvasImageData } from '@jbrowse/plugin-linear-genome-view'\nimport { untracked } from 'mobx'\n\nimport { createAutorun } from '../util.ts'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface RPCRenderableModel {\n  id: string\n  error: unknown\n  featureDensityStatsReadyAndRegionNotTooLarge: boolean\n  effectiveRpcDriverName: string\n  adapterConfig: unknown\n  configuration: AnyConfigurationModel\n  renderingStopToken?: StopToken\n  setRenderingStopToken: (token?: StopToken) => void\n  setLoading: (loading: boolean) => void\n  setError: (error: unknown) => void\n  setRenderingImageData: (imageData: ImageBitmap | undefined) => void\n  setLastDrawnOffsetPx: (offsetPx: number) => void\n  setLastDrawnBpPerPx: (bpPerPx: number) => void\n  ref: HTMLCanvasElement | null\n  renderingImageData?: ImageBitmap\n  setStatusMessage?: (msg: string) => void\n  setCanvasDrawn?: (drawn: boolean) => void\n}\n\nexport interface RPCRenderSetupParams<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n> {\n  self: T\n  rpcMethodName: string\n  getRPCParams: (params: {\n    view: LGV\n    session: ReturnType<typeof getSession>\n    sequenceAdapter: unknown\n    stopToken: StopToken\n  }) => Record<string, unknown>\n  onResult: (result: R) => void\n}\n\nexport function createRPCRenderFunction<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n>({ self, rpcMethodName, getRPCParams, onResult }: RPCRenderSetupParams<T, R>) {\n  return async () => {\n    const view = getContainingView(self) as LGV\n\n    if (\n      !view.initialized ||\n      self.error ||\n      !self.featureDensityStatsReadyAndRegionNotTooLarge\n    ) {\n      return\n    }\n\n    const { bpPerPx } = view\n\n    try {\n      const session = getSession(self)\n      const { rpcManager, assemblyManager } = session\n      const assemblyName = view.assemblyNames[0]\n      if (!assemblyName) {\n        return\n      }\n\n      const assembly = assemblyManager.get(assemblyName)\n      const sequenceAdapterConfig = assembly?.configuration?.sequence?.adapter\n      const sequenceAdapter = sequenceAdapterConfig\n        ? getSnapshot(sequenceAdapterConfig)\n        : undefined\n\n      const previousToken = untracked(() => self.renderingStopToken)\n      if (previousToken) {\n        stopStopToken(previousToken)\n      }\n\n      const stopToken = createStopToken()\n      self.setRenderingStopToken(stopToken)\n      self.setLoading(true)\n      self.setCanvasDrawn?.(false)\n\n      const viewSnapshot = {\n        displayedRegions: structuredClone(view.displayedRegions),\n        bpPerPx: view.bpPerPx,\n        offsetPx: view.offsetPx,\n        interRegionPaddingWidth: view.interRegionPaddingWidth,\n        minimumBlockWidth: view.minimumBlockWidth,\n        width: view.width,\n      }\n\n      const sessionId = getRpcSessionId(self)\n      const adapterConfig = self.adapterConfig\n      const config = getSnapshot(self.configuration)\n      const result = (await rpcManager.call(sessionId, rpcMethodName, {\n        sessionId,\n        view: viewSnapshot,\n        adapterConfig,\n        sequenceAdapter,\n        config,\n        statusCallback: (msg: string) => {\n          if (isAlive(self)) {\n            self.setStatusMessage?.(msg)\n          }\n        },\n        stopToken,\n        ...getRPCParams({ view, session, sequenceAdapter, stopToken }),\n      })) as R & { imageData?: ImageBitmap; offsetPx?: number }\n\n      if (result.imageData) {\n        self.setRenderingImageData(result.imageData)\n        if (result.offsetPx !== undefined) {\n          self.setLastDrawnOffsetPx(result.offsetPx)\n        }\n        onResult(result)\n      }\n\n      self.setLastDrawnBpPerPx(bpPerPx)\n    } catch (error) {\n      if (!isAbortException(error)) {\n        console.error(error)\n        self.setError(error)\n      }\n    } finally {\n      self.setRenderingStopToken(undefined)\n      self.setLoading(false)\n    }\n  }\n}\n\nexport function setupCanvasRenderingAutorun<T extends RPCRenderableModel>(\n  self: T,\n) {\n  createAutorun(\n    self,\n    async () => {\n      const success = drawCanvasImageData(self.ref, self.renderingImageData)\n      if (isAlive(self)) {\n        self.setCanvasDrawn?.(success)\n      }\n    },\n    {\n      name: 'CanvasRenderAutorun',\n    },\n  )\n}\n","import { getContainingView } from '@jbrowse/core/util'\nimport { isAlive } from '@jbrowse/mobx-state-tree'\n\nimport {\n  buildFlatbushIndex,\n  buildMismatchFlatbushIndex,\n} from '../RenderLinearReadCloudDisplayRPC/drawFeatsCommon.ts'\nimport {\n  createRPCRenderFunction,\n  setupCanvasRenderingAutorun,\n} from '../shared/createRPCRenderingSetup.ts'\nimport { setupModificationsAutorun } from '../shared/setupModificationsAutorun.ts'\nimport { createAutorun } from '../util.ts'\n\nimport type { LinearReadCloudDisplayModel } from './model.ts'\nimport type { FlatbushItem } from '../PileupRenderer/types.ts'\nimport type { FlatbushEntry } from '../shared/flatbushType.ts'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\ninterface CloudRenderResult {\n  layoutHeight?: number\n  cloudMaxDistance?: number\n  featuresForFlatbush?: FlatbushEntry[]\n  mismatchFlatbush?: ArrayBuffer\n  mismatchItems?: FlatbushItem[]\n}\n\nexport function doAfterAttachRPC(self: LinearReadCloudDisplayModel) {\n  const createCloudRender = (drawCloud: boolean) =>\n    createRPCRenderFunction({\n      self,\n      rpcMethodName: 'RenderLinearReadCloudDisplay',\n      getRPCParams: () => ({\n        ...self.renderProps(),\n        drawCloud,\n        ...(drawCloud && { cloudModeHeight: self.height }),\n      }),\n      onResult: (result: CloudRenderResult) => {\n        if (!drawCloud && result.layoutHeight !== undefined) {\n          self.setLayoutHeight(result.layoutHeight)\n        }\n        if (drawCloud && result.cloudMaxDistance !== undefined) {\n          self.setCloudMaxDistance(result.cloudMaxDistance)\n        }\n        if (result.featuresForFlatbush) {\n          buildFlatbushIndex(result.featuresForFlatbush, self)\n        }\n        if (result.mismatchFlatbush && result.mismatchItems) {\n          buildMismatchFlatbushIndex(\n            result.mismatchFlatbush,\n            result.mismatchItems,\n            self,\n          )\n        }\n      },\n    })\n\n  const performCloudRender = createCloudRender(true)\n  const performStackRender = createCloudRender(false)\n\n  createAutorun(\n    self,\n    async () => {\n      if (!self.drawCloud || !isAlive(self)) {\n        return\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      performCloudRender()\n    },\n    {\n      delay: 1000,\n      name: 'CloudRender',\n    },\n  )\n\n  createAutorun(\n    self,\n    async () => {\n      if (self.drawCloud || !isAlive(self)) {\n        return\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      performStackRender()\n    },\n    {\n      delay: 1000,\n      name: 'StackRender',\n    },\n  )\n\n  setupCanvasRenderingAutorun(self)\n\n  setupModificationsAutorun(self, () => {\n    const view = getContainingView(self) as LGV\n    return view.initialized && self.featureDensityStatsReadyAndRegionNotTooLarge\n  })\n}\n"],"names":["setupModificationsAutorun","model","isReady","createAutorun","async","view","getContainingView","adapterConfig","staticBlocks","modifications","simplexModifications","getUniqueModifications","blocks","isAlive","updateVisibleModifications","setSimplexModifications","setModificationsReady","delay","name","createRPCRenderFunction","self","rpcMethodName","getRPCParams","onResult","initialized","error","featureDensityStatsReadyAndRegionNotTooLarge","bpPerPx","session","getSession","rpcManager","assemblyManager","assemblyName","assemblyNames","assembly","get","sequenceAdapterConfig","configuration","sequence","adapter","sequenceAdapter","getSnapshot","undefined","previousToken","untracked","renderingStopToken","stopStopToken","stopToken","createStopToken","setRenderingStopToken","setLoading","setCanvasDrawn","viewSnapshot","displayedRegions","structuredClone","offsetPx","interRegionPaddingWidth","minimumBlockWidth","width","sessionId","getRpcSessionId","config","result","call","statusCallback","msg","setStatusMessage","imageData","setRenderingImageData","setLastDrawnOffsetPx","setLastDrawnBpPerPx","isAbortException","console","setError","setupCanvasRenderingAutorun","success","drawCanvasImageData","ref","renderingImageData","doAfterAttachRPC","createCloudRender","drawCloud","renderProps","cloudModeHeight","height","layoutHeight","setLayoutHeight","cloudMaxDistance","setCloudMaxDistance","featuresForFlatbush","buildFlatbushIndex","mismatchFlatbush","mismatchItems","buildMismatchFlatbushIndex","performCloudRender","performStackRender"],"ignoreList":[],"sourceRoot":""}