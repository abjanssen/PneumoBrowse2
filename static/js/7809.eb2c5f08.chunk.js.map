{"version":3,"file":"static/js/7809.eb2c5f08.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts","../../../plugins/gff3/src/featureData.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { unzip } from '@gmod/bgzf-filehandle'\nimport { parseStringSync } from 'gff-nostream'\nimport { isGzip, updateStatus } from '@jbrowse/core/util'\nimport type { Buffer } from 'buffer'\n\nimport { featureData } from '../featureData'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  gffFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  private async loadDataP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const buf = (await openLocation(\n      this.getConf('gffLocation'),\n      this.pluginManager,\n    ).readFile(opts)) as Buffer\n    const buffer = isGzip(buf)\n      ? await updateStatus('Unzipping', statusCallback, () => unzip(buf))\n      : buf\n    const headerLines = []\n    const featureMap = {} as Record<string, string>\n    let blockStart = 0\n\n    const decoder =\n      typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined\n\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf('\\n', blockStart)\n      // could be a non-newline ended file, so subarray to end of file if n===-1\n      const b =\n        n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n)\n      const line = (decoder?.decode(b) || b.toString()).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else if (line.startsWith('>')) {\n          break\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = ''\n          }\n          featureMap[refName] += `${line}\\n`\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${Math.floor(blockStart / 1_000_000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1_000_000).toLocaleString('en-US')} MB`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing GFF data')\n            const intervalTree = new IntervalTree()\n            parseStringSync(lines)\n              .flat()\n              .map(\n                (f, i) =>\n                  new SimpleFeature({\n                    data: featureData(f),\n                    id: `${this.id}-${refName}-${i}`,\n                  }),\n              )\n              .forEach(obj =>\n                intervalTree.insert([obj.get('start'), obj.get('end')], obj),\n              )\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header: headerLines.join('\\n'),\n      intervalTreeMap,\n    }\n  }\n\n  private async loadData(opts: BaseOptions) {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.loadData(opts)\n    return Object.keys(intervalTreeMap)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTreeMap } = await this.loadData(opts)\n        intervalTreeMap[refName]?.(opts.statusCallback)\n          .search([start, end])\n          .forEach(f => {\n            observer.next(f)\n          })\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(/* { region } */) {}\n}\n","import { GFF3FeatureLineWithRefs } from 'gff-nostream'\n\ninterface GFF3Feature {\n  start: number\n  end: number\n  strand?: number\n  type: string | null\n  source: string | null\n  refName: string\n  derived_features: unknown[] | null\n  phase?: number\n  score?: number\n  subfeatures: GFF3Feature[] | undefined\n  [key: string]: unknown\n}\n\nexport function featureData(data: GFF3FeatureLineWithRefs): GFF3Feature {\n  const {\n    end,\n    start,\n    child_features,\n    derived_features,\n    attributes,\n    type,\n    source,\n    phase,\n    seq_id,\n    score,\n    strand,\n  } = data\n\n  let strand2: number | undefined\n  if (strand === '+') {\n    strand2 = 1\n  } else if (strand === '-') {\n    strand2 = -1\n  } else if (strand === '.') {\n    strand2 = 0\n  }\n\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_id',\n    'score',\n    'type',\n    'source',\n    'phase',\n    'strand',\n  ])\n  const dataAttributes = attributes || {}\n  const resultAttributes = {} as Record<string, unknown>\n  for (const a of Object.keys(dataAttributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (dataAttributes[a] && a !== '_lineHash') {\n      let attr: string | string[] | undefined = dataAttributes[a]\n      if (Array.isArray(attr) && attr.length === 1) {\n        ;[attr] = attr\n      }\n      resultAttributes[b] = attr\n    }\n  }\n\n  return {\n    ...resultAttributes,\n    start: start! - 1,\n    end: end!,\n    strand: strand2,\n    type,\n    source,\n    refName: seq_id!,\n    derived_features,\n    phase: phase === null ? undefined : Number(phase),\n    score: score === null ? undefined : score,\n    subfeatures: child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    ),\n  }\n}\n"],"names":["Gff3Adapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","loadDataP","opts","statusCallback","buf","openLocation","this","getConf","pluginManager","readFile","buffer","isGzip","updateStatus","unzip","headerLines","featureMap","blockStart","decoder","TextDecoder","undefined","i","length","n","indexOf","b","subarray","line","decode","toString","trim","startsWith","push","ret","refName","slice","Math","floor","toLocaleString","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","intervalTree","IntervalTree","parseStringSync","flat","f","SimpleFeature","data","featureData","id","forEach","obj","insert","get","header","join","loadData","gffFeatures","catch","e","getRefNames","keys","getHeader","getFeatures","query","ObservableCreate","async","start","end","search","observer","next","complete","error","signal","freeResources","child_features","derived_features","attributes","type","source","phase","seq_id","score","strand","strand2","defaultFields","Set","dataAttributes","resultAttributes","a","toLowerCase","has","attr","Array","isArray","Number","subfeatures","flatMap","childLocs","childLoc"],"sourceRoot":""}