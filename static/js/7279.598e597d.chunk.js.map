{"version":3,"file":"static/js/7279.598e597d.chunk.js","mappings":"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","sources":["../../../node_modules/.pnpm/idb@8.0.3/node_modules/idb/build/index.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.8_react@19.2.3__@emotion+s_933d2fda488d510f6989ff70678c1870/node_modules/@mui/material/esm/Fab/fabClasses.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/Share.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.8_react@19.2.3__@emotion+s_933d2fda488d510f6989ff70678c1870/node_modules/@mui/material/esm/CssBaseline/CssBaseline.js","../../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/serializeError/index.ts","../../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/client.ts","../../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/server.ts","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/Storage.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/Undo.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.8_react@19.2.3__@emotion+s_933d2fda488d510f6989ff70678c1870/node_modules/@mui/material/esm/AppBar/appBarClasses.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.8_react@19.2.3__@emotion+s_933d2fda488d510f6989ff70678c1870/node_modules/@mui/material/esm/AppBar/AppBar.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/Redo.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/FileCopy.js","../../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","../../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","../../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/SpaceDashboard.js","../../../node_modules/.pnpm/@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2.8_react@19.2.3__@emotion+s_933d2fda488d510f6989ff70678c1870/node_modules/@mui/material/esm/Fab/Fab.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/Publish.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/GetApp.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/Extension.js","../../../node_modules/.pnpm/mobx-react-lite@4.1.1_mobx@6.15.0_react-dom@19.2.3_react@19.2.3__react@19.2.3/node_modules/mobx-react-lite/src/observer.ts","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/Launch.js","../../../node_modules/.pnpm/@mui+icons-material@7.3.7_@mui+material@7.3.7_@emotion+react@11.14.0_@types+react@19.2._30e1b55107c86a25823f59a01e2da619/node_modules/@mui/icons-material/esm/Settings.js","../../../node_modules/.pnpm/@jbrowse+mobx-state-tree@5.5.0_mobx@6.15.0/node_modules/@jbrowse/mobx-state-tree/dist/mobx-state-tree.module.js"],"sourcesContent":["const instanceOfAny = (object, constructors) => constructors.some((c) => object instanceof c);\n\nlet idbProxyableTypes;\nlet cursorAdvanceMethods;\n// This is a function to prevent it throwing up in node environments.\nfunction getIdbProxyableTypes() {\n    return (idbProxyableTypes ||\n        (idbProxyableTypes = [\n            IDBDatabase,\n            IDBObjectStore,\n            IDBIndex,\n            IDBCursor,\n            IDBTransaction,\n        ]));\n}\n// This is a function to prevent it throwing up in node environments.\nfunction getCursorAdvanceMethods() {\n    return (cursorAdvanceMethods ||\n        (cursorAdvanceMethods = [\n            IDBCursor.prototype.advance,\n            IDBCursor.prototype.continue,\n            IDBCursor.prototype.continuePrimaryKey,\n        ]));\n}\nconst transactionDoneMap = new WeakMap();\nconst transformCache = new WeakMap();\nconst reverseTransformCache = new WeakMap();\nfunction promisifyRequest(request) {\n    const promise = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            request.removeEventListener('success', success);\n            request.removeEventListener('error', error);\n        };\n        const success = () => {\n            resolve(wrap(request.result));\n            unlisten();\n        };\n        const error = () => {\n            reject(request.error);\n            unlisten();\n        };\n        request.addEventListener('success', success);\n        request.addEventListener('error', error);\n    });\n    // This mapping exists in reverseTransformCache but doesn't exist in transformCache. This\n    // is because we create many promises from a single IDBRequest.\n    reverseTransformCache.set(promise, request);\n    return promise;\n}\nfunction cacheDonePromiseForTransaction(tx) {\n    // Early bail if we've already created a done promise for this transaction.\n    if (transactionDoneMap.has(tx))\n        return;\n    const done = new Promise((resolve, reject) => {\n        const unlisten = () => {\n            tx.removeEventListener('complete', complete);\n            tx.removeEventListener('error', error);\n            tx.removeEventListener('abort', error);\n        };\n        const complete = () => {\n            resolve();\n            unlisten();\n        };\n        const error = () => {\n            reject(tx.error || new DOMException('AbortError', 'AbortError'));\n            unlisten();\n        };\n        tx.addEventListener('complete', complete);\n        tx.addEventListener('error', error);\n        tx.addEventListener('abort', error);\n    });\n    // Cache it for later retrieval.\n    transactionDoneMap.set(tx, done);\n}\nlet idbProxyTraps = {\n    get(target, prop, receiver) {\n        if (target instanceof IDBTransaction) {\n            // Special handling for transaction.done.\n            if (prop === 'done')\n                return transactionDoneMap.get(target);\n            // Make tx.store return the only store in the transaction, or undefined if there are many.\n            if (prop === 'store') {\n                return receiver.objectStoreNames[1]\n                    ? undefined\n                    : receiver.objectStore(receiver.objectStoreNames[0]);\n            }\n        }\n        // Else transform whatever we get back.\n        return wrap(target[prop]);\n    },\n    set(target, prop, value) {\n        target[prop] = value;\n        return true;\n    },\n    has(target, prop) {\n        if (target instanceof IDBTransaction &&\n            (prop === 'done' || prop === 'store')) {\n            return true;\n        }\n        return prop in target;\n    },\n};\nfunction replaceTraps(callback) {\n    idbProxyTraps = callback(idbProxyTraps);\n}\nfunction wrapFunction(func) {\n    // Due to expected object equality (which is enforced by the caching in `wrap`), we\n    // only create one new func per func.\n    // Cursor methods are special, as the behaviour is a little more different to standard IDB. In\n    // IDB, you advance the cursor and wait for a new 'success' on the IDBRequest that gave you the\n    // cursor. It's kinda like a promise that can resolve with many values. That doesn't make sense\n    // with real promises, so each advance methods returns a new promise for the cursor object, or\n    // undefined if the end of the cursor has been reached.\n    if (getCursorAdvanceMethods().includes(func)) {\n        return function (...args) {\n            // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n            // the original object.\n            func.apply(unwrap(this), args);\n            return wrap(this.request);\n        };\n    }\n    return function (...args) {\n        // Calling the original function with the proxy as 'this' causes ILLEGAL INVOCATION, so we use\n        // the original object.\n        return wrap(func.apply(unwrap(this), args));\n    };\n}\nfunction transformCachableValue(value) {\n    if (typeof value === 'function')\n        return wrapFunction(value);\n    // This doesn't return, it just creates a 'done' promise for the transaction,\n    // which is later returned for transaction.done (see idbObjectHandler).\n    if (value instanceof IDBTransaction)\n        cacheDonePromiseForTransaction(value);\n    if (instanceOfAny(value, getIdbProxyableTypes()))\n        return new Proxy(value, idbProxyTraps);\n    // Return the same value back if we're not going to transform it.\n    return value;\n}\nfunction wrap(value) {\n    // We sometimes generate multiple promises from a single IDBRequest (eg when cursoring), because\n    // IDB is weird and a single IDBRequest can yield many responses, so these can't be cached.\n    if (value instanceof IDBRequest)\n        return promisifyRequest(value);\n    // If we've already transformed this value before, reuse the transformed value.\n    // This is faster, but it also provides object equality.\n    if (transformCache.has(value))\n        return transformCache.get(value);\n    const newValue = transformCachableValue(value);\n    // Not all types are transformed.\n    // These may be primitive types, so they can't be WeakMap keys.\n    if (newValue !== value) {\n        transformCache.set(value, newValue);\n        reverseTransformCache.set(newValue, value);\n    }\n    return newValue;\n}\nconst unwrap = (value) => reverseTransformCache.get(value);\n\n/**\n * Open a database.\n *\n * @param name Name of the database.\n * @param version Schema version.\n * @param callbacks Additional callbacks.\n */\nfunction openDB(name, version, { blocked, upgrade, blocking, terminated } = {}) {\n    const request = indexedDB.open(name, version);\n    const openPromise = wrap(request);\n    if (upgrade) {\n        request.addEventListener('upgradeneeded', (event) => {\n            upgrade(wrap(request.result), event.oldVersion, event.newVersion, wrap(request.transaction), event);\n        });\n    }\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event.newVersion, event));\n    }\n    openPromise\n        .then((db) => {\n        if (terminated)\n            db.addEventListener('close', () => terminated());\n        if (blocking) {\n            db.addEventListener('versionchange', (event) => blocking(event.oldVersion, event.newVersion, event));\n        }\n    })\n        .catch(() => { });\n    return openPromise;\n}\n/**\n * Delete a database.\n *\n * @param name Name of the database.\n */\nfunction deleteDB(name, { blocked } = {}) {\n    const request = indexedDB.deleteDatabase(name);\n    if (blocked) {\n        request.addEventListener('blocked', (event) => blocked(\n        // Casting due to https://github.com/microsoft/TypeScript-DOM-lib-generator/pull/1405\n        event.oldVersion, event));\n    }\n    return wrap(request).then(() => undefined);\n}\n\nconst readMethods = ['get', 'getKey', 'getAll', 'getAllKeys', 'count'];\nconst writeMethods = ['put', 'add', 'delete', 'clear'];\nconst cachedMethods = new Map();\nfunction getMethod(target, prop) {\n    if (!(target instanceof IDBDatabase &&\n        !(prop in target) &&\n        typeof prop === 'string')) {\n        return;\n    }\n    if (cachedMethods.get(prop))\n        return cachedMethods.get(prop);\n    const targetFuncName = prop.replace(/FromIndex$/, '');\n    const useIndex = prop !== targetFuncName;\n    const isWrite = writeMethods.includes(targetFuncName);\n    if (\n    // Bail if the target doesn't exist on the target. Eg, getAll isn't in Edge.\n    !(targetFuncName in (useIndex ? IDBIndex : IDBObjectStore).prototype) ||\n        !(isWrite || readMethods.includes(targetFuncName))) {\n        return;\n    }\n    const method = async function (storeName, ...args) {\n        // isWrite ? 'readwrite' : undefined gzipps better, but fails in Edge :(\n        const tx = this.transaction(storeName, isWrite ? 'readwrite' : 'readonly');\n        let target = tx.store;\n        if (useIndex)\n            target = target.index(args.shift());\n        // Must reject if op rejects.\n        // If it's a write operation, must reject if tx.done rejects.\n        // Must reject with op rejection first.\n        // Must resolve with op value.\n        // Must handle both promises (no unhandled rejections)\n        return (await Promise.all([\n            target[targetFuncName](...args),\n            isWrite && tx.done,\n        ]))[0];\n    };\n    cachedMethods.set(prop, method);\n    return method;\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get: (target, prop, receiver) => getMethod(target, prop) || oldTraps.get(target, prop, receiver),\n    has: (target, prop) => !!getMethod(target, prop) || oldTraps.has(target, prop),\n}));\n\nconst advanceMethodProps = ['continue', 'continuePrimaryKey', 'advance'];\nconst methodMap = {};\nconst advanceResults = new WeakMap();\nconst ittrProxiedCursorToOriginalProxy = new WeakMap();\nconst cursorIteratorTraps = {\n    get(target, prop) {\n        if (!advanceMethodProps.includes(prop))\n            return target[prop];\n        let cachedFunc = methodMap[prop];\n        if (!cachedFunc) {\n            cachedFunc = methodMap[prop] = function (...args) {\n                advanceResults.set(this, ittrProxiedCursorToOriginalProxy.get(this)[prop](...args));\n            };\n        }\n        return cachedFunc;\n    },\n};\nasync function* iterate(...args) {\n    // tslint:disable-next-line:no-this-assignment\n    let cursor = this;\n    if (!(cursor instanceof IDBCursor)) {\n        cursor = await cursor.openCursor(...args);\n    }\n    if (!cursor)\n        return;\n    cursor = cursor;\n    const proxiedCursor = new Proxy(cursor, cursorIteratorTraps);\n    ittrProxiedCursorToOriginalProxy.set(proxiedCursor, cursor);\n    // Map this double-proxy back to the original, so other cursor methods work.\n    reverseTransformCache.set(proxiedCursor, unwrap(cursor));\n    while (cursor) {\n        yield proxiedCursor;\n        // If one of the advancing methods was not called, call continue().\n        cursor = await (advanceResults.get(proxiedCursor) || cursor.continue());\n        advanceResults.delete(proxiedCursor);\n    }\n}\nfunction isIteratorProp(target, prop) {\n    return ((prop === Symbol.asyncIterator &&\n        instanceOfAny(target, [IDBIndex, IDBObjectStore, IDBCursor])) ||\n        (prop === 'iterate' && instanceOfAny(target, [IDBIndex, IDBObjectStore])));\n}\nreplaceTraps((oldTraps) => ({\n    ...oldTraps,\n    get(target, prop, receiver) {\n        if (isIteratorProp(target, prop))\n            return iterate;\n        return oldTraps.get(target, prop, receiver);\n    },\n    has(target, prop) {\n        return isIteratorProp(target, prop) || oldTraps.has(target, prop);\n    },\n}));\n\nexport { deleteDB, openDB, unwrap, wrap };\n","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getFabUtilityClass(slot) {\n  return generateUtilityClass('MuiFab', slot);\n}\nconst fabClasses = generateUtilityClasses('MuiFab', ['root', 'primary', 'secondary', 'extended', 'circular', 'focusVisible', 'disabled', 'colorInherit', 'sizeSmall', 'sizeMedium', 'sizeLarge', 'info', 'error', 'warning', 'success']);\nexport default fabClasses;","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92\"\n}), 'Share');","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { globalCss } from \"../zero-styled/index.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\n\n// to determine if the global styles are static or dynamic\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst isDynamicSupport = typeof globalCss({}) === 'function';\nexport const html = (theme, enableColorScheme) => ({\n  WebkitFontSmoothing: 'antialiased',\n  // Antialiasing.\n  MozOsxFontSmoothing: 'grayscale',\n  // Antialiasing.\n  // Change from `box-sizing: content-box` so that `width`\n  // is not affected by `padding` or `border`.\n  boxSizing: 'border-box',\n  // Fix font resize problem in iOS\n  WebkitTextSizeAdjust: '100%',\n  // When used under CssVarsProvider, colorScheme should not be applied dynamically because it will generate the stylesheet twice for server-rendered applications.\n  ...(enableColorScheme && !theme.vars && {\n    colorScheme: theme.palette.mode\n  })\n});\nexport const body = theme => ({\n  color: (theme.vars || theme).palette.text.primary,\n  ...theme.typography.body1,\n  backgroundColor: (theme.vars || theme).palette.background.default,\n  '@media print': {\n    // Save printer ink.\n    backgroundColor: (theme.vars || theme).palette.common.white\n  }\n});\nexport const styles = (theme, enableColorScheme = false) => {\n  const colorSchemeStyles = {};\n  if (enableColorScheme && theme.colorSchemes && typeof theme.getColorSchemeSelector === 'function') {\n    Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {\n      const selector = theme.getColorSchemeSelector(key);\n      if (selector.startsWith('@')) {\n        // for @media (prefers-color-scheme), we need to target :root\n        colorSchemeStyles[selector] = {\n          ':root': {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      } else {\n        // else, it's likely that the selector already target an element with a class or data attribute\n        colorSchemeStyles[selector.replace(/\\s*&/, '')] = {\n          colorScheme: scheme.palette?.mode\n        };\n      }\n    });\n  }\n  let defaultStyles = {\n    html: html(theme, enableColorScheme),\n    '*, *::before, *::after': {\n      boxSizing: 'inherit'\n    },\n    'strong, b': {\n      fontWeight: theme.typography.fontWeightBold\n    },\n    body: {\n      margin: 0,\n      // Remove the margin in all browsers.\n      ...body(theme),\n      // Add support for document.body.requestFullScreen().\n      // Other elements, if background transparent, are not supported.\n      '&::backdrop': {\n        backgroundColor: (theme.vars || theme).palette.background.default\n      }\n    },\n    ...colorSchemeStyles\n  };\n  const themeOverrides = theme.components?.MuiCssBaseline?.styleOverrides;\n  if (themeOverrides) {\n    defaultStyles = [defaultStyles, themeOverrides];\n  }\n  return defaultStyles;\n};\n\n// `ecs` stands for enableColorScheme. This is internal logic to make it work with Pigment CSS, so shorter is better.\nconst SELECTOR = 'mui-ecs';\nconst staticStyles = theme => {\n  const result = styles(theme, false);\n  const baseStyles = Array.isArray(result) ? result[0] : result;\n  if (!theme.vars && baseStyles) {\n    baseStyles.html[`:root:has(${SELECTOR})`] = {\n      colorScheme: theme.palette.mode\n    };\n  }\n  if (theme.colorSchemes) {\n    Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {\n      const selector = theme.getColorSchemeSelector(key);\n      if (selector.startsWith('@')) {\n        // for @media (prefers-color-scheme), we need to target :root\n        baseStyles[selector] = {\n          [`:root:not(:has(.${SELECTOR}))`]: {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      } else {\n        // else, it's likely that the selector already target an element with a class or data attribute\n        baseStyles[selector.replace(/\\s*&/, '')] = {\n          [`&:not(:has(.${SELECTOR}))`]: {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      }\n    });\n  }\n  return result;\n};\nconst GlobalStyles = globalCss(isDynamicSupport ? ({\n  theme,\n  enableColorScheme\n}) => styles(theme, enableColorScheme) : ({\n  theme\n}) => staticStyles(theme));\n\n/**\n * Kickstart an elegant, consistent, and simple baseline to build upon.\n */\nfunction CssBaseline(inProps) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCssBaseline'\n  });\n  const {\n    children,\n    enableColorScheme = false\n  } = props;\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [isDynamicSupport && /*#__PURE__*/_jsx(GlobalStyles, {\n      enableColorScheme: enableColorScheme\n    }), !isDynamicSupport && !enableColorScheme && /*#__PURE__*/_jsx(\"span\", {\n      className: SELECTOR,\n      style: {\n        display: 'none'\n      }\n    }), children]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? CssBaseline.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * You can wrap a node.\n   */\n  children: PropTypes.node,\n  /**\n   * Enable `color-scheme` CSS property to use `theme.palette.mode`.\n   * For more details, check out https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/color-scheme\n   * For browser support, check out https://caniuse.com/?search=color-scheme\n   * @default false\n   */\n  enableColorScheme: PropTypes.bool\n} : void 0;\nexport default CssBaseline;","import { errorConstructors, errorFactories } from './errorConstructors.ts'\nimport NonError from './nonError.ts'\n\nconst errorProperties = [\n  { property: 'name', enumerable: false },\n  { property: 'message', enumerable: false },\n  { property: 'stack', enumerable: false },\n  { property: 'code', enumerable: true },\n  { property: 'cause', enumerable: false },\n  { property: 'errors', enumerable: false },\n] as const\n\nconst toJsonWasCalled = new WeakSet()\n\nfunction toJSON(from: { toJSON: () => unknown }) {\n  toJsonWasCalled.add(from)\n  const json = from.toJSON()\n  toJsonWasCalled.delete(from)\n  return json\n}\n\nfunction newError(name: string) {\n  const factory = errorFactories.get(name)\n  if (factory) {\n    return factory()\n  }\n\n  const ErrorConstructor = errorConstructors.get(name) ?? Error\n  if (name === 'AggregateError') {\n    return new AggregateError([])\n  }\n  return new ErrorConstructor()\n}\n\nexport function isErrorLike(value: unknown): value is Error {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as Error).name === 'string' &&\n    typeof (value as Error).message === 'string' &&\n    typeof (value as Error).stack === 'string'\n  )\n}\n\nfunction isMinimumViableSerializedError(\n  value: unknown,\n): value is { name: string; message: string } {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as { message?: unknown }).message === 'string' &&\n    !Array.isArray(value)\n  )\n}\n\ninterface DestroyCircularOptions {\n  from: Record<string, unknown>\n  seen: unknown[]\n  to?: Record<string, unknown> | Error | unknown[]\n  forceEnumerable?: boolean\n  maxDepth: number\n  depth: number\n  useToJSON?: boolean\n  serialize: boolean\n}\n\nfunction destroyCircular({\n  from,\n  seen,\n  to,\n  forceEnumerable,\n  maxDepth,\n  depth,\n  useToJSON,\n  serialize,\n}: DestroyCircularOptions): Record<string, unknown> {\n  if (!to) {\n    if (Array.isArray(from)) {\n      to = []\n    } else if (!serialize && isErrorLike(from)) {\n      to = newError(from.name)\n    } else {\n      to = {}\n    }\n  }\n\n  seen.push(from)\n\n  if (depth >= maxDepth) {\n    return to as Record<string, unknown>\n  }\n\n  if (\n    useToJSON &&\n    typeof (from as { toJSON?: unknown }).toJSON === 'function' &&\n    !toJsonWasCalled.has(from)\n  ) {\n    return toJSON(from as { toJSON: () => unknown }) as Record<string, unknown>\n  }\n\n  const continueDestroyCircular = (value: Record<string, unknown>) =>\n    destroyCircular({\n      from: value,\n      seen: [...seen],\n      forceEnumerable,\n      maxDepth,\n      depth,\n      useToJSON,\n      serialize,\n    })\n\n  for (const [key, value] of Object.entries(from)) {\n    if (\n      value &&\n      value instanceof Uint8Array &&\n      value.constructor.name === 'Buffer'\n    ) {\n      ;(to as Record<string, unknown>)[key] = serialize\n        ? '[object Buffer]'\n        : value\n      continue\n    }\n\n    if (\n      value !== null &&\n      typeof value === 'object' &&\n      typeof (value as { pipe?: unknown }).pipe === 'function'\n    ) {\n      ;(to as Record<string, unknown>)[key] = serialize\n        ? '[object Stream]'\n        : value\n      continue\n    }\n\n    if (typeof value === 'function') {\n      if (!serialize) {\n        ;(to as Record<string, unknown>)[key] = value\n      }\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      try {\n        ;(to as Record<string, unknown>)[key] = value\n      } catch {}\n      continue\n    }\n\n    if (!seen.includes(from[key])) {\n      depth++\n      ;(to as Record<string, unknown>)[key] = continueDestroyCircular(\n        from[key] as Record<string, unknown>,\n      )\n      continue\n    }\n\n    ;(to as Record<string, unknown>)[key] = '[Circular]'\n  }\n\n  if (serialize || to instanceof Error) {\n    for (const { property, enumerable } of errorProperties) {\n      const val = from[property]\n      if (val !== undefined && val !== null) {\n        Object.defineProperty(to, property, {\n          value:\n            isErrorLike(val) || Array.isArray(val)\n              ? continueDestroyCircular(\n                  val as unknown as Record<string, unknown>,\n                )\n              : val,\n          enumerable: forceEnumerable ? true : enumerable,\n          configurable: true,\n          writable: true,\n        })\n      }\n    }\n  }\n\n  return to as Record<string, unknown>\n}\n\nexport interface ErrorObject {\n  name?: string\n  message: string\n  stack?: string\n  code?: string\n  cause?: unknown\n}\n\nexport function serializeError(\n  value: unknown,\n  options: { maxDepth?: number; useToJSON?: boolean } = {},\n) {\n  const { maxDepth = Number.POSITIVE_INFINITY, useToJSON = true } = options\n\n  if (typeof value === 'object' && value !== null) {\n    return destroyCircular({\n      from: value as Record<string, unknown>,\n      seen: [],\n      forceEnumerable: true,\n      maxDepth,\n      depth: 0,\n      useToJSON,\n      serialize: true,\n    }) as unknown as ErrorObject\n  }\n\n  let normalized: unknown = value\n  if (typeof value === 'function') {\n    normalized = '<Function>'\n  }\n\n  return destroyCircular({\n    from: new NonError(normalized) as unknown as Record<string, unknown>,\n    seen: [],\n    forceEnumerable: true,\n    maxDepth,\n    depth: 0,\n    useToJSON,\n    serialize: true,\n  }) as unknown as ErrorObject\n}\n\nexport function deserializeError(\n  value: unknown,\n  options: { maxDepth?: number } = {},\n) {\n  const { maxDepth = Number.POSITIVE_INFINITY } = options\n\n  if (value instanceof Error) {\n    return value\n  }\n\n  if (isMinimumViableSerializedError(value)) {\n    return destroyCircular({\n      from: value as unknown as Record<string, unknown>,\n      seen: [],\n      to: newError((value as { name?: string }).name ?? 'Error'),\n      maxDepth,\n      depth: 0,\n      serialize: false,\n    }) as unknown as Error\n  }\n\n  return new NonError(value)\n}\n","import EventEmitter from './ee.ts'\nimport { deserializeError } from './serializeError/index.ts'\n\ninterface RpcMessageData {\n  uid: string\n  libRpc?: true\n  error?: string\n  method?: string\n  eventName?: string\n  data: unknown\n}\n\nlet counter = 0\n\nexport default class RpcClient extends EventEmitter {\n  protected calls = new Map<string, (data: unknown) => void>()\n  protected errors = new Map<string, (error: Error) => void>()\n\n  constructor(public worker: Worker) {\n    super()\n    this.worker.addEventListener(\n      'message',\n      (e: MessageEvent<RpcMessageData>) => {\n        this.handler(e)\n      },\n    )\n    this.worker.addEventListener('error', (e: ErrorEvent) => {\n      this.catch(e)\n    })\n  }\n\n  protected handler(e: MessageEvent<RpcMessageData>) {\n    const { uid, error, method, eventName, data, libRpc } = e.data\n    if (!libRpc) {\n      return\n    }\n    if (error) {\n      this.reject(uid, error)\n    } else if (method) {\n      this.resolve(uid, data)\n    } else if (eventName) {\n      this.emit(eventName, data)\n    }\n  }\n\n  protected catch(e: ErrorEvent) {\n    this.emit('error', {\n      message: e.message,\n      lineno: e.lineno,\n      filename: e.filename,\n    })\n  }\n\n  protected reject(uid: string, error: string | Error) {\n    const errorFn = this.errors.get(uid)\n    if (errorFn) {\n      errorFn(deserializeError(error))\n      this.clear(uid)\n    }\n  }\n\n  protected resolve(uid: string, data: unknown) {\n    const callFn = this.calls.get(uid)\n    if (callFn) {\n      callFn(data)\n      this.clear(uid)\n    }\n  }\n\n  protected clear(uid: string) {\n    this.calls.delete(uid)\n    this.errors.delete(uid)\n  }\n\n  call(\n    method: string,\n    data: unknown,\n    { transferables = [] }: { transferables?: Transferable[] } = {},\n  ) {\n    const uid = String(++counter)\n    return new Promise((resolve, reject) => {\n      this.calls.set(uid, resolve)\n      this.errors.set(uid, reject)\n      this.worker.postMessage(\n        { method, uid, data, libRpc: true },\n        transferables,\n      )\n    })\n  }\n}\n","import { ErrorObject, serializeError } from './serializeError/index.ts'\n\nfunction isTransferable(object: unknown): object is Transferable {\n  try {\n    return (\n      object instanceof ArrayBuffer ||\n      object instanceof ImageBitmap ||\n      object instanceof OffscreenCanvas ||\n      object instanceof MessagePort\n    )\n  } catch {\n    return false\n  }\n}\n\nfunction isObject(data: unknown): data is Record<string, unknown> {\n  return Object(data) === data\n}\n\nfunction peekTransferables(data: unknown) {\n  const result: Transferable[] = []\n  if (isTransferable(data)) {\n    result.push(data)\n  } else if (isObject(data)) {\n    for (const key of Object.keys(data)) {\n      const val = data[key]\n      if (isTransferable(val)) {\n        result.push(val)\n      }\n    }\n  }\n  return result\n}\n\nexport interface RpcResult {\n  __rpcResult: true\n  value: unknown\n  transferables: Transferable[]\n}\n\nexport function rpcResult(\n  value: unknown,\n  transferables: Transferable[],\n): RpcResult {\n  return { __rpcResult: true, value, transferables }\n}\n\ntype Procedure = (data: unknown) => Promise<unknown>\n\ninterface RpcMessageData {\n  method: string\n  uid: string\n  libRpc?: true\n  data: unknown\n}\n\nfunction isRpcResult(value: unknown): value is RpcResult {\n  return typeof value === 'object' && value !== null && '__rpcResult' in value\n}\n\nexport default class RpcServer {\n  protected methods: Record<string, Procedure>\n\n  constructor(methods: Record<string, Procedure>) {\n    this.methods = methods\n    self.addEventListener('message', (e: MessageEvent<RpcMessageData>) => {\n      this.handler(e)\n    })\n  }\n\n  protected handler(e: MessageEvent<RpcMessageData>) {\n    const { libRpc, method, uid, data } = e.data\n    if (!libRpc) {\n      return\n    }\n    const methodFn = this.methods[method]\n    if (methodFn) {\n      Promise.resolve(data)\n        .then(methodFn)\n        .then(\n          response => {\n            this.reply(uid, method, response)\n          },\n          (error: unknown) => {\n            this.throw(uid, serializeError(error))\n          },\n        )\n    } else {\n      this.throw(uid, `Unknown RPC method \"${method}\"`)\n    }\n  }\n\n  protected reply(uid: string, method: string, response: unknown) {\n    try {\n      if (isRpcResult(response)) {\n        const { value, transferables } = response\n        self.postMessage(\n          { uid, method, data: value, libRpc: true },\n          transferables,\n        )\n      } else {\n        const transferables = peekTransferables(response)\n        self.postMessage(\n          { uid, method, data: response, libRpc: true },\n          transferables,\n        )\n      }\n    } catch (e) {\n      this.throw(uid, serializeError(e))\n    }\n  }\n\n  protected throw(uid: string, error: ErrorObject | string) {\n    self.postMessage({ uid, error, libRpc: true })\n  }\n\n  emit(eventName: string, data: unknown, transferables?: Transferable[]) {\n    const transfer = transferables ?? peekTransferables(data)\n    self.postMessage({ eventName, data, libRpc: true }, transfer)\n  }\n}\n","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M2 20h20v-4H2zm2-3h2v2H4zM2 4v4h20V4zm4 3H4V5h2zm-4 7h20v-4H2zm2-3h2v2H4z\"\n}), 'Storage');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8\"\n}), 'Undo');","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getAppBarUtilityClass(slot) {\n  return generateUtilityClass('MuiAppBar', slot);\n}\nconst appBarClasses = generateUtilityClasses('MuiAppBar', ['root', 'positionFixed', 'positionAbsolute', 'positionSticky', 'positionStatic', 'positionRelative', 'colorDefault', 'colorPrimary', 'colorSecondary', 'colorInherit', 'colorTransparent', 'colorError', 'colorInfo', 'colorSuccess', 'colorWarning']);\nexport default appBarClasses;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { styled } from \"../zero-styled/index.js\";\nimport memoTheme from \"../utils/memoTheme.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\nimport capitalize from \"../utils/capitalize.js\";\nimport createSimplePaletteValueFilter from \"../utils/createSimplePaletteValueFilter.js\";\nimport Paper from \"../Paper/index.js\";\nimport { getAppBarUtilityClass } from \"./appBarClasses.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    color,\n    position,\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root', `color${capitalize(color)}`, `position${capitalize(position)}`]\n  };\n  return composeClasses(slots, getAppBarUtilityClass, classes);\n};\n\n// var2 is the fallback.\n// Ex. var1: 'var(--a)', var2: 'var(--b)'; return: 'var(--a, var(--b))'\nconst joinVars = (var1, var2) => var1 ? `${var1?.replace(')', '')}, ${var2})` : var2;\nconst AppBarRoot = styled(Paper, {\n  name: 'MuiAppBar',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[`position${capitalize(ownerState.position)}`], styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(memoTheme(({\n  theme\n}) => ({\n  display: 'flex',\n  flexDirection: 'column',\n  width: '100%',\n  boxSizing: 'border-box',\n  // Prevent padding issue with the Modal and fixed positioned AppBar.\n  flexShrink: 0,\n  variants: [{\n    props: {\n      position: 'fixed'\n    },\n    style: {\n      position: 'fixed',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0,\n      '@media print': {\n        // Prevent the app bar to be visible on each printed page.\n        position: 'absolute'\n      }\n    }\n  }, {\n    props: {\n      position: 'absolute'\n    },\n    style: {\n      position: 'absolute',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0\n    }\n  }, {\n    props: {\n      position: 'sticky'\n    },\n    style: {\n      position: 'sticky',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0\n    }\n  }, {\n    props: {\n      position: 'static'\n    },\n    style: {\n      position: 'static'\n    }\n  }, {\n    props: {\n      position: 'relative'\n    },\n    style: {\n      position: 'relative'\n    }\n  }, {\n    props: {\n      color: 'inherit'\n    },\n    style: {\n      '--AppBar-color': 'inherit',\n      color: 'var(--AppBar-color)'\n    }\n  }, {\n    props: {\n      color: 'default'\n    },\n    style: {\n      '--AppBar-background': theme.vars ? theme.vars.palette.AppBar.defaultBg : theme.palette.grey[100],\n      '--AppBar-color': theme.vars ? theme.vars.palette.text.primary : theme.palette.getContrastText(theme.palette.grey[100]),\n      ...theme.applyStyles('dark', {\n        '--AppBar-background': theme.vars ? theme.vars.palette.AppBar.defaultBg : theme.palette.grey[900],\n        '--AppBar-color': theme.vars ? theme.vars.palette.text.primary : theme.palette.getContrastText(theme.palette.grey[900])\n      })\n    }\n  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(['contrastText'])).map(([color]) => ({\n    props: {\n      color\n    },\n    style: {\n      '--AppBar-background': (theme.vars ?? theme).palette[color].main,\n      '--AppBar-color': (theme.vars ?? theme).palette[color].contrastText\n    }\n  })), {\n    props: props => props.enableColorOnDark === true && !['inherit', 'transparent'].includes(props.color),\n    style: {\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)'\n    }\n  }, {\n    props: props => props.enableColorOnDark === false && !['inherit', 'transparent'].includes(props.color),\n    style: {\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)',\n      ...theme.applyStyles('dark', {\n        backgroundColor: theme.vars ? joinVars(theme.vars.palette.AppBar.darkBg, 'var(--AppBar-background)') : null,\n        color: theme.vars ? joinVars(theme.vars.palette.AppBar.darkColor, 'var(--AppBar-color)') : null\n      })\n    }\n  }, {\n    props: {\n      color: 'transparent'\n    },\n    style: {\n      '--AppBar-background': 'transparent',\n      '--AppBar-color': 'inherit',\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)',\n      ...theme.applyStyles('dark', {\n        backgroundImage: 'none'\n      })\n    }\n  }]\n})));\nconst AppBar = /*#__PURE__*/React.forwardRef(function AppBar(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiAppBar'\n  });\n  const {\n    className,\n    color = 'primary',\n    enableColorOnDark = false,\n    position = 'fixed',\n    ...other\n  } = props;\n  const ownerState = {\n    ...props,\n    color,\n    position,\n    enableColorOnDark\n  };\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(AppBarRoot, {\n    square: true,\n    component: \"header\",\n    ownerState: ownerState,\n    elevation: 4,\n    className: clsx(classes.root, className, position === 'fixed' && 'mui-fixed'),\n    ref: ref,\n    ...other\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? AppBar.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'inherit', 'primary', 'secondary', 'transparent', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * Shadow depth, corresponds to `dp` in the spec.\n   * It accepts values between 0 and 24 inclusive.\n   * @default 4\n   */\n  elevation: PropTypes.number,\n  /**\n   * If true, the `color` prop is applied in dark mode.\n   * @default false\n   */\n  enableColorOnDark: PropTypes.bool,\n  /**\n   * The positioning type. The behavior of the different options is described\n   * [in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/position).\n   * Note: `sticky` is not universally supported and will fall back to `static` when unavailable.\n   * @default 'fixed'\n   */\n  position: PropTypes.oneOf(['absolute', 'fixed', 'relative', 'static', 'sticky']),\n  /**\n   * If `false`, rounded corners are enabled.\n   * @default true\n   */\n  square: PropTypes.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default AppBar;","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z\"\n}), 'Redo');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm-1 4 6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2zm-1 7h5.5L14 6.5z\"\n}), 'FileCopy');","// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter<V> {\n  callbacks = new Set<(arg: V) => void>()\n  currentMessage?: V\n\n  addCallback(callback: (arg: V) => void = () => {}): void {\n    this.callbacks.add(callback)\n    if (this.currentMessage) {\n      callback(this.currentMessage)\n    }\n  }\n\n  callback(message: V) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController.ts'\nimport AggregateStatusReporter from './AggregateStatusReporter.ts'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U, V> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: (arg: V) => void,\n) => Promise<U>\n\ninterface Entry<U, V> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter<V>\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U, V = string> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U, V>>\n  private fillCallback: FillCallback<T, U, V>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U, V>\n    cache: Cache<Entry<U, V>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U, V>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter<V>()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U, V> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: V) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch((error: unknown) => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      (error: unknown) => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M11 21H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h6zm2 0h6c1.1 0 2-.9 2-2v-7h-8zm8-11V5c0-1.1-.9-2-2-2h-6v7z\"\n}), 'SpaceDashboard');","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport composeClasses from '@mui/utils/composeClasses';\nimport ButtonBase from \"../ButtonBase/index.js\";\nimport capitalize from \"../utils/capitalize.js\";\nimport fabClasses, { getFabUtilityClass } from \"./fabClasses.js\";\nimport rootShouldForwardProp from \"../styles/rootShouldForwardProp.js\";\nimport { styled } from \"../zero-styled/index.js\";\nimport memoTheme from \"../utils/memoTheme.js\";\nimport createSimplePaletteValueFilter from \"../utils/createSimplePaletteValueFilter.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    color,\n    variant,\n    classes,\n    size\n  } = ownerState;\n  const slots = {\n    root: ['root', variant, `size${capitalize(size)}`, color === 'inherit' ? 'colorInherit' : color]\n  };\n  const composedClasses = composeClasses(slots, getFabUtilityClass, classes);\n  return {\n    ...classes,\n    // forward the focused, disabled, etc. classes to the ButtonBase\n    ...composedClasses\n  };\n};\nconst FabRoot = styled(ButtonBase, {\n  name: 'MuiFab',\n  slot: 'Root',\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[ownerState.variant], styles[`size${capitalize(ownerState.size)}`], ownerState.color === 'inherit' && styles.colorInherit, styles[capitalize(ownerState.size)], styles[ownerState.color]];\n  }\n})(memoTheme(({\n  theme\n}) => ({\n  ...theme.typography.button,\n  minHeight: 36,\n  transition: theme.transitions.create(['background-color', 'box-shadow', 'border-color'], {\n    duration: theme.transitions.duration.short\n  }),\n  borderRadius: '50%',\n  padding: 0,\n  minWidth: 0,\n  width: 56,\n  height: 56,\n  zIndex: (theme.vars || theme).zIndex.fab,\n  boxShadow: (theme.vars || theme).shadows[6],\n  '&:active': {\n    boxShadow: (theme.vars || theme).shadows[12]\n  },\n  color: theme.vars ? theme.vars.palette.grey[900] : theme.palette.getContrastText?.(theme.palette.grey[300]),\n  backgroundColor: (theme.vars || theme).palette.grey[300],\n  '&:hover': {\n    backgroundColor: (theme.vars || theme).palette.grey.A100,\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: (theme.vars || theme).palette.grey[300]\n    },\n    textDecoration: 'none'\n  },\n  [`&.${fabClasses.focusVisible}`]: {\n    boxShadow: (theme.vars || theme).shadows[6]\n  },\n  variants: [{\n    props: {\n      size: 'small'\n    },\n    style: {\n      width: 40,\n      height: 40\n    }\n  }, {\n    props: {\n      size: 'medium'\n    },\n    style: {\n      width: 48,\n      height: 48\n    }\n  }, {\n    props: {\n      variant: 'extended'\n    },\n    style: {\n      borderRadius: 48 / 2,\n      padding: '0 16px',\n      width: 'auto',\n      minHeight: 'auto',\n      minWidth: 48,\n      height: 48\n    }\n  }, {\n    props: {\n      variant: 'extended',\n      size: 'small'\n    },\n    style: {\n      width: 'auto',\n      padding: '0 8px',\n      borderRadius: 34 / 2,\n      minWidth: 34,\n      height: 34\n    }\n  }, {\n    props: {\n      variant: 'extended',\n      size: 'medium'\n    },\n    style: {\n      width: 'auto',\n      padding: '0 16px',\n      borderRadius: 40 / 2,\n      minWidth: 40,\n      height: 40\n    }\n  }, {\n    props: {\n      color: 'inherit'\n    },\n    style: {\n      color: 'inherit'\n    }\n  }]\n})), memoTheme(({\n  theme\n}) => ({\n  variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(['dark', 'contrastText'])) // check all the used fields in the style below\n  .map(([color]) => ({\n    props: {\n      color\n    },\n    style: {\n      color: (theme.vars || theme).palette[color].contrastText,\n      backgroundColor: (theme.vars || theme).palette[color].main,\n      '&:hover': {\n        backgroundColor: (theme.vars || theme).palette[color].dark,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: (theme.vars || theme).palette[color].main\n        }\n      }\n    }\n  }))]\n})), memoTheme(({\n  theme\n}) => ({\n  [`&.${fabClasses.disabled}`]: {\n    color: (theme.vars || theme).palette.action.disabled,\n    boxShadow: (theme.vars || theme).shadows[0],\n    backgroundColor: (theme.vars || theme).palette.action.disabledBackground\n  }\n})));\nconst Fab = /*#__PURE__*/React.forwardRef(function Fab(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiFab'\n  });\n  const {\n    children,\n    className,\n    color = 'default',\n    component = 'button',\n    disabled = false,\n    disableFocusRipple = false,\n    focusVisibleClassName,\n    size = 'large',\n    variant = 'circular',\n    ...other\n  } = props;\n  const ownerState = {\n    ...props,\n    color,\n    component,\n    disabled,\n    disableFocusRipple,\n    size,\n    variant\n  };\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(FabRoot, {\n    className: clsx(classes.root, className),\n    component: component,\n    disabled: disabled,\n    focusRipple: !disableFocusRipple,\n    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),\n    ownerState: ownerState,\n    ref: ref,\n    ...other,\n    classes: classes,\n    children: children\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? Fab.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'default'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'error', 'info', 'inherit', 'primary', 'secondary', 'success', 'warning']), PropTypes.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the  keyboard focus ripple is disabled.\n   * @default false\n   */\n  disableFocusRipple: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  focusVisibleClassName: PropTypes.string,\n  /**\n   * The URL to link to when the button is clicked.\n   * If defined, an `a` element will be used as the root node.\n   */\n  href: PropTypes.string,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense button styling.\n   * @default 'large'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['small', 'medium', 'large']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The variant to use.\n   * @default 'circular'\n   */\n  variant: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['circular', 'extended']), PropTypes.string])\n} : void 0;\nexport default Fab;","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M5 4v2h14V4zm0 10h4v6h6v-6h4l-7-7z\"\n}), 'Publish');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 9h-4V3H9v6H5l7 7zM5 18v2h14v-2z\"\n}), 'GetApp');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7s2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11\"\n}), 'Extension');","import { forwardRef, memo } from \"react\"\n\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { useObserver } from \"./useObserver\"\n\nlet warnObserverOptionsDeprecated = true\nlet warnLegacyContextTypes = true\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\nconst isFunctionNameConfigurable =\n    Object.getOwnPropertyDescriptor(() => {}, \"name\")?.configurable ?? false\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof forwardRef === \"function\" && forwardRef((props: any) => null)[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof memo === \"function\" && memo((props: any) => null)[\"$$typeof\"]\n\n/**\n * @deprecated Observer options will be removed in the next major version of mobx-react-lite.\n * Look at the individual properties for alternatives.\n */\nexport interface IObserverOptions {\n    /**\n     * @deprecated Pass a `React.forwardRef` component to observer instead of using the options object\n     * e.g. `observer(React.forwardRef(fn))`\n     */\n    readonly forwardRef?: boolean\n}\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefRenderFunction<TRef, P>,\n    options: IObserverOptions & {\n        /**\n         * @deprecated Pass a `React.forwardRef` component to observer instead of using the options object\n         * e.g. `observer(React.forwardRef(fn))`\n         */\n        forwardRef: true\n    }\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\n\nexport function observer<P extends object>(\n    baseComponent: React.FunctionComponent<P>,\n    options?: IObserverOptions\n): React.FunctionComponent<P>\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefExoticComponent<\n        React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n    >\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\nexport function observer<\n    C extends React.FunctionComponent<any> | React.ForwardRefRenderFunction<any>,\n    Options extends IObserverOptions\n>(\n    baseComponent: C,\n    options?: Options\n): Options extends { forwardRef: true }\n    ? C extends React.ForwardRefRenderFunction<infer TRef, infer P>\n        ? C &\n              React.MemoExoticComponent<\n                  React.ForwardRefExoticComponent<\n                      React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n                  >\n              >\n        : never /* forwardRef set for a non forwarding component */\n    : C & { displayName: string }\n\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer<P extends object, TRef = {}>(\n    baseComponent:\n        | React.ForwardRefRenderFunction<TRef, P>\n        | React.FunctionComponent<P>\n        | React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>,\n    // TODO remove in next major\n    options?: IObserverOptions\n) {\n    if (process.env.NODE_ENV !== \"production\" && warnObserverOptionsDeprecated && options) {\n        warnObserverOptionsDeprecated = false\n        console.warn(\n            `[mobx-react-lite] \\`observer(fn, { forwardRef: true })\\` is deprecated, use \\`observer(React.forwardRef(fn))\\``\n        )\n    }\n\n    if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            `[mobx-react-lite] You are trying to use \\`observer\\` on a function component wrapped in either another \\`observer\\` or \\`React.memo\\`. The observer already applies 'React.memo' for you.`\n        )\n    }\n\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent\n    }\n\n    let useForwardRef = options?.forwardRef ?? false\n    let render = baseComponent\n\n    const baseComponentName = baseComponent.displayName || baseComponent.name\n\n    // If already wrapped with forwardRef, unwrap,\n    // so we can patch render and apply memo\n    if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n        useForwardRef = true\n        render = baseComponent[\"render\"]\n        if (typeof render !== \"function\") {\n            throw new Error(\n                `[mobx-react-lite] \\`render\\` property of ForwardRef was not a function`\n            )\n        }\n    }\n\n    let observerComponent = (props: any, ref: React.Ref<TRef>) => {\n        return useObserver(() => render(props, ref), baseComponentName)\n    }\n\n    // Inherit original name and displayName, see #3438\n    ;(observerComponent as React.FunctionComponent).displayName = baseComponent.displayName\n\n    if (isFunctionNameConfigurable) {\n        Object.defineProperty(observerComponent, \"name\", {\n            value: baseComponent.name,\n            writable: true,\n            configurable: true\n        })\n    }\n\n    // Support legacy context: `contextTypes` must be applied before `memo`\n    if ((baseComponent as any).contextTypes) {\n        ;(observerComponent as React.FunctionComponent).contextTypes = (\n            baseComponent as any\n        ).contextTypes\n\n        if (process.env.NODE_ENV !== \"production\" && warnLegacyContextTypes) {\n            warnLegacyContextTypes = false\n            console.warn(\n                `[mobx-react-lite] Support for Legacy Context in function components will be removed in the next major release.`\n            )\n        }\n    }\n\n    if (useForwardRef) {\n        // `forwardRef` must be applied prior `memo`\n        // `forwardRef(observer(cmp))` throws:\n        // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n        observerComponent = forwardRef(observerComponent)\n    }\n\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    observerComponent = memo(observerComponent)\n\n    copyStaticProperties(baseComponent, observerComponent)\n\n    if (\"production\" !== process.env.NODE_ENV) {\n        Object.defineProperty(observerComponent, \"contextTypes\", {\n            set() {\n                throw new Error(\n                    `[mobx-react-lite] \\`${\n                        this.displayName || this.type?.displayName || this.type?.name || \"Component\"\n                    }.contextTypes\\` must be set before applying \\`observer\\`.`\n                )\n            }\n        })\n    }\n\n    return observerComponent\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList: any = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n    // Don't redefine `displayName`,\n    // it's defined as getter-setter pair on `memo` (see #3192).\n    displayName: true\n}\n\nfunction copyStaticProperties(base: any, target: any) {\n    Object.keys(base).forEach(key => {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z\"\n}), 'Launch');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6\"\n}), 'Settings');","import { isComputedProp, isObservableProp, createAtom, action, computed, _allowStateChangesInsideComputed, reaction, runInAction, observable, values, entries, isObservableArray, _getGlobalState, isObservableObject, defineProperty as defineProperty$1, _interceptReads, intercept, observe, ObservableMap, _getAdministration, set, makeObservable, getAtom, when } from 'mobx';\n\nlet livelinessChecking = \"warn\";\n/**\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelinessChecking(mode) {\n    livelinessChecking = mode;\n}\n/**\n * Returns the current liveliness checking mode.\n *\n * @returns `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction getLivelinessChecking() {\n    return livelinessChecking;\n}\n/**\n * @deprecated use setLivelinessChecking instead\n * @hidden\n *\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelynessChecking(mode) {\n    setLivelinessChecking(mode);\n}\n\n/**\n * @hidden\n */\nvar Hook;\n(function (Hook) {\n    Hook[\"afterCreate\"] = \"afterCreate\";\n    Hook[\"afterAttach\"] = \"afterAttach\";\n    Hook[\"afterCreationFinalization\"] = \"afterCreationFinalization\";\n    Hook[\"beforeDetach\"] = \"beforeDetach\";\n    Hook[\"beforeDestroy\"] = \"beforeDestroy\";\n})(Hook || (Hook = {}));\n\n/**\n * Returns the _actual_ type of the given tree node. (Or throws)\n *\n * @param object\n * @returns\n */\nfunction getType(object) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).type;\n}\n/**\n * Returns the _declared_ type of the given sub property of an object, array or map.\n * In the case of arrays and maps the property name is optional and will be ignored.\n *\n * Example:\n * ```ts\n * const Box = types.model({ x: 0, y: 0 })\n * const box = Box.create()\n *\n * console.log(getChildType(box, \"x\").name) // 'number'\n * ```\n *\n * @param object\n * @param propertyName\n * @returns\n */\nfunction getChildType(object, propertyName) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).getChildType(propertyName);\n}\n/**\n * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.\n * Patches can be used to deeply observe a model tree.\n *\n * @param target the model instance from which to receive patches\n * @param callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch\n * @returns function to remove the listener\n */\nfunction onPatch(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onPatch(callback);\n}\n/**\n * Registers a function that is invoked whenever a new snapshot for the given model instance is available.\n * The listener will only be fire at the end of the current MobX (trans)action.\n * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.\n *\n * @param target\n * @param callback\n * @returns\n */\nfunction onSnapshot(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onSnapshot(callback);\n}\n/**\n * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.\n *\n * Can apply a single past, or an array of patches.\n *\n * @param target\n * @param patch\n * @returns\n */\nfunction applyPatch(target, patch) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(patch, p => typeof p === \"object\", \"object or array\", 2);\n    getStateTreeNode(target).applyPatches(asArray(patch));\n}\n/**\n * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.\n * Returns a recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IPatchRecorder {\n *      // the recorded patches\n *      patches: IJsonPatch[]\n *      // the inverse of the recorded patches\n *      inversePatches: IJsonPatch[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording patches\n *      stop(): void\n *      // resume recording patches\n *      resume(): void\n *      // apply all the recorded patches on the given target (the original subject if omitted)\n *      replay(target?: IAnyStateTreeNode): void\n *      // reverse apply the recorded patches on the given target  (the original subject if omitted)\n *      // stops the recorder if not already stopped\n *      undo(): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain patches.\n *\n * @param subject\n * @param filter\n * @returns\n */\nfunction recordPatches(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    const data = {\n        patches: [],\n        inversePatches: []\n    };\n    // we will generate the immutable copy of patches on demand for public consumption\n    const publicData = {};\n    let disposer;\n    const recorder = {\n        get recording() {\n            return !!disposer;\n        },\n        get patches() {\n            if (!publicData.patches) {\n                publicData.patches = data.patches.slice();\n            }\n            return publicData.patches;\n        },\n        get reversedInversePatches() {\n            if (!publicData.reversedInversePatches) {\n                publicData.reversedInversePatches = data.inversePatches\n                    .slice()\n                    .reverse();\n            }\n            return publicData.reversedInversePatches;\n        },\n        get inversePatches() {\n            if (!publicData.inversePatches) {\n                publicData.inversePatches = data.inversePatches.slice();\n            }\n            return publicData.inversePatches;\n        },\n        stop() {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume() {\n            if (disposer) {\n                return;\n            }\n            disposer = onPatch(subject, (patch, inversePatch) => {\n                // skip patches that are asked to be filtered if there's a filter in place\n                if (filter && !filter(patch, inversePatch, getRunningActionContext())) {\n                    return;\n                }\n                data.patches.push(patch);\n                data.inversePatches.push(inversePatch);\n                // mark immutable public patches as dirty\n                publicData.patches = undefined;\n                publicData.inversePatches = undefined;\n                publicData.reversedInversePatches = undefined;\n            });\n        },\n        replay(target) {\n            applyPatch(target || subject, data.patches);\n        },\n        undo(target) {\n            applyPatch(target || subject, data.inversePatches.slice().reverse());\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * The inverse of `unprotect`.\n *\n * @param target\n */\nfunction protect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (!node.isRoot) {\n        throw fail(\"`protect` can only be invoked on root nodes\");\n    }\n    node.isProtectionEnabled = true;\n}\n/**\n * By default it is not allowed to directly modify a model. Models can only be modified through actions.\n * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.\n * For example because you are building a PoC or don't have any middleware attached to your tree.\n *\n * In that case you can disable this protection by calling `unprotect` on the root of your tree.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *     done: false\n * }).actions(self => ({\n *     toggle() {\n *         self.done = !self.done\n *     }\n * }))\n *\n * const todo = Todo.create()\n * todo.done = true // throws!\n * todo.toggle() // OK\n * unprotect(todo)\n * todo.done = false // OK\n * ```\n */\nfunction unprotect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (!node.isRoot) {\n        throw fail(\"`unprotect` can only be invoked on root nodes\");\n    }\n    node.isProtectionEnabled = false;\n}\n/**\n * Returns true if the object is in protected mode, @see protect\n */\nfunction isProtected(target) {\n    return getStateTreeNode(target).isProtected;\n}\n/**\n * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.\n *\n * @param target\n * @param snapshot\n * @returns\n */\nfunction applySnapshot(target, snapshot) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).applySnapshot(snapshot);\n}\n/**\n * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use\n * structural sharing where possible. Doesn't require MobX transactions to be completed.\n *\n * @param target\n * @param applyPostProcess If true (the default) then postProcessSnapshot gets applied.\n * @returns\n */\nfunction getSnapshot(target, applyPostProcess = true) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (applyPostProcess) {\n        return node.snapshot;\n    }\n    return freeze(node.type.getSnapshot(node, false));\n}\n/**\n * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction hasParent(target, depth = 1) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--depth === 0) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the immediate parent of this object, or throws.\n *\n * Note that the immediate parent can be either an object, map or array, and\n * doesn't necessarily refer to the parent model.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction getParent(target, depth = 1) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    let d = depth;\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--d === 0) {\n            return parent.storedValue;\n        }\n        parent = parent.parent;\n    }\n    throw fail(`Failed to find the parent of ${getStateTreeNode(target)} at depth ${depth}`);\n}\n/**\n * Given a model instance, returns `true` if the object has a parent of given type, that is, is part of another object, map or array\n *\n * @param target\n * @param type\n * @returns\n */\nfunction hasParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue)) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the target's parent of a given type, or throws.\n *\n * @param target\n * @param type\n * @returns\n */\nfunction getParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue)) {\n            return parent.storedValue;\n        }\n        parent = parent.parent;\n    }\n    throw fail(`Failed to find the parent of ${getStateTreeNode(target)} of a given type`);\n}\n/**\n * Given an object in a model tree, returns the root object of that tree.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @returns\n */\nfunction getRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).root.storedValue;\n}\n/**\n * Returns the path of the given object in the model tree\n *\n * @param target\n * @returns\n */\nfunction getPath(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).path;\n}\n/**\n * Returns the path of the given object as unescaped string array.\n *\n * @param target\n * @returns\n */\nfunction getPathParts(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return splitJsonPath(getStateTreeNode(target).path);\n}\n/**\n * Returns true if the given object is the root of a model tree.\n *\n * @param target\n * @returns\n */\nfunction isRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).isRoot;\n}\n/**\n * Resolves a path relatively to a given object.\n * Returns undefined if no value can be found.\n *\n * @param target\n * @param path escaped json path\n * @returns\n */\nfunction resolvePath(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    const node = resolveNodeByPath(getStateTreeNode(target), path);\n    return node ? node.value : undefined;\n}\n/**\n * Resolves a model instance given a root target, the type and the identifier you are searching for.\n * Returns undefined if no value can be found.\n *\n * @param type\n * @param target\n * @param identifier\n * @returns\n */\nfunction resolveIdentifier(type, target, identifier) {\n    // check all arguments\n    assertIsType(type, 1);\n    assertIsStateTreeNode(target, 2);\n    assertIsValidIdentifier(identifier, 3);\n    const node = getStateTreeNode(target).root.identifierCache.resolve(type, normalizeIdentifier(identifier));\n    return node?.value;\n}\n/**\n * Returns the identifier of the target node.\n * This is the *string normalized* identifier, which might not match the type of the identifier attribute\n *\n * @param target\n * @returns\n */\nfunction getIdentifier(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).identifier;\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns such reference if the check passes,\n * else it returns undefined.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction tryReference(getter, checkIfAlive = true) {\n    try {\n        const node = getter();\n        if (node === undefined || node === null) {\n            return undefined;\n        }\n        else if (isStateTreeNode(node)) {\n            if (!checkIfAlive) {\n                return node;\n            }\n            else {\n                return isAlive(node) ? node : undefined;\n            }\n        }\n        else {\n            throw fail(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return undefined;\n        }\n        throw e;\n    }\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns if the check passes or not.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction isValidReference(getter, checkIfAlive = true) {\n    try {\n        const node = getter();\n        if (node === undefined || node === null) {\n            return false;\n        }\n        else if (isStateTreeNode(node)) {\n            return checkIfAlive ? isAlive(node) : true;\n        }\n        else {\n            throw fail(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return false;\n        }\n        throw e;\n    }\n}\n/**\n * Try to resolve a given path relative to a given node.\n *\n * @param target\n * @param path\n * @returns\n */\nfunction tryResolve(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    const node = resolveNodeByPath(getStateTreeNode(target), path, false);\n    if (node === undefined) {\n        return undefined;\n    }\n    try {\n        return node.value;\n    }\n    catch (e) {\n        // For what ever reason not resolvable (e.g. totally not existing path, or value that cannot be fetched)\n        // see test / issue: 'try resolve doesn't work #686'\n        return undefined;\n    }\n}\n/**\n * Given two state tree nodes that are part of the same tree,\n * returns the shortest jsonpath needed to navigate from the one to the other\n *\n * @param base\n * @param target\n * @returns\n */\nfunction getRelativePath(base, target) {\n    // check all arguments\n    assertIsStateTreeNode(base, 1);\n    assertIsStateTreeNode(target, 2);\n    return getRelativePathBetweenNodes(getStateTreeNode(base), getStateTreeNode(target));\n}\n/**\n * Returns a deep copy of the given state tree node as new tree.\n * Shorthand for `snapshot(x) = getType(x).create(getSnapshot(x))`\n *\n * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc. during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_\n *\n * @param source\n * @param keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.\n * @returns\n */\nfunction clone(source, keepEnvironment = true) {\n    // check all arguments\n    assertIsStateTreeNode(source, 1);\n    const node = getStateTreeNode(source);\n    return node.type.create(node.snapshot, keepEnvironment === true\n        ? node.root.environment\n        : keepEnvironment === false\n            ? undefined\n            : keepEnvironment); // it's an object or something else\n}\n/**\n * Removes a model element from the state tree, and let it live on as a new state tree\n */\nfunction detach(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    getStateTreeNode(target).detach();\n    return target;\n}\n/**\n * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore\n */\nfunction destroy(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (node.isRoot) {\n        node.die();\n    }\n    else {\n        node.parent.removeChild(node.subpath);\n    }\n}\n/**\n * Returns true if the given state tree node is not killed yet.\n * This means that the node is still a part of a tree, and that `destroy`\n * has not been called. If a node is not alive anymore, the only thing one can do with it\n * is requesting it's last path and snapshot\n *\n * @param target\n * @returns\n */\nfunction isAlive(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).observableIsAlive;\n}\n/**\n * Use this utility to register a function that should be called whenever the\n * targeted state tree node is destroyed. This is a useful alternative to managing\n * cleanup methods yourself using the `beforeDestroy` hook.\n *\n * This methods returns the same disposer that was passed as argument.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string\n * }).actions(self => ({\n *   afterCreate() {\n *     const autoSaveDisposer = reaction(\n *       () => getSnapshot(self),\n *       snapshot => sendSnapshotToServerSomehow(snapshot)\n *     )\n *     // stop sending updates to server if this\n *     // instance is destroyed\n *     addDisposer(self, autoSaveDisposer)\n *   }\n * }))\n * ```\n *\n * @param target\n * @param disposer\n * @returns The same disposer that was passed as argument\n */\nfunction addDisposer(target, disposer) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(disposer, 2);\n    const node = getStateTreeNode(target);\n    node.addDisposer(disposer);\n    return disposer;\n}\n/**\n * Returns the environment of the current state tree. For more info on environments,\n * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired\n *\n * Returns an empty environment if the tree wasn't initialized with an environment\n *\n * @param target\n * @returns\n */\nfunction getEnv(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    const env = node.root.environment;\n    if (!env) {\n        return EMPTY_OBJECT;\n    }\n    return env;\n}\n/**\n * Performs a depth first walk through a tree.\n */\nfunction walk(target, processor) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(processor, 2);\n    const node = getStateTreeNode(target);\n    // tslint:disable-next-line:no_unused-variable\n    node.getChildren().forEach(child => {\n        if (isStateTreeNode(child.storedValue)) {\n            walk(child.storedValue, processor);\n        }\n    });\n    processor(node.storedValue);\n}\n/**\n * Returns a reflection of the model type properties and name for either a model type or model node.\n *\n * @param typeOrNode\n * @returns\n */\nfunction getPropertyMembers(typeOrNode) {\n    let type;\n    if (isStateTreeNode(typeOrNode)) {\n        type = getType(typeOrNode);\n    }\n    else {\n        type = typeOrNode;\n    }\n    assertArg(type, t => isModelType(t), \"model type or model instance\", 1);\n    return {\n        name: type.name,\n        properties: { ...type.properties }\n    };\n}\n/**\n * Returns a reflection of the model node, including name, properties, views, volatile state,\n * and actions. `flowActions` is also provided as a separate array of names for any action that\n * came from a flow generator as well.\n *\n * In the case where a model has two actions: `doSomething` and `doSomethingWithFlow`, where\n * `doSomethingWithFlow` is a flow generator, the `actions` array will contain both actions,\n * i.e. [\"doSomething\", \"doSomethingWithFlow\"], and the `flowActions` array will contain only\n * the flow action, i.e. [\"doSomethingWithFlow\"].\n *\n * @param target\n * @returns\n */\nfunction getMembers(target) {\n    const type = getStateTreeNode(target).type;\n    const reflected = {\n        ...getPropertyMembers(type),\n        actions: [],\n        volatile: [],\n        views: [],\n        flowActions: []\n    };\n    const props = Object.getOwnPropertyNames(target);\n    props.forEach(key => {\n        if (key in reflected.properties) {\n            return;\n        }\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor.get) {\n            if (isComputedProp(target, key)) {\n                reflected.views.push(key);\n            }\n            else {\n                reflected.volatile.push(key);\n            }\n            return;\n        }\n        if (descriptor.value._isFlowAction === true) {\n            reflected.flowActions.push(key);\n        }\n        if (descriptor.value._isMSTAction === true) {\n            reflected.actions.push(key);\n        }\n        else if (isObservableProp(target, key)) {\n            reflected.volatile.push(key);\n        }\n        else {\n            reflected.views.push(key);\n        }\n    });\n    return reflected;\n}\n/**\n * Casts a node snapshot or instance type to an instance type so it can be assigned to a type instance.\n * Note that this is just a cast for the type system, this is, it won't actually convert a snapshot to an instance,\n * but just fool typescript into thinking so.\n * Either way, casting when outside an assignation operation won't compile.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * }).actions(self => ({\n *   someAction() {\n *     // this will allow the compiler to assign a snapshot to the property\n *     self.innerModel = cast({ a: 5 })\n *   }\n * }))\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object cast as an instance\n */\nfunction cast(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a snapshot type so it can be assigned to a type snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * })\n *\n * const a = ModelA.create({ n: 5 });\n * // this will allow the compiler to use a model as if it were a snapshot\n * const b = ModelB.create({ innerModel: castToSnapshot(a)})\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object cast as an input (creation) snapshot\n */\nfunction castToSnapshot(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a reference snapshot type so it can be assigned to a reference snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a reference snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   id: types.identifier,\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   refA: types.reference(ModelA)\n * })\n *\n * const a = ModelA.create({ id: 'someId', n: 5 });\n * // this will allow the compiler to use a model as if it were a reference snapshot\n * const b = ModelB.create({ refA: castToReferenceSnapshot(a)})\n * ```\n *\n * @param instance Instance\n * @returns The same object cast as a reference snapshot (string or number)\n */\nfunction castToReferenceSnapshot(instance) {\n    return instance;\n}\n/**\n * Returns the unique node id (not to be confused with the instance identifier) for a\n * given instance.\n * This id is a number that is unique for each instance.\n *\n * @export\n * @param target\n * @returns\n */\nfunction getNodeId(target) {\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).nodeId;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass BaseNode {\n    type;\n    environment;\n    _escapedSubpath;\n    _subpath;\n    get subpath() {\n        return this._subpath;\n    }\n    _subpathUponDeath;\n    get subpathUponDeath() {\n        return this._subpathUponDeath;\n    }\n    _pathUponDeath;\n    get pathUponDeath() {\n        return this._pathUponDeath;\n    }\n    storedValue; // usually the same type as the value, but not always (such as with references)\n    get value() {\n        return this.type.getValue(this);\n    }\n    aliveAtom;\n    _state = NodeLifeCycle.INITIALIZING;\n    get state() {\n        return this._state;\n    }\n    set state(val) {\n        const wasAlive = this.isAlive;\n        this._state = val;\n        const isAlive = this.isAlive;\n        if (this.aliveAtom && wasAlive !== isAlive) {\n            this.aliveAtom.reportChanged();\n        }\n    }\n    _hookSubscribers;\n    fireInternalHook(name) {\n        if (this._hookSubscribers) {\n            this._hookSubscribers.emit(name, this, name);\n        }\n    }\n    registerHook(hook, hookHandler) {\n        if (!this._hookSubscribers) {\n            this._hookSubscribers = new EventHandlers();\n        }\n        return this._hookSubscribers.register(hook, hookHandler);\n    }\n    _parent;\n    get parent() {\n        return this._parent;\n    }\n    constructor(type, parent, subpath, environment) {\n        this.type = type;\n        this.environment = environment;\n        this.environment = environment;\n        this.baseSetParent(parent, subpath);\n    }\n    getReconciliationType() {\n        return this.type;\n    }\n    pathAtom;\n    baseSetParent(parent, subpath) {\n        this._parent = parent;\n        this._subpath = subpath;\n        this._escapedSubpath = undefined; // regenerate when needed\n        if (this.pathAtom) {\n            this.pathAtom.reportChanged();\n        }\n    }\n    /*\n     * Returns (escaped) path representation as string\n     */\n    get path() {\n        return this.getEscapedPath(true);\n    }\n    getEscapedPath(reportObserved) {\n        if (reportObserved) {\n            if (!this.pathAtom) {\n                this.pathAtom = createAtom(`path`);\n            }\n            this.pathAtom.reportObserved();\n        }\n        if (!this.parent) {\n            return \"\";\n        }\n        // regenerate escaped subpath if needed\n        if (this._escapedSubpath === undefined) {\n            this._escapedSubpath = !this._subpath ? \"\" : escapeJsonPath(this._subpath);\n        }\n        return (this.parent.getEscapedPath(reportObserved) + \"/\" + this._escapedSubpath);\n    }\n    get isRoot() {\n        return this.parent === null;\n    }\n    get isAlive() {\n        return this.state !== NodeLifeCycle.DEAD;\n    }\n    get isDetaching() {\n        return this.state === NodeLifeCycle.DETACHING;\n    }\n    get observableIsAlive() {\n        if (!this.aliveAtom) {\n            this.aliveAtom = createAtom(`alive`);\n        }\n        this.aliveAtom.reportObserved();\n        return this.isAlive;\n    }\n    baseFinalizeCreation(whenFinalized) {\n        if (devMode()) {\n            if (!this.isAlive) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: cannot finalize the creation of a node that is already dead\");\n            }\n        }\n        // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already\n        if (this.state === NodeLifeCycle.CREATED) {\n            if (this.parent) {\n                if (this.parent.state !== NodeLifeCycle.FINALIZED) {\n                    // parent not ready yet, postpone\n                    return;\n                }\n                this.fireHook(Hook.afterAttach);\n            }\n            this.state = NodeLifeCycle.FINALIZED;\n            if (whenFinalized) {\n                whenFinalized();\n            }\n        }\n    }\n    baseFinalizeDeath() {\n        if (this._hookSubscribers) {\n            this._hookSubscribers.clearAll();\n        }\n        this._subpathUponDeath = this._subpath;\n        this._pathUponDeath = this.getEscapedPath(false);\n        this.baseSetParent(null, \"\");\n        this.state = NodeLifeCycle.DEAD;\n    }\n    baseAboutToDie() {\n        this.fireHook(Hook.beforeDestroy);\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nclass ScalarNode extends BaseNode {\n    constructor(simpleType, parent, subpath, environment, initialSnapshot) {\n        super(simpleType, parent, subpath, environment);\n        try {\n            this.storedValue = simpleType.createNewInstance(initialSnapshot);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        this.state = NodeLifeCycle.CREATED;\n        // for scalar nodes there's no point in firing this event since it would fire on the constructor, before\n        // anybody can actually register for/listen to it\n        // this.fireHook(Hook.AfterCreate)\n        this.finalizeCreation();\n    }\n    get root() {\n        // future optimization: store root ref in the node and maintain it\n        if (!this.parent) {\n            throw fail(`This scalar node is not part of a tree`);\n        }\n        return this.parent.root;\n    }\n    setParent(newParent, subpath) {\n        const parentChanged = this.parent !== newParent;\n        const subpathChanged = this.subpath !== subpath;\n        if (!parentChanged && !subpathChanged) {\n            return;\n        }\n        if (devMode()) {\n            if (!subpath) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: subpath expected\");\n            }\n            if (!newParent) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: parent expected\");\n            }\n            if (parentChanged) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: scalar nodes cannot change their parent\");\n            }\n        }\n        this.environment = undefined; // use parent's\n        this.baseSetParent(this.parent, subpath);\n    }\n    get snapshot() {\n        return freeze(this.getSnapshot());\n    }\n    getSnapshot() {\n        return this.type.getSnapshot(this);\n    }\n    toString() {\n        const path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n        return `${this.type.name}@${path}${this.isAlive ? \"\" : \" [dead]\"}`;\n    }\n    die() {\n        if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) {\n            return;\n        }\n        this.aboutToDie();\n        this.finalizeDeath();\n    }\n    finalizeCreation() {\n        this.baseFinalizeCreation();\n    }\n    aboutToDie() {\n        this.baseAboutToDie();\n    }\n    finalizeDeath() {\n        this.baseFinalizeDeath();\n    }\n    fireHook(name) {\n        this.fireInternalHook(name);\n    }\n}\nScalarNode.prototype.die = action(ScalarNode.prototype.die);\n\n// noinspection ES6UnusedImports\nlet nextNodeId = 1;\nconst snapshotReactionOptions = {\n    onError(e) {\n        throw e;\n    }\n};\n/**\n * @internal\n * @hidden\n */\nclass ObjectNode extends BaseNode {\n    nodeId = ++nextNodeId;\n    identifierAttribute;\n    identifier; // Identifier is always normalized to string, even if the identifier property isn't\n    unnormalizedIdentifier;\n    identifierCache;\n    isProtectionEnabled = true;\n    middlewares;\n    hasSnapshotPostProcessor = false;\n    _applyPatches;\n    applyPatches(patches) {\n        this.createObservableInstanceIfNeeded();\n        this._applyPatches(patches);\n    }\n    _applySnapshot;\n    applySnapshot(snapshot) {\n        this.createObservableInstanceIfNeeded();\n        this._applySnapshot(snapshot);\n    }\n    _autoUnbox = true; // unboxing is disabled when reading child nodes\n    _isRunningAction = false; // only relevant for root\n    _hasSnapshotReaction = false;\n    _observableInstanceState = 0 /* ObservableInstanceLifecycle.UNINITIALIZED */;\n    _childNodes;\n    _initialSnapshot;\n    _cachedInitialSnapshot;\n    _cachedInitialSnapshotCreated = false;\n    _snapshotComputed;\n    constructor(complexType, parent, subpath, environment, initialValue) {\n        super(complexType, parent, subpath, environment);\n        this._snapshotComputed = computed(() => freeze(this.getSnapshot()));\n        this.unbox = this.unbox.bind(this);\n        this._initialSnapshot = freeze(initialValue);\n        this.identifierAttribute = complexType.identifierAttribute;\n        if (!parent) {\n            this.identifierCache = new IdentifierCache();\n        }\n        this._childNodes = complexType.initializeChildNodes(this, this._initialSnapshot);\n        // identifier can not be changed during lifecycle of a node\n        // so we safely can read it from initial snapshot\n        this.identifier = null;\n        this.unnormalizedIdentifier = null;\n        if (this.identifierAttribute && this._initialSnapshot) {\n            let id = this._initialSnapshot[this.identifierAttribute];\n            if (id === undefined) {\n                // try with the actual node if not (for optional identifiers)\n                const childNode = this._childNodes[this.identifierAttribute];\n                if (childNode) {\n                    id = childNode.value;\n                }\n            }\n            if (typeof id !== \"string\" && typeof id !== \"number\") {\n                throw fail(`Instance identifier '${this.identifierAttribute}' for type '${this.type.name}' must be a string or a number`);\n            }\n            // normalize internal identifier to string\n            this.identifier = normalizeIdentifier(id);\n            this.unnormalizedIdentifier = id;\n        }\n        if (!parent) {\n            this.identifierCache.addNodeToCache(this);\n        }\n        else {\n            parent.root.identifierCache.addNodeToCache(this);\n        }\n    }\n    createObservableInstanceIfNeeded(fireHooks = true) {\n        if (this._observableInstanceState ===\n            0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            this.createObservableInstance(fireHooks);\n        }\n    }\n    createObservableInstance(fireHooks = true) {\n        if (devMode()) {\n            if (this.state !== NodeLifeCycle.INITIALIZING) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: the creation of the observable instance must be done on the initializing phase\");\n            }\n        }\n        this._observableInstanceState = 1 /* ObservableInstanceLifecycle.CREATING */;\n        // make sure the parent chain is created as well\n        // array with parent chain from parent to child\n        const parentChain = [];\n        let parent = this.parent;\n        // for performance reasons we never go back further than the most direct\n        // uninitialized parent\n        // this is done to avoid traversing the whole tree to the root when using\n        // the same reference again\n        while (parent &&\n            parent._observableInstanceState ===\n                0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            parentChain.unshift(parent);\n            parent = parent.parent;\n        }\n        // initialize the uninitialized parent chain from parent to child\n        for (const p of parentChain) {\n            // delay firing hooks until after all parents have been created\n            p.createObservableInstanceIfNeeded(false);\n        }\n        const type = this.type;\n        try {\n            // @ts-expect-error\n            this.storedValue = type.createNewInstance(this._childNodes);\n            this.preboot();\n            this._isRunningAction = true;\n            type.finalizeNewInstance(this, this.storedValue);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        finally {\n            this._isRunningAction = false;\n        }\n        this._observableInstanceState = 2 /* ObservableInstanceLifecycle.CREATED */;\n        this._snapshotComputed.trackAndCompute();\n        if (this.isRoot) {\n            this._addSnapshotReaction();\n        }\n        this._childNodes = EMPTY_OBJECT;\n        this.state = NodeLifeCycle.CREATED;\n        if (fireHooks) {\n            this.fireHook(Hook.afterCreate);\n            // Note that the parent might not be finalized at this point\n            // so afterAttach won't be called until later in that case\n            this.finalizeCreation();\n            // fire the hooks of the parents that we created\n            for (const p of parentChain.reverse()) {\n                p.fireHook(Hook.afterCreate);\n                // This will call afterAttach on the child if necessary\n                p.finalizeCreation();\n            }\n        }\n    }\n    get root() {\n        const parent = this.parent;\n        return parent ? parent.root : this;\n    }\n    clearParent() {\n        if (!this.parent) {\n            return;\n        }\n        // detach if attached\n        this.fireHook(Hook.beforeDetach);\n        const previousState = this.state;\n        this.state = NodeLifeCycle.DETACHING;\n        const root = this.root;\n        const newEnv = root.environment;\n        const newIdCache = root.identifierCache.splitCache(this);\n        try {\n            this.parent.removeChild(this.subpath);\n            this.baseSetParent(null, \"\");\n            this.environment = newEnv;\n            this.identifierCache = newIdCache;\n        }\n        finally {\n            this.state = previousState;\n        }\n    }\n    setParent(newParent, subpath) {\n        const parentChanged = newParent !== this.parent;\n        const subpathChanged = subpath !== this.subpath;\n        if (!parentChanged && !subpathChanged) {\n            return;\n        }\n        if (devMode()) {\n            if (!subpath) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: subpath expected\");\n            }\n            if (!newParent) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: new parent expected\");\n            }\n            if (this.parent && parentChanged) {\n                throw fail(`A node cannot exists twice in the state tree. Failed to add ${this} to path '${newParent.path}/${subpath}'.`);\n            }\n            if (!this.parent && newParent.root === this) {\n                throw fail(`A state tree is not allowed to contain itself. Cannot assign ${this} to path '${newParent.path}/${subpath}'`);\n            }\n            if (!this.parent &&\n                !!this.environment &&\n                this.environment !== newParent.root.environment) {\n                throw fail(`A state tree cannot be made part of another state tree as long as their environments are different.`);\n            }\n        }\n        if (parentChanged) {\n            // attach to new parent\n            this.environment = undefined; // will use root's\n            newParent.root.identifierCache.mergeCache(this);\n            this.baseSetParent(newParent, subpath);\n            this.fireHook(Hook.afterAttach);\n        }\n        else if (subpathChanged) {\n            // moving to a new subpath on the same parent\n            this.baseSetParent(this.parent, subpath);\n        }\n    }\n    fireHook(name) {\n        this.fireInternalHook(name);\n        const fn = this.storedValue &&\n            typeof this.storedValue === \"object\" &&\n            this.storedValue[name];\n        if (typeof fn === \"function\") {\n            // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)\n            if (_allowStateChangesInsideComputed) {\n                _allowStateChangesInsideComputed(() => {\n                    fn.apply(this.storedValue);\n                });\n            }\n            else {\n                fn.apply(this.storedValue);\n            }\n        }\n    }\n    _snapshotUponDeath;\n    // advantage of using computed for a snapshot is that nicely respects transactions etc.\n    get snapshot() {\n        if (this.hasSnapshotPostProcessor) {\n            this.createObservableInstanceIfNeeded();\n        }\n        return this._snapshotComputed.get();\n    }\n    // NOTE: we use this method to get snapshot without creating @computed overhead\n    getSnapshot() {\n        if (!this.isAlive) {\n            return this._snapshotUponDeath;\n        }\n        return this._observableInstanceState === 2 /* ObservableInstanceLifecycle.CREATED */\n            ? this._getActualSnapshot()\n            : this._getCachedInitialSnapshot();\n    }\n    _getActualSnapshot() {\n        return this.type.getSnapshot(this);\n    }\n    _getCachedInitialSnapshot() {\n        if (!this._cachedInitialSnapshotCreated) {\n            const type = this.type;\n            const childNodes = this._childNodes;\n            const snapshot = this._initialSnapshot;\n            this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);\n            this._cachedInitialSnapshotCreated = true;\n        }\n        return this._cachedInitialSnapshot;\n    }\n    isRunningAction() {\n        if (this._isRunningAction) {\n            return true;\n        }\n        if (this.isRoot) {\n            return false;\n        }\n        return this.parent.isRunningAction();\n    }\n    assertAlive(context) {\n        const livelinessChecking = getLivelinessChecking();\n        if (!this.isAlive && livelinessChecking !== \"ignore\") {\n            const error = this._getAssertAliveError(context);\n            switch (livelinessChecking) {\n                case \"error\":\n                    throw fail(error);\n                case \"warn\":\n                    warnError(error);\n            }\n        }\n    }\n    _getAssertAliveError(context) {\n        const escapedPath = this.getEscapedPath(false) || this.pathUponDeath || \"\";\n        const subpath = (context.subpath && escapeJsonPath(context.subpath)) || \"\";\n        let actionContext = context.actionContext || getCurrentActionContext();\n        // try to use a real action context if possible since it includes the action name\n        if (actionContext &&\n            actionContext.type !== \"action\" &&\n            actionContext.parentActionEvent) {\n            actionContext = actionContext.parentActionEvent;\n        }\n        let actionFullPath = \"\";\n        if (actionContext && actionContext.name != null) {\n            // try to use the context, and if it not available use the node one\n            const actionPath = (actionContext &&\n                actionContext.context &&\n                getPath(actionContext.context)) ||\n                escapedPath;\n            actionFullPath = `${actionPath}.${actionContext.name}()`;\n        }\n        return `You are trying to read or write to an object that is no longer part of a state tree. (Object type: '${this.type.name}', Path upon death: '${escapedPath}', Subpath: '${subpath}', Action: '${actionFullPath}'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.`;\n    }\n    getChildNode(subpath) {\n        this.assertAlive({\n            subpath\n        });\n        this._autoUnbox = false;\n        try {\n            return this._observableInstanceState ===\n                2 /* ObservableInstanceLifecycle.CREATED */\n                ? this.type.getChildNode(this, subpath)\n                : this._childNodes[subpath];\n        }\n        finally {\n            this._autoUnbox = true;\n        }\n    }\n    getChildren() {\n        this.assertAlive(EMPTY_OBJECT);\n        this._autoUnbox = false;\n        try {\n            return this._observableInstanceState ===\n                2 /* ObservableInstanceLifecycle.CREATED */\n                ? this.type.getChildren(this)\n                : convertChildNodesToArray(this._childNodes);\n        }\n        finally {\n            this._autoUnbox = true;\n        }\n    }\n    getChildType(propertyName) {\n        return this.type.getChildType(propertyName);\n    }\n    get isProtected() {\n        return this.root.isProtectionEnabled;\n    }\n    assertWritable(context) {\n        this.assertAlive(context);\n        if (!this.isRunningAction() && this.isProtected) {\n            throw fail(`Cannot modify '${this}', the object is protected and can only be modified by using an action.`);\n        }\n    }\n    removeChild(subpath) {\n        this.type.removeChild(this, subpath);\n    }\n    // bound on the constructor\n    unbox(childNode) {\n        if (!childNode) {\n            return childNode;\n        }\n        this.assertAlive({\n            subpath: childNode.subpath || childNode.subpathUponDeath\n        });\n        return this._autoUnbox ? childNode.value : childNode;\n    }\n    toString() {\n        const path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n        const identifier = this.identifier ? `(id: ${this.identifier})` : \"\";\n        return `${this.type.name}@${path}${identifier}${this.isAlive ? \"\" : \" [dead]\"}`;\n    }\n    finalizeCreation() {\n        this.baseFinalizeCreation(() => {\n            for (const child of this.getChildren()) {\n                child.finalizeCreation();\n            }\n            this.fireInternalHook(Hook.afterCreationFinalization);\n        });\n    }\n    detach() {\n        if (!this.isAlive) {\n            throw fail(`Error while detaching, node is not alive.`);\n        }\n        this.clearParent();\n    }\n    preboot() {\n        const self = this;\n        this._applyPatches = createActionInvoker(this.storedValue, \"@APPLY_PATCHES\", (patches) => {\n            patches.forEach(patch => {\n                if (!patch.path) {\n                    self.type.applySnapshot(self, patch.value);\n                    return;\n                }\n                const parts = splitJsonPath(patch.path);\n                const node = resolveNodeByPathParts(self, parts.slice(0, -1));\n                node.applyPatchLocally(parts[parts.length - 1], patch);\n            });\n        });\n        this._applySnapshot = createActionInvoker(this.storedValue, \"@APPLY_SNAPSHOT\", (snapshot) => {\n            // if the snapshot is the same as the current one, avoid performing a reconcile\n            if (snapshot === self.snapshot) {\n                return;\n            }\n            // else, apply it by calling the type logic\n            return self.type.applySnapshot(self, snapshot);\n        });\n        addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n        addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON);\n    }\n    die() {\n        if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) {\n            return;\n        }\n        this.aboutToDie();\n        this.finalizeDeath();\n    }\n    aboutToDie() {\n        if (this._observableInstanceState ===\n            0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            return;\n        }\n        this.getChildren().forEach(node => {\n            node.aboutToDie();\n        });\n        // beforeDestroy should run before the disposers since else we could end up in a situation where\n        // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released\n        this.baseAboutToDie();\n        this._internalEventsEmit(\"dispose\" /* InternalEvents.Dispose */);\n        this._internalEventsClear(\"dispose\" /* InternalEvents.Dispose */);\n    }\n    finalizeDeath() {\n        // invariant: not called directly but from \"die\"\n        this.getChildren().forEach(node => {\n            node.finalizeDeath();\n        });\n        this.root.identifierCache.notifyDied(this);\n        // \"kill\" the computed prop and just store the last snapshot\n        const snapshot = this.snapshot;\n        this._snapshotUponDeath = snapshot;\n        this._internalEventsClearAll();\n        this.baseFinalizeDeath();\n    }\n    onSnapshot(onChange) {\n        this._addSnapshotReaction();\n        return this._internalEventsRegister(\"snapshot\" /* InternalEvents.Snapshot */, onChange);\n    }\n    emitSnapshot(snapshot) {\n        this._internalEventsEmit(\"snapshot\" /* InternalEvents.Snapshot */, snapshot);\n    }\n    onPatch(handler) {\n        return this._internalEventsRegister(\"patch\" /* InternalEvents.Patch */, handler);\n    }\n    emitPatch(basePatch, source) {\n        if (this._internalEventsHasSubscribers(\"patch\" /* InternalEvents.Patch */)) {\n            const localizedPatch = extend({}, basePatch, {\n                path: source.path.substr(this.path.length) + \"/\" + basePatch.path // calculate the relative path of the patch\n            });\n            const [patch, reversePatch] = splitPatch(localizedPatch);\n            this._internalEventsEmit(\"patch\" /* InternalEvents.Patch */, patch, reversePatch);\n        }\n        if (this.parent) {\n            this.parent.emitPatch(basePatch, source);\n        }\n    }\n    hasDisposer(disposer) {\n        return this._internalEventsHas(\"dispose\" /* InternalEvents.Dispose */, disposer);\n    }\n    addDisposer(disposer) {\n        if (!this.hasDisposer(disposer)) {\n            this._internalEventsRegister(\"dispose\" /* InternalEvents.Dispose */, disposer, true);\n            return;\n        }\n        throw fail(\"cannot add a disposer when it is already registered for execution\");\n    }\n    removeDisposer(disposer) {\n        if (!this._internalEventsHas(\"dispose\" /* InternalEvents.Dispose */, disposer)) {\n            throw fail(\"cannot remove a disposer which was never registered for execution\");\n        }\n        this._internalEventsUnregister(\"dispose\" /* InternalEvents.Dispose */, disposer);\n    }\n    removeMiddleware(middleware) {\n        if (this.middlewares) {\n            const index = this.middlewares.indexOf(middleware);\n            if (index >= 0) {\n                this.middlewares.splice(index, 1);\n            }\n        }\n    }\n    addMiddleWare(handler, includeHooks = true) {\n        const middleware = { handler, includeHooks };\n        if (!this.middlewares) {\n            this.middlewares = [middleware];\n        }\n        else {\n            this.middlewares.push(middleware);\n        }\n        return () => {\n            this.removeMiddleware(middleware);\n        };\n    }\n    applyPatchLocally(subpath, patch) {\n        this.assertWritable({\n            subpath\n        });\n        this.createObservableInstanceIfNeeded();\n        this.type.applyPatchLocally(this, subpath, patch);\n    }\n    _addSnapshotReaction() {\n        if (!this._hasSnapshotReaction) {\n            const snapshotDisposer = reaction(() => this.snapshot, snapshot => this.emitSnapshot(snapshot), snapshotReactionOptions);\n            this.addDisposer(snapshotDisposer);\n            this._hasSnapshotReaction = true;\n        }\n    }\n    // #region internal event handling\n    _internalEvents;\n    // we proxy the methods to avoid creating an EventHandlers instance when it is not needed\n    _internalEventsHasSubscribers(event) {\n        return !!this._internalEvents && this._internalEvents.hasSubscribers(event);\n    }\n    _internalEventsRegister(event, eventHandler, atTheBeginning = false) {\n        if (!this._internalEvents) {\n            this._internalEvents = new EventHandlers();\n        }\n        return this._internalEvents.register(event, eventHandler, atTheBeginning);\n    }\n    _internalEventsHas(event, eventHandler) {\n        return (!!this._internalEvents && this._internalEvents.has(event, eventHandler));\n    }\n    _internalEventsUnregister(event, eventHandler) {\n        if (this._internalEvents) {\n            this._internalEvents.unregister(event, eventHandler);\n        }\n    }\n    _internalEventsEmit(event, ...args) {\n        if (this._internalEvents) {\n            this._internalEvents.emit(event, ...args);\n        }\n    }\n    _internalEventsClear(event) {\n        if (this._internalEvents) {\n            this._internalEvents.clear(event);\n        }\n    }\n    _internalEventsClearAll() {\n        if (this._internalEvents) {\n            this._internalEvents.clearAll();\n        }\n    }\n}\nObjectNode.prototype.createObservableInstance = action(ObjectNode.prototype.createObservableInstance);\nObjectNode.prototype.detach = action(ObjectNode.prototype.detach);\nObjectNode.prototype.die = action(ObjectNode.prototype.die);\n\n// Cache for validation results to avoid re-validating the same object against the same type\n// Uses WeakMap so cached objects can be garbage collected\nconst validationCache = new WeakMap();\n/**\n * @internal\n * @hidden\n */\nvar TypeFlags;\n(function (TypeFlags) {\n    TypeFlags[TypeFlags[\"String\"] = 1] = \"String\";\n    TypeFlags[TypeFlags[\"Number\"] = 2] = \"Number\";\n    TypeFlags[TypeFlags[\"Boolean\"] = 4] = \"Boolean\";\n    TypeFlags[TypeFlags[\"Date\"] = 8] = \"Date\";\n    TypeFlags[TypeFlags[\"Literal\"] = 16] = \"Literal\";\n    TypeFlags[TypeFlags[\"Array\"] = 32] = \"Array\";\n    TypeFlags[TypeFlags[\"Map\"] = 64] = \"Map\";\n    TypeFlags[TypeFlags[\"Object\"] = 128] = \"Object\";\n    TypeFlags[TypeFlags[\"Frozen\"] = 256] = \"Frozen\";\n    TypeFlags[TypeFlags[\"Optional\"] = 512] = \"Optional\";\n    TypeFlags[TypeFlags[\"Reference\"] = 1024] = \"Reference\";\n    TypeFlags[TypeFlags[\"Identifier\"] = 2048] = \"Identifier\";\n    TypeFlags[TypeFlags[\"Late\"] = 4096] = \"Late\";\n    TypeFlags[TypeFlags[\"Refinement\"] = 8192] = \"Refinement\";\n    TypeFlags[TypeFlags[\"Union\"] = 16384] = \"Union\";\n    TypeFlags[TypeFlags[\"Null\"] = 32768] = \"Null\";\n    TypeFlags[TypeFlags[\"Undefined\"] = 65536] = \"Undefined\";\n    TypeFlags[TypeFlags[\"Integer\"] = 131072] = \"Integer\";\n    TypeFlags[TypeFlags[\"Custom\"] = 262144] = \"Custom\";\n    TypeFlags[TypeFlags[\"SnapshotProcessor\"] = 524288] = \"SnapshotProcessor\";\n    TypeFlags[TypeFlags[\"Lazy\"] = 1048576] = \"Lazy\";\n    TypeFlags[TypeFlags[\"Finite\"] = 2097152] = \"Finite\";\n    TypeFlags[TypeFlags[\"Float\"] = 4194304] = \"Float\";\n})(TypeFlags || (TypeFlags = {}));\n/**\n * @internal\n * @hidden\n */\nconst cannotDetermineSubtype = \"cannotDetermine\";\n/** @hidden */\nconst $type = Symbol(\"$type\");\n/**\n * A base type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nclass BaseType {\n    [$type];\n    // these are just to make inner types avaialable to inherited classes\n    C;\n    S;\n    T;\n    N;\n    isType = true;\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n    create(snapshot, environment) {\n        typecheckInternal(this, snapshot);\n        return this.instantiate(null, \"\", environment, snapshot).value;\n    }\n    getSnapshot(node, applyPostProcess) {\n        // istanbul ignore next\n        throw fail(\"unimplemented method\");\n    }\n    isAssignableFrom(type) {\n        return type === this;\n    }\n    validate(value, context) {\n        const node = getStateTreeNodeSafe(value);\n        if (node) {\n            const valueType = getType(value);\n            return this.isAssignableFrom(valueType)\n                ? typeCheckSuccess()\n                : typeCheckFailure(context, value);\n            // it is tempting to compare snapshots, but in that case we should always clone on assignments...\n        }\n        // check cache for object values (only at root level to avoid context mismatches)\n        if (typeof value === \"object\" && value !== null && context.length === 1) {\n            const typeCache = validationCache.get(value);\n            if (typeCache) {\n                const cached = typeCache.get(this);\n                if (cached !== undefined) {\n                    return cached;\n                }\n            }\n        }\n        const result = this.isValidSnapshot(value, context);\n        // cache result for object values (only at root level)\n        if (typeof value === \"object\" && value !== null && context.length === 1) {\n            let typeCache = validationCache.get(value);\n            if (!typeCache) {\n                typeCache = new WeakMap();\n                validationCache.set(value, typeCache);\n            }\n            typeCache.set(this, result);\n        }\n        return result;\n    }\n    is(thing) {\n        return this.validate(thing, [{ path: \"\", type: this }]).length === 0;\n    }\n    get Type() {\n        // istanbul ignore next\n        throw fail(\"Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`\");\n    }\n    get TypeWithoutSTN() {\n        // istanbul ignore next\n        throw fail(\"Factory.TypeWithoutSTN should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.TypeWithoutSTN`\");\n    }\n    get SnapshotType() {\n        // istanbul ignore next\n        throw fail(\"Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`\");\n    }\n    get CreationType() {\n        // istanbul ignore next\n        throw fail(\"Factory.CreationType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.CreationType`\");\n    }\n}\nBaseType.prototype.create = action(BaseType.prototype.create);\n/**\n * A complex type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nclass ComplexType extends BaseType {\n    identifierAttribute;\n    constructor(name) {\n        super(name);\n    }\n    create(snapshot = this.getDefaultSnapshot(), environment) {\n        return super.create(snapshot, environment);\n    }\n    getValue(node) {\n        node.createObservableInstanceIfNeeded();\n        return node.storedValue;\n    }\n    isMatchingSnapshotId(current, snapshot) {\n        return (!current.identifierAttribute ||\n            current.identifier ===\n                normalizeIdentifier(snapshot[current.identifierAttribute]));\n    }\n    tryToReconcileNode(current, newValue) {\n        if (current.isDetaching) {\n            return false;\n        }\n        if (current.snapshot === newValue) {\n            // newValue is the current snapshot of the node, noop\n            return true;\n        }\n        if (isStateTreeNode(newValue) && getStateTreeNode(newValue) === current) {\n            // the current node is the same as the new one\n            return true;\n        }\n        if (current.type === this &&\n            isMutable(newValue) &&\n            !isStateTreeNode(newValue) &&\n            this.isMatchingSnapshotId(current, newValue)) {\n            // the newValue has no node, so can be treated like a snapshot\n            // we can reconcile\n            current.applySnapshot(newValue);\n            return true;\n        }\n        return false;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const nodeReconciled = this.tryToReconcileNode(current, newValue);\n        if (nodeReconciled) {\n            current.setParent(parent, subpath);\n            return current;\n        }\n        // current node cannot be recycled in any way\n        current.die(); // noop if detaching\n        // attempt to reuse the new one\n        if (isStateTreeNode(newValue) && this.isAssignableFrom(getType(newValue))) {\n            // newValue is a Node as well, move it here..\n            const newNode = getStateTreeNode(newValue);\n            newNode.setParent(parent, subpath);\n            return newNode;\n        }\n        // nothing to do, we have to create a new node\n        return this.instantiate(parent, subpath, undefined, newValue);\n    }\n    getSubTypes() {\n        return null;\n    }\n}\nComplexType.prototype.create = action(ComplexType.prototype.create);\n/**\n * @internal\n * @hidden\n */\nclass SimpleType extends BaseType {\n    createNewInstance(snapshot) {\n        return snapshot;\n    }\n    getValue(node) {\n        // if we ever find a case where scalar nodes can be accessed without iterating through its parent\n        // uncomment this to make sure the parent chain is created when this is accessed\n        // if (node.parent) {\n        //     node.parent.createObservableInstanceIfNeeded()\n        // }\n        return node.storedValue;\n    }\n    getSnapshot(node) {\n        return node.storedValue;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        // reconcile only if type and value are still the same, and only if the node is not detaching\n        if (!current.isDetaching &&\n            current.type === this &&\n            current.storedValue === newValue) {\n            return current;\n        }\n        const res = this.instantiate(parent, subpath, undefined, newValue);\n        current.die(); // noop if detaching\n        return res;\n    }\n    getSubTypes() {\n        return null;\n    }\n}\n/**\n * Returns if a given value represents a type.\n *\n * @param value Value to check.\n * @returns `true` if the value is a type.\n */\nfunction isType(value) {\n    return typeof value === \"object\" && value && value.isType === true;\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsType(type, argNumber) {\n    assertArg(type, isType, \"mobx-state-tree type\", argNumber);\n}\n\nconst runningActions = new Map();\n/**\n * Note: Consider migrating to `createActionTrackingMiddleware2`, it is easier to use.\n *\n * Convenience utility to create action based middleware that supports async processes more easily.\n * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called\n *\n * The create middleware tracks the process of an action (assuming it passes the `filter`).\n * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware(hooks) {\n    return function actionTrackingMiddleware(call, next, abort) {\n        switch (call.type) {\n            case \"action\": {\n                if (!hooks.filter || hooks.filter(call) === true) {\n                    const context = hooks.onStart(call);\n                    hooks.onResume(call, context);\n                    runningActions.set(call.id, {\n                        call,\n                        context,\n                        async: false\n                    });\n                    try {\n                        const res = next(call);\n                        hooks.onSuspend(call, context);\n                        if (runningActions.get(call.id).async === false) {\n                            runningActions.delete(call.id);\n                            hooks.onSuccess(call, context, res);\n                        }\n                        return res;\n                    }\n                    catch (e) {\n                        runningActions.delete(call.id);\n                        hooks.onFail(call, context, e);\n                        throw e;\n                    }\n                }\n                else {\n                    return next(call);\n                }\n            }\n            case \"flow_spawn\": {\n                const root = runningActions.get(call.rootId);\n                root.async = true;\n                return next(call);\n            }\n            case \"flow_resume\":\n            case \"flow_resume_error\": {\n                const root = runningActions.get(call.rootId);\n                hooks.onResume(call, root.context);\n                try {\n                    return next(call);\n                }\n                finally {\n                    hooks.onSuspend(call, root.context);\n                }\n            }\n            case \"flow_throw\": {\n                const root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onFail(call, root.context, call.args[0]);\n                return next(call);\n            }\n            case \"flow_return\": {\n                const root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onSuccess(call, root.context, call.args[0]);\n                return next(call);\n            }\n        }\n    };\n}\n\nclass RunningAction {\n    hooks;\n    call;\n    flowsPending = 0;\n    running = true;\n    constructor(hooks, call) {\n        this.hooks = hooks;\n        this.call = call;\n        if (hooks) {\n            hooks.onStart(call);\n        }\n    }\n    finish(error) {\n        if (this.running) {\n            this.running = false;\n            if (this.hooks) {\n                this.hooks.onFinish(this.call, error);\n            }\n        }\n    }\n    incFlowsPending() {\n        this.flowsPending++;\n    }\n    decFlowsPending() {\n        this.flowsPending--;\n    }\n    get hasFlowsPending() {\n        return this.flowsPending > 0;\n    }\n}\n/**\n * Convenience utility to create action based middleware that supports async processes more easily.\n * The flow is like this:\n * - for each action: if filter passes -> `onStart` -> (inner actions recursively) -> `onFinish`\n *\n * Example: if we had an action `a` that called inside an action `b1`, then `b2` the flow would be:\n * - `filter(a)`\n * - `onStart(a)`\n *   - `filter(b1)`\n *   - `onStart(b1)`\n *   - `onFinish(b1)`\n *   - `filter(b2)`\n *   - `onStart(b2)`\n *   - `onFinish(b2)`\n * - `onFinish(a)`\n *\n * The flow is the same no matter if the actions are sync or async.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware2(middlewareHooks) {\n    const runningActions = new Map();\n    return function actionTrackingMiddleware(call, next) {\n        // find parentRunningAction\n        const parentRunningAction = call.parentActionEvent\n            ? runningActions.get(call.parentActionEvent.id)\n            : undefined;\n        if (call.type === \"action\") {\n            const newCall = {\n                ...call,\n                // make a shallow copy of the parent action env\n                env: parentRunningAction && parentRunningAction.call.env,\n                parentCall: parentRunningAction && parentRunningAction.call\n            };\n            const passesFilter = !middlewareHooks.filter || middlewareHooks.filter(newCall);\n            const hooks = passesFilter ? middlewareHooks : undefined;\n            const runningAction = new RunningAction(hooks, newCall);\n            runningActions.set(call.id, runningAction);\n            let res;\n            try {\n                res = next(call);\n            }\n            catch (e) {\n                runningActions.delete(call.id);\n                runningAction.finish(e);\n                throw e;\n            }\n            // sync action finished\n            if (!runningAction.hasFlowsPending) {\n                runningActions.delete(call.id);\n                runningAction.finish();\n            }\n            return res;\n        }\n        else {\n            if (!parentRunningAction) {\n                return next(call);\n            }\n            switch (call.type) {\n                case \"flow_spawn\": {\n                    parentRunningAction.incFlowsPending();\n                    return next(call);\n                }\n                case \"flow_resume\":\n                case \"flow_resume_error\": {\n                    return next(call);\n                }\n                case \"flow_throw\": {\n                    const error = call.args[0];\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            runningActions.delete(call.parentActionEvent.id);\n                            parentRunningAction.finish(error);\n                        }\n                    }\n                }\n                case \"flow_return\": {\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            runningActions.delete(call.parentActionEvent.id);\n                            parentRunningAction.finish();\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\n\nfunction serializeArgument(node, actionName, index, arg) {\n    if (arg instanceof Date) {\n        return { $MST_DATE: arg.getTime() };\n    }\n    if (isPrimitive(arg)) {\n        return arg;\n    }\n    // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an\n    // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot\n    if (isStateTreeNode(arg)) {\n        return serializeTheUnserializable(`[MSTNode: ${getType(arg).name}]`);\n    }\n    if (typeof arg === \"function\") {\n        return serializeTheUnserializable(`[function]`);\n    }\n    if (typeof arg === \"object\" && !isPlainObject(arg) && !isArray(arg)) {\n        return serializeTheUnserializable(`[object ${(arg && arg.constructor && arg.constructor.name) ||\n            \"Complex Object\"}]`);\n    }\n    try {\n        // Check if serializable, cycle free etc...\n        // MWE: there must be a better way....\n        JSON.stringify(arg); // or throws\n        return arg;\n    }\n    catch (e) {\n        return serializeTheUnserializable(\"\" + e);\n    }\n}\nfunction deserializeArgument(adm, value) {\n    if (value && typeof value === \"object\" && \"$MST_DATE\" in value) {\n        return new Date(value[\"$MST_DATE\"]);\n    }\n    return value;\n}\nfunction serializeTheUnserializable(baseType) {\n    return {\n        $MST_UNSERIALIZABLE: true,\n        type: baseType\n    };\n}\n/**\n * Applies an action or a series of actions in a single MobX transaction.\n * Does not return any value\n * Takes an action description as produced by the `onAction` middleware.\n *\n * @param target\n * @param actions\n */\nfunction applyAction(target, actions) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(actions, a => typeof a === \"object\", \"object or array\", 2);\n    runInAction(() => {\n        asArray(actions).forEach(action => baseApplyAction(target, action));\n    });\n}\nfunction baseApplyAction(target, action) {\n    const resolvedTarget = tryResolve(target, action.path || \"\");\n    if (!resolvedTarget) {\n        throw fail(`Invalid action path: ${action.path || \"\"}`);\n    }\n    const node = getStateTreeNode(resolvedTarget);\n    // Reserved functions\n    if (action.name === \"@APPLY_PATCHES\") {\n        return applyPatch.call(null, resolvedTarget, action.args[0]);\n    }\n    if (action.name === \"@APPLY_SNAPSHOT\") {\n        return applySnapshot.call(null, resolvedTarget, action.args[0]);\n    }\n    if (!(typeof resolvedTarget[action.name] === \"function\")) {\n        throw fail(`Action '${action.name}' does not exist in '${node.path}'`);\n    }\n    return resolvedTarget[action.name].apply(resolvedTarget, action.args ? action.args.map(v => deserializeArgument(node, v)) : []);\n}\n/**\n * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IActionRecorder {\n *      // the recorded actions\n *      actions: ISerializedActionCall[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording actions\n *      stop(): void\n *      // resume recording actions\n *      resume(): void\n *      // apply all the recorded actions on the given object\n *      replay(target: IAnyStateTreeNode): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain actions.\n *\n * @param subject\n * @returns\n */\nfunction recordActions(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    const actions = [];\n    const listener = (call) => {\n        const recordThis = filter ? filter(call, getRunningActionContext()) : true;\n        if (recordThis) {\n            actions.push(call);\n        }\n    };\n    let disposer;\n    const recorder = {\n        actions,\n        get recording() {\n            return !!disposer;\n        },\n        stop() {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume() {\n            if (disposer) {\n                return;\n            }\n            disposer = onAction(subject, listener);\n        },\n        replay(target) {\n            applyAction(target, actions);\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.\n * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.\n * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.\n *\n * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: \"someType\" }` will be generated.\n * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).\n * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * }).actions(self => ({\n *   add(todo) {\n *     self.todos.push(todo);\n *   }\n * }))\n *\n * const s = TodoStore.create({ todos: [] })\n *\n * let disposer = onAction(s, (call) => {\n *   console.log(call);\n * })\n *\n * s.add({ task: \"Grab a coffee\" })\n * // Logs: { name: \"add\", path: \"\", args: [{ task: \"Grab a coffee\" }] }\n * ```\n *\n * @param target\n * @param listener\n * @param attachAfter (default false) fires the listener *after* the action has executed instead of before.\n * @returns\n */\nfunction onAction(target, listener, attachAfter = false) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    if (devMode()) {\n        if (!isRoot(target)) {\n            warnError(\"Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.\");\n        }\n        if (!isProtected(target)) {\n            warnError(\"Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.\");\n        }\n    }\n    return addMiddleware(target, function handler(rawCall, next) {\n        if (rawCall.type === \"action\" && rawCall.id === rawCall.rootId) {\n            const sourceNode = getStateTreeNode(rawCall.context);\n            const info = {\n                name: rawCall.name,\n                path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode),\n                args: rawCall.args.map((arg, index) => serializeArgument(sourceNode, rawCall.name, index, arg))\n            };\n            if (attachAfter) {\n                const res = next(rawCall);\n                listener(info);\n                return res;\n            }\n            else {\n                listener(info);\n                return next(rawCall);\n            }\n        }\n        else {\n            return next(rawCall);\n        }\n    });\n}\n\nlet nextActionId = 1;\nlet currentActionContext;\n/**\n * @internal\n * @hidden\n */\nfunction getCurrentActionContext() {\n    return currentActionContext;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getNextActionId() {\n    return nextActionId++;\n}\n// TODO: optimize away entire action context if there is no middleware in tree?\n/**\n * @internal\n * @hidden\n */\nfunction runWithActionContext(context, fn) {\n    const node = getStateTreeNode(context.context);\n    if (context.type === \"action\") {\n        node.assertAlive({\n            actionContext: context\n        });\n    }\n    const baseIsRunningAction = node._isRunningAction;\n    node._isRunningAction = true;\n    const previousContext = currentActionContext;\n    currentActionContext = context;\n    try {\n        return runMiddleWares(node, context, fn);\n    }\n    finally {\n        currentActionContext = previousContext;\n        node._isRunningAction = baseIsRunningAction;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction getParentActionContext(parentContext) {\n    if (!parentContext) {\n        return undefined;\n    }\n    if (parentContext.type === \"action\") {\n        return parentContext;\n    }\n    return parentContext.parentActionEvent;\n}\n/**\n * @internal\n * @hidden\n */\nfunction createActionInvoker(target, name, fn) {\n    const res = function () {\n        const id = getNextActionId();\n        const parentContext = currentActionContext;\n        const parentActionContext = getParentActionContext(parentContext);\n        return runWithActionContext({\n            type: \"action\",\n            name,\n            id,\n            args: argsToArray(arguments),\n            context: target,\n            tree: getRoot(target),\n            rootId: parentContext ? parentContext.rootId : id,\n            parentId: parentContext ? parentContext.id : 0,\n            allParentIds: parentContext\n                ? [...parentContext.allParentIds, parentContext.id]\n                : [],\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        }, fn);\n    };\n    res._isMSTAction = true;\n    res._isFlowAction = fn._isFlowAction;\n    return res;\n}\n/**\n * Middleware can be used to intercept any action is invoked on the subtree where it is attached.\n * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.\n *\n * For more details, see the [middleware docs](concepts/middleware.md)\n *\n * @param target Node to apply the middleware to.\n * @param middleware Middleware to apply.\n * @returns A callable function to dispose the middleware.\n */\nfunction addMiddleware(target, handler, includeHooks = true) {\n    const node = getStateTreeNode(target);\n    if (devMode()) {\n        if (!node.isProtectionEnabled) {\n            warnError(\"It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`\");\n        }\n    }\n    return node.addMiddleWare(handler, includeHooks);\n}\n/**\n * Binds middleware to a specific action.\n *\n * Example:\n * ```ts\n * type.actions(self => {\n *   function takeA____() {\n *       self.toilet.donate()\n *       self.wipe()\n *       self.wipe()\n *       self.toilet.flush()\n *   }\n *   return {\n *     takeA____: decorate(atomic, takeA____)\n *   }\n * })\n * ```\n *\n * @param handler\n * @param fn\n * @param includeHooks\n * @returns The original function\n */\nfunction decorate(handler, fn, includeHooks = true) {\n    const middleware = { handler, includeHooks };\n    fn.$mst_middleware = fn.$mst_middleware || [];\n    fn.$mst_middleware.push(middleware);\n    return fn;\n}\nclass CollectedMiddlewares {\n    arrayIndex = 0;\n    inArrayIndex = 0;\n    middlewares = [];\n    constructor(node, fn) {\n        // we just push middleware arrays into an array of arrays to avoid making copies\n        if (fn.$mst_middleware) {\n            this.middlewares.push(fn.$mst_middleware);\n        }\n        let n = node;\n        // Find all middlewares. Optimization: cache this?\n        while (n) {\n            if (n.middlewares) {\n                this.middlewares.push(n.middlewares);\n            }\n            n = n.parent;\n        }\n    }\n    get isEmpty() {\n        return this.middlewares.length <= 0;\n    }\n    getNextMiddleware() {\n        const array = this.middlewares[this.arrayIndex];\n        if (!array) {\n            return undefined;\n        }\n        const item = array[this.inArrayIndex++];\n        if (!item) {\n            this.arrayIndex++;\n            this.inArrayIndex = 0;\n            return this.getNextMiddleware();\n        }\n        return item;\n    }\n}\nfunction runMiddleWares(node, baseCall, originalFn) {\n    const middlewares = new CollectedMiddlewares(node, originalFn);\n    // Short circuit\n    if (middlewares.isEmpty) {\n        return action(originalFn).apply(null, baseCall.args);\n    }\n    let result = null;\n    function runNextMiddleware(call) {\n        const middleware = middlewares.getNextMiddleware();\n        const handler = middleware && middleware.handler;\n        if (!handler) {\n            return action(originalFn).apply(null, call.args);\n        }\n        // skip hooks if asked to\n        if (!middleware.includeHooks && Hook[call.name]) {\n            return runNextMiddleware(call);\n        }\n        let nextInvoked = false;\n        function next(call2, callback) {\n            nextInvoked = true;\n            // the result can contain\n            // - the non manipulated return value from an action\n            // - the non manipulated abort value\n            // - one of the above but manipulated through the callback function\n            result = runNextMiddleware(call2);\n            if (callback) {\n                result = callback(result);\n            }\n        }\n        let abortInvoked = false;\n        function abort(value) {\n            abortInvoked = true;\n            // overwrite the result\n            // can be manipulated through middlewares earlier in the queue using the callback fn\n            result = value;\n        }\n        handler(call, next, abort);\n        if (devMode()) {\n            if (!nextInvoked && !abortInvoked) {\n                const node2 = getStateTreeNode(call.tree);\n                throw fail(`Neither the next() nor the abort() callback within the middleware ${handler.name} for the action: \"${call.name}\" on the node: ${node2.type.name} was invoked.`);\n            }\n            else if (nextInvoked && abortInvoked) {\n                const node2 = getStateTreeNode(call.tree);\n                throw fail(`The next() and abort() callback within the middleware ${handler.name} for the action: \"${call.name}\" on the node: ${node2.type.name} were invoked.`);\n            }\n        }\n        return result;\n    }\n    return runNextMiddleware(baseCall);\n}\n\n/**\n * Returns the currently executing MST action context, or undefined if none.\n */\nfunction getRunningActionContext() {\n    let current = getCurrentActionContext();\n    while (current && current.type !== \"action\") {\n        current = current.parentActionEvent;\n    }\n    return current;\n}\nfunction _isActionContextThisOrChildOf(actionContext, sameOrParent, includeSame) {\n    const parentId = typeof sameOrParent === \"number\" ? sameOrParent : sameOrParent.id;\n    let current = includeSame\n        ? actionContext\n        : actionContext.parentActionEvent;\n    while (current) {\n        if (current.id === parentId) {\n            return true;\n        }\n        current = current.parentActionEvent;\n    }\n    return false;\n}\n/**\n * Returns if the given action context is a parent of this action context.\n */\nfunction isActionContextChildOf(actionContext, parent) {\n    return _isActionContextThisOrChildOf(actionContext, parent, false);\n}\n/**\n * Returns if the given action context is this or a parent of this action context.\n */\nfunction isActionContextThisOrChildOf(actionContext, parentOrThis) {\n    return _isActionContextThisOrChildOf(actionContext, parentOrThis, true);\n}\n\nfunction safeStringify(value) {\n    try {\n        return JSON.stringify(value);\n    }\n    catch (e) {\n        // istanbul ignore next\n        return `<Unserializable: ${e}>`;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction prettyPrintValue(value) {\n    return typeof value === \"function\"\n        ? `<function${value.name ? \" \" + value.name : \"\"}>`\n        : isStateTreeNode(value)\n            ? `<${value}>`\n            : `\\`${safeStringify(value)}\\``;\n}\nfunction shortenPrintValue(valueInString) {\n    return valueInString.length < 280\n        ? valueInString\n        : `${valueInString.substring(0, 272)}......${valueInString.substring(valueInString.length - 8)}`;\n}\nfunction toErrorString(error) {\n    const { value } = error;\n    const type = error.context[error.context.length - 1].type;\n    const fullPath = error.context\n        .map(({ path }) => path)\n        .filter(path => path.length > 0)\n        .join(\"/\");\n    const pathPrefix = fullPath.length > 0 ? `at path \"/${fullPath}\" ` : ``;\n    const currentTypename = isStateTreeNode(value)\n        ? `value of type ${getStateTreeNode(value).type.name}:`\n        : isPrimitive(value)\n            ? \"value\"\n            : \"snapshot\";\n    const isSnapshotCompatible = type && isStateTreeNode(value) && type.is(getStateTreeNode(value).snapshot);\n    return (`${pathPrefix}${currentTypename} ${prettyPrintValue(value)} is not assignable ${type ? `to type: \\`${type.name}\\`` : ``}` +\n        (error.message ? ` (${error.message})` : \"\") +\n        (type\n            ? isPrimitiveType(type) || isPrimitive(value)\n                ? `.`\n                : `, expected an instance of \\`${type.name}\\` or a snapshot like \\`${type.describe()}\\` instead.` +\n                    (isSnapshotCompatible\n                        ? \" (Note that a snapshot of the provided value is compatible with the targeted type)\"\n                        : \"\")\n            : `.`));\n}\n/**\n * @internal\n * @hidden\n * Pushes a new entry onto the context array (mutates in place for performance).\n * Returns the same context array for chaining.\n */\nfunction getContextForPath(context, path, type) {\n    context.push({ path, type });\n    return context;\n}\n/**\n * @internal\n * @hidden\n * Pops the last entry from the context array (mutates in place).\n * Must be called after validation to restore context state.\n */\nfunction popContext(context) {\n    context.pop();\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckSuccess() {\n    return EMPTY_ARRAY;\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckFailure(context, value, message) {\n    // Clone context since it may be mutated after this error is created\n    return [{ context: context.slice(), value, message }];\n}\n/**\n * @internal\n * @hidden\n */\nfunction flattenTypeErrors(errors) {\n    return errors.flat();\n}\n// TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change\n/**\n * @internal\n * @hidden\n */\nfunction typecheckInternal(type, value) {\n    // runs typeChecking if it is in dev-mode or through a process.env.ENABLE_TYPE_CHECK flag\n    if (isTypeCheckingEnabled()) {\n        typecheck(type, value);\n    }\n}\n/**\n * Run's the typechecker for the given type on the given value, which can be a snapshot or an instance.\n * Throws if the given value is not according the provided type specification.\n * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)\n *\n * @param type Type to check against.\n * @param value Value to be checked, either a snapshot or an instance.\n */\nfunction typecheck(type, value) {\n    const errors = type.validate(value, [{ path: \"\", type }]);\n    if (errors.length > 0) {\n        throw fail(validationErrorsToString(type, value, errors));\n    }\n}\nfunction validationErrorsToString(type, value, errors) {\n    if (errors.length === 0) {\n        return undefined;\n    }\n    return (`Error while converting ${shortenPrintValue(prettyPrintValue(value))} to \\`${type.name}\\`:\\n\\n    ` + errors.map(toErrorString).join(\"\\n    \"));\n}\n\nlet identifierCacheId = 0;\n/**\n * @internal\n * @hidden\n */\nclass IdentifierCache {\n    cacheId = identifierCacheId++;\n    // n.b. in cache all identifiers are normalized to strings\n    cache = observable.map();\n    // last time the cache (array) for a given time changed\n    // n.b. it is not really the time, but just an integer that gets increased after each modification to the array\n    lastCacheModificationPerId = observable.map();\n    constructor() { }\n    updateLastCacheModificationPerId(identifier) {\n        const lcm = this.lastCacheModificationPerId.get(identifier);\n        // we start at 1 since 0 means no update since cache creation\n        this.lastCacheModificationPerId.set(identifier, lcm === undefined ? 1 : lcm + 1);\n    }\n    getLastCacheModificationPerId(identifier) {\n        const modificationId = this.lastCacheModificationPerId.get(identifier) || 0;\n        return `${this.cacheId}-${modificationId}`;\n    }\n    addNodeToCache(node, lastCacheUpdate = true) {\n        if (node.identifierAttribute) {\n            const identifier = node.identifier;\n            if (!this.cache.has(identifier)) {\n                this.cache.set(identifier, observable.array([], mobxShallow));\n            }\n            const set = this.cache.get(identifier);\n            if (set.indexOf(node) !== -1) {\n                throw fail(`Already registered`);\n            }\n            set.push(node);\n            if (lastCacheUpdate) {\n                this.updateLastCacheModificationPerId(identifier);\n            }\n        }\n    }\n    mergeCache(node) {\n        values(node.identifierCache.cache).forEach(nodes => nodes.forEach(child => {\n            this.addNodeToCache(child);\n        }));\n    }\n    notifyDied(node) {\n        if (node.identifierAttribute) {\n            const id = node.identifier;\n            const set = this.cache.get(id);\n            if (set) {\n                set.remove(node);\n                // remove empty sets from cache\n                if (!set.length) {\n                    this.cache.delete(id);\n                }\n                this.updateLastCacheModificationPerId(node.identifier);\n            }\n        }\n    }\n    splitCache(splitNode) {\n        const newCache = new IdentifierCache();\n        // The slash is added here so we only match children of the splitNode. In version 5.1.8 and\n        // earlier there was no trailing slash, so non children that started with the same path string\n        // were being matched incorrectly.\n        const basePath = splitNode.path + \"/\";\n        entries(this.cache).forEach(([id, nodes]) => {\n            let modified = false;\n            for (let i = nodes.length - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (node === splitNode || node.path.indexOf(basePath) === 0) {\n                    newCache.addNodeToCache(node, false); // no need to update lastUpdated since it is a whole new cache\n                    nodes.splice(i, 1);\n                    // remove empty sets from cache\n                    if (!nodes.length) {\n                        this.cache.delete(id);\n                    }\n                    modified = true;\n                }\n            }\n            if (modified) {\n                this.updateLastCacheModificationPerId(id);\n            }\n        });\n        return newCache;\n    }\n    has(type, identifier) {\n        const set = this.cache.get(identifier);\n        if (!set) {\n            return false;\n        }\n        return set.some(candidate => type.isAssignableFrom(candidate.type));\n    }\n    resolve(type, identifier) {\n        const set = this.cache.get(identifier);\n        if (!set) {\n            return null;\n        }\n        const matches = set.filter(candidate => type.isAssignableFrom(candidate.type));\n        switch (matches.length) {\n            case 0:\n                return null;\n            case 1:\n                return matches[0];\n            default:\n                throw fail(`Cannot resolve a reference to type '${type.name}' with id: '${identifier}' unambigously, there are multiple candidates: ${matches\n                    .map(n => n.path)\n                    .join(\", \")}`);\n        }\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction createObjectNode(type, parent, subpath, environment, initialValue) {\n    const existingNode = getStateTreeNodeSafe(initialValue);\n    if (existingNode) {\n        if (existingNode.parent) {\n            // istanbul ignore next\n            throw fail(`Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '${parent ? parent.path : \"\"}/${subpath}', but it lives already at '${existingNode.path}'`);\n        }\n        if (parent) {\n            existingNode.setParent(parent, subpath);\n        }\n        // else it already has no parent since it is a pre-requisite\n        return existingNode;\n    }\n    // not a node, a snapshot\n    return new ObjectNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction createScalarNode(type, parent, subpath, environment, initialValue) {\n    return new ScalarNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction isNode(value) {\n    return value instanceof ScalarNode || value instanceof ObjectNode;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar NodeLifeCycle;\n(function (NodeLifeCycle) {\n    NodeLifeCycle[NodeLifeCycle[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n    NodeLifeCycle[NodeLifeCycle[\"CREATED\"] = 1] = \"CREATED\";\n    NodeLifeCycle[NodeLifeCycle[\"FINALIZED\"] = 2] = \"FINALIZED\";\n    NodeLifeCycle[NodeLifeCycle[\"DETACHING\"] = 3] = \"DETACHING\";\n    NodeLifeCycle[NodeLifeCycle[\"DEAD\"] = 4] = \"DEAD\"; // no coming back from this one\n})(NodeLifeCycle || (NodeLifeCycle = {}));\n/**\n * Returns true if the given value is a node in a state tree.\n * More precisely, that is, if the value is an instance of a\n * `types.model`, `types.array` or `types.map`.\n *\n * @param value\n * @returns true if the value is a state tree node.\n */\nfunction isStateTreeNode(value) {\n    return !!(value && value.$treenode);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsStateTreeNode(value, argNumber) {\n    assertArg(value, isStateTreeNode, \"mobx-state-tree node\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNode(value) {\n    if (!isStateTreeNode(value)) {\n        // istanbul ignore next\n        throw fail(`Value ${value} is no MST Node`);\n    }\n    return value.$treenode;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNodeSafe(value) {\n    return (value && value.$treenode) || null;\n}\n/**\n * @internal\n * @hidden\n */\nfunction toJSON() {\n    return getStateTreeNode(this).snapshot;\n}\nconst doubleDot = (_) => \"..\";\n/**\n * @internal\n * @hidden\n */\nfunction getRelativePathBetweenNodes(base, target) {\n    // PRE condition target is (a child of) base!\n    if (base.root !== target.root) {\n        throw fail(`Cannot calculate relative path: objects '${base}' and '${target}' are not part of the same object tree`);\n    }\n    const baseParts = splitJsonPath(base.path);\n    const targetParts = splitJsonPath(target.path);\n    let common = 0;\n    for (; common < baseParts.length; common++) {\n        if (baseParts[common] !== targetParts[common]) {\n            break;\n        }\n    }\n    // TODO: assert that no targetParts paths are \"..\", \".\" or \"\"!\n    return (baseParts.slice(common).map(doubleDot).join(\"/\") +\n        joinJsonPath(targetParts.slice(common)));\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPath(base, path, failIfResolveFails = true) {\n    return resolveNodeByPathParts(base, splitJsonPath(path), failIfResolveFails);\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPathParts(base, pathParts, failIfResolveFails = true) {\n    let current = base;\n    try {\n        for (let i = 0; i < pathParts.length; i++) {\n            const part = pathParts[i];\n            if (part === \"..\") {\n                current = current.parent;\n                if (current) {\n                    continue;\n                } // not everything has a parent\n            }\n            else if (part === \".\") {\n                continue;\n            }\n            else if (current) {\n                if (current instanceof ScalarNode) {\n                    // check if the value of a scalar resolves to a state tree node (e.g. references)\n                    // then we can continue resolving...\n                    const value = current.value;\n                    if (isStateTreeNode(value)) {\n                        current = getStateTreeNode(value);\n                        // fall through\n                    }\n                }\n                if (current instanceof ObjectNode) {\n                    const subType = current.getChildType(part);\n                    if (subType) {\n                        current = current.getChildNode(part);\n                        if (current) {\n                            continue;\n                        }\n                    }\n                }\n            }\n            throw fail(`Could not resolve '${part}' in path '${joinJsonPath(pathParts.slice(0, i)) || \"/\"}' while resolving '${joinJsonPath(pathParts)}'`);\n        }\n    }\n    catch (e) {\n        if (!failIfResolveFails) {\n            return undefined;\n        }\n        throw e;\n    }\n    return current;\n}\n/**\n * @internal\n * @hidden\n */\nfunction convertChildNodesToArray(childNodes) {\n    if (!childNodes) {\n        return EMPTY_ARRAY;\n    }\n    const keys = Object.keys(childNodes);\n    if (!keys.length) {\n        return EMPTY_ARRAY;\n    }\n    const result = new Array(keys.length);\n    keys.forEach((key, index) => {\n        result[index] = childNodes[key];\n    });\n    return result;\n}\n\n// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n/*\n    All contents of this file are deprecated.\n\n    The term `process` has been replaced with `flow` to avoid conflicts with the\n    global `process` object.\n\n    Refer to `flow.ts` for any further changes to this implementation.\n*/\nconst DEPRECATION_MESSAGE = \"See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. \" +\n    \"Note that the middleware event types starting with `process` now start with `flow`.\";\n/**\n * @hidden\n *\n * @deprecated has been renamed to `flow()`.\n * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.\n * Note that the middleware event types starting with `process` now start with `flow`.\n *\n * @returns {Promise}\n */\nfunction process$1(asyncAction) {\n    deprecated(\"process\", \"`process()` has been renamed to `flow()`. \" + DEPRECATION_MESSAGE);\n    return flow(asyncAction);\n}\n\nconst plainObjectString = Object.toString();\n/**\n * @internal\n * @hidden\n */\nconst EMPTY_ARRAY = Object.freeze([]);\n/**\n * @internal\n * @hidden\n */\nconst EMPTY_OBJECT = Object.freeze({});\n/**\n * @internal\n * @hidden\n */\nconst mobxShallow = _getGlobalState().useProxies\n    ? { deep: false }\n    : { deep: false, proxy: false };\nObject.freeze(mobxShallow);\n/**\n * @internal\n * @hidden\n */\nfunction fail(message = \"Illegal state\") {\n    return new Error(\"[mobx-state-tree] \" + message);\n}\n/**\n * @internal\n * @hidden\n */\nfunction identity(_) {\n    return _;\n}\n/**\n * @internal\n * @hidden\n */\nconst isInteger = Number.isInteger;\n/**\n * @internal\n * @hidden\n */\nfunction isFloat(val) {\n    return Number(val) === val && val % 1 !== 0;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isFinite(val) {\n    return Number.isFinite(val);\n}\n/**\n * @internal\n * @hidden\n */\nfunction isArray(val) {\n    return Array.isArray(val) || isObservableArray(val);\n}\n/**\n * @internal\n * @hidden\n */\nfunction asArray(val) {\n    if (!val) {\n        return EMPTY_ARRAY;\n    }\n    if (isArray(val)) {\n        return val;\n    }\n    return [val];\n}\n/**\n * @internal\n * @hidden\n */\nfunction extend(a, ...b) {\n    for (let i = 0; i < b.length; i++) {\n        const current = b[i];\n        for (const key in current) {\n            a[key] = current[key];\n        }\n    }\n    return a;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPlainObject(value) {\n    if (value === null || typeof value !== \"object\") {\n        return false;\n    }\n    const proto = Object.getPrototypeOf(value);\n    if (proto == null) {\n        return true;\n    }\n    return proto.constructor?.toString() === plainObjectString;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isMutable(value) {\n    return (value !== null &&\n        typeof value === \"object\" &&\n        !(value instanceof Date) &&\n        !(value instanceof RegExp));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPrimitive(value, includeDate = true) {\n    return (value === null ||\n        value === undefined ||\n        typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\" ||\n        (includeDate && value instanceof Date));\n}\n/**\n * @internal\n * @hidden\n * Freeze a value and return it (if not in production)\n */\nfunction freeze(value) {\n    if (!devMode()) {\n        return value;\n    }\n    return isPrimitive(value) || isObservableArray(value)\n        ? value\n        : Object.freeze(value);\n}\n/**\n * @internal\n * @hidden\n * Recursively freeze a value (if not in production)\n */\nfunction deepFreeze(value) {\n    if (!devMode()) {\n        return value;\n    }\n    freeze(value);\n    if (isPlainObject(value)) {\n        Object.keys(value).forEach(propKey => {\n            if (!isPrimitive(value[propKey]) &&\n                !Object.isFrozen(value[propKey])) {\n                deepFreeze(value[propKey]);\n            }\n        });\n    }\n    return value;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isSerializable(value) {\n    return typeof value !== \"function\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction defineProperty(object, key, descriptor) {\n    isObservableObject(object)\n        ? defineProperty$1(object, key, descriptor)\n        : Object.defineProperty(object, key, descriptor);\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenFinalProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenWritableProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nclass EventHandler {\n    handlers = [];\n    emitting = false;\n    pendingUnregisters = null;\n    get hasSubscribers() {\n        return this.handlers.length > 0;\n    }\n    register(fn, atTheBeginning = false) {\n        if (atTheBeginning) {\n            this.handlers.unshift(fn);\n        }\n        else {\n            this.handlers.push(fn);\n        }\n        return () => {\n            this.unregister(fn);\n        };\n    }\n    has(fn) {\n        return this.handlers.indexOf(fn) >= 0;\n    }\n    unregister(fn) {\n        if (this.emitting) {\n            // defer unregistration until emit is done\n            if (!this.pendingUnregisters) {\n                this.pendingUnregisters = [];\n            }\n            this.pendingUnregisters.push(fn);\n            return;\n        }\n        const index = this.handlers.indexOf(fn);\n        if (index >= 0) {\n            this.handlers.splice(index, 1);\n        }\n    }\n    clear() {\n        this.handlers.length = 0;\n    }\n    emit(...args) {\n        // use emitting flag to defer unregistrations instead of copying array\n        this.emitting = true;\n        try {\n            for (const f of this.handlers) {\n                f(...args);\n            }\n        }\n        finally {\n            this.emitting = false;\n            // process any deferred unregistrations\n            if (this.pendingUnregisters) {\n                for (const fn of this.pendingUnregisters) {\n                    const index = this.handlers.indexOf(fn);\n                    if (index >= 0) {\n                        this.handlers.splice(index, 1);\n                    }\n                }\n                this.pendingUnregisters = null;\n            }\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass EventHandlers {\n    eventHandlers;\n    hasSubscribers(event) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        return !!handler && handler.hasSubscribers;\n    }\n    register(event, fn, atTheBeginning = false) {\n        if (!this.eventHandlers) {\n            this.eventHandlers = {};\n        }\n        let handler = this.eventHandlers[event];\n        if (!handler) {\n            handler = this.eventHandlers[event] = new EventHandler();\n        }\n        return handler.register(fn, atTheBeginning);\n    }\n    has(event, fn) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        return !!handler && handler.has(fn);\n    }\n    unregister(event, fn) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        if (handler) {\n            handler.unregister(fn);\n        }\n    }\n    clear(event) {\n        if (this.eventHandlers) {\n            delete this.eventHandlers[event];\n        }\n    }\n    clearAll() {\n        this.eventHandlers = undefined;\n    }\n    emit(event, ...args) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        if (handler) {\n            handler.emit(...args);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction argsToArray(args) {\n    const res = new Array(args.length);\n    for (let i = 0; i < args.length; i++) {\n        res[i] = args[i];\n    }\n    return res;\n}\n/**\n * @internal\n * @hidden\n */\nfunction stringStartsWith(str, beginning) {\n    return str.indexOf(beginning) === 0;\n}\n/**\n * @internal\n * @hidden\n */\nconst deprecated = function (id, message) {\n    // skip if running production\n    if (!devMode()) {\n        return;\n    }\n    // warn if hasn't been warned before\n    if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {\n        warnError(\"Deprecation warning: \" + message);\n    }\n    // mark as warned to avoid duplicate warn message\n    if (deprecated.ids) {\n        deprecated.ids[id] = true;\n    }\n};\ndeprecated.ids = {};\n/**\n * @internal\n * @hidden\n */\nfunction warnError(msg) {\n    console.warn(new Error(`[mobx-state-tree] ${msg}`));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isTypeCheckingEnabled() {\n    return (devMode() ||\n        (typeof process !== \"undefined\" &&\n            process.env &&\n            process.env.ENABLE_TYPE_CHECK === \"true\"));\n}\nlet _devMode = process.env.NODE_ENV !== \"production\";\n/**\n * @internal\n * @hidden\n */\nfunction devMode() {\n    return _devMode;\n}\n/**\n * @internal\n * @hidden\n */\nfunction setDevMode(value) {\n    _devMode = value;\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertArg(value, fn, typeName, argNumber) {\n    if (devMode()) {\n        if (!fn(value)) {\n            // istanbul ignore next\n            throw fail(`expected ${typeName} as argument ${asArray(argNumber).join(\" or \")}, got ${value} instead`);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsFunction(value, argNumber) {\n    assertArg(value, fn => typeof fn === \"function\", \"function\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsNumber(value, argNumber, min, max) {\n    assertArg(value, n => typeof n === \"number\", \"number\", argNumber);\n    {\n        assertArg(value, n => n >= min, `number greater than ${min}`, argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsString(value, argNumber, canBeEmpty = true) {\n    assertArg(value, s => typeof s === \"string\", \"string\", argNumber);\n    if (!canBeEmpty) {\n        assertArg(value, s => s !== \"\", \"not empty string\", argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction setImmediateWithFallback(fn) {\n    if (typeof queueMicrotask === \"function\") {\n        queueMicrotask(fn);\n    }\n    else if (typeof setImmediate === \"function\") {\n        setImmediate(fn);\n    }\n    else {\n        setTimeout(fn, 1);\n    }\n}\n\n/**\n * See [asynchronous actions](concepts/async-actions.md).\n *\n * @returns The flow as a promise.\n */\nfunction flow(generator) {\n    return createFlowSpawner(generator.name, generator);\n}\n/**\n * @deprecated Not needed since TS3.6.\n * Used for TypeScript to make flows that return a promise return the actual promise result.\n *\n * @param val\n * @returns\n */\nfunction castFlowReturn(val) {\n    return val;\n}\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise-returning function to a generator-returning one.\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n * const getDataGen = toGeneratorFunction(getDataAsync);\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* getDataGen(\"input value\");\n *     ...\n *   })\n * }))\n * ```\n */\nfunction toGeneratorFunction(p) {\n    return function* (...args) {\n        return (yield p(...args));\n    };\n}\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise to a generator yielding that promise\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* toGenerator(getDataAsync(\"input value\"));\n *     ...\n *   })\n * }))\n * ```\n */\nfunction* toGenerator(p) {\n    return (yield p);\n}\n/**\n * @internal\n * @hidden\n */\nfunction createFlowSpawner(name, generator) {\n    const spawner = function flowSpawner() {\n        // Implementation based on https://github.com/tj/co/blob/master/index.js\n        const runId = getNextActionId();\n        const parentContext = getCurrentActionContext();\n        if (!parentContext) {\n            throw fail(\"a mst flow must always have a parent context\");\n        }\n        const parentActionContext = getParentActionContext(parentContext);\n        if (!parentActionContext) {\n            throw fail(\"a mst flow must always have a parent action context\");\n        }\n        const contextBase = {\n            name,\n            id: runId,\n            tree: parentContext.tree,\n            context: parentContext.context,\n            parentId: parentContext.id,\n            allParentIds: [...parentContext.allParentIds, parentContext.id],\n            rootId: parentContext.rootId,\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        };\n        const args = arguments;\n        function wrap(fn, type, arg) {\n            fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow\n            return runWithActionContext({\n                ...contextBase,\n                type,\n                args: [arg]\n            }, fn);\n        }\n        return new Promise(function (resolve, reject) {\n            let gen;\n            const init = function asyncActionInit() {\n                gen = generator.apply(null, arguments);\n                onFulfilled(undefined); // kick off the flow\n            };\n            init.$mst_middleware = spawner.$mst_middleware;\n            runWithActionContext({\n                ...contextBase,\n                type: \"flow_spawn\",\n                args: argsToArray(args)\n            }, init);\n            function onFulfilled(res) {\n                let ret;\n                try {\n                    // prettier-ignore\n                    const cancelError = wrap((r) => { ret = gen.next(r); }, \"flow_resume\", res);\n                    if (cancelError instanceof Error) {\n                        ret = gen.throw(cancelError);\n                    }\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n                return;\n            }\n            function onRejected(err) {\n                let ret;\n                try {\n                    // prettier-ignore\n                    wrap((r) => { ret = gen.throw(r); }, \"flow_resume_error\", err); // or yieldError?\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (ret.done) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { resolve(r); }, \"flow_return\", ret.value);\n                    });\n                    return;\n                }\n                // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100\n                if (!ret.value || typeof ret.value.then !== \"function\") {\n                    // istanbul ignore next\n                    throw fail(\"Only promises can be yielded to `async`, got: \" + ret);\n                }\n                return ret.value.then(onFulfilled, onRejected);\n            }\n        });\n    };\n    spawner._isFlowAction = true;\n    return spawner;\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction splitPatch(patch) {\n    if (!(\"oldValue\" in patch)) {\n        throw fail(`Patches without \\`oldValue\\` field cannot be inversed`);\n    }\n    return [stripPatch(patch), invertPatch(patch)];\n}\n/**\n * @internal\n * @hidden\n */\nfunction stripPatch(patch) {\n    // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec\n    // this removes the ability to undo the patch\n    switch (patch.op) {\n        case \"add\":\n            return { op: \"add\", path: patch.path, value: patch.value };\n        case \"remove\":\n            return { op: \"remove\", path: patch.path };\n        case \"replace\":\n            return { op: \"replace\", path: patch.path, value: patch.value };\n    }\n}\nfunction invertPatch(patch) {\n    switch (patch.op) {\n        case \"add\":\n            return {\n                op: \"remove\",\n                path: patch.path\n            };\n        case \"remove\":\n            return {\n                op: \"add\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n        case \"replace\":\n            return {\n                op: \"replace\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n    }\n}\n/**\n * Simple simple check to check it is a number.\n */\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\n/**\n * Escape slashes and backslashes.\n *\n * http://tools.ietf.org/html/rfc6901\n */\nfunction escapeJsonPath(path) {\n    if (isNumber(path) === true) {\n        return \"\" + path;\n    }\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1) {\n        return path;\n    }\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescape slashes and backslashes.\n */\nfunction unescapeJsonPath(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n/**\n * Generates a json-path compliant json path from path parts.\n *\n * @param path\n * @returns\n */\nfunction joinJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    if (path.length === 0) {\n        return \"\";\n    }\n    const getPathStr = (p) => p.map(escapeJsonPath).join(\"/\");\n    if (path[0] === \".\" || path[0] === \"..\") {\n        // relative\n        return getPathStr(path);\n    }\n    else {\n        // absolute\n        return \"/\" + getPathStr(path);\n    }\n}\n/**\n * Splits and decodes a json path into several parts.\n *\n * @param path\n * @returns\n */\nfunction splitJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    const parts = path.split(\"/\").map(unescapeJsonPath);\n    const valid = path === \"\" ||\n        path === \".\" ||\n        path === \"..\" ||\n        stringStartsWith(path, \"/\") ||\n        stringStartsWith(path, \"./\") ||\n        stringStartsWith(path, \"../\");\n    if (!valid) {\n        throw fail(`a json path must be either rooted, empty or relative, but got '${path}'`);\n    }\n    // '/a/b/c' -> [\"a\", \"b\", \"c\"]\n    // '../../b/c' -> [\"..\", \"..\", \"b\", \"c\"]\n    // '' -> []\n    // '/' -> ['']\n    // './a' -> [\".\", \"a\"]\n    // /./a' -> [\".\", \"a\"] equivalent to './a'\n    if (parts[0] === \"\") {\n        parts.shift();\n    }\n    return parts;\n}\n\n/** @hidden */\nconst $preProcessorFailed = Symbol(\"$preProcessorFailed\");\nclass SnapshotProcessor extends BaseType {\n    _subtype;\n    _processors;\n    get flags() {\n        return this._subtype.flags | TypeFlags.SnapshotProcessor;\n    }\n    constructor(_subtype, _processors, name) {\n        super(name || _subtype.name);\n        this._subtype = _subtype;\n        this._processors = _processors;\n    }\n    describe() {\n        return `snapshotProcessor(${this._subtype.describe()})`;\n    }\n    preProcessSnapshot(sn) {\n        if (this._processors.preProcessor) {\n            return this._processors.preProcessor.call(null, sn);\n        }\n        return sn;\n    }\n    preProcessSnapshotSafe(sn) {\n        try {\n            return this.preProcessSnapshot(sn);\n        }\n        catch (e) {\n            return $preProcessorFailed;\n        }\n    }\n    postProcessSnapshot(sn, node) {\n        if (this._processors.postProcessor) {\n            return this._processors.postProcessor.call(null, sn, node.storedValue);\n        }\n        return sn;\n    }\n    _fixNode(node) {\n        // the node has to use these methods rather than the original type ones\n        proxyNodeTypeMethods(node.type, this, \"create\");\n        if (node instanceof ObjectNode) {\n            node.hasSnapshotPostProcessor = !!this._processors.postProcessor;\n        }\n        const oldGetSnapshot = node.getSnapshot;\n        node.getSnapshot = () => this.postProcessSnapshot(oldGetSnapshot.call(node), node);\n        if (!isUnionType(this._subtype)) {\n            node.getReconciliationType = () => {\n                return this;\n            };\n        }\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const processedInitialValue = isStateTreeNode(initialValue)\n            ? initialValue\n            : this.preProcessSnapshot(initialValue);\n        const node = this._subtype.instantiate(parent, subpath, environment, processedInitialValue);\n        this._fixNode(node);\n        return node;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const node = this._subtype.reconcile(current, isStateTreeNode(newValue) ? newValue : this.preProcessSnapshot(newValue), parent, subpath);\n        if (node !== current) {\n            this._fixNode(node);\n        }\n        return node;\n    }\n    getSnapshot(node, applyPostProcess = true) {\n        const sn = this._subtype.getSnapshot(node);\n        return applyPostProcess ? this.postProcessSnapshot(sn, node) : sn;\n    }\n    isValidSnapshot(value, context) {\n        const processedSn = this.preProcessSnapshotSafe(value);\n        if (processedSn === $preProcessorFailed) {\n            return typeCheckFailure(context, value, \"Failed to preprocess value\");\n        }\n        return this._subtype.validate(processedSn, context);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n    is(thing) {\n        const value = isType(thing)\n            ? this._subtype\n            : isStateTreeNode(thing)\n                ? getSnapshot(thing, false)\n                : this.preProcessSnapshotSafe(thing);\n        if (value === $preProcessorFailed) {\n            return false;\n        }\n        return (this._subtype.validate(value, [{ path: \"\", type: this._subtype }])\n            .length === 0);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    isMatchingSnapshotId(current, snapshot) {\n        if (!(this._subtype instanceof ComplexType)) {\n            return false;\n        }\n        const processedSn = this.preProcessSnapshot(snapshot);\n        return this._subtype.isMatchingSnapshotId(current, processedSn);\n    }\n}\nfunction proxyNodeTypeMethods(nodeType, snapshotProcessorType, ...methods) {\n    for (const method of methods) {\n        nodeType[method] = snapshotProcessorType[method].bind(snapshotProcessorType);\n    }\n}\n/**\n * `types.snapshotProcessor` - Runs a pre/post snapshot processor before/after serializing a given type.\n *\n * Example:\n * ```ts\n * const Todo1 = types.model({ text: types.string })\n * // in the backend the text type must be null when empty\n * interface BackendTodo {\n *     text: string | null\n * }\n *\n * const Todo2 = types.snapshotProcessor(Todo1, {\n *     // from snapshot to instance\n *     preProcessor(snapshot: BackendTodo) {\n *         return {\n *             text: sn.text || \"\";\n *         }\n *     },\n *\n *     // from instance to snapshot\n *     postProcessor(snapshot, node): BackendTodo {\n *         return {\n *             text: !sn.text ? null : sn.text\n *         }\n *     }\n * })\n * ```\n *\n * @param type Type to run the processors over.\n * @param processors Processors to run.\n * @param name Type name, or undefined to inherit the inner type one.\n * @returns\n */\nfunction snapshotProcessor(type, processors, name) {\n    assertIsType(type, 1);\n    if (devMode()) {\n        if (processors.postProcessor &&\n            typeof processors.postProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"postSnapshotProcessor must be a function\");\n        }\n        if (processors.preProcessor &&\n            typeof processors.preProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"preSnapshotProcessor must be a function\");\n        }\n    }\n    return new SnapshotProcessor(type, processors, name);\n}\n\nconst needsIdentifierError = `Map.put can only be used to store complex values that have an identifier type attribute`;\nfunction tryCollectModelTypes(type, modelTypes) {\n    const subtypes = type.getSubTypes();\n    if (subtypes === cannotDetermineSubtype) {\n        return false;\n    }\n    if (subtypes) {\n        const subtypesArray = asArray(subtypes);\n        for (const subtype of subtypesArray) {\n            if (!tryCollectModelTypes(subtype, modelTypes)) {\n                return false;\n            }\n        }\n    }\n    if (type instanceof ModelType) {\n        modelTypes.push(type);\n    }\n    return true;\n}\n/**\n * @internal\n * @hidden\n */\nvar MapIdentifierMode;\n(function (MapIdentifierMode) {\n    MapIdentifierMode[MapIdentifierMode[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MapIdentifierMode[MapIdentifierMode[\"YES\"] = 1] = \"YES\";\n    MapIdentifierMode[MapIdentifierMode[\"NO\"] = 2] = \"NO\";\n})(MapIdentifierMode || (MapIdentifierMode = {}));\nclass MSTMap extends ObservableMap {\n    constructor(initialData, name) {\n        super(initialData, observable.ref.enhancer, name);\n    }\n    get(key) {\n        // maybe this is over-enthousiastic? normalize numeric keys to strings\n        return super.get(\"\" + key);\n    }\n    has(key) {\n        return super.has(\"\" + key);\n    }\n    delete(key) {\n        return super.delete(\"\" + key);\n    }\n    set(key, value) {\n        return super.set(\"\" + key, value);\n    }\n    put(value) {\n        if (!value) {\n            throw fail(`Map.put cannot be used to set empty values`);\n        }\n        if (isStateTreeNode(value)) {\n            const node = getStateTreeNode(value);\n            if (devMode()) {\n                if (!node.identifierAttribute) {\n                    throw fail(needsIdentifierError);\n                }\n            }\n            if (node.identifier === null) {\n                throw fail(needsIdentifierError);\n            }\n            this.set(node.identifier, value);\n            return value;\n        }\n        else if (!isMutable(value)) {\n            throw fail(`Map.put can only be used to store complex values`);\n        }\n        else {\n            const mapNode = getStateTreeNode(this);\n            const mapType = mapNode.type;\n            if (mapType.identifierMode !== MapIdentifierMode.YES) {\n                throw fail(needsIdentifierError);\n            }\n            const idAttr = mapType.mapIdentifierAttribute;\n            const id = value[idAttr];\n            if (!isValidIdentifier(id)) {\n                // try again but this time after creating a node for the value\n                // since it might be an optional identifier\n                const newNode = this.put(mapType.getChildType().create(value, mapNode.environment));\n                return this.put(getSnapshot(newNode));\n            }\n            const key = normalizeIdentifier(id);\n            this.set(key, value);\n            return this.get(key);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass MapType extends ComplexType {\n    _subType;\n    identifierMode = MapIdentifierMode.UNKNOWN;\n    mapIdentifierAttribute = undefined;\n    flags = TypeFlags.Map;\n    hookInitializers = [];\n    constructor(name, _subType, hookInitializers = []) {\n        super(name);\n        this._subType = _subType;\n        this._determineIdentifierMode();\n        this.hookInitializers = hookInitializers;\n    }\n    hooks(hooks) {\n        const hookInitializers = this.hookInitializers.length > 0\n            ? this.hookInitializers.concat(hooks)\n            : [hooks];\n        return new MapType(this.name, this._subType, hookInitializers);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        this._determineIdentifierMode();\n        return createObjectNode(this, parent, subpath, environment, initialValue);\n    }\n    _determineIdentifierMode() {\n        if (this.identifierMode !== MapIdentifierMode.UNKNOWN) {\n            return;\n        }\n        const modelTypes = [];\n        if (tryCollectModelTypes(this._subType, modelTypes)) {\n            const identifierAttribute = modelTypes.reduce((current, type) => {\n                if (!type.identifierAttribute) {\n                    return current;\n                }\n                if (current && current !== type.identifierAttribute) {\n                    throw fail(`The objects in a map should all have the same identifier attribute, expected '${current}', but child of type '${type.name}' declared attribute '${type.identifierAttribute}' as identifier`);\n                }\n                return type.identifierAttribute;\n            }, undefined);\n            if (identifierAttribute) {\n                this.identifierMode = MapIdentifierMode.YES;\n                this.mapIdentifierAttribute = identifierAttribute;\n            }\n            else {\n                this.identifierMode = MapIdentifierMode.NO;\n            }\n        }\n    }\n    initializeChildNodes(objNode, initialSnapshot = {}) {\n        const subType = objNode.type._subType;\n        const result = {};\n        Object.keys(initialSnapshot).forEach(name => {\n            result[name] = subType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        return new MSTMap(childNodes, this.name);\n    }\n    finalizeNewInstance(node, instance) {\n        _interceptReads(instance, node.unbox);\n        const type = node.type;\n        type.hookInitializers.forEach(initializer => {\n            const hooks = initializer(instance);\n            Object.keys(hooks).forEach(name => {\n                const hook = hooks[name];\n                const actionInvoker = createActionInvoker(instance, name, hook);\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n            });\n        });\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    describe() {\n        return this.name;\n    }\n    getChildren(node) {\n        // return (node.storedValue as ObservableMap<any>).values()\n        return values(node.storedValue);\n    }\n    getChildNode(node, key) {\n        const childNode = node.storedValue.get(\"\" + key);\n        if (!childNode) {\n            throw fail(\"Not a child \" + key);\n        }\n        return childNode;\n    }\n    willChange(change) {\n        const node = getStateTreeNode(change.object);\n        const key = change.name;\n        node.assertWritable({ subpath: key });\n        const mapType = node.type;\n        const subType = mapType._subType;\n        switch (change.type) {\n            case \"update\":\n                {\n                    const { newValue } = change;\n                    const oldValue = change.object.get(key);\n                    if (newValue === oldValue) {\n                        return null;\n                    }\n                    typecheckInternal(subType, newValue);\n                    change.newValue = subType.reconcile(node.getChildNode(key), change.newValue, node, key);\n                    mapType.processIdentifier(key, change.newValue);\n                }\n                break;\n            case \"add\":\n                {\n                    typecheckInternal(subType, change.newValue);\n                    change.newValue = subType.instantiate(node, key, undefined, change.newValue);\n                    mapType.processIdentifier(key, change.newValue);\n                }\n                break;\n        }\n        return change;\n    }\n    processIdentifier(expected, node) {\n        if (this.identifierMode === MapIdentifierMode.YES &&\n            node instanceof ObjectNode) {\n            const identifier = node.identifier;\n            if (identifier !== expected) {\n                throw fail(`A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '${identifier}', but expected: '${expected}'`);\n            }\n        }\n    }\n    getSnapshot(node) {\n        const res = {};\n        node.getChildren().forEach(childNode => {\n            res[childNode.subpath] = childNode.snapshot;\n        });\n        return res;\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = {};\n        Object.keys(childNodes).forEach(key => {\n            processed[key] = childNodes[key].getSnapshot();\n        });\n        return processed;\n    }\n    didChange(change) {\n        const node = getStateTreeNode(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: escapeJsonPath(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"add\":\n                return void node.emitPatch({\n                    op: \"add\",\n                    path: escapeJsonPath(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: undefined\n                }, node);\n            case \"delete\":\n                // a node got deleted, get the old snapshot and make the node die\n                const oldSnapshot = change.oldValue.snapshot;\n                change.oldValue.die();\n                // emit the patch\n                return void node.emitPatch({\n                    op: \"remove\",\n                    path: escapeJsonPath(change.name),\n                    oldValue: oldSnapshot\n                }, node);\n        }\n    }\n    applyPatchLocally(node, subpath, patch) {\n        const target = node.storedValue;\n        switch (patch.op) {\n            case \"add\":\n            case \"replace\":\n                target.set(subpath, patch.value);\n                break;\n            case \"remove\":\n                target.delete(subpath);\n                break;\n        }\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const target = node.storedValue;\n        const currentKeys = {};\n        Array.from(target.keys()).forEach(key => {\n            currentKeys[key] = false;\n        });\n        if (snapshot) {\n            // Don't use target.replace, as it will throw away all existing items first\n            for (const key in snapshot) {\n                target.set(key, snapshot[key]);\n                currentKeys[\"\" + key] = true;\n            }\n        }\n        Object.keys(currentKeys).forEach(key => {\n            if (currentKeys[key] === false) {\n                target.delete(key);\n            }\n        });\n    }\n    getChildType() {\n        return this._subType;\n    }\n    isValidSnapshot(value, context) {\n        if (!isPlainObject(value)) {\n            return typeCheckFailure(context, value, \"Value is not a plain object\");\n        }\n        for (const key of Object.keys(value)) {\n            getContextForPath(context, key, this._subType);\n            const errors = this._subType.validate(value[key], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    getDefaultSnapshot() {\n        return EMPTY_OBJECT;\n    }\n    removeChild(node, subpath) {\n        node.storedValue.delete(subpath);\n    }\n}\nMapType.prototype.applySnapshot = action(MapType.prototype.applySnapshot);\n/**\n * `types.map` - Creates a key based collection type who's children are all of a uniform declared type.\n * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.\n *\n * This type will always produce [observable maps](https://mobx.js.org/api.html#observablemap)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   id: types.identifier,\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.map(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: {} })\n * unprotect(s)\n * s.todos.set(17, { task: \"Grab coffee\", id: 17 })\n * s.todos.put({ task: \"Grab cookie\", id: 18 }) // put will infer key from the identifier\n * console.log(s.todos.get(17).task) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction map(subtype) {\n    return new MapType(`Map<string, ${subtype.name}>`, subtype);\n}\n/**\n * Returns if a given value represents a map type.\n *\n * @param type\n * @returns `true` if it is a map type.\n */\nfunction isMapType(type) {\n    return isType(type) && (type.flags & TypeFlags.Map) > 0;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass ArrayType extends ComplexType {\n    _subType;\n    flags = TypeFlags.Array;\n    hookInitializers = [];\n    constructor(name, _subType, hookInitializers = []) {\n        super(name);\n        this._subType = _subType;\n        this.hookInitializers = hookInitializers;\n    }\n    hooks(hooks) {\n        const hookInitializers = this.hookInitializers.length > 0\n            ? this.hookInitializers.concat(hooks)\n            : [hooks];\n        return new ArrayType(this.name, this._subType, hookInitializers);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createObjectNode(this, parent, subpath, environment, initialValue);\n    }\n    initializeChildNodes(objNode, snapshot = []) {\n        const subType = objNode.type._subType;\n        const result = {};\n        snapshot.forEach((item, index) => {\n            const subpath = \"\" + index;\n            result[subpath] = subType.instantiate(objNode, subpath, undefined, item);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        const options = { ...mobxShallow, name: this.name };\n        return observable.array(convertChildNodesToArray(childNodes), options);\n    }\n    finalizeNewInstance(node, instance) {\n        _getAdministration(instance).dehancer = node.unbox;\n        const type = node.type;\n        type.hookInitializers.forEach(initializer => {\n            const hooks = initializer(instance);\n            Object.keys(hooks).forEach(name => {\n                const hook = hooks[name];\n                const actionInvoker = createActionInvoker(instance, name, hook);\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n            });\n        });\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    describe() {\n        return this.name;\n    }\n    getChildren(node) {\n        return node.storedValue.slice();\n    }\n    getChildNode(node, key) {\n        const index = Number(key);\n        if (index < node.storedValue.length) {\n            return node.storedValue[index];\n        }\n        throw fail(\"Not a child: \" + key);\n    }\n    willChange(change) {\n        const node = getStateTreeNode(change.object);\n        node.assertWritable({ subpath: \"\" + change.index });\n        const subType = node.type._subType;\n        const childNodes = node.getChildren();\n        switch (change.type) {\n            case \"update\":\n                {\n                    if (change.newValue === change.object[change.index]) {\n                        return null;\n                    }\n                    const updatedNodes = reconcileArrayChildren(node, subType, [childNodes[change.index]], [change.newValue], [change.index]);\n                    if (!updatedNodes) {\n                        return null;\n                    }\n                    change.newValue = updatedNodes[0];\n                }\n                break;\n            case \"splice\":\n                {\n                    const { index, removedCount, added } = change;\n                    const addedNodes = reconcileArrayChildren(node, subType, childNodes.slice(index, index + removedCount), added, added.map((_, i) => index + i));\n                    if (!addedNodes) {\n                        return null;\n                    }\n                    change.added = addedNodes;\n                    // update paths of remaining items\n                    for (let i = index + removedCount; i < childNodes.length; i++) {\n                        childNodes[i].setParent(node, \"\" + (i + added.length - removedCount));\n                    }\n                }\n                break;\n        }\n        return change;\n    }\n    getSnapshot(node) {\n        return node.getChildren().map(childNode => childNode.snapshot);\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = [];\n        Object.keys(childNodes).forEach(key => {\n            processed.push(childNodes[key].getSnapshot());\n        });\n        return processed;\n    }\n    didChange(change) {\n        const node = getStateTreeNode(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: \"\" + change.index,\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"splice\":\n                for (let i = change.removedCount - 1; i >= 0; i--) {\n                    node.emitPatch({\n                        op: \"remove\",\n                        path: \"\" + (change.index + i),\n                        oldValue: change.removed[i].snapshot\n                    }, node);\n                }\n                for (let i = 0; i < change.addedCount; i++) {\n                    node.emitPatch({\n                        op: \"add\",\n                        path: \"\" + (change.index + i),\n                        value: node.getChildNode(\"\" + (change.index + i)).snapshot,\n                        oldValue: undefined\n                    }, node);\n                }\n                return;\n        }\n    }\n    applyPatchLocally(node, subpath, patch) {\n        const target = node.storedValue;\n        const index = subpath === \"-\" ? target.length : Number(subpath);\n        switch (patch.op) {\n            case \"replace\":\n                target[index] = patch.value;\n                break;\n            case \"add\":\n                target.splice(index, 0, patch.value);\n                break;\n            case \"remove\":\n                target.splice(index, 1);\n                break;\n        }\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const target = node.storedValue;\n        target.replace(snapshot);\n    }\n    getChildType() {\n        return this._subType;\n    }\n    isValidSnapshot(value, context) {\n        if (!isArray(value)) {\n            return typeCheckFailure(context, value, \"Value is not an array\");\n        }\n        for (let i = 0; i < value.length; i++) {\n            getContextForPath(context, \"\" + i, this._subType);\n            const errors = this._subType.validate(value[i], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    getDefaultSnapshot() {\n        return EMPTY_ARRAY;\n    }\n    removeChild(node, subpath) {\n        node.storedValue.splice(Number(subpath), 1);\n    }\n}\nArrayType.prototype.applySnapshot = action(ArrayType.prototype.applySnapshot);\n/**\n * `types.array` - Creates an index based collection type who's children are all of a uniform declared type.\n *\n * This type will always produce [observable arrays](https://mobx.js.org/api.html#observablearray)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: [] })\n * unprotect(s) // needed to allow modifying outside of an action\n * s.todos.push({ task: \"Grab coffee\" })\n * console.log(s.todos[0]) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction array(subtype) {\n    assertIsType(subtype, 1);\n    return new ArrayType(`${subtype.name}[]`, subtype);\n}\nfunction reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {\n    let nothingChanged = true;\n    for (let i = 0;; i++) {\n        const hasNewNode = i <= newValues.length - 1;\n        const oldNode = oldNodes[i];\n        let newValue = hasNewNode ? newValues[i] : undefined;\n        const newPath = \"\" + newPaths[i];\n        // for some reason, instead of newValue we got a node, fallback to the storedValue\n        // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681\n        if (isNode(newValue)) {\n            newValue = newValue.storedValue;\n        }\n        if (!oldNode && !hasNewNode) {\n            // both are empty, end\n            break;\n        }\n        else if (!hasNewNode) {\n            // new one does not exists\n            nothingChanged = false;\n            oldNodes.splice(i, 1);\n            if (oldNode instanceof ObjectNode) {\n                // since it is going to be returned by pop/splice/shift better create it before killing it\n                // so it doesn't end up in an undead state\n                oldNode.createObservableInstanceIfNeeded();\n            }\n            oldNode.die();\n            i--;\n        }\n        else if (!oldNode) {\n            // there is no old node, create it\n            // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.\n            if (isStateTreeNode(newValue) &&\n                getStateTreeNode(newValue).parent === parent) {\n                // this node is owned by this parent, but not in the reconcilable set, so it must be double\n                throw fail(`Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '${parent.path}/${newPath}', but it lives already at '${getStateTreeNode(newValue).path}'`);\n            }\n            nothingChanged = false;\n            const newNode = valueAsNode(childType, parent, newPath, newValue);\n            oldNodes.splice(i, 0, newNode);\n        }\n        else if (areSame(oldNode, newValue)) {\n            // both are the same, reconcile\n            oldNodes[i] = valueAsNode(childType, parent, newPath, newValue, oldNode);\n        }\n        else {\n            // nothing to do, try to reorder\n            let oldMatch = undefined;\n            // find a possible candidate to reuse\n            for (let j = i; j < oldNodes.length; j++) {\n                if (areSame(oldNodes[j], newValue)) {\n                    oldMatch = oldNodes.splice(j, 1)[0];\n                    break;\n                }\n            }\n            nothingChanged = false;\n            const newNode = valueAsNode(childType, parent, newPath, newValue, oldMatch);\n            oldNodes.splice(i, 0, newNode);\n        }\n    }\n    return nothingChanged ? null : oldNodes;\n}\n/**\n * Convert a value to a node at given parent and subpath. Attempts to reuse old node if possible and given.\n */\nfunction valueAsNode(childType, parent, subpath, newValue, oldNode) {\n    // ensure the value is valid-ish\n    typecheckInternal(childType, newValue);\n    function getNewNode() {\n        // the new value has a MST node\n        if (isStateTreeNode(newValue)) {\n            const childNode = getStateTreeNode(newValue);\n            childNode.assertAlive(EMPTY_OBJECT);\n            // the node lives here\n            if (childNode.parent !== null && childNode.parent === parent) {\n                childNode.setParent(parent, subpath);\n                return childNode;\n            }\n        }\n        // there is old node and new one is a value/snapshot\n        if (oldNode) {\n            return childType.reconcile(oldNode, newValue, parent, subpath);\n        }\n        // nothing to do, create from scratch\n        return childType.instantiate(parent, subpath, undefined, newValue);\n    }\n    const newNode = getNewNode();\n    if (oldNode && oldNode !== newNode) {\n        if (oldNode instanceof ObjectNode) {\n            // since it is going to be returned by pop/splice/shift better create it before killing it\n            // so it doesn't end up in an undead state\n            oldNode.createObservableInstanceIfNeeded();\n        }\n        oldNode.die();\n    }\n    return newNode;\n}\n/**\n * Check if a node holds a value.\n */\nfunction areSame(oldNode, newValue) {\n    // never consider dead old nodes for reconciliation\n    if (!oldNode.isAlive) {\n        return false;\n    }\n    // the new value has the same node\n    if (isStateTreeNode(newValue)) {\n        const newNode = getStateTreeNode(newValue);\n        return newNode.isAlive && newNode === oldNode;\n    }\n    // the provided value is the snapshot of the old node\n    if (oldNode.snapshot === newValue) {\n        return true;\n    }\n    // Non object nodes don't get reconciled\n    if (!(oldNode instanceof ObjectNode)) {\n        return false;\n    }\n    const oldNodeType = oldNode.getReconciliationType();\n    // new value is a snapshot with the correct identifier\n    return (oldNode.identifier !== null &&\n        oldNode.identifierAttribute &&\n        isPlainObject(newValue) &&\n        oldNodeType.is(newValue) &&\n        oldNodeType.isMatchingSnapshotId(oldNode, newValue));\n}\n/**\n * Returns if a given value represents an array type.\n *\n * @param type\n * @returns `true` if the type is an array type.\n */\nfunction isArrayType(type) {\n    return isType(type) && (type.flags & TypeFlags.Array) > 0;\n}\n\nconst PRE_PROCESS_SNAPSHOT = \"preProcessSnapshot\";\nconst POST_PROCESS_SNAPSHOT = \"postProcessSnapshot\";\nfunction objectTypeToString() {\n    return getStateTreeNode(this).toString();\n}\nconst defaultObjectOptions = {\n    name: \"AnonymousModel\",\n    properties: {},\n    initializers: EMPTY_ARRAY\n};\nfunction toPropertiesObject(declaredProps) {\n    const keysList = Object.keys(declaredProps);\n    const alreadySeenKeys = new Set();\n    keysList.forEach(key => {\n        if (alreadySeenKeys.has(key)) {\n            throw fail(`${key} is declared twice in the model. Model should not contain the same keys`);\n        }\n        alreadySeenKeys.add(key);\n    });\n    // loop through properties and ensures that all items are types\n    return keysList.reduce((props, key) => {\n        // warn if user intended a HOOK\n        if (key in Hook) {\n            throw fail(`Hook '${key}' was defined as property. Hooks should be defined as part of the actions`);\n        }\n        // the user intended to use a view\n        const descriptor = Object.getOwnPropertyDescriptor(declaredProps, key);\n        if (\"get\" in descriptor) {\n            throw fail(\"Getters are not supported as properties. Please use views instead\");\n        }\n        // undefined and null are not valid\n        const value = descriptor.value;\n        if (value === null || value === undefined) {\n            throw fail(\"The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?\");\n        }\n        // its a primitive, convert to its type\n        else if (isPrimitive(value)) {\n            props[key] = optional(getPrimitiveFactoryFromValue(value), value);\n        }\n        // map defaults to empty object automatically for models\n        else if (value instanceof MapType) {\n            props[key] = optional(value, {});\n        }\n        else if (value instanceof ArrayType) {\n            props[key] = optional(value, []);\n        }\n        // its already a type\n        else if (isType(value)) ;\n        // its a function, maybe the user wanted a view?\n        else if (devMode() && typeof value === \"function\") {\n            throw fail(`Invalid type definition for property '${key}', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?`);\n        }\n        // no other complex values\n        else if (devMode() && typeof value === \"object\") {\n            throw fail(`Invalid type definition for property '${key}', it looks like you passed an object. Try passing another model type or a types.frozen.`);\n        }\n        else {\n            throw fail(`Invalid type definition for property '${key}', cannot infer a type from a value like '${value}' (${typeof value})`);\n        }\n        return props;\n    }, { ...declaredProps });\n}\n/**\n * @internal\n * @hidden\n */\nclass ModelType extends ComplexType {\n    flags = TypeFlags.Object;\n    /*\n     * The original object definition\n     */\n    initializers;\n    properties;\n    preProcessor;\n    postProcessor;\n    propertyNames;\n    constructor(opts) {\n        super(opts.name || defaultObjectOptions.name);\n        Object.assign(this, defaultObjectOptions, opts);\n        // ensures that any default value gets converted to its related type\n        this.properties = toPropertiesObject(this.properties);\n        freeze(this.properties); // make sure nobody messes with it\n        this.propertyNames = Object.keys(this.properties);\n        this.identifierAttribute = this._getIdentifierAttribute();\n    }\n    _getIdentifierAttribute() {\n        let identifierAttribute = undefined;\n        this.forAllProps((propName, propType) => {\n            if (propType.flags & TypeFlags.Identifier) {\n                if (identifierAttribute) {\n                    throw fail(`Cannot define property '${propName}' as object identifier, property '${identifierAttribute}' is already defined as identifier property`);\n                }\n                identifierAttribute = propName;\n            }\n        });\n        return identifierAttribute;\n    }\n    cloneAndEnhance(opts) {\n        return new ModelType({\n            name: opts.name || this.name,\n            properties: Object.assign({}, this.properties, opts.properties),\n            initializers: this.initializers.concat(opts.initializers || []),\n            preProcessor: opts.preProcessor || this.preProcessor,\n            postProcessor: opts.postProcessor || this.postProcessor\n        });\n    }\n    actions(fn) {\n        const actionInitializer = (self) => {\n            this.instantiateActions(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [actionInitializer] });\n    }\n    instantiateActions(self, actions) {\n        // check if return is correct\n        if (!isPlainObject(actions)) {\n            throw fail(`actions initializer should return a plain object containing actions`);\n        }\n        // bind actions to the object created\n        Object.keys(actions).forEach(name => {\n            // warn if preprocessor was given\n            if (name === PRE_PROCESS_SNAPSHOT) {\n                throw fail(`Cannot define action '${PRE_PROCESS_SNAPSHOT}', it should be defined using 'type.preProcessSnapshot(fn)' instead`);\n            }\n            // warn if postprocessor was given\n            if (name === POST_PROCESS_SNAPSHOT) {\n                throw fail(`Cannot define action '${POST_PROCESS_SNAPSHOT}', it should be defined using 'type.postProcessSnapshot(fn)' instead`);\n            }\n            let action2 = actions[name];\n            // apply hook composition\n            const baseAction = self[name];\n            if (name in Hook && baseAction) {\n                const specializedAction = action2;\n                action2 = function () {\n                    baseAction.apply(null, arguments);\n                    specializedAction.apply(null, arguments);\n                };\n            }\n            // the goal of this is to make sure actions using \"this\" can call themselves,\n            // while still allowing the middlewares to register them\n            const middlewares = action2.$mst_middleware; // make sure middlewares are not lost\n            const boundAction = action2.bind(actions);\n            boundAction._isFlowAction =\n                action2._isFlowAction || false;\n            boundAction.$mst_middleware = middlewares;\n            const actionInvoker = createActionInvoker(self, name, boundAction);\n            actions[name] = actionInvoker;\n            (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, name, actionInvoker);\n        });\n    }\n    named = name => {\n        return this.cloneAndEnhance({ name });\n    };\n    props = properties => {\n        return this.cloneAndEnhance({ properties });\n    };\n    volatile(fn) {\n        if (typeof fn !== \"function\") {\n            throw fail(`You passed an ${typeof fn} to volatile state as an argument, when function is expected`);\n        }\n        const stateInitializer = (self) => {\n            this.instantiateVolatileState(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [stateInitializer] });\n    }\n    instantiateVolatileState(self, state) {\n        // check views return\n        if (!isPlainObject(state)) {\n            throw fail(`volatile state initializer should return a plain object containing state`);\n        }\n        set(self, state);\n    }\n    extend(fn) {\n        const initializer = (self) => {\n            const { actions, views, state, ...rest } = fn(self);\n            for (const key in rest) {\n                throw fail(`The \\`extend\\` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '${key}'`);\n            }\n            if (state) {\n                this.instantiateVolatileState(self, state);\n            }\n            if (views) {\n                this.instantiateViews(self, views);\n            }\n            if (actions) {\n                this.instantiateActions(self, actions);\n            }\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [initializer] });\n    }\n    views(fn) {\n        const viewInitializer = (self) => {\n            this.instantiateViews(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [viewInitializer] });\n    }\n    instantiateViews(self, views) {\n        // check views return\n        if (!isPlainObject(views)) {\n            throw fail(`views initializer should return a plain object containing views`);\n        }\n        Object.getOwnPropertyNames(views).forEach(key => {\n            // is this a computed property?\n            const descriptor = Object.getOwnPropertyDescriptor(views, key);\n            if (\"get\" in descriptor) {\n                defineProperty$1(self, key, descriptor);\n                makeObservable(self, { [key]: computed });\n            }\n            else if (typeof descriptor.value === \"function\") {\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, key, descriptor.value);\n            }\n            else {\n                throw fail(`A view member should either be a function or getter based property`);\n            }\n        });\n    }\n    preProcessSnapshot = preProcessor => {\n        const currentPreprocessor = this.preProcessor;\n        if (!currentPreprocessor) {\n            return this.cloneAndEnhance({ preProcessor });\n        }\n        else {\n            return this.cloneAndEnhance({\n                preProcessor: snapshot => currentPreprocessor(preProcessor(snapshot))\n            });\n        }\n    };\n    postProcessSnapshot = postProcessor => {\n        const currentPostprocessor = this.postProcessor;\n        if (!currentPostprocessor) {\n            return this.cloneAndEnhance({ postProcessor });\n        }\n        else {\n            return this.cloneAndEnhance({\n                postProcessor: snapshot => postProcessor(currentPostprocessor(snapshot))\n            });\n        }\n    };\n    instantiate(parent, subpath, environment, initialValue) {\n        const value = isStateTreeNode(initialValue)\n            ? initialValue\n            : this.applySnapshotPreProcessor(initialValue);\n        return createObjectNode(this, parent, subpath, environment, value);\n        // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class\n        // that pre-reserves all these fields for fast object-member lookups\n    }\n    initializeChildNodes(objNode, initialSnapshot = {}) {\n        const type = objNode.type;\n        const result = {};\n        type.forAllProps((name, childType) => {\n            result[name] = childType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        const options = { ...mobxShallow, name: this.name };\n        return observable.object(childNodes, EMPTY_OBJECT, options);\n    }\n    finalizeNewInstance(node, instance) {\n        addHiddenFinalProp(instance, \"toString\", objectTypeToString);\n        this.forAllProps(name => {\n            _interceptReads(instance, name, node.unbox);\n        });\n        this.initializers.reduce((self, fn) => fn(self), instance);\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    willChange(chg) {\n        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n        const change = chg;\n        const node = getStateTreeNode(change.object);\n        const subpath = change.name;\n        node.assertWritable({ subpath });\n        const childType = node.type.properties[subpath];\n        // only properties are typed, state are stored as-is references\n        if (childType) {\n            typecheckInternal(childType, change.newValue);\n            change.newValue = childType.reconcile(node.getChildNode(subpath), change.newValue, node, subpath);\n        }\n        return change;\n    }\n    didChange(chg) {\n        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n        const change = chg;\n        const childNode = getStateTreeNode(change.object);\n        const childType = childNode.type.properties[change.name];\n        if (!childType) {\n            // don't emit patches for volatile state\n            return;\n        }\n        const oldChildValue = change.oldValue ? change.oldValue.snapshot : undefined;\n        childNode.emitPatch({\n            op: \"replace\",\n            path: escapeJsonPath(change.name),\n            value: change.newValue.snapshot,\n            oldValue: oldChildValue\n        }, childNode);\n    }\n    getChildren(node) {\n        const res = [];\n        this.forAllProps(name => {\n            res.push(this.getChildNode(node, name));\n        });\n        return res;\n    }\n    getChildNode(node, key) {\n        if (!(key in this.properties)) {\n            throw fail(\"Not a value property: \" + key);\n        }\n        const adm = _getAdministration(node.storedValue, key);\n        const childNode = adm.raw?.();\n        if (!childNode) {\n            throw fail(\"Node not available for property \" + key);\n        }\n        return childNode;\n    }\n    getSnapshot(node, applyPostProcess = true) {\n        const res = {};\n        this.forAllProps((name, type) => {\n            try {\n                // TODO: FIXME, make sure the observable ref is used!\n                const atom = getAtom(node.storedValue, name);\n                atom.reportObserved();\n            }\n            catch (e) {\n                throw fail(`${name} property is declared twice`);\n            }\n            res[name] = this.getChildNode(node, name).snapshot;\n        });\n        if (applyPostProcess) {\n            return this.applySnapshotPostProcessor(res);\n        }\n        return res;\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = {};\n        Object.keys(childNodes).forEach(key => {\n            processed[key] = childNodes[key].getSnapshot();\n        });\n        return this.applySnapshotPostProcessor(processed);\n    }\n    applyPatchLocally(node, subpath, patch) {\n        if (!(patch.op === \"replace\" || patch.op === \"add\")) {\n            throw fail(`object does not support operation ${patch.op}`);\n        }\n        node.storedValue[subpath] = patch.value;\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const preProcessedSnapshot = this.applySnapshotPreProcessor(snapshot);\n        this.forAllProps(name => {\n            node.storedValue[name] = preProcessedSnapshot[name];\n        });\n    }\n    applySnapshotPreProcessor(snapshot) {\n        const processor = this.preProcessor;\n        return processor ? processor.call(null, snapshot) : snapshot;\n    }\n    applySnapshotPostProcessor(snapshot) {\n        const postProcessor = this.postProcessor;\n        if (postProcessor) {\n            return postProcessor.call(null, snapshot);\n        }\n        return snapshot;\n    }\n    getChildType(propertyName) {\n        assertIsString(propertyName, 1);\n        return this.properties[propertyName];\n    }\n    isValidSnapshot(value, context) {\n        const snapshot = this.applySnapshotPreProcessor(value);\n        if (!isPlainObject(snapshot)) {\n            return typeCheckFailure(context, snapshot, \"Value is not a plain object\");\n        }\n        for (const key of this.propertyNames) {\n            const propType = this.properties[key];\n            getContextForPath(context, key, propType);\n            const errors = propType.validate(snapshot[key], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    forAllProps(fn) {\n        this.propertyNames.forEach(key => fn(key, this.properties[key]));\n    }\n    describe() {\n        // optimization: cache\n        return (\"{ \" +\n            this.propertyNames\n                .map(key => key + \": \" + this.properties[key].describe())\n                .join(\"; \") +\n            \" }\");\n    }\n    getDefaultSnapshot() {\n        return EMPTY_OBJECT;\n    }\n    removeChild(node, subpath) {\n        node.storedValue[subpath] = undefined;\n    }\n}\nModelType.prototype.applySnapshot = action(ModelType.prototype.applySnapshot);\n/**\n * `types.model` - Creates a new model type by providing a name, properties, volatile state and actions.\n *\n * See the [model type](/concepts/trees#creating-models) description or the [getting started](intro/getting-started.md#getting-started-1) tutorial.\n */\nfunction model(...args) {\n    if (devMode() && typeof args[0] !== \"string\" && args[1]) {\n        throw fail(\"Model creation failed. First argument must be a string when two arguments are provided\");\n    }\n    const name = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n    const properties = args.shift() || {};\n    return new ModelType({ name, properties });\n}\n/**\n * `types.compose` - Composes a new model from one or more existing model types.\n * This method can be invoked in two forms:\n * Given 2 or more model types, the types are composed into a new Type.\n * Given first parameter as a string and 2 or more model types,\n * the types are composed into a new Type with the given name\n */\nfunction compose(...args) {\n    // TODO: just join the base type names if no name is provided\n    const hasTypename = typeof args[0] === \"string\";\n    const typeName = hasTypename ? args[0] : \"AnonymousModel\";\n    if (hasTypename) {\n        args.shift();\n    }\n    // check all parameters\n    if (devMode()) {\n        args.forEach((type, i) => {\n            assertArg(type, isModelType, \"mobx-state-tree model type\", hasTypename ? i + 2 : i + 1);\n        });\n    }\n    return args\n        .reduce((prev, cur) => prev.cloneAndEnhance({\n        name: prev.name + \"_\" + cur.name,\n        properties: cur.properties,\n        initializers: cur.initializers,\n        preProcessor: (snapshot) => cur.applySnapshotPreProcessor(prev.applySnapshotPreProcessor(snapshot)),\n        postProcessor: (snapshot) => cur.applySnapshotPostProcessor(prev.applySnapshotPostProcessor(snapshot))\n    }))\n        .named(typeName);\n}\n/**\n * Returns if a given value represents a model type.\n *\n * @param type\n * @returns\n */\nfunction isModelType(type) {\n    return isType(type) && (type.flags & TypeFlags.Object) > 0;\n}\n\n// TODO: implement CoreType using types.custom ?\n/**\n * @internal\n * @hidden\n */\nclass CoreType extends SimpleType {\n    flags;\n    checker;\n    initializer;\n    constructor(name, flags, checker, initializer = identity) {\n        super(name);\n        this.flags = flags;\n        this.checker = checker;\n        this.initializer = initializer;\n        this.flags = flags;\n    }\n    describe() {\n        return this.name;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    createNewInstance(snapshot) {\n        return this.initializer(snapshot);\n    }\n    isValidSnapshot(value, context) {\n        if (isPrimitive(value) && this.checker(value)) {\n            return typeCheckSuccess();\n        }\n        const typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name;\n        return typeCheckFailure(context, value, `Value is not a ${typeName}`);\n    }\n}\n/**\n * `types.string` - Creates a type that can only contain a string value.\n * This type is used for string values by default\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *   firstName: types.string,\n *   lastName: \"Doe\"\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst string = new CoreType(\"string\", TypeFlags.String, v => typeof v === \"string\");\n/**\n * `types.number` - Creates a type that can only contain a numeric value.\n * This type is used for numeric values by default\n *\n * Example:\n * ```ts\n * const Vector = types.model({\n *   x: types.number,\n *   y: 1.5\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst number = new CoreType(\"number\", TypeFlags.Number, v => typeof v === \"number\");\n/**\n * `types.integer` - Creates a type that can only contain an integer value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.integer,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst integer = new CoreType(\"integer\", TypeFlags.Integer, v => isInteger(v));\n/**\n * `types.float` - Creates a type that can only contain an float value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.float,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst float = new CoreType(\"float\", TypeFlags.Float, v => isFloat(v));\n/**\n * `types.finite` - Creates a type that can only contain an finite value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.finite,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst finite = new CoreType(\"finite\", TypeFlags.Finite, v => isFinite(v));\n/**\n * `types.boolean` - Creates a type that can only contain a boolean value.\n * This type is used for boolean values by default\n *\n * Example:\n * ```ts\n * const Thing = types.model({\n *   isCool: types.boolean,\n *   isAwesome: false\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst boolean = new CoreType(\"boolean\", TypeFlags.Boolean, v => typeof v === \"boolean\");\n/**\n * `types.null` - The type of the value `null`\n */\nconst nullType = new CoreType(\"null\", TypeFlags.Null, v => v === null);\n/**\n * `types.undefined` - The type of the value `undefined`\n */\nconst undefinedType = new CoreType(\"undefined\", TypeFlags.Undefined, v => v === undefined);\nconst _DatePrimitive = new CoreType(\"Date\", TypeFlags.Date, v => typeof v === \"number\" || v instanceof Date, v => (v instanceof Date ? v : new Date(v)));\n_DatePrimitive.getSnapshot = function (node) {\n    return node.storedValue.getTime();\n};\n/**\n * `types.Date` - Creates a type that can only contain a javascript Date value.\n *\n * Example:\n * ```ts\n * const LogLine = types.model({\n *   timestamp: types.Date,\n * })\n *\n * LogLine.create({ timestamp: new Date() })\n * ```\n */\nconst DatePrimitive = _DatePrimitive;\n/**\n * @internal\n * @hidden\n */\nfunction getPrimitiveFactoryFromValue(value) {\n    switch (typeof value) {\n        case \"string\":\n            return string;\n        case \"number\":\n            return number; // In the future, isInteger(value) ? integer : number would be interesting, but would be too breaking for now\n        case \"boolean\":\n            return boolean;\n        case \"object\":\n            if (value instanceof Date) {\n                return DatePrimitive;\n            }\n    }\n    throw fail(\"Cannot determine primitive type from value \" + value);\n}\n/**\n * Returns if a given value represents a primitive type.\n *\n * @param type\n * @returns\n */\nfunction isPrimitiveType(type) {\n    return (isType(type) &&\n        (type.flags &\n            (TypeFlags.String |\n                TypeFlags.Number |\n                TypeFlags.Integer |\n                TypeFlags.Boolean |\n                TypeFlags.Date)) >\n            0);\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Literal extends SimpleType {\n    value;\n    flags = TypeFlags.Literal;\n    constructor(value) {\n        super(JSON.stringify(value));\n        this.value = value;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    describe() {\n        return JSON.stringify(this.value);\n    }\n    isValidSnapshot(value, context) {\n        if (isPrimitive(value) && value === this.value) {\n            return typeCheckSuccess();\n        }\n        return typeCheckFailure(context, value, `Value is not a literal ${JSON.stringify(this.value)}`);\n    }\n}\n/**\n * `types.literal` - The literal type will return a type that will match only the exact given type.\n * The given value must be a primitive, in order to be serialized to a snapshot correctly.\n * You can use literal to match exact strings for example the exact male or female string.\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *     name: types.string,\n *     gender: types.union(types.literal('male'), types.literal('female'))\n * })\n * ```\n *\n * @param value The value to use in the strict equal check\n * @returns\n */\nfunction literal(value) {\n    // check that the given value is a primitive\n    assertArg(value, isPrimitive, \"primitive\", 1);\n    return new Literal(value);\n}\n/**\n * Returns if a given value represents a literal type.\n *\n * @param type\n * @returns\n */\nfunction isLiteralType(type) {\n    return isType(type) && (type.flags & TypeFlags.Literal) > 0;\n}\n\nclass Refinement extends BaseType {\n    _subtype;\n    _predicate;\n    _message;\n    get flags() {\n        return this._subtype.flags | TypeFlags.Refinement;\n    }\n    constructor(name, _subtype, _predicate, _message) {\n        super(name);\n        this._subtype = _subtype;\n        this._predicate = _predicate;\n        this._message = _message;\n    }\n    describe() {\n        return this.name;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        // create the child type\n        return this._subtype.instantiate(parent, subpath, environment, initialValue);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    isValidSnapshot(value, context) {\n        const subtypeErrors = this._subtype.validate(value, context);\n        if (subtypeErrors.length > 0) {\n            return subtypeErrors;\n        }\n        const snapshot = isStateTreeNode(value)\n            ? getStateTreeNode(value).snapshot\n            : value;\n        if (!this._predicate(snapshot)) {\n            return typeCheckFailure(context, value, this._message(value));\n        }\n        return typeCheckSuccess();\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this._subtype.reconcile(current, newValue, parent, subpath);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n}\n/**\n * `types.refinement` - Creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n *\n * @param name\n * @param type\n * @param predicate\n * @returns\n */\nfunction refinement(...args) {\n    const name = typeof args[0] === \"string\"\n        ? args.shift()\n        : isType(args[0])\n            ? args[0].name\n            : null;\n    const type = args[0];\n    const predicate = args[1];\n    const message = args[2]\n        ? args[2]\n        : (v) => \"Value does not respect the refinement predicate\";\n    // ensures all parameters are correct\n    assertIsType(type, [1, 2]);\n    assertIsString(name, 1);\n    assertIsFunction(predicate, [2, 3]);\n    assertIsFunction(message, [3, 4]);\n    return new Refinement(name, type, predicate, message);\n}\n/**\n * Returns if a given value is a refinement type.\n *\n * @param type\n * @returns\n */\nfunction isRefinementType(type) {\n    return (type.flags & TypeFlags.Refinement) > 0;\n}\n\n/**\n * `types.enumeration` - Can be used to create an string based enumeration.\n * (note: this methods is just sugar for a union of string literals)\n *\n * Example:\n * ```ts\n * const TrafficLight = types.model({\n *   color: types.enumeration(\"Color\", [\"Red\", \"Orange\", \"Green\"])\n * })\n * ```\n *\n * @param name descriptive name of the enumeration (optional)\n * @param options possible values this enumeration can have\n * @returns\n */\nfunction enumeration(name, options) {\n    const realOptions = typeof name === \"string\" ? options : name;\n    // check all options\n    if (devMode()) {\n        realOptions.forEach((option, i) => {\n            assertIsString(option, i + 1);\n        });\n    }\n    const type = union(...realOptions.map(option => literal(\"\" + option)));\n    if (typeof name === \"string\") {\n        type.name = name;\n    }\n    return type;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Union extends BaseType {\n    _types;\n    _dispatcher;\n    _eager = true;\n    get flags() {\n        let result = TypeFlags.Union;\n        this._types.forEach(type => {\n            result |= type.flags;\n        });\n        return result;\n    }\n    constructor(name, _types, options) {\n        super(name);\n        this._types = _types;\n        options = {\n            eager: true,\n            dispatcher: undefined,\n            ...options\n        };\n        this._dispatcher = options.dispatcher;\n        if (!options.eager) {\n            this._eager = false;\n        }\n    }\n    isAssignableFrom(type) {\n        return this._types.some(subType => subType.isAssignableFrom(type));\n    }\n    describe() {\n        return (\"(\" + this._types.map(factory => factory.describe()).join(\" | \") + \")\");\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const type = this.determineType(initialValue, undefined);\n        if (!type) {\n            throw fail(\"No matching type for union \" + this.describe());\n        } // can happen in prod builds\n        return type.instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const type = this.determineType(newValue, current.getReconciliationType());\n        if (!type) {\n            throw fail(\"No matching type for union \" + this.describe());\n        } // can happen in prod builds\n        return type.reconcile(current, newValue, parent, subpath);\n    }\n    determineType(value, reconcileCurrentType) {\n        // try the dispatcher, if defined\n        if (this._dispatcher) {\n            return this._dispatcher(value);\n        }\n        // fast path: when type checking is disabled, try quick structural matching first\n        if (!isTypeCheckingEnabled()) {\n            const quickMatch = this.tryQuickMatch(value, reconcileCurrentType);\n            if (quickMatch) {\n                return quickMatch;\n            }\n            // for plain object snapshots that didn't match via quick path, try all types\n            // with quick matching before falling back to full validation\n            // (state tree nodes must go through full validation for type identity checks)\n            if (isPlainObject(value) && !isStateTreeNode(value)) {\n                for (const type of this._types) {\n                    if (this.snapshotLooksLikeType(value, type)) {\n                        return type;\n                    }\n                }\n            }\n        }\n        // find the most accomodating type\n        // if we are using reconciliation try the current node type first (fix for #1045)\n        if (reconcileCurrentType) {\n            if (reconcileCurrentType.is(value)) {\n                return reconcileCurrentType;\n            }\n            return this._types\n                .filter(t => t !== reconcileCurrentType)\n                .find(type => type.is(value));\n        }\n        else {\n            return this._types.find(type => type.is(value));\n        }\n    }\n    tryQuickMatch(value, reconcileCurrentType) {\n        // state tree nodes need full type compatibility checking\n        // (e.g., A.is(B.create()) must return false even if snapshots are compatible)\n        if (isStateTreeNode(value)) {\n            return undefined;\n        }\n        // for non-object values, try primitive matching\n        if (!isPlainObject(value)) {\n            return this.tryMatchPrimitive(value);\n        }\n        // for objects, try structural matching against model types\n        const typesToCheck = reconcileCurrentType\n            ? [\n                reconcileCurrentType,\n                ...this._types.filter(t => t !== reconcileCurrentType)\n            ]\n            : this._types;\n        for (const type of typesToCheck) {\n            if (this.snapshotLooksLikeType(value, type)) {\n                return type;\n            }\n        }\n        return undefined;\n    }\n    tryMatchPrimitive(value) {\n        const valueType = typeof value;\n        for (const type of this._types) {\n            const flags = type.flags;\n            if ((valueType === \"string\" && flags & TypeFlags.String) ||\n                (valueType === \"number\" &&\n                    flags &\n                        (TypeFlags.Number |\n                            TypeFlags.Integer |\n                            TypeFlags.Float |\n                            TypeFlags.Finite)) ||\n                (valueType === \"boolean\" && flags & TypeFlags.Boolean) ||\n                (value === null && flags & TypeFlags.Null) ||\n                (value === undefined && flags & TypeFlags.Undefined)) {\n                return type;\n            }\n            // for literals, check exact value match\n            if (flags & TypeFlags.Literal) {\n                if (type.is(value)) {\n                    return type;\n                }\n            }\n        }\n        return undefined;\n    }\n    snapshotLooksLikeType(value, type) {\n        // for model types, check if snapshot has all the required property keys\n        // and that any literal-typed properties match exactly\n        if (type instanceof ModelType) {\n            const props = type.properties;\n            // use cached propertyNames from ModelType instead of Object.keys()\n            for (const key of type.propertyNames) {\n                const propType = props[key];\n                const isOptional = propType.flags & TypeFlags.Optional;\n                const propValue = value[key];\n                // check required properties exist and are not undefined\n                // (unless the type accepts undefined, which Optional types do)\n                if (!isOptional) {\n                    if (!(key in value) || propValue === undefined) {\n                        return false;\n                    }\n                }\n                // for literal types, verify the value matches exactly\n                // this is critical for discriminated unions\n                if (propType.flags & TypeFlags.Literal) {\n                    if (!propType.is(propValue)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    isValidSnapshot(value, context) {\n        if (this._dispatcher) {\n            return this._dispatcher(value).validate(value, context);\n        }\n        const allErrors = [];\n        let applicableTypes = 0;\n        for (let i = 0; i < this._types.length; i++) {\n            const type = this._types[i];\n            const errors = type.validate(value, context);\n            if (errors.length === 0) {\n                if (this._eager) {\n                    return typeCheckSuccess();\n                }\n                else {\n                    applicableTypes++;\n                }\n            }\n            else {\n                allErrors.push(errors);\n            }\n        }\n        if (applicableTypes === 1) {\n            return typeCheckSuccess();\n        }\n        return typeCheckFailure(context, value, \"No type is applicable for the union\").concat(flattenTypeErrors(allErrors));\n    }\n    getSubTypes() {\n        return this._types;\n    }\n}\n/**\n * `types.union` - Create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form `(snapshot) => Type`.\n *\n * @param optionsOrType\n * @param otherTypes\n * @returns\n */\nfunction union(optionsOrType, ...otherTypes) {\n    const options = isType(optionsOrType) ? undefined : optionsOrType;\n    const types = isType(optionsOrType)\n        ? [optionsOrType, ...otherTypes]\n        : otherTypes;\n    const name = \"(\" + types.map(type => type.name).join(\" | \") + \")\";\n    // check all options\n    if (devMode()) {\n        if (options) {\n            assertArg(options, o => isPlainObject(o), \"object { eager?: boolean, dispatcher?: Function }\", 1);\n        }\n        types.forEach((type, i) => {\n            assertIsType(type, options ? i + 2 : i + 1);\n        });\n    }\n    return new Union(name, types, options);\n}\n/**\n * Returns if a given value represents a union type.\n *\n * @param type\n * @returns\n */\nfunction isUnionType(type) {\n    return (type.flags & TypeFlags.Union) > 0;\n}\n\n/**\n * @hidden\n * @internal\n */\nclass OptionalValue extends BaseType {\n    _subtype;\n    _defaultValue;\n    optionalValues;\n    get flags() {\n        return this._subtype.flags | TypeFlags.Optional;\n    }\n    constructor(_subtype, _defaultValue, optionalValues) {\n        super(_subtype.name);\n        this._subtype = _subtype;\n        this._defaultValue = _defaultValue;\n        this.optionalValues = optionalValues;\n    }\n    describe() {\n        return this._subtype.describe() + \"?\";\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        if (this.optionalValues.indexOf(initialValue) >= 0) {\n            const defaultInstanceOrSnapshot = this.getDefaultInstanceOrSnapshot();\n            return this._subtype.instantiate(parent, subpath, environment, defaultInstanceOrSnapshot);\n        }\n        return this._subtype.instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this._subtype.reconcile(current, this.optionalValues.indexOf(newValue) < 0 && this._subtype.is(newValue)\n            ? newValue\n            : this.getDefaultInstanceOrSnapshot(), parent, subpath);\n    }\n    getDefaultInstanceOrSnapshot() {\n        const defaultInstanceOrSnapshot = typeof this._defaultValue === \"function\"\n            ? this._defaultValue()\n            : this._defaultValue;\n        // while static values are already snapshots and checked on types.optional\n        // generator functions must always be rechecked just in case\n        if (typeof this._defaultValue === \"function\") {\n            typecheckInternal(this, defaultInstanceOrSnapshot);\n        }\n        return defaultInstanceOrSnapshot;\n    }\n    isValidSnapshot(value, context) {\n        // defaulted values can be skipped\n        if (this.optionalValues.indexOf(value) >= 0) {\n            return typeCheckSuccess();\n        }\n        // bounce validation to the sub-type\n        return this._subtype.validate(value, context);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n}\nfunction checkOptionalPreconditions(type, defaultValueOrFunction) {\n    // make sure we never pass direct instances\n    if (typeof defaultValueOrFunction !== \"function\" &&\n        isStateTreeNode(defaultValueOrFunction)) {\n        throw fail(\"default value cannot be an instance, pass a snapshot or a function that creates an instance/snapshot instead\");\n    }\n    assertIsType(type, 1);\n    if (devMode()) {\n        // we only check default values if they are passed directly\n        // if they are generator functions they will be checked once they are generated\n        // we don't check generator function results here to avoid generating a node just for type-checking purposes\n        // which might generate side-effects\n        if (typeof defaultValueOrFunction !== \"function\") {\n            typecheckInternal(type, defaultValueOrFunction);\n        }\n    }\n}\n/**\n * `types.optional` - Can be used to create a property with a default value.\n *\n * Depending on the third argument (`optionalValues`) there are two ways of operation:\n * - If the argument is not provided, then if a value is not provided in the snapshot (`undefined` or missing),\n *   it will default to the provided `defaultValue`\n * - If the argument is provided, then if the value in the snapshot matches one of the optional values inside the array then it will\n *   default to the provided `defaultValue`. Additionally, if one of the optional values inside the array is `undefined` then a missing\n *   property is also valid.\n *\n *   Note that it is also possible to include values of the same type as the intended subtype as optional values,\n *   in this case the optional value will be transformed into the `defaultValue` (e.g. `types.optional(types.string, \"unnamed\", [undefined, \"\"])`\n *   will transform the snapshot values `undefined` (and therefore missing) and empty strings into the string `\"unnamed\"` when it gets\n *   instantiated).\n *\n * If `defaultValue` is a function, the function will be invoked for every new instance.\n * Applying a snapshot in which the optional value is one of the optional values (or `undefined`/_not_ present if none are provided) causes the\n * value to be reset.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string,\n *   subtitle1: types.optional(types.string, \"\", [null]),\n *   subtitle2: types.optional(types.string, \"\", [null, undefined]),\n *   done: types.optional(types.boolean, false),\n *   created: types.optional(types.Date, () => new Date()),\n * })\n *\n * // if done is missing / undefined it will become false\n * // if created is missing / undefined it will get a freshly generated timestamp\n * // if subtitle1 is null it will default to \"\", but it cannot be missing or undefined\n * // if subtitle2 is null or undefined it will default to \"\"; since it can be undefined it can also be missing\n * const todo = Todo.create({ title: \"Get coffee\", subtitle1: null })\n * ```\n *\n * @param type\n * @param defaultValueOrFunction\n * @param optionalValues an optional array with zero or more primitive values (string, number, boolean, null or undefined)\n *                       that will be converted into the default. `[ undefined ]` is assumed when none is provided\n * @returns\n */\nfunction optional(type, defaultValueOrFunction, optionalValues) {\n    checkOptionalPreconditions(type, defaultValueOrFunction);\n    return new OptionalValue(type, defaultValueOrFunction, optionalValues ? optionalValues : undefinedAsOptionalValues);\n}\nconst undefinedAsOptionalValues = [undefined];\n/**\n * Returns if a value represents an optional type.\n *\n * @template IT\n * @param type\n * @returns\n */\nfunction isOptionalType(type) {\n    return isType(type) && (type.flags & TypeFlags.Optional) > 0;\n}\n\nconst optionalUndefinedType = optional(undefinedType, undefined);\nconst optionalNullType = optional(nullType, null);\n/**\n * `types.maybe` - Maybe will make a type nullable, and also optional.\n * The value `undefined` will be used to represent nullability.\n *\n * @param type\n * @returns\n */\nfunction maybe(type) {\n    assertIsType(type, 1);\n    return union(type, optionalUndefinedType);\n}\n/**\n * `types.maybeNull` - Maybe will make a type nullable, and also optional.\n * The value `null` will be used to represent no value.\n *\n * @param type\n * @returns\n */\nfunction maybeNull(type) {\n    assertIsType(type, 1);\n    return union(type, optionalNullType);\n}\n\nclass Late extends BaseType {\n    _definition;\n    _subType;\n    get flags() {\n        return (this._subType ? this._subType.flags : 0) | TypeFlags.Late;\n    }\n    getSubType(mustSucceed) {\n        if (!this._subType) {\n            let t = undefined;\n            try {\n                t = this._definition();\n            }\n            catch (e) {\n                if (e instanceof ReferenceError) // can happen in strict ES5 code when a definition is self refering\n                 {\n                    t = undefined;\n                }\n                else {\n                    throw e;\n                }\n            }\n            if (mustSucceed && t === undefined) {\n                throw fail(\"Late type seems to be used too early, the definition (still) returns undefined\");\n            }\n            if (t) {\n                if (devMode() && !isType(t)) {\n                    throw fail(\"Failed to determine subtype, make sure types.late returns a type definition.\");\n                }\n                this._subType = t;\n            }\n        }\n        return this._subType;\n    }\n    constructor(name, _definition) {\n        super(name);\n        this._definition = _definition;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return this.getSubType(true).instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this.getSubType(true).reconcile(current, newValue, parent, subpath);\n    }\n    describe() {\n        const t = this.getSubType(false);\n        return t ? t.name : \"<uknown late type>\";\n    }\n    isValidSnapshot(value, context) {\n        const t = this.getSubType(false);\n        if (!t) {\n            // See #916; the variable the definition closure is pointing to wasn't defined yet, so can't be evaluted yet here\n            return typeCheckSuccess();\n        }\n        return t.validate(value, context);\n    }\n    isAssignableFrom(type) {\n        const t = this.getSubType(false);\n        return t ? t.isAssignableFrom(type) : false;\n    }\n    getSubTypes() {\n        const subtype = this.getSubType(false);\n        return subtype ? subtype : cannotDetermineSubtype;\n    }\n}\n/**\n * `types.late` - Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.\n * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.\n *\n * Example:\n * ```ts\n *   // TypeScript isn't smart enough to infer self referencing types.\n *  const Node = types.model({\n *       children: types.array(types.late((): IAnyModelType => Node)) // then typecast each array element to Instance<typeof Node>\n *  })\n * ```\n *\n * @param name The name to use for the type that will be returned.\n * @param type A function that returns the type that will be defined.\n * @returns\n */\nfunction late(nameOrType, maybeType) {\n    const name = typeof nameOrType === \"string\"\n        ? nameOrType\n        : `late(${nameOrType.toString()})`;\n    const type = typeof nameOrType === \"string\" ? maybeType : nameOrType;\n    // checks that the type is actually a late type\n    if (devMode()) {\n        if (!(typeof type === \"function\" && type.length === 0)) {\n            throw fail(\"Invalid late type, expected a function with zero arguments that returns a type, got: \" +\n                type);\n        }\n    }\n    return new Late(name, type);\n}\n/**\n * Returns if a given value represents a late type.\n *\n * @param type\n * @returns\n */\nfunction isLateType(type) {\n    return isType(type) && (type.flags & TypeFlags.Late) > 0;\n}\n\nfunction lazy(name, options) {\n    // TODO: fix this unknown casting to be stricter\n    return new Lazy(name, options);\n}\n/**\n * @internal\n * @hidden\n */\nclass Lazy extends SimpleType {\n    options;\n    flags = TypeFlags.Lazy;\n    loadedType = null;\n    pendingNodeList = observable.array();\n    constructor(name, options) {\n        super(name);\n        this.options = options;\n        when(() => this.pendingNodeList.length > 0 &&\n            this.pendingNodeList.some(node => node.isAlive &&\n                this.options.shouldLoadPredicate(node.parent ? node.parent.value : null)), () => {\n            this.options.loadType().then(action((type) => {\n                this.loadedType = type;\n                this.pendingNodeList.forEach(node => {\n                    if (!node.parent) {\n                        return;\n                    }\n                    if (!this.loadedType) {\n                        return;\n                    }\n                    node.parent.applyPatches([\n                        {\n                            op: \"replace\",\n                            path: `/${node.subpath}`,\n                            value: node.snapshot\n                        }\n                    ]);\n                });\n            }));\n        });\n    }\n    describe() {\n        return `<lazy ${this.name}>`;\n    }\n    instantiate(parent, subpath, environment, value) {\n        if (this.loadedType) {\n            return this.loadedType.instantiate(parent, subpath, environment, value);\n        }\n        const node = createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n        this.pendingNodeList.push(node);\n        when(() => !node.isAlive, () => this.pendingNodeList.splice(this.pendingNodeList.indexOf(node), 1));\n        return node;\n    }\n    isValidSnapshot(value, context) {\n        if (this.loadedType) {\n            return this.loadedType.validate(value, context);\n        }\n        if (!isSerializable(value)) {\n            return typeCheckFailure(context, value, \"Value is not serializable and cannot be lazy\");\n        }\n        return typeCheckSuccess();\n    }\n    reconcile(current, value, parent, subpath) {\n        if (this.loadedType) {\n            current.die();\n            return this.loadedType.instantiate(parent, subpath, parent.environment, value);\n        }\n        return super.reconcile(current, value, parent, subpath);\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Frozen extends SimpleType {\n    subType;\n    flags = TypeFlags.Frozen;\n    constructor(subType) {\n        super(subType ? `frozen(${subType.name})` : \"frozen\");\n        this.subType = subType;\n    }\n    describe() {\n        return \"<any immutable value>\";\n    }\n    instantiate(parent, subpath, environment, value) {\n        // create the node\n        return createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n    }\n    isValidSnapshot(value, context) {\n        if (!isSerializable(value)) {\n            return typeCheckFailure(context, value, \"Value is not serializable and cannot be frozen\");\n        }\n        if (this.subType) {\n            return this.subType.validate(value, context);\n        }\n        return typeCheckSuccess();\n    }\n}\nconst untypedFrozenInstance = new Frozen();\n/**\n * `types.frozen` - Frozen can be used to store any value that is serializable in itself (that is valid JSON).\n * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.\n * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.\n *\n * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.\n *\n * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.\n *\n * Frozen properties can be defined in three different ways\n * 1. `types.frozen(SubType)` - provide a valid MST type and frozen will check if the provided data conforms the snapshot for that type\n * 2. `types.frozen({ someDefaultValue: true})` - provide a primitive value, object or array, and MST will infer the type from that object, and also make it the default value for the field\n * 3. `types.frozen<TypeScriptType>()` - provide a typescript type, to help in strongly typing the field (design time only)\n *\n * Example:\n * ```ts\n * const GameCharacter = types.model({\n *   name: string,\n *   location: types.frozen({ x: 0, y: 0})\n * })\n *\n * const hero = GameCharacter.create({\n *   name: \"Mario\",\n *   location: { x: 7, y: 4 }\n * })\n *\n * hero.location = { x: 10, y: 2 } // OK\n * hero.location.x = 7 // Not ok!\n * ```\n *\n * ```ts\n * type Point = { x: number, y: number }\n *    const Mouse = types.model({\n *         loc: types.frozen<Point>()\n *    })\n * ```\n *\n * @param defaultValueOrType\n * @returns\n */\nfunction frozen(arg) {\n    if (arguments.length === 0) {\n        return untypedFrozenInstance;\n    }\n    else if (isType(arg)) {\n        return new Frozen(arg);\n    }\n    else {\n        return optional(untypedFrozenInstance, arg);\n    }\n}\n/**\n * Returns if a given value represents a frozen type.\n *\n * @param type\n * @returns\n */\nfunction isFrozenType(type) {\n    return isType(type) && (type.flags & TypeFlags.Frozen) > 0;\n}\n\nfunction getInvalidationCause(hook) {\n    switch (hook) {\n        case Hook.beforeDestroy:\n            return \"destroy\";\n        case Hook.beforeDetach:\n            return \"detach\";\n        default:\n            return undefined;\n    }\n}\nclass StoredReference {\n    targetType;\n    identifier;\n    node;\n    resolvedReference;\n    constructor(value, targetType) {\n        this.targetType = targetType;\n        if (isValidIdentifier(value)) {\n            this.identifier = value;\n        }\n        else if (isStateTreeNode(value)) {\n            const targetNode = getStateTreeNode(value);\n            if (!targetNode.identifierAttribute) {\n                throw fail(`Can only store references with a defined identifier attribute.`);\n            }\n            const id = targetNode.unnormalizedIdentifier;\n            if (id === null || id === undefined) {\n                throw fail(`Can only store references to tree nodes with a defined identifier.`);\n            }\n            this.identifier = id;\n        }\n        else {\n            throw fail(`Can only store references to tree nodes or identifiers, got: '${value}'`);\n        }\n    }\n    updateResolvedReference(node) {\n        const normalizedId = normalizeIdentifier(this.identifier);\n        const root = node.root;\n        const lastCacheModification = root.identifierCache.getLastCacheModificationPerId(normalizedId);\n        if (!this.resolvedReference ||\n            this.resolvedReference.lastCacheModification !== lastCacheModification) {\n            const { targetType } = this;\n            // reference was initialized with the identifier of the target\n            const target = root.identifierCache.resolve(targetType, normalizedId);\n            if (!target) {\n                throw new InvalidReferenceError(`[mobx-state-tree] Failed to resolve reference '${this.identifier}' to type '${this.targetType.name}' (from node: ${node.path})`);\n            }\n            this.resolvedReference = {\n                node: target,\n                lastCacheModification: lastCacheModification\n            };\n        }\n    }\n    get resolvedValue() {\n        this.updateResolvedReference(this.node);\n        return this.resolvedReference.node.value;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass InvalidReferenceError extends Error {\n    constructor(m) {\n        super(m);\n        Object.setPrototypeOf(this, InvalidReferenceError.prototype);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass BaseReferenceType extends SimpleType {\n    targetType;\n    onInvalidated;\n    flags = TypeFlags.Reference;\n    constructor(targetType, onInvalidated) {\n        super(`reference(${targetType.name})`);\n        this.targetType = targetType;\n        this.onInvalidated = onInvalidated;\n    }\n    describe() {\n        return this.name;\n    }\n    isAssignableFrom(type) {\n        return this.targetType.isAssignableFrom(type);\n    }\n    isValidSnapshot(value, context) {\n        return isValidIdentifier(value)\n            ? typeCheckSuccess()\n            : typeCheckFailure(context, value, \"Value is not a valid identifier, which is a string or a number\");\n    }\n    fireInvalidated(cause, storedRefNode, referenceId, refTargetNode) {\n        // to actually invalidate a reference we need an alive parent,\n        // since it is a scalar value (immutable-ish) and we need to change it\n        // from the parent\n        const storedRefParentNode = storedRefNode.parent;\n        if (!storedRefParentNode || !storedRefParentNode.isAlive) {\n            return;\n        }\n        const storedRefParentValue = storedRefParentNode.storedValue;\n        if (!storedRefParentValue) {\n            return;\n        }\n        this.onInvalidated({\n            cause,\n            parent: storedRefParentValue,\n            invalidTarget: refTargetNode ? refTargetNode.storedValue : undefined,\n            invalidId: referenceId,\n            replaceRef(newRef) {\n                applyPatch(storedRefNode.root.storedValue, {\n                    op: \"replace\",\n                    value: newRef,\n                    path: storedRefNode.path\n                });\n            },\n            removeRef() {\n                if (isModelType(storedRefParentNode.type)) {\n                    this.replaceRef(undefined);\n                }\n                else {\n                    applyPatch(storedRefNode.root.storedValue, {\n                        op: \"remove\",\n                        path: storedRefNode.path\n                    });\n                }\n            }\n        });\n    }\n    addTargetNodeWatcher(storedRefNode, referenceId) {\n        // this will make sure the target node becomes created\n        const refTargetValue = this.getValue(storedRefNode);\n        if (!refTargetValue) {\n            return undefined;\n        }\n        const refTargetNode = getStateTreeNode(refTargetValue);\n        const hookHandler = (_, refTargetNodeHook) => {\n            const cause = getInvalidationCause(refTargetNodeHook);\n            if (!cause) {\n                return;\n            }\n            this.fireInvalidated(cause, storedRefNode, referenceId, refTargetNode);\n        };\n        const refTargetDetachHookDisposer = refTargetNode.registerHook(Hook.beforeDetach, hookHandler);\n        const refTargetDestroyHookDisposer = refTargetNode.registerHook(Hook.beforeDestroy, hookHandler);\n        return () => {\n            refTargetDetachHookDisposer();\n            refTargetDestroyHookDisposer();\n        };\n    }\n    watchTargetNodeForInvalidations(storedRefNode, identifier, customGetSet) {\n        if (!this.onInvalidated) {\n            return;\n        }\n        let onRefTargetDestroyedHookDisposer;\n        // get rid of the watcher hook when the stored ref node is destroyed\n        // detached is ignored since scalar nodes (where the reference resides) cannot be detached\n        storedRefNode.registerHook(Hook.beforeDestroy, () => {\n            if (onRefTargetDestroyedHookDisposer) {\n                onRefTargetDestroyedHookDisposer();\n            }\n        });\n        const startWatching = (sync) => {\n            // re-create hook in case the stored ref gets reattached\n            if (onRefTargetDestroyedHookDisposer) {\n                onRefTargetDestroyedHookDisposer();\n            }\n            // make sure the target node is actually there and initialized\n            const storedRefParentNode = storedRefNode.parent;\n            const storedRefParentValue = storedRefParentNode && storedRefParentNode.storedValue;\n            if (storedRefParentNode &&\n                storedRefParentNode.isAlive &&\n                storedRefParentValue) {\n                let refTargetNodeExists;\n                if (customGetSet) {\n                    refTargetNodeExists = !!customGetSet.get(identifier, storedRefParentValue);\n                }\n                else {\n                    refTargetNodeExists = storedRefNode.root.identifierCache.has(this.targetType, normalizeIdentifier(identifier));\n                }\n                if (!refTargetNodeExists) {\n                    // we cannot change the reference in sync mode\n                    // since we are in the middle of a reconciliation/instantiation and the change would be overwritten\n                    // for those cases just let the wrong reference be assigned and fail upon usage\n                    // (like current references do)\n                    // this means that effectively this code will only run when it is created from a snapshot\n                    if (!sync) {\n                        this.fireInvalidated(\"invalidSnapshotReference\", storedRefNode, identifier, null);\n                    }\n                }\n                else {\n                    onRefTargetDestroyedHookDisposer = this.addTargetNodeWatcher(storedRefNode, identifier);\n                }\n            }\n        };\n        if (storedRefNode.state === NodeLifeCycle.FINALIZED) {\n            // already attached, so the whole tree is ready\n            startWatching(true);\n        }\n        else {\n            if (!storedRefNode.isRoot) {\n                // start watching once the whole tree is ready\n                storedRefNode.root.registerHook(Hook.afterCreationFinalization, () => {\n                    // make sure to attach it so it can start listening\n                    if (storedRefNode.parent) {\n                        storedRefNode.parent.createObservableInstanceIfNeeded();\n                    }\n                });\n            }\n            // start watching once the node is attached somewhere / parent changes\n            storedRefNode.registerHook(Hook.afterAttach, () => {\n                startWatching(false);\n            });\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierReferenceType extends BaseReferenceType {\n    constructor(targetType, onInvalidated) {\n        super(targetType, onInvalidated);\n    }\n    getValue(storedRefNode) {\n        if (!storedRefNode.isAlive) {\n            return undefined;\n        }\n        const storedRef = storedRefNode.storedValue;\n        return storedRef.resolvedValue;\n    }\n    getSnapshot(storedRefNode) {\n        const ref = storedRefNode.storedValue;\n        return ref.identifier;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const identifier = isStateTreeNode(initialValue)\n            ? getIdentifier(initialValue)\n            : initialValue;\n        const storedRef = new StoredReference(initialValue, this.targetType);\n        const storedRefNode = createScalarNode(this, parent, subpath, environment, storedRef);\n        storedRef.node = storedRefNode;\n        this.watchTargetNodeForInvalidations(storedRefNode, identifier, undefined);\n        return storedRefNode;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        if (!current.isDetaching && current.type === this) {\n            const compareByValue = isStateTreeNode(newValue);\n            const ref = current.storedValue;\n            if ((!compareByValue && ref.identifier === newValue) ||\n                (compareByValue && ref.resolvedValue === newValue)) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n        }\n        const newNode = this.instantiate(parent, subpath, undefined, newValue);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass CustomReferenceType extends BaseReferenceType {\n    options;\n    constructor(targetType, options, onInvalidated) {\n        super(targetType, onInvalidated);\n        this.options = options;\n    }\n    getValue(storedRefNode) {\n        if (!storedRefNode.isAlive) {\n            return undefined;\n        }\n        const referencedNode = this.options.get(storedRefNode.storedValue, storedRefNode.parent ? storedRefNode.parent.storedValue : null);\n        return referencedNode;\n    }\n    getSnapshot(storedRefNode) {\n        return storedRefNode.storedValue;\n    }\n    instantiate(parent, subpath, environment, newValue) {\n        const identifier = isStateTreeNode(newValue)\n            ? this.options.set(newValue, parent ? parent.storedValue : null)\n            : newValue;\n        const storedRefNode = createScalarNode(this, parent, subpath, environment, identifier);\n        this.watchTargetNodeForInvalidations(storedRefNode, identifier, this.options);\n        return storedRefNode;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const newIdentifier = isStateTreeNode(newValue)\n            ? this.options.set(newValue, current ? current.storedValue : null)\n            : newValue;\n        if (!current.isDetaching &&\n            current.type === this &&\n            current.storedValue === newIdentifier) {\n            current.setParent(parent, subpath);\n            return current;\n        }\n        const newNode = this.instantiate(parent, subpath, undefined, newIdentifier);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n/**\n * `types.reference` - Creates a reference to another type, which should have defined an identifier.\n * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.\n */\nfunction reference(subType, options) {\n    assertIsType(subType, 1);\n    if (devMode()) {\n        if (arguments.length === 2 && typeof arguments[1] === \"string\") {\n            // istanbul ignore next\n            throw fail(\"References with base path are no longer supported. Please remove the base path.\");\n        }\n    }\n    const getSetOptions = options\n        ? options\n        : undefined;\n    const onInvalidated = options\n        ? options.onInvalidated\n        : undefined;\n    if (getSetOptions && (getSetOptions.get || getSetOptions.set)) {\n        if (devMode()) {\n            if (!getSetOptions.get || !getSetOptions.set) {\n                throw fail(\"reference options must either contain both a 'get' and a 'set' method or none of them\");\n            }\n        }\n        return new CustomReferenceType(subType, {\n            get: getSetOptions.get,\n            set: getSetOptions.set\n        }, onInvalidated);\n    }\n    else {\n        return new IdentifierReferenceType(subType, onInvalidated);\n    }\n}\n/**\n * Returns if a given value represents a reference type.\n *\n * @param type\n * @returns\n */\nfunction isReferenceType(type) {\n    return (type.flags & TypeFlags.Reference) > 0;\n}\n/**\n * `types.safeReference` - A safe reference is like a standard reference, except that it accepts the undefined value by default\n * and automatically sets itself to undefined (when the parent is a model) / removes itself from arrays and maps\n * when the reference it is pointing to gets detached/destroyed.\n *\n * The optional options parameter object accepts a parameter named `acceptsUndefined`, which is set to true by default, so it is suitable\n * for model properties.\n * When used inside collections (arrays/maps), it is recommended to set this option to false so it can't take undefined as value,\n * which is usually the desired in those cases.\n * Additionally, the optional options parameter object accepts a parameter named `onInvalidated`, which will be called when the reference target node that the reference is pointing to is about to be detached/destroyed\n *\n * Strictly speaking it is a `types.maybe(types.reference(X))` (when `acceptsUndefined` is set to true, the default) and\n * `types.reference(X)` (when `acceptsUndefined` is set to false), both of them with a customized `onInvalidated` option.\n *\n * @param subType\n * @param options\n * @returns\n */\nfunction safeReference(subType, options) {\n    const refType = reference(subType, {\n        ...options,\n        onInvalidated(ev) {\n            if (options && options.onInvalidated) {\n                options.onInvalidated(ev);\n            }\n            ev.removeRef();\n        }\n    });\n    if (options && options.acceptsUndefined === false) {\n        return refType;\n    }\n    else {\n        return maybe(refType);\n    }\n}\n\nclass BaseIdentifierType extends SimpleType {\n    validType;\n    flags = TypeFlags.Identifier;\n    constructor(name, validType) {\n        super(name);\n        this.validType = validType;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        if (!parent || !(parent.type instanceof ModelType)) {\n            throw fail(`Identifier types can only be instantiated as direct child of a model type`);\n        }\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        // we don't consider detaching here since identifier are scalar nodes, and scalar nodes cannot be detached\n        if (current.storedValue !== newValue) {\n            throw fail(`Tried to change identifier from '${current.storedValue}' to '${newValue}'. Changing identifiers is not allowed.`);\n        }\n        current.setParent(parent, subpath);\n        return current;\n    }\n    isValidSnapshot(value, context) {\n        if (typeof value !== this.validType) {\n            return typeCheckFailure(context, value, `Value is not a valid ${this.describe()}, expected a ${this.validType}`);\n        }\n        return typeCheckSuccess();\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierType extends BaseIdentifierType {\n    flags = TypeFlags.Identifier;\n    constructor() {\n        super(`identifier`, \"string\");\n    }\n    describe() {\n        return `identifier`;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierNumberType extends BaseIdentifierType {\n    constructor() {\n        super(\"identifierNumber\", \"number\");\n    }\n    getSnapshot(node) {\n        return node.storedValue;\n    }\n    describe() {\n        return `identifierNumber`;\n    }\n}\n/**\n * `types.identifier` - Identifiers are used to make references, lifecycle events and reconciling works.\n * Inside a state tree, for each type can exist only one instance for each given identifier.\n * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.\n * Identifier can be used only as type property of a model.\n * This type accepts as parameter the value type of the identifier field that can be either string or number.\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifier,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nconst identifier = new IdentifierType();\n/**\n * `types.identifierNumber` - Similar to `types.identifier`. This one will serialize from / to a number when applying snapshots\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifierNumber,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nconst identifierNumber = new IdentifierNumberType();\n/**\n * Returns if a given value represents an identifier type.\n *\n * @param type\n * @returns\n */\nfunction isIdentifierType(type) {\n    return isType(type) && (type.flags & TypeFlags.Identifier) > 0;\n}\n/**\n * @internal\n * @hidden\n */\nfunction normalizeIdentifier(id) {\n    return \"\" + id;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isValidIdentifier(id) {\n    return typeof id === \"string\" || typeof id === \"number\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsValidIdentifier(id, argNumber) {\n    assertArg(id, isValidIdentifier, \"string or number (identifier)\", argNumber);\n}\n\n/**\n * `types.custom` - Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.\n *\n * The signature of the options is:\n * ```ts\n * export interface CustomTypeOptions<S, T> {\n *     // Friendly name\n *     name: string\n *     // given a serialized value and environment, how to turn it into the target type\n *     fromSnapshot(snapshot: S, env: any): T\n *     // return the serialization of the current value\n *     toSnapshot(value: T): S\n *     // if true, this is a converted value, if false, it's a snapshot\n *     isTargetType(value: T | S): value is T\n *     // a non empty string is assumed to be a validation error\n *     getValidationMessage?(snapshot: S): string\n * }\n * ```\n *\n * Example:\n * ```ts\n * const DecimalPrimitive = types.custom<string, Decimal>({\n *     name: \"Decimal\",\n *     fromSnapshot(value: string) {\n *         return new Decimal(value)\n *     },\n *     toSnapshot(value: Decimal) {\n *         return value.toString()\n *     },\n *     isTargetType(value: string | Decimal): boolean {\n *         return value instanceof Decimal\n *     },\n *     getValidationMessage(value: string): string {\n *         if (/^-?\\d+\\.\\d+$/.test(value)) return \"\" // OK\n *         return `'${value}' doesn't look like a valid decimal number`\n *     }\n * })\n *\n * const Wallet = types.model({\n *     balance: DecimalPrimitive\n * })\n * ```\n *\n * @param options\n * @returns\n */\nfunction custom(options) {\n    return new CustomType(options);\n}\n/**\n * @internal\n * @hidden\n */\nclass CustomType extends SimpleType {\n    options;\n    flags = TypeFlags.Custom;\n    constructor(options) {\n        super(options.name);\n        this.options = options;\n    }\n    describe() {\n        return this.name;\n    }\n    isValidSnapshot(value, context) {\n        if (this.options.isTargetType(value)) {\n            return typeCheckSuccess();\n        }\n        const typeError = this.options.getValidationMessage(value);\n        if (typeError) {\n            return typeCheckFailure(context, value, `Invalid value for type '${this.name}': ${typeError}`);\n        }\n        return typeCheckSuccess();\n    }\n    getSnapshot(node) {\n        return this.options.toSnapshot(node.storedValue);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const valueToStore = this.options.isTargetType(initialValue)\n            ? initialValue\n            : this.options.fromSnapshot(initialValue, parent && parent.root.environment);\n        return createScalarNode(this, parent, subpath, environment, valueToStore);\n    }\n    reconcile(current, value, parent, subpath) {\n        const isSnapshot = !this.options.isTargetType(value);\n        // in theory customs use scalar nodes which cannot be detached, but still...\n        if (!current.isDetaching) {\n            const unchanged = current.type === this &&\n                (isSnapshot\n                    ? value === current.snapshot\n                    : value === current.storedValue);\n            if (unchanged) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n        }\n        const valueToStore = isSnapshot\n            ? this.options.fromSnapshot(value, parent.root.environment)\n            : value;\n        const newNode = this.instantiate(parent, subpath, undefined, valueToStore);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n\n// we import the types to re-export them inside types.\nconst types = {\n    enumeration,\n    model,\n    compose,\n    custom,\n    reference,\n    safeReference,\n    union,\n    optional,\n    literal,\n    maybe,\n    maybeNull,\n    refinement,\n    string,\n    boolean,\n    number,\n    integer,\n    float,\n    finite,\n    Date: DatePrimitive,\n    map,\n    array,\n    frozen,\n    identifier,\n    identifierNumber,\n    late,\n    lazy,\n    undefined: undefinedType,\n    null: nullType,\n    snapshotProcessor\n};\n\nexport { addDisposer, addMiddleware, applyAction, applyPatch, applySnapshot, cast, castFlowReturn, castToReferenceSnapshot, castToSnapshot, clone, createActionTrackingMiddleware, createActionTrackingMiddleware2, decorate, destroy, detach, escapeJsonPath, flow, getChildType, getEnv, getIdentifier, getLivelinessChecking, getMembers, getNodeId, getParent, getParentOfType, getPath, getPathParts, getPropertyMembers, getRelativePath, getRoot, getRunningActionContext, getSnapshot, getType, hasParent, hasParentOfType, isActionContextChildOf, isActionContextThisOrChildOf, isAlive, isArrayType, isFrozenType, isIdentifierType, isLateType, isLiteralType, isMapType, isModelType, isOptionalType, isPrimitiveType, isProtected, isReferenceType, isRefinementType, isRoot, isStateTreeNode, isType, isUnionType, isValidReference, joinJsonPath, onAction, onPatch, onSnapshot, process$1 as process, protect, recordActions, recordPatches, resolveIdentifier, resolvePath, setDevMode, setLivelinessChecking, setLivelynessChecking, splitJsonPath, types as t, toGenerator, toGeneratorFunction, tryReference, tryResolve, typecheck, types, unescapeJsonPath, unprotect, walk };\n"],"names":["instanceOfAny","object","constructors","some","c","idbProxyableTypes","cursorAdvanceMethods","transactionDoneMap","WeakMap","transformCache","reverseTransformCache","idbProxyTraps","get","target","prop","receiver","IDBTransaction","objectStoreNames","undefined","objectStore","wrap","set","value","has","replaceTraps","callback","transformCachableValue","func","IDBCursor","prototype","advance","continue","continuePrimaryKey","includes","args","apply","unwrap","this","request","tx","done","Promise","resolve","reject","unlisten","removeEventListener","complete","error","DOMException","addEventListener","cacheDonePromiseForTransaction","IDBDatabase","IDBObjectStore","IDBIndex","Proxy","IDBRequest","promise","success","result","promisifyRequest","newValue","openDB","name","version","blocked","upgrade","blocking","terminated","indexedDB","open","openPromise","event","oldVersion","newVersion","transaction","then","db","catch","readMethods","writeMethods","cachedMethods","Map","getMethod","targetFuncName","replace","useIndex","isWrite","method","async","storeName","store","index","shift","all","oldTraps","advanceMethodProps","methodMap","advanceResults","ittrProxiedCursorToOriginalProxy","cursorIteratorTraps","cachedFunc","iterate","cursor","openCursor","proxiedCursor","delete","isIteratorProp","Symbol","asyncIterator","getFabUtilityClass","slot","generateUtilityClass","generateUtilityClasses","createSvgIcon","_jsx","d","isDynamicSupport","globalCss","html","theme","enableColorScheme","WebkitFontSmoothing","MozOsxFontSmoothing","boxSizing","WebkitTextSizeAdjust","vars","colorScheme","palette","mode","body","color","text","primary","typography","body1","backgroundColor","background","default","common","white","styles","colorSchemeStyles","colorSchemes","getColorSchemeSelector","Object","entries","forEach","key","scheme","selector","startsWith","defaultStyles","fontWeight","fontWeightBold","margin","themeOverrides","components","MuiCssBaseline","styleOverrides","SELECTOR","GlobalStyles","baseStyles","Array","isArray","staticStyles","inProps","props","useDefaultProps","children","_jsxs","React","className","style","display","errorProperties","property","enumerable","toJsonWasCalled","WeakSet","newError","factory","errorFactories","ErrorConstructor","errorConstructors","Error","AggregateError","isErrorLike","message","stack","destroyCircular","from","seen","to","forceEnumerable","maxDepth","depth","useToJSON","serialize","push","toJSON","add","json","continueDestroyCircular","Uint8Array","constructor","pipe","val","defineProperty","configurable","writable","deserializeError","options","Number","POSITIVE_INFINITY","isMinimumViableSerializedError","NonError","counter","RpcClient","EventEmitter","worker","super","calls","errors","e","handler","uid","eventName","data","libRpc","emit","lineno","filename","errorFn","clear","callFn","call","transferables","String","postMessage","rpcResult","__rpcResult","getAppBarUtilityClass","joinVars","var1","var2","AppBarRoot","styled","Paper","overridesResolver","ownerState","root","capitalize","position","memoTheme","flexDirection","width","flexShrink","variants","zIndex","appBar","top","left","right","AppBar","defaultBg","grey","getContrastText","applyStyles","filter","createSimplePaletteValueFilter","map","main","contrastText","enableColorOnDark","darkBg","darkColor","backgroundImage","ref","other","classes","slots","composeClasses","useUtilityClasses","square","component","elevation","clsx","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","addSignal","signal","aborted","handleAborted","size","abort","AggregateStatusReporter","callbacks","addCallback","currentMessage","elt","AbortablePromiseCache","fill","cache","TypeError","fillCallback","isAbortException","exception","code","evict","entry","statusCallback","aborter","statusReporter","newEntry","settled","console","checkSinglePromise","checkForSingleAbort","assign","AbortSignal","cacheEntry","cachedEntry","keyIter","keys","deleteCount","next","FabRoot","ButtonBase","shouldForwardProp","rootShouldForwardProp","variant","colorInherit","button","minHeight","transition","transitions","create","duration","short","borderRadius","padding","minWidth","height","fab","boxShadow","shadows","A100","textDecoration","fabClasses","focusVisible","dark","disabled","action","disabledBackground","disableFocusRipple","focusVisibleClassName","composedClasses","focusRipple","hasSymbol","for","isFunctionNameConfigurable","_b","_a","getOwnPropertyDescriptor","ReactForwardRefSymbol","forwardRef","ReactMemoSymbol","memo","observer","baseComponent","isUsingStaticRendering","useForwardRef","render","baseComponentName","displayName","base","observerComponent","useObserver","contextTypes","hoistBlackList","$$typeof","compare","type","livelinessChecking","setLivelinessChecking","getLivelinessChecking","setLivelynessChecking","Hook","getType","assertIsStateTreeNode","getStateTreeNode","getChildType","propertyName","onPatch","assertIsFunction","onSnapshot","applyPatch","patch","assertArg","p","applyPatches","asArray","recordPatches","subject","patches","inversePatches","publicData","disposer","recorder","recording","slice","reversedInversePatches","reverse","stop","resume","inversePatch","getRunningActionContext","replay","undo","protect","node","isRoot","fail","isProtectionEnabled","unprotect","isProtected","applySnapshot","snapshot","getSnapshot","applyPostProcess","freeze","hasParent","assertIsNumber","parent","getParent","storedValue","hasParentOfType","assertIsType","is","getParentOfType","getRoot","getPath","path","getPathParts","splitJsonPath","resolvePath","assertIsString","resolveNodeByPath","resolveIdentifier","identifier","isValidIdentifier","identifierCache","normalizeIdentifier","getIdentifier","tryReference","getter","checkIfAlive","isStateTreeNode","isAlive","InvalidReferenceError","isValidReference","tryResolve","getRelativePath","getRelativePathBetweenNodes","clone","source","keepEnvironment","environment","detach","destroy","die","removeChild","subpath","observableIsAlive","addDisposer","getEnv","EMPTY_OBJECT","walk","processor","getChildren","child","getPropertyMembers","typeOrNode","t","isModelType","properties","getMembers","reflected","actions","volatile","views","flowActions","getOwnPropertyNames","descriptor","isComputedProp","_isFlowAction","_isMSTAction","isObservableProp","cast","snapshotOrInstance","castToSnapshot","castToReferenceSnapshot","instance","getNodeId","nodeId","BaseNode","_escapedSubpath","_subpath","_subpathUponDeath","subpathUponDeath","_pathUponDeath","pathUponDeath","getValue","aliveAtom","_state","NodeLifeCycle","INITIALIZING","state","wasAlive","reportChanged","_hookSubscribers","fireInternalHook","registerHook","hook","hookHandler","EventHandlers","register","_parent","baseSetParent","getReconciliationType","pathAtom","getEscapedPath","reportObserved","createAtom","escapeJsonPath","DEAD","isDetaching","DETACHING","baseFinalizeCreation","whenFinalized","devMode","CREATED","FINALIZED","fireHook","afterAttach","baseFinalizeDeath","clearAll","baseAboutToDie","beforeDestroy","ScalarNode","simpleType","initialSnapshot","createNewInstance","finalizeCreation","setParent","newParent","parentChanged","subpathChanged","toString","aboutToDie","finalizeDeath","nextNodeId","snapshotReactionOptions","onError","ObjectNode","identifierAttribute","unnormalizedIdentifier","middlewares","hasSnapshotPostProcessor","_applyPatches","createObservableInstanceIfNeeded","_applySnapshot","_autoUnbox","_isRunningAction","_hasSnapshotReaction","_observableInstanceState","_childNodes","_initialSnapshot","_cachedInitialSnapshot","_cachedInitialSnapshotCreated","_snapshotComputed","complexType","initialValue","computed","unbox","bind","IdentifierCache","initializeChildNodes","id","childNode","addNodeToCache","fireHooks","createObservableInstance","parentChain","unshift","preboot","finalizeNewInstance","trackAndCompute","_addSnapshotReaction","afterCreate","clearParent","beforeDetach","previousState","newEnv","newIdCache","splitCache","mergeCache","fn","_allowStateChangesInsideComputed","_snapshotUponDeath","_getActualSnapshot","_getCachedInitialSnapshot","childNodes","processInitialSnapshot","isRunningAction","assertAlive","context","_getAssertAliveError","warnError","escapedPath","actionContext","getCurrentActionContext","parentActionEvent","actionFullPath","getChildNode","convertChildNodesToArray","assertWritable","afterCreationFinalization","self","createActionInvoker","parts","resolveNodeByPathParts","applyPatchLocally","length","addHiddenFinalProp","_internalEventsEmit","_internalEventsClear","notifyDied","_internalEventsClearAll","onChange","_internalEventsRegister","emitSnapshot","emitPatch","basePatch","_internalEventsHasSubscribers","localizedPatch","a","b","i","current","extend","substr","reversePatch","stripPatch","invertPatch","splitPatch","hasDisposer","_internalEventsHas","removeDisposer","_internalEventsUnregister","removeMiddleware","middleware","indexOf","splice","addMiddleWare","includeHooks","snapshotDisposer","reaction","_internalEvents","hasSubscribers","eventHandler","atTheBeginning","unregister","validationCache","TypeFlags","cannotDetermineSubtype","$type","BaseType","C","S","T","N","isType","typecheckInternal","instantiate","isAssignableFrom","validate","getStateTreeNodeSafe","valueType","typeCheckSuccess","typeCheckFailure","typeCache","cached","isValidSnapshot","thing","Type","TypeWithoutSTN","SnapshotType","CreationType","ComplexType","getDefaultSnapshot","isMatchingSnapshotId","tryToReconcileNode","isMutable","reconcile","newNode","getSubTypes","SimpleType","res","argNumber","runningActions","createActionTrackingMiddleware","hooks","onStart","onResume","onSuspend","onSuccess","onFail","rootId","RunningAction","flowsPending","running","finish","onFinish","incFlowsPending","decFlowsPending","hasFlowsPending","createActionTrackingMiddleware2","middlewareHooks","parentRunningAction","newCall","env","parentCall","passesFilter","runningAction","serializeTheUnserializable","baseType","$MST_UNSERIALIZABLE","applyAction","runInAction","resolvedTarget","v","deserializeArgument","Date","baseApplyAction","recordActions","listener","onAction","attachAfter","addMiddleware","rawCall","sourceNode","info","arg","actionName","$MST_DATE","getTime","isPrimitive","isPlainObject","JSON","stringify","serializeArgument","currentActionContext","nextActionId","getNextActionId","runWithActionContext","baseIsRunningAction","previousContext","baseCall","originalFn","CollectedMiddlewares","isEmpty","runNextMiddleware","getNextMiddleware","nextInvoked","abortInvoked","call2","node2","tree","runMiddleWares","getParentActionContext","parentContext","parentActionContext","argsToArray","arguments","parentId","allParentIds","parentEvent","decorate","$mst_middleware","arrayIndex","inArrayIndex","n","array","_isActionContextThisOrChildOf","sameOrParent","includeSame","isActionContextChildOf","isActionContextThisOrChildOf","parentOrThis","prettyPrintValue","safeStringify","toErrorString","fullPath","join","pathPrefix","currentTypename","isSnapshotCompatible","isPrimitiveType","describe","getContextForPath","popContext","pop","EMPTY_ARRAY","isTypeCheckingEnabled","typecheck","valueInString","substring","validationErrorsToString","identifierCacheId","cacheId","observable","lastCacheModificationPerId","updateLastCacheModificationPerId","lcm","getLastCacheModificationPerId","modificationId","lastCacheUpdate","mobxShallow","values","nodes","remove","splitNode","newCache","basePath","modified","candidate","matches","createObjectNode","existingNode","createScalarNode","isNode","$treenode","doubleDot","_","baseParts","targetParts","joinJsonPath","failIfResolveFails","pathParts","part","process$1","asyncAction","deprecated","flow","plainObjectString","_getGlobalState","useProxies","deep","proxy","identity","isInteger","isObservableArray","proto","getPrototypeOf","RegExp","includeDate","deepFreeze","propKey","isFrozen","isSerializable","isObservableObject","defineProperty$1","propName","addHiddenWritableProp","EventHandler","handlers","emitting","pendingUnregisters","f","eventHandlers","stringStartsWith","str","beginning","ids","hasOwnProperty","msg","warn","process","_devMode","setDevMode","typeName","min","max","canBeEmpty","s","setImmediateWithFallback","queueMicrotask","setImmediate","setTimeout","generator","spawner","runId","contextBase","gen","init","onFulfilled","ret","cancelError","r","throw","onRejected","err","createFlowSpawner","castFlowReturn","toGeneratorFunction","toGenerator","op","oldValue","unescapeJsonPath","getPathStr","split","$preProcessorFailed","SnapshotProcessor","_subtype","_processors","flags","preProcessSnapshot","sn","preProcessor","preProcessSnapshotSafe","postProcessSnapshot","postProcessor","_fixNode","nodeType","snapshotProcessorType","methods","proxyNodeTypeMethods","oldGetSnapshot","isUnionType","processedInitialValue","processedSn","needsIdentifierError","tryCollectModelTypes","modelTypes","subtypes","subtypesArray","subtype","ModelType","MapIdentifierMode","MSTMap","ObservableMap","initialData","enhancer","put","mapNode","mapType","identifierMode","YES","mapIdentifierAttribute","MapType","_subType","UNKNOWN","hookInitializers","_determineIdentifierMode","concat","reduce","NO","objNode","subType","_interceptReads","initializer","actionInvoker","intercept","willChange","observe","didChange","change","processIdentifier","expected","processed","oldSnapshot","currentKeys","isMapType","ArrayType","item","_getAdministration","dehancer","updatedNodes","reconcileArrayChildren","removedCount","added","addedNodes","removed","addedCount","childType","oldNodes","newValues","newPaths","nothingChanged","hasNewNode","oldNode","newPath","areSame","valueAsNode","oldMatch","j","getNewNode","oldNodeType","isArrayType","PRE_PROCESS_SNAPSHOT","POST_PROCESS_SNAPSHOT","objectTypeToString","defaultObjectOptions","initializers","propertyNames","opts","declaredProps","keysList","alreadySeenKeys","optional","string","number","boolean","DatePrimitive","getPrimitiveFactoryFromValue","toPropertiesObject","_getIdentifierAttribute","forAllProps","propType","Identifier","cloneAndEnhance","instantiateActions","action2","baseAction","specializedAction","boundAction","named","instantiateVolatileState","rest","instantiateViews","makeObservable","currentPreprocessor","currentPostprocessor","applySnapshotPreProcessor","chg","oldChildValue","adm","raw","getAtom","applySnapshotPostProcessor","preProcessedSnapshot","CoreType","checker","integer","Integer","float","Float","isFloat","finite","Finite","isFinite","Boolean","nullType","Null","undefinedType","Undefined","_DatePrimitive","Literal","literal","isLiteralType","Refinement","_predicate","_message","subtypeErrors","isRefinementType","Union","_types","_dispatcher","_eager","eager","dispatcher","determineType","reconcileCurrentType","quickMatch","tryQuickMatch","snapshotLooksLikeType","find","tryMatchPrimitive","typesToCheck","isOptional","Optional","propValue","allErrors","applicableTypes","flat","union","optionsOrType","otherTypes","types","o","OptionalValue","_defaultValue","optionalValues","defaultInstanceOrSnapshot","getDefaultInstanceOrSnapshot","defaultValueOrFunction","checkOptionalPreconditions","undefinedAsOptionalValues","isOptionalType","optionalUndefinedType","optionalNullType","maybe","Late","_definition","getSubType","mustSucceed","ReferenceError","isLateType","Lazy","loadedType","pendingNodeList","when","shouldLoadPredicate","loadType","Frozen","untypedFrozenInstance","isFrozenType","StoredReference","targetType","resolvedReference","targetNode","updateResolvedReference","normalizedId","lastCacheModification","resolvedValue","m","setPrototypeOf","BaseReferenceType","onInvalidated","Reference","fireInvalidated","cause","storedRefNode","referenceId","refTargetNode","storedRefParentNode","storedRefParentValue","invalidTarget","invalidId","replaceRef","newRef","removeRef","addTargetNodeWatcher","refTargetValue","refTargetNodeHook","getInvalidationCause","refTargetDetachHookDisposer","refTargetDestroyHookDisposer","watchTargetNodeForInvalidations","customGetSet","onRefTargetDestroyedHookDisposer","startWatching","sync","refTargetNodeExists","IdentifierReferenceType","storedRef","compareByValue","CustomReferenceType","newIdentifier","reference","getSetOptions","isReferenceType","BaseIdentifierType","validType","identifierNumber","isIdentifierType","CustomType","Custom","isTargetType","typeError","getValidationMessage","toSnapshot","fromSnapshot","isSnapshot","valueToStore","enumeration","realOptions","option","model","compose","hasTypename","prev","cur","custom","safeReference","refType","ev","acceptsUndefined","maybeNull","refinement","predicate","frozen","late","nameOrType","maybeType","lazy","null","snapshotProcessor","processors"],"ignoreList":[],"sourceRoot":""}