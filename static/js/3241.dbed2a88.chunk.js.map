{"version":3,"file":"static/js/3241.dbed2a88.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/shared/color.ts","../../../plugins/alignments/src/shared/canvasUtils.ts","../../../plugins/alignments/src/shared/chevron.ts","../../../plugins/alignments/src/shared/primaryStrand.ts","../../../plugins/alignments/src/LinearReadCloudDisplay/drawFeatsCommon.ts","../../../plugins/alignments/src/shared/drawPairChains.ts","../../../plugins/alignments/src/shared/drawLongReadChains.ts"],"sourcesContent":["import { orientationTypes, pairMap } from '../util'\n\nimport type { ChainStats, ReducedFeature } from './fetchChains'\n\n/**\n * Numeric codes for pair types\n * Used to classify paired-end reads without relying on color string comparisons\n */\nexport const PairType = {\n  /** Proper pair: correct orientation (LR) and normal insert size */\n  PROPER_PAIR: 0,\n  /** Long insert: same chromosome but insert size exceeds upper threshold */\n  LONG_INSERT: 1,\n  /** Short insert: same chromosome but insert size below lower threshold */\n  SHORT_INSERT: 2,\n  /** Inter-chromosome: mates on different chromosomes */\n  INTER_CHROM: 3,\n  /** Abnormal orientation: RR, RL, LL, etc. (not LR) */\n  ABNORMAL_ORIENTATION: 4,\n  /** Unmapped mate: mate is unmapped */\n  UNMAPPED_MATE: 5,\n} as const\n\nexport type PairTypeValue = (typeof PairType)[keyof typeof PairType]\n\nexport const fillColor = {\n  color_fwd_strand_not_proper: '#ECC8C8',\n  color_rev_strand_not_proper: '#BEBED8',\n  color_fwd_strand: '#EC8B8B',\n  color_rev_strand: '#8F8FD8',\n  color_fwd_missing_mate: '#D11919',\n  color_rev_missing_mate: '#1919D1',\n  color_fwd_diff_chr: '#000',\n  color_rev_diff_chr: '#969696',\n  color_pair_lr: '#c8c8c8',\n  color_pair_rr: '#3a3a9d',\n  color_pair_rl: 'teal',\n  color_pair_ll: 'green',\n  color_nostrand: '#c8c8c8',\n  color_interchrom: 'purple',\n  color_longinsert: 'red',\n  color_shortinsert: 'pink',\n  color_unmapped_mate: '#8B008B',\n  color_unknown: 'grey',\n}\n\n// manually calculated by running\n// const color = require('color')\n// Object.fromEntries(Object.entries(fillColor).map(([key,val])=>{\n//   return [key, color(val).darken('0.3').hex()]\n// }))\n// this avoids (expensive) use of Color module at runtime\nexport const strokeColor = {\n  color_fwd_strand_not_proper: '#CA6767',\n  color_rev_strand_not_proper: '#7272AA',\n  color_fwd_strand: '#DC2A2A',\n  color_rev_strand: '#4141BA',\n  color_fwd_missing_mate: '#921111',\n  color_rev_missing_mate: '#111192',\n  color_fwd_diff_chr: '#000000',\n  color_rev_diff_chr: '#696969',\n  color_pair_lr: '#8C8C8C',\n  color_pair_rr: '#00002A',\n  color_pair_rl: '#005A5A',\n  color_pair_ll: '#005A00',\n  color_nostrand: '#8C8C8C',\n  color_interchrom: '#5A005A',\n  color_longinsert: '#B30000',\n  color_shortinsert: '#FF3A5C',\n  color_unmapped_mate: '#5A005A',\n  color_unknown: '#444',\n}\n\nconst defaultColor = [\n  fillColor.color_pair_lr,\n  strokeColor.color_pair_lr,\n] as const\n\n/**\n * Get the pair type classification for a paired-end read\n * Used internally by color functions and externally for filtering logic\n *\n * @param type - Color scheme type (insertSizeAndOrientation, orientation, insertSize)\n * @param f1 - First read in the pair\n * @param f2 - Second read in the pair\n * @param stats - Optional statistics for insert size thresholds\n * @returns Numeric code representing the pair type\n */\nexport function getPairedType({\n  type,\n  f1,\n  f2,\n  stats,\n}: {\n  type: string\n  f1: {\n    refName: string\n    pair_orientation?: string\n    tlen?: number\n    flags?: number\n  }\n  f2: { refName: string }\n  stats?: ChainStats\n}): PairTypeValue {\n  // Check for unmapped mate first (highest priority)\n  if (f1.flags !== undefined && f1.flags & 8) {\n    return PairType.UNMAPPED_MATE\n  }\n\n  // Check orientation first (if applicable)\n  if (type === 'insertSizeAndOrientation' || type === 'orientation') {\n    const orientationType = orientationTypes.fr\n    const r = orientationType[f1.pair_orientation || ''] as\n      | keyof typeof pairMap\n      | undefined\n    // If orientation is not LR (proper), it's abnormal\n    if (r && r !== 'LR') {\n      return PairType.ABNORMAL_ORIENTATION\n    }\n  }\n\n  // Check insert size (if applicable)\n  if (type === 'insertSizeAndOrientation' || type === 'insertSize') {\n    const sameRef = f1.refName === f2.refName\n    const tlen = Math.abs(f1.tlen || 0)\n\n    if (!sameRef) {\n      return PairType.INTER_CHROM\n    }\n\n    if (stats) {\n      if (tlen > stats.upper) {\n        return PairType.LONG_INSERT\n      }\n      if (tlen < stats.lower) {\n        return PairType.SHORT_INSERT\n      }\n    }\n  }\n\n  // If all checks pass, it's a proper pair\n  return PairType.PROPER_PAIR\n}\n\n/**\n * Get color for a paired-end read based on insert size only\n * Uses getPairedType() internally to determine classification\n */\nexport function getPairedInsertSizeColor(\n  f1: { refName: string; tlen?: number; flags?: number },\n  f2: { refName: string },\n  stats?: ChainStats,\n) {\n  const pairType = getPairedType({ type: 'insertSize', f1, f2, stats })\n\n  switch (pairType) {\n    case PairType.UNMAPPED_MATE:\n      return [\n        fillColor.color_unmapped_mate,\n        strokeColor.color_unmapped_mate,\n      ] as const\n    case PairType.LONG_INSERT:\n      return [fillColor.color_longinsert, strokeColor.color_longinsert] as const\n    case PairType.SHORT_INSERT:\n      return [\n        fillColor.color_shortinsert,\n        strokeColor.color_shortinsert,\n      ] as const\n    case PairType.INTER_CHROM:\n      return [fillColor.color_interchrom, strokeColor.color_interchrom] as const\n    case PairType.PROPER_PAIR:\n      return undefined\n    default:\n      return undefined\n  }\n}\n\n/**\n * Get color for a paired-end read based on orientation only\n * Returns undefined for proper pairs (LR orientation)\n */\nexport function getPairedOrientationColorOrDefault(f: {\n  pair_orientation?: string\n  flags?: number\n}) {\n  // Check for unmapped mate first\n  if (f.flags !== undefined && f.flags & 8) {\n    return [\n      fillColor.color_unmapped_mate,\n      strokeColor.color_unmapped_mate,\n    ] as const\n  }\n\n  const type = orientationTypes.fr\n  const r = type[f.pair_orientation || ''] as keyof typeof pairMap\n  const type2 = pairMap[r] as keyof typeof fillColor\n  return r === 'LR'\n    ? undefined\n    : ([fillColor[type2], strokeColor[type2]] as const)\n}\n\n/**\n * Get color for a paired-end read based on orientation only\n * Returns default color for proper pairs\n */\nexport function getPairedOrientationColor(f: {\n  pair_orientation?: string\n  flags?: number\n}) {\n  return getPairedOrientationColorOrDefault(f) || defaultColor\n}\n\n/**\n * Get color for a paired-end read based on both insert size and orientation\n * Prioritizes orientation coloring over insert size coloring\n * Uses getPairedType() internally to determine classification\n */\nexport function getPairedInsertSizeAndOrientationColor(\n  f1: {\n    refName: string\n    pair_orientation?: string\n    tlen?: number\n    flags?: number\n  },\n  f2: { refName: string },\n  stats?: ChainStats,\n) {\n  return (\n    getPairedOrientationColorOrDefault(f1) ||\n    getPairedInsertSizeColor(f1, f2, stats) ||\n    defaultColor\n  )\n}\n\nexport function getSingletonColor(f: { tlen?: number }, stats?: ChainStats) {\n  const tlen = Math.abs(f.tlen || 0)\n  // If TLEN is abnormally large, color it dark red\n  if (stats && tlen > stats.upper) {\n    return [\n      fillColor.color_fwd_missing_mate,\n      strokeColor.color_fwd_missing_mate,\n    ] as const\n  }\n  // Otherwise use properly paired coloring for normal-looking singletons\n  return defaultColor // [fillColor.color_pair_lr, strokeColor.color_pair_lr] as const\n}\n\nexport function getPairedColor({\n  type,\n  v0,\n  v1,\n  stats,\n}: {\n  type: string\n  v0: ReducedFeature\n  v1: ReducedFeature\n  stats?: ChainStats\n}) {\n  if (type === 'insertSizeAndOrientation') {\n    return getPairedInsertSizeAndOrientationColor(v0, v1, stats)\n  }\n  if (type === 'orientation') {\n    return getPairedOrientationColor(v0)\n  }\n  if (type === 'insertSize') {\n    return getPairedInsertSizeColor(v0, v1, stats)\n  }\n  return undefined\n}\n","/**\n * Shared canvas drawing utilities for LinearRead displays\n */\n\n// avoid drawing negative width features for SVG exports\nexport function fillRectCtx(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  ctx: CanvasRenderingContext2D,\n  fillColor?: string,\n) {\n  if (width < 0) {\n    x += width\n    width = -width\n  }\n  if (height < 0) {\n    y += height\n    height = -height\n  }\n\n  if (fillColor) {\n    ctx.fillStyle = fillColor\n  }\n\n  ctx.fillRect(x, y, width, height)\n}\n\nexport function strokeRectCtx(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  ctx: CanvasRenderingContext2D,\n  strokeColor?: string,\n) {\n  if (width < 0) {\n    x += width\n    width = -width\n  }\n  if (height < 0) {\n    y += height\n    height = -height\n  }\n\n  if (strokeColor) {\n    ctx.strokeStyle = strokeColor\n  }\n  ctx.strokeRect(x, y, width, height)\n}\n","/**\n * Draw a chevron shape (arrow-like) for directional features like reads\n * @param ctx - Canvas rendering context\n * @param x - X position\n * @param y - Y position\n * @param width - Width of the chevron\n * @param height - Height of the chevron\n * @param strand - Strand direction (-1 for reverse, 1 for forward)\n * @param color - Fill color\n * @param chevronWidth - Width of the chevron pointer in pixels\n * @param stroke - Optional stroke color (if not provided, no stroke is drawn)\n */\nexport function drawChevron(\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  strand: number,\n  color: string,\n  chevronWidth: number,\n  stroke?: string,\n) {\n  ctx.fillStyle = color\n  ctx.beginPath()\n  if (strand === -1) {\n    ctx.moveTo(x - chevronWidth, y + height / 2)\n    ctx.lineTo(x, y + height)\n    ctx.lineTo(x + width, y + height)\n    ctx.lineTo(x + width, y)\n    ctx.lineTo(x, y)\n  } else {\n    ctx.moveTo(x, y)\n    ctx.lineTo(x, y + height)\n    ctx.lineTo(x + width, y + height)\n    ctx.lineTo(x + width + chevronWidth, y + height / 2)\n    ctx.lineTo(x + width, y)\n  }\n  ctx.closePath()\n  ctx.fill()\n  if (stroke) {\n    ctx.strokeStyle = stroke\n    ctx.stroke()\n  }\n}\n","import type { ReducedFeature } from './fetchChains'\n\n/**\n * Gets the primary strand for a feature, handling both primary and supplementary alignments.\n *\n * For non-supplementary alignments (!(flags & 2048)), uses the feature's strand property.\n * For supplementary alignments, parses the SA tag to get the primary alignment's strand.\n *\n * @param feat - The feature to get the primary strand from\n * @returns The primary strand (-1 for reverse, 1 for forward, or undefined if SA tag is missing)\n */\nexport function getPrimaryStrand(feat: ReducedFeature) {\n  // Check if this is not a supplementary alignment (flag 2048)\n  if (!(feat.flags & 2048)) {\n    return feat.strand\n  } else {\n    // Parse SA tag to get primary alignment strand\n    const res = feat.SA?.split(';')[0]?.split(',')[2]\n    return res === '-' ? -1 : 1\n  }\n}\n\n/**\n * Gets the primary strand for a feature by checking the reverse complement flag.\n *\n * For non-supplementary alignments (!(flags & 2048)), checks flag 16 (reverse complement).\n * For supplementary alignments, parses the SA tag to get the primary alignment's strand.\n *\n * @param feat - The feature to get the primary strand from\n * @returns The primary strand (-1 for reverse, 1 for forward, or undefined if SA tag is missing)\n */\nexport function getPrimaryStrandFromFlags(feat: ReducedFeature) {\n  // Check if this is not a supplementary alignment (flag 2048)\n  if (!(feat.flags & 2048)) {\n    return feat.flags & 16 ? -1 : 1\n  } else {\n    // Parse SA tag to get primary alignment strand\n    const res = feat.SA?.split(';')[0]?.split(',')[2]\n    return res === '-' ? -1 : 1\n  }\n}\n","import { getConf } from '@jbrowse/core/configuration'\nimport { getContainingView, getSession } from '@jbrowse/core/util'\nimport Flatbush from '@jbrowse/core/util/flatbush'\n\nimport { PairType, getPairedType } from '../shared/color'\nimport { drawLongReadChains } from '../shared/drawLongReadChains'\nimport { drawPairChains } from '../shared/drawPairChains'\nimport { shouldRenderChevrons } from '../shared/util'\n\nimport type { LinearReadCloudDisplayModel } from './model'\nimport type { ChainData, ReducedFeature } from '../shared/fetchChains'\nimport type { FlatbushEntry } from '../shared/flatbushType'\nimport type { Assembly } from '@jbrowse/core/assemblyManager/assembly'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface ComputedChain {\n  distance: number\n  minX: number\n  maxX: number\n  chain: ReducedFeature[]\n  id: string\n}\n\n/**\n * Filter chains based on singleton and proper pair settings\n */\nexport function filterChains(\n  chains: ReducedFeature[][],\n  drawSingletons: boolean,\n  drawProperPairs: boolean,\n  type: string,\n  chainData: ChainData,\n) {\n  const filtered: ReducedFeature[][] = []\n\n  for (const chain_ of chains) {\n    const chain = chain_\n\n    // Filter out singletons if drawSingletons is false\n    if (!drawSingletons && chain.length === 1) {\n      continue\n    }\n\n    // Filter out proper pairs if drawProperPairs is false\n    // Check if this is a paired-end read using SAM flag 1 (read paired)\n    let isPairedEnd = false\n    for (const element of chain) {\n      if (element.flags & 1) {\n        isPairedEnd = true\n        break\n      }\n    }\n\n    if (!drawProperPairs && isPairedEnd) {\n      // Collect non-supplementary alignments\n      const nonSupplementary: ReducedFeature[] = []\n      for (const element of chain) {\n        if (!(element.flags & 2048)) {\n          nonSupplementary.push(element)\n        }\n      }\n\n      if (nonSupplementary.length === 2) {\n        const v0 = nonSupplementary[0]!\n        const v1 = nonSupplementary[1]!\n        const pairType = getPairedType({\n          type,\n          f1: v0,\n          f2: v1,\n          stats: chainData.stats,\n        })\n        // Filter out proper pairs\n        if (pairType === PairType.PROPER_PAIR) {\n          continue\n        }\n      }\n    }\n\n    filtered.push(chain)\n  }\n\n  return filtered\n}\n\n/**\n * Compute pixel bounds for each chain\n */\nexport function computeChainBounds(\n  chains: ReducedFeature[][],\n  view: LGV,\n  asm: Assembly,\n) {\n  const computedChains: ComputedChain[] = []\n\n  // get bounds on the 'distances' (TLEN for pairs, pixel span for others)\n  for (const chain_ of chains) {\n    const chain = chain_\n    let minX = Number.MAX_VALUE\n    let maxX = Number.MIN_VALUE\n    let chainId = ''\n    let tlenDistance = 0\n    const chainLength = chain.length\n\n    for (let j = 0; j < chainLength; j++) {\n      const elt = chain[j]!\n      const refName = asm.getCanonicalRefName(elt.refName) || elt.refName\n      const rs = view.bpToPx({ refName, coord: elt.start })?.offsetPx\n      const re = view.bpToPx({ refName, coord: elt.end })?.offsetPx\n      if (rs !== undefined && re !== undefined) {\n        minX = Math.min(minX, rs)\n        maxX = Math.max(maxX, re)\n      }\n      if (!chainId) {\n        chainId = elt.id\n      }\n      // Use TLEN from the first feature that has it (only for non-singletons)\n      if (chainLength > 1 && tlenDistance === 0 && elt.tlen) {\n        tlenDistance = Math.abs(elt.tlen)\n      }\n    }\n\n    // For pairs/chains, prefer TLEN over pixel distance; singletons use pixel distance\n    const distance = tlenDistance > 0 ? tlenDistance : Math.abs(maxX - minX)\n\n    computedChains.push({\n      distance,\n      minX,\n      maxX,\n      chain,\n      id: chainId,\n    })\n  }\n\n  return computedChains\n}\n\n/**\n * Sort chains: singletons first, then by width within each group\n */\nexport function sortComputedChains(computedChains: ComputedChain[]) {\n  computedChains.sort((a, b) => {\n    const aIsSingleton = a.chain.length === 1 ? 1 : 0\n    const bIsSingleton = b.chain.length === 1 ? 1 : 0\n\n    // Sort singletons first (higher value = earlier in sort)\n    if (bIsSingleton !== aIsSingleton) {\n      return bIsSingleton - aIsSingleton\n    }\n\n    // Within each group, sort by width (smaller first)\n    return a.distance - b.distance\n  })\n}\n\n/**\n * Build Flatbush index for mouseover detection\n */\nexport function buildFlatbushIndex(\n  featuresForFlatbush: FlatbushEntry[],\n  self: LinearReadCloudDisplayModel,\n) {\n  const finalFlatbush = new Flatbush(Math.max(featuresForFlatbush.length, 1))\n  const length = featuresForFlatbush.length\n  if (length) {\n    for (let i = 0; i < length; i++) {\n      const { x1, y1, x2, y2 } = featuresForFlatbush[i]!\n      finalFlatbush.add(x1, y1, x2, y2)\n    }\n  } else {\n    // flatbush does not like 0 items\n    finalFlatbush.add(0, 0)\n  }\n  finalFlatbush.finish()\n  self.setFeatureLayout(finalFlatbush)\n  self.setFeaturesForFlatbush(featuresForFlatbush)\n}\n\n/**\n * Add full-width rectangles for each chain to enable mouseover on connecting lines\n */\nexport function addChainMouseoverRects(\n  computedChains: ComputedChain[],\n  chainYOffsets: Map<string, number>,\n  featureHeight: number,\n  view: LGV,\n  featuresForFlatbush: FlatbushEntry[],\n) {\n  for (const computedChain of computedChains) {\n    const { id, chain, minX, maxX } = computedChain\n    const chainY = chainYOffsets.get(id)\n    if (chainY === undefined) {\n      continue\n    }\n\n    const chainMinXPx = minX - view.offsetPx\n    const chainMaxXPx = maxX - view.offsetPx\n    if (chain.length > 0) {\n      featuresForFlatbush.push({\n        x1: chainMinXPx,\n        y1: chainY,\n        x2: chainMaxXPx,\n        y2: chainY + featureHeight,\n        data: chain[0]!, // Use first feature as representative\n        chainId: id,\n        chainMinX: chainMinXPx,\n        chainMaxX: chainMaxXPx,\n        chain,\n      })\n    }\n  }\n}\n\n/**\n * Common drawing function that delegates Y-offset calculation to a strategy function\n */\nexport function drawFeatsCommon(\n  self: LinearReadCloudDisplayModel,\n  ctx: CanvasRenderingContext2D,\n  calculateYOffsets: (\n    computedChains: ComputedChain[],\n    self: LinearReadCloudDisplayModel,\n    view: LGV,\n    featureHeight: number,\n  ) => { chainYOffsets: Map<string, number>; layoutHeight?: number },\n) {\n  const { chainData } = self\n  if (!chainData) {\n    return\n  }\n  const { assemblyManager } = getSession(self)\n  const view = getContainingView(self) as LGV\n  const assemblyName = view.assemblyNames[0]!\n  const asm = assemblyManager.get(assemblyName)\n  if (!asm) {\n    return\n  }\n  const featureHeight = self.featureHeight ?? getConf(self, 'featureHeight')\n\n  const type = self.colorBy?.type || 'insertSizeAndOrientation'\n  const drawSingletons = self.drawSingletons\n  const drawProperPairs = self.drawProperPairs\n  const { chains } = chainData\n\n  // Filter chains based on settings\n  const filteredChains = filterChains(\n    chains,\n    drawSingletons,\n    drawProperPairs,\n    type,\n    chainData,\n  )\n\n  // Compute pixel bounds for each chain\n  const computedChains = computeChainBounds(filteredChains, view, asm)\n\n  // Sort chains: singletons first, then by width within each group\n  sortComputedChains(computedChains)\n\n  // Calculate Y-offsets using the provided strategy\n  const { chainYOffsets, layoutHeight } = calculateYOffsets(\n    computedChains,\n    self,\n    view,\n    featureHeight,\n  )\n\n  // Initialize array for Flatbush mouseover data\n  const featuresForFlatbush: FlatbushEntry[] = []\n\n  const renderChevrons = shouldRenderChevrons(view.bpPerPx, featureHeight)\n\n  // Delegate rendering to specialized functions for paired and long-read chains\n  drawPairChains({\n    ctx,\n    type,\n    chainData,\n    view,\n    asm,\n    chainYOffsets,\n    renderChevrons,\n    featureHeight,\n    featuresForFlatbush,\n    computedChains,\n  })\n\n  drawLongReadChains({\n    ctx,\n    chainData,\n    view,\n    asm,\n    chainYOffsets,\n    renderChevrons,\n    featureHeight,\n    featuresForFlatbush,\n    computedChains,\n    flipStrandLongReadChains: self.flipStrandLongReadChains,\n  })\n\n  // Add full-width rectangles for each chain to enable mouseover on connecting lines\n  addChainMouseoverRects(\n    computedChains,\n    chainYOffsets,\n    featureHeight,\n    view,\n    featuresForFlatbush,\n  )\n\n  // Build and set Flatbush index\n  buildFlatbushIndex(featuresForFlatbush, self)\n\n  // Set layout height if provided (for stack mode)\n  if (layoutHeight !== undefined) {\n    self.setLayoutHeight(layoutHeight)\n  }\n}\n","import { fillRectCtx, strokeRectCtx } from './canvasUtils'\nimport { drawChevron } from './chevron'\nimport { getPairedColor, getSingletonColor } from './color'\nimport { CHEVRON_WIDTH } from './util'\n\nimport type { ChainData, ReducedFeature } from './fetchChains'\nimport type { FlatbushEntry } from './flatbushType'\nimport type { Assembly } from '@jbrowse/core/assemblyManager/assembly'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport function drawPairChains({\n  ctx,\n  type,\n  chainData,\n  view,\n  asm,\n  chainYOffsets,\n  renderChevrons,\n  featureHeight,\n  featuresForFlatbush,\n  computedChains,\n}: {\n  ctx: CanvasRenderingContext2D\n  type: string\n  chainData: ChainData\n  view: LGV\n  asm: Assembly\n  chainYOffsets: Map<string, number>\n  renderChevrons: boolean\n  featureHeight: number\n  featuresForFlatbush: FlatbushEntry[]\n  computedChains: {\n    distance: number\n    minX: number\n    maxX: number\n    chain: ReducedFeature[]\n    id: string\n  }[]\n}): void {\n  for (const computedChain of computedChains) {\n    const { id, chain, minX, maxX } = computedChain\n\n    // Guard clause: skip non-paired-end chains\n    let isPairedEnd = false\n    for (const element of chain) {\n      if (element.flags & 1) {\n        isPairedEnd = true\n        break\n      }\n    }\n    if (!isPairedEnd) {\n      continue\n    }\n\n    const chainY = chainYOffsets.get(id)\n    if (chainY === undefined) {\n      continue\n    }\n\n    // Collect non-supplementary alignments\n    const nonSupplementary: ReducedFeature[] = []\n    for (const element of chain) {\n      if (!(element.flags & 2048)) {\n        nonSupplementary.push(element)\n      }\n    }\n    const hasBothMates = nonSupplementary.length === 2\n\n    // Get colors based on whether both mates are visible\n    const [pairedFill, pairedStroke] = hasBothMates\n      ? getPairedColor({\n          type,\n          v0: nonSupplementary[0]!,\n          v1: nonSupplementary[1]!,\n          stats: chainData.stats,\n        }) || ['#888', '#888']\n      : getSingletonColor(nonSupplementary[0] || chain[0]!, chainData.stats)\n\n    // Draw connecting line for pairs with both mates visible\n    if (hasBothMates) {\n      const v0 = nonSupplementary[0]!\n      const v1 = nonSupplementary[1]!\n      const r1s = view.bpToPx({\n        refName: asm.getCanonicalRefName2(v0.refName),\n        coord: v0.start,\n      })?.offsetPx\n      const r2s = view.bpToPx({\n        refName: asm.getCanonicalRefName2(v1.refName),\n        coord: v1.start,\n      })?.offsetPx\n\n      if (r1s !== undefined && r2s !== undefined) {\n        fillRectCtx(\n          r1s - view.offsetPx,\n          chainY + featureHeight / 2 - 0.5,\n          r2s - r1s,\n          1,\n          ctx,\n          '#666',\n        )\n      }\n    }\n\n    // Draw the paired-end features (both mates or singleton)\n    const viewOffsetPx = view.offsetPx\n    const chainMinXPx = minX - viewOffsetPx\n    const chainMaxXPx = maxX - viewOffsetPx\n\n    for (let i = 0, l = chain.length; i < l; i++) {\n      const feat = chain[i]!\n      const s = view.bpToPx({\n        refName: asm.getCanonicalRefName2(feat.refName),\n        coord: feat.start,\n      })\n      const e = view.bpToPx({\n        refName: asm.getCanonicalRefName2(feat.refName),\n        coord: feat.end,\n      })\n\n      if (!s || !e) {\n        continue\n      }\n\n      const xPos = s.offsetPx - viewOffsetPx\n      const width = Math.max(e.offsetPx - s.offsetPx, 3)\n\n      if (renderChevrons) {\n        drawChevron(\n          ctx,\n          xPos,\n          chainY,\n          width,\n          featureHeight,\n          feat.strand,\n          pairedFill,\n          CHEVRON_WIDTH,\n          pairedStroke,\n        )\n      } else {\n        fillRectCtx(xPos, chainY, width, featureHeight, ctx, pairedFill)\n        strokeRectCtx(xPos, chainY, width, featureHeight, ctx, pairedStroke)\n      }\n\n      featuresForFlatbush.push({\n        x1: xPos,\n        y1: chainY,\n        x2: xPos + width,\n        y2: chainY + featureHeight,\n        data: feat,\n        chainId: id,\n        chainMinX: chainMinXPx,\n        chainMaxX: chainMaxXPx,\n        chain,\n      })\n    }\n  }\n}\n","import { fillRectCtx, strokeRectCtx } from './canvasUtils'\nimport { drawChevron } from './chevron'\nimport { fillColor, getSingletonColor, strokeColor } from './color'\nimport { getPrimaryStrandFromFlags } from './primaryStrand'\nimport { CHEVRON_WIDTH } from './util'\n\nimport type { ChainData, ReducedFeature } from './fetchChains'\nimport type { FlatbushEntry } from './flatbushType'\nimport type { Assembly } from '@jbrowse/core/assemblyManager/assembly'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport function drawLongReadChains({\n  ctx,\n  chainData,\n  view,\n  asm,\n  chainYOffsets,\n  renderChevrons,\n  featureHeight,\n  featuresForFlatbush,\n  computedChains,\n  flipStrandLongReadChains,\n}: {\n  ctx: CanvasRenderingContext2D\n  chainData: ChainData\n  view: LGV\n  asm: Assembly\n  chainYOffsets: Map<string, number>\n  renderChevrons: boolean\n  featureHeight: number\n  featuresForFlatbush: FlatbushEntry[]\n  computedChains: {\n    distance: number\n    minX: number\n    maxX: number\n    chain: ReducedFeature[]\n    id: string\n  }[]\n  flipStrandLongReadChains: boolean\n}): void {\n  const getStrandColorKey = (strand: number) =>\n    strand === -1 ? 'color_rev_strand' : 'color_fwd_strand'\n\n  for (const computedChain of computedChains) {\n    const { id, chain, minX, maxX } = computedChain\n\n    // Guard clause: skip paired-end reads (handled by drawPairChains)\n    let isPairedEnd = false\n    for (const element of chain) {\n      if (element.flags & 1) {\n        isPairedEnd = true\n        break\n      }\n    }\n    if (isPairedEnd) {\n      continue\n    }\n\n    const chainY = chainYOffsets.get(id)\n    if (chainY === undefined) {\n      continue\n    }\n\n    // Collect non-supplementary alignments\n    const nonSupplementary: ReducedFeature[] = []\n    for (const element of chain) {\n      if (!(element.flags & 2048)) {\n        nonSupplementary.push(element)\n      }\n    }\n    const isSingleton = chain.length === 1\n    const c1 = nonSupplementary[0] || chain[0]!\n    const primaryStrand = getPrimaryStrandFromFlags(c1)\n\n    // Draw connecting line for multi-segment long reads\n    if (!isSingleton) {\n      const firstFeat = chain[0]!\n      const lastFeat = chain[chain.length - 1]!\n\n      const firstPx = view.bpToPx({\n        refName: asm.getCanonicalRefName2(firstFeat.refName),\n        coord: firstFeat.start,\n      })?.offsetPx\n      const lastPx = view.bpToPx({\n        refName: asm.getCanonicalRefName2(lastFeat.refName),\n        coord: lastFeat.end,\n      })?.offsetPx\n\n      if (firstPx !== undefined && lastPx !== undefined) {\n        const lineY = chainY + featureHeight / 2 - 0.5\n        ctx.beginPath()\n        ctx.strokeStyle = '#666'\n        ctx.moveTo(firstPx - view.offsetPx, lineY)\n        ctx.lineTo(lastPx - view.offsetPx, lineY)\n        ctx.stroke()\n      }\n    }\n\n    // Draw the features\n    const viewOffsetPx = view.offsetPx\n    const chainMinXPx = minX - viewOffsetPx\n    const chainMaxXPx = maxX - viewOffsetPx\n\n    for (let i = 0, l = chain.length; i < l; i++) {\n      const feat = chain[i]!\n      const s = view.bpToPx({\n        refName: asm.getCanonicalRefName2(feat.refName),\n        coord: feat.start,\n      })\n      const e = view.bpToPx({\n        refName: asm.getCanonicalRefName2(feat.refName),\n        coord: feat.end,\n      })\n\n      if (!s || !e) {\n        continue\n      }\n\n      const effectiveStrand =\n        isSingleton || !flipStrandLongReadChains\n          ? feat.strand\n          : feat.strand * primaryStrand\n\n      const [featureFill, featureStroke] = isSingleton\n        ? getSingletonColor(feat, chainData.stats)\n        : [\n            fillColor[getStrandColorKey(effectiveStrand)],\n            strokeColor[getStrandColorKey(effectiveStrand)],\n          ]\n\n      const xPos = s.offsetPx - viewOffsetPx\n      const width = Math.max(e.offsetPx - s.offsetPx, 3)\n\n      if (renderChevrons) {\n        drawChevron(\n          ctx,\n          xPos,\n          chainY,\n          width,\n          featureHeight,\n          effectiveStrand,\n          featureFill,\n          CHEVRON_WIDTH,\n          featureStroke,\n        )\n      } else {\n        fillRectCtx(xPos, chainY, width, featureHeight, ctx, featureFill)\n        strokeRectCtx(xPos, chainY, width, featureHeight, ctx, featureStroke)\n      }\n\n      featuresForFlatbush.push({\n        x1: xPos,\n        y1: chainY,\n        x2: xPos + width,\n        y2: chainY + featureHeight,\n        data: feat,\n        chainId: id,\n        chainMinX: chainMinXPx,\n        chainMaxX: chainMaxXPx,\n        chain,\n      })\n    }\n  }\n}\n"],"names":["PairType","PROPER_PAIR","LONG_INSERT","SHORT_INSERT","INTER_CHROM","ABNORMAL_ORIENTATION","UNMAPPED_MATE","fillColor","color_fwd_strand_not_proper","color_rev_strand_not_proper","color_fwd_strand","color_rev_strand","color_fwd_missing_mate","color_rev_missing_mate","color_fwd_diff_chr","color_rev_diff_chr","color_pair_lr","color_pair_rr","color_pair_rl","color_pair_ll","color_nostrand","color_interchrom","color_longinsert","color_shortinsert","color_unmapped_mate","color_unknown","strokeColor","defaultColor","getPairedType","type","f1","f2","stats","undefined","flags","r","orientationTypes","fr","pair_orientation","sameRef","refName","tlen","Math","abs","upper","lower","getPairedInsertSizeColor","getPairedOrientationColorOrDefault","f","type2","pairMap","getPairedOrientationColor","getPairedInsertSizeAndOrientationColor","getSingletonColor","getPairedColor","v0","v1","fillRectCtx","x","y","width","height","ctx","fillStyle","fillRect","strokeRectCtx","strokeStyle","strokeRect","drawChevron","strand","color","chevronWidth","stroke","beginPath","moveTo","lineTo","closePath","fill","getPrimaryStrandFromFlags","feat","res","SA","split","drawFeatsCommon","self","calculateYOffsets","chainData","assemblyManager","getSession","view","getContainingView","assemblyName","assemblyNames","asm","get","featureHeight","getConf","colorBy","drawSingletons","drawProperPairs","chains","filteredChains","filtered","chain_","chain","length","isPairedEnd","element","nonSupplementary","push","filterChains","computedChains","minX","Number","MAX_VALUE","maxX","MIN_VALUE","chainId","tlenDistance","chainLength","j","elt","getCanonicalRefName","rs","bpToPx","coord","start","offsetPx","re","end","min","max","id","distance","computeChainBounds","sort","a","b","aIsSingleton","bIsSingleton","sortComputedChains","chainYOffsets","layoutHeight","featuresForFlatbush","renderChevrons","shouldRenderChevrons","bpPerPx","computedChain","chainY","hasBothMates","pairedFill","pairedStroke","r1s","getCanonicalRefName2","r2s","viewOffsetPx","chainMinXPx","chainMaxXPx","i","l","s","e","xPos","CHEVRON_WIDTH","x1","y1","x2","y2","data","chainMinX","chainMaxX","drawPairChains","flipStrandLongReadChains","getStrandColorKey","isSingleton","primaryStrand","firstFeat","lastFeat","firstPx","lastPx","lineY","effectiveStrand","featureFill","featureStroke","drawLongReadChains","addChainMouseoverRects","finalFlatbush","Flatbush","add","finish","setFeatureLayout","setFeaturesForFlatbush","buildFlatbushIndex","setLayoutHeight"],"sourceRoot":""}