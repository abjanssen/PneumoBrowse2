{"version":3,"file":"static/js/856.24884ca3.chunk.js","mappings":"0OAeOA,eAAeC,EACpBC,EACAC,GAEA,MAAM,QACJC,EAAO,OACPC,EAAM,QACNC,EAAO,QACPC,EAAO,UACPC,EAAS,eACTC,EAAiBA,QACfP,EAEEQ,EAASJ,EAAQ,GACjBK,GAASD,EAAOE,IAAMF,EAAOG,OAASN,EACtCO,EAAYT,EAASD,EAAQW,OAE7BC,GAAYC,EAAAA,EAAAA,IAAuBT,IACnC,gBAAEU,KAAoBC,SAAeC,EAAAA,EAAAA,cACzC,iBACAX,EACA,KACEY,EAAAA,EAAAA,GAAuBV,EAAON,EAAQH,EAAaoB,IACjD,MAAMC,GAASC,EAAAA,EAAAA,SAAQrB,EAAUsB,GAAKA,EAAEC,IAAI,WAC5C,IAAIC,EAAgC,GACpCL,EAAIM,OACJ,IAAK,MAAMC,KAAUzB,EAAS,CAC5B,MAAQc,gBAAiBY,IAAYC,EAAAA,EAAAA,GAAOT,EAAK,IAC5CpB,EACHC,SAAUoB,EAAOM,EAAOG,OAAS,GACjC3B,OAAQS,EACRmB,cAAeA,IAAMJ,EAAOK,OAAS,OACrClB,cAEFW,EAAqBA,EAAmBQ,OAAOL,GAC/CR,EAAIc,YAAc,wBAClBd,EAAIe,YACJf,EAAIgB,OAAO,EAAGxB,GACdQ,EAAIiB,OAAO5B,EAAOG,GAClBQ,EAAIkB,SACJlB,EAAImB,UAAU,EAAG3B,EACnB,CAEA,OADAQ,EAAIoB,UACG,CAAExB,gBAAiBS,MAI1BgB,EAAa,IACdxB,EACHhB,SAAUe,EAAgB0B,IAAIC,EAAAA,wBAC9BxC,SACAM,SAGF,OAAOmC,EAAAA,EAAAA,IAAUH,GAAYI,EAAAA,EAAAA,GAAqB5B,GACpD,C,2FCnDA,SAAS6B,EAAQd,EAAee,GAC9B,MAAMC,EAAWhB,EAAMiB,QACjBC,EAAIF,EAASE,GAAK,EAAIH,GAC5B,OAAOI,EAAAA,EAAAA,GAAO,IACTH,EACHE,GAAGE,EAAAA,EAAAA,OAAMF,EAAG,EAAG,MAEnB,CAEA,SAASG,EAAOrB,EAAee,GAC7B,MAAMC,EAAWhB,EAAMiB,QACjBC,EAAIF,EAASE,GAAK,EAAIH,GAC5B,OAAOI,EAAAA,EAAAA,GAAO,IACTH,EACHE,GAAGE,EAAAA,EAAAA,OAAMF,EAAG,EAAG,MAEnB,CAEA,MAAMI,EAAc,GAGb,SAASzB,EACdT,EACAmC,GAgBA,MAAM,SACJtD,EAAQ,QACRI,EAAO,QACPD,EAAO,UACPoD,EACArD,OAAQsD,EAAgB,OACxBC,EAAM,MACNC,EAAK,oBACLC,EAAmB,OACnBC,EAAS,EAAC,cACV9B,EAAa,SACb+B,EAAQ,UACRxD,EAAS,UACTQ,GAAYC,EAAAA,EAAAA,IAAuBT,IACjCiD,EACE/C,EAASJ,EAAQ,GACjBK,GAASD,EAAOE,IAAMF,EAAOG,OAASN,EAGtC0D,EAAcvD,EAAOG,MACrBqD,EAAYxD,EAAOE,IACnBuD,EAAiBzD,EAAO0D,SAKxB/D,EAASsD,EAA4B,EAATI,EAE5BM,GAASC,EAAAA,EAAAA,IAAeV,EAAQ,UAChCW,GAAYD,EAAAA,EAAAA,IAAeV,EAAQ,aACnCY,GAAmBF,EAAAA,EAAAA,IAAeV,EAAQ,oBAC1Ca,GAAaH,EAAAA,EAAAA,IAAeV,EAAQ,qBACpCc,GAAUJ,EAAAA,EAAAA,IAAeV,EAAQ,WAEjCe,GAAQC,EAAAA,EAAAA,UAAS,IAAKlB,EAAWmB,MAAO,CAAC,EAAGxE,GAAS2D,aACrDc,GAAUC,EAAAA,EAAAA,WAAUrB,EAAUsB,WAC9BC,EAASN,EAAMM,SACfC,EAAUD,EAAO,GACjBE,EAAUF,EAAO,GAGjBG,EAAgC,QAAxB1B,EAAUsB,UAClBK,EAAOC,KAAKC,IAAI,GAChBC,EAAaL,EAAUD,EACvBO,EAA6B,IAAfD,EAAmBnF,EAASmF,EAAa,EACvDE,EAASN,EAAQE,KAAKC,IAAIL,GAAWG,EAAO,EAE5CM,GADSP,EAAQE,KAAKC,IAAIJ,GAAWE,EAAO,GACzBK,EACnBE,EAAuB,IAAZD,EAAgBtF,EAASsF,EAAU,EAE9CE,GADiB7B,EAAW,CAAC3D,EAAQ,GAAK,CAAC,EAAGA,IAChB,KAAOA,EAGrCyF,EAAMV,EACPW,IACC,MACMC,GADSV,KAAKC,IAAIQ,GAAKV,EACJK,GAAUE,EAC7BK,EAASJ,EAAeG,EAAS3F,EAAS2F,EAChD,OAAO1C,EAAAA,EAAAA,OAAM2C,EAAQ,EAAG5F,GAAU0D,GAEnCgC,IACC,MAAMC,GAAUD,EAAIb,GAAWO,EACzBQ,EAASJ,EAAeG,EAAS3F,EAAS2F,EAChD,OAAO1C,EAAAA,EAAAA,OAAM2C,EAAQ,EAAG5F,GAAU0D,GAIlCmC,EAAaH,GAAe1B,EADhB0B,IAAcD,EAAIhB,GAAWgB,EAAIC,GACRI,CAASJ,GAAKT,KAAKc,IAAI1B,EAAS,GAGrE2B,EAAiB,EAAI9F,EAE3B,IAAI+F,GAAc,EAEdC,EAAaC,OAAOC,kBACxB,MAAMvF,EAAkB,GAClBwF,EAAiBxB,EAAUT,GAAcU,EAAUV,EAKzD,GAAyB,aAArBD,EAAiC,CACnC,IAAImC,EACAC,EACJ,IAAK,MAAMC,KAAW1G,EAAS2G,SAAU,EACvCC,EAAAA,EAAAA,IAAgB/F,GAEhB,MAAMgG,EAASH,EAAQnF,IAAI,SACrBuF,EAAOJ,EAAQnF,IAAI,OACnBwF,EAAS/C,GACVD,EAAY+C,GAAQZ,GACpBW,EAAS/C,GAAeoC,EACvBc,EAAUhD,GACXD,EAAY8C,GAAUX,GACtBY,EAAOhD,GAAeoC,EAC3B,GAAIQ,EAAQnF,IAAI,WAAY,CAC1B,MAAM0F,EAAI9B,KAAKc,IAAIe,EAAUD,EAAS1D,EAAakB,GAC7C0B,EAAMS,EAAQnF,IAAI,YAClB2F,EAAIpF,EAAc4E,EAAST,GAC3BkB,EAAaZ,EACfW,EACAA,IAAMV,EACJC,EACCA,EAAU5D,GAAQK,EAAAA,EAAAA,GAAOgE,GAAI,IAAKE,SACzCC,EAAAA,EAAAA,aAAYN,EAAQpB,EAAIM,GAAMgB,EAAGlB,EAAUE,GAAM9E,EAAKgG,GACtDX,EAAUU,CACZ,CACF,CACAT,OAAUa,EACVd,OAAUc,EACV,IAAK,MAAMZ,KAAW1G,EAAS2G,SAAU,EACvCC,EAAAA,EAAAA,IAAgB/F,GAChB,MAAMgG,EAASH,EAAQnF,IAAI,SACrBuF,EAAOJ,EAAQnF,IAAI,OACnBwF,EAAS/C,GACVD,EAAY+C,GAAQZ,GACpBW,EAAS/C,GAAeoC,EACvBc,EAAUhD,GACXD,EAAY8C,GAAUX,GACtBY,EAAOhD,GAAeoC,EACrBqB,EAAQb,EAAQnF,IAAI,SACpB0E,EAAMS,EAAQnF,IAAI,YAClBiG,EAAMd,EAAQnF,IAAI,YAClBkG,EAAUf,EAAQnF,IAAI,WACtB2F,EAAIpF,EAAc4E,EAASa,GAC3BJ,EACJZ,GAAkBkB,EACdP,IAAMV,EACJC,EACCA,GAAUvD,EAAAA,EAAAA,GAAOpB,EAAc4E,EAAST,IACtCyB,KAAIxE,EAAAA,EAAAA,GAAOpB,EAAc4E,EAASc,KAClCG,WACLT,EACAD,EAAI9B,KAAKc,IAAIe,EAAUD,EAAS1D,EAAakB,IAEjDY,KAAKyC,MAAMb,KAAY5B,KAAKyC,MAAMxB,IAClCY,EAAUD,EAAS,KAEnBhG,EAAgB8G,KAAKnB,GACrBN,EAAaW,GAEfZ,EAAcA,GAAeoB,EAAQxC,GAAWwC,EAAQvC,GACxDqC,EAAAA,EAAAA,aAAYN,EAAQpB,EAAI4B,GAAQN,EAAGlB,EAAUwB,GAAQpG,EAAKgG,GAC1DX,EAAUU,CACZ,CACAT,OAAUa,EACVd,OAAUc,EACV,IAAK,MAAMZ,KAAW1G,EAAS2G,SAAU,EACvCC,EAAAA,EAAAA,IAAgB/F,GAChB,MAAMgG,EAASH,EAAQnF,IAAI,SACrBuF,EAAOJ,EAAQnF,IAAI,OACnBwF,EAAS/C,GACVD,EAAY+C,GAAQZ,GACpBW,EAAS/C,GAAeoC,EACvBc,EAAUhD,GACXD,EAAY8C,GAAUX,GACtBY,EAAOhD,GAAeoC,EAE3B,GAAIQ,EAAQnF,IAAI,WAAY,CAC1B,MAAMiG,EAAMd,EAAQnF,IAAI,YAClB2F,EAAIpF,EAAc4E,EAASc,GAC3BP,EAAI9B,KAAKc,IAAIe,EAAUD,EAAS1D,EAAakB,GAC7C4C,EAAaZ,EACfW,EACAA,IAAMV,EACJC,EACCA,EAAUrD,GAAOF,EAAAA,EAAAA,GAAOgE,GAAI,IAAKE,SAExCC,EAAAA,EAAAA,aAAYN,EAAQpB,EAAI6B,GAAMP,EAAGlB,EAAUyB,GAAMrG,EAAKgG,GACtDX,EAAUU,CACZ,CACF,CACF,MACE,IAAK,MAAMR,KAAW1G,EAAS2G,SAAU,EACvCC,EAAAA,EAAAA,IAAgB/F,GAChB,MAAMgG,EAASH,EAAQnF,IAAI,SACrBuF,EAAOJ,EAAQnF,IAAI,OACnBwF,EAAS/C,GACVD,EAAY+C,GAAQZ,GACpBW,EAAS/C,GAAeoC,EACvBc,EAAUhD,GACXD,EAAY8C,GAAUX,GACtBY,EAAOhD,GAAeoC,GAIzBf,KAAKyC,MAAMb,KAAY5B,KAAKyC,MAAMxB,IAClCY,EAAUD,EAAS,KAEnBhG,EAAgB8G,KAAKnB,GACrBN,EAAaW,GAGf,MAAMQ,EAAQb,EAAQnF,IAAI,SACpB2F,EAAIpF,EAAc4E,EAASa,GAEjCpB,EAAcA,GAAeoB,EAAQxC,GAAWwC,EAAQvC,EACxD,MAAMiC,EAAI9B,KAAKc,IAAIe,EAAUD,EAAS1D,EAAakB,GAEnD,GAAyB,QAArBF,EAA4B,CAC9B,MAAMyD,EAAIpB,EAAQnF,IAAI,WAAamF,EAAQnF,IAAI,YAAcgG,GAC7DF,EAAAA,EAAAA,aAAYN,EAAQpB,EAAImC,GAAIb,EAAGlB,EAAU+B,GAAI3G,EAAK+F,EACpD,MAAO,GAAyB,QAArB7C,EAA4B,CACrC,MAAMyD,EAAIpB,EAAQnF,IAAI,WAAamF,EAAQnF,IAAI,YAAcgG,GAC7DF,EAAAA,EAAAA,aAAYN,EAAQpB,EAAImC,GAAIb,EAAGlB,EAAU+B,GAAI3G,EAAK+F,EACpD,MACEG,EAAAA,EAAAA,aAAYN,EAAQpB,EAAI4B,GAAQN,EAAGlB,EAAUwB,GAAQpG,EAAK+F,EAE9D,CAMF,GADA/F,EAAIM,OACA0E,EAAa,CACfhF,EAAI4G,UAAY3D,EAChB,IAAK,MAAMsC,KAAW1G,EAAS2G,SAAU,EACvCC,EAAAA,EAAAA,IAAgB/F,GAChB,MAAMgG,EAASH,EAAQnF,IAAI,SACrBuF,EAAOJ,EAAQnF,IAAI,OACnBwF,EAAS/C,GACVD,EAAY+C,GAAQZ,GACpBW,EAAS/C,GAAeoC,EAIvBe,GAHUjD,GACXD,EAAY8C,GAAUX,GACtBY,EAAOhD,GAAeoC,GACPa,EAAS1D,EACvBkE,EAAQb,EAAQnF,IAAI,SACtBgG,EAAQvC,GACVqC,EAAAA,EAAAA,aAAYN,EAAQnD,EAAQqD,EAzPjB,EAyPgC9F,GAClCoG,EAAQxC,GAAmC,QAAxBxB,EAAUsB,YACtCwC,EAAAA,EAAAA,aAAYN,EAAQvD,EAAkByD,EA3P3B,EA2P0C9F,EAEzD,CACF,CAGA,GAFAA,EAAIoB,UAEAoB,EAAqB,CACvBxC,EAAI6G,UAAY,EAChB7G,EAAIc,YAAc,wBAClB,IAAK,MAAMgG,KAAQvE,EAAMiD,OACvBxF,EAAIe,YACJf,EAAIgB,OAAO,EAAGgD,KAAK+C,MAAMvC,EAAIsC,KAC7B9G,EAAIiB,OAAO5B,EAAO2E,KAAK+C,MAAMvC,EAAIsC,KACjC9G,EAAIkB,QAER,CAEA,MAAO,CACLtB,kBAEJ,C","sources":["webpack://@jbrowse/web/../../plugins/wiggle/src/MultiRowXYPlotRenderer/renderMultiRowXYPlot.ts","webpack://@jbrowse/web/../../plugins/wiggle/src/drawXY.ts"],"sourcesContent":["import {\n  createStopTokenChecker,\n  groupBy,\n  renderToAbstractCanvas,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\n\nimport { drawXY } from '../drawXY.ts'\nimport { serializeWiggleFeature } from '../util.ts'\n\nimport type { MultiRenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderMultiRowXYPlot(\n  renderProps: MultiRenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    sources,\n    height,\n    regions,\n    bpPerPx,\n    stopToken,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const rowHeight = height / sources.length\n\n  const lastCheck = createStopTokenChecker(stopToken)\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx => {\n        const groups = groupBy(features, f => f.get('source'))\n        let allReducedFeatures: Feature[] = []\n        ctx.save()\n        for (const source of sources) {\n          const { reducedFeatures: reduced } = drawXY(ctx, {\n            ...renderProps,\n            features: groups[source.name] || [],\n            height: rowHeight,\n            colorCallback: () => source.color || 'blue',\n            lastCheck,\n          })\n          allReducedFeatures = allReducedFeatures.concat(reduced)\n          ctx.strokeStyle = 'rgba(200,200,200,0.8)'\n          ctx.beginPath()\n          ctx.moveTo(0, rowHeight)\n          ctx.lineTo(width, rowHeight)\n          ctx.stroke()\n          ctx.translate(0, rowHeight)\n        }\n        ctx.restore()\n        return { reducedFeatures: allReducedFeatures }\n      }),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { fillRectCtx, getOrigin, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, Region } from '@jbrowse/core/util'\nimport type { Colord } from '@jbrowse/core/util/colord'\nimport type {\n  LastStopTokenCheck,\n  StopToken,\n} from '@jbrowse/core/util/stopToken'\n\nfunction lighten(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 + amount)\n  return colord({\n    ...hslColor,\n    l: clamp(l, 0, 100),\n  })\n}\n\nfunction darken(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 - amount)\n  return colord({\n    ...hslColor,\n    l: clamp(l, 0, 100),\n  })\n}\n\nconst fudgeFactor = 0.3\nconst clipHeight = 2\n\nexport function drawXY(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    bpPerPx: number\n    regions: Region[]\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    config: AnyConfigurationModel\n    displayCrossHatches: boolean\n    inverted: boolean\n    offset?: number\n    lastCheck?: LastStopTokenCheck\n    stopToken?: StopToken\n    colorCallback: (f: Feature, score: number) => string\n  },\n) {\n  const {\n    features,\n    bpPerPx,\n    regions,\n    scaleOpts,\n    height: unadjustedHeight,\n    config,\n    ticks,\n    displayCrossHatches,\n    offset = 0,\n    colorCallback,\n    inverted,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  // Extract region values once to avoid repeated property access in hot loop\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionReversed = region.reversed\n\n  // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the\n  // wiggle display, and makes the height of the actual drawn area add\n  // \"padding\" to the top and bottom of the display\n  const height = unadjustedHeight - offset * 2\n\n  const filled = readConfObject(config, 'filled')\n  const clipColor = readConfObject(config, 'clipColor')\n  const summaryScoreMode = readConfObject(config, 'summaryScoreMode')\n  const pivotValue = readConfObject(config, 'bicolorPivotValue')\n  const minSize = readConfObject(config, 'minSize')\n\n  const scale = getScale({ ...scaleOpts, range: [0, height], inverted })\n  const originY = getOrigin(scaleOpts.scaleType)\n  const domain = scale.domain()\n  const niceMin = domain[0]!\n  const niceMax = domain[1]!\n\n  // Precompute scale values for fast toY calculation\n  const isLog = scaleOpts.scaleType === 'log'\n  const log2 = Math.log(2)\n  const domainSpan = niceMax - niceMin\n  const linearRatio = domainSpan !== 0 ? height / domainSpan : 0\n  const logMin = isLog ? Math.log(niceMin) / log2 : 0\n  const logMax = isLog ? Math.log(niceMax) / log2 : 0\n  const logSpan = logMax - logMin\n  const logRatio = logSpan !== 0 ? height / logSpan : 0\n  const effectiveRange = inverted ? [height, 0] : [0, height]\n  const rangeFlipped = effectiveRange[0] === height\n\n  // Inlined toY - avoids d3-scale function call overhead\n  const toY = isLog\n    ? (n: number) => {\n        const logVal = Math.log(n) / log2\n        const scaled = (logVal - logMin) * logRatio\n        const result = rangeFlipped ? scaled : height - scaled\n        return clamp(result, 0, height) + offset\n      }\n    : (n: number) => {\n        const scaled = (n - niceMin) * linearRatio\n        const result = rangeFlipped ? scaled : height - scaled\n        return clamp(result, 0, height) + offset\n      }\n\n  const toOrigin = (n: number) => toY(originY) - toY(n)\n  const getHeight = (n: number) => (filled ? toOrigin(n) : Math.max(minSize, 1))\n\n  // Precompute for inline px calculation (avoids featureSpanPx function call overhead)\n  const inverseBpPerPx = 1 / bpPerPx\n\n  let hasClipping = false\n\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n  const crossingOrigin = niceMin < pivotValue && niceMax > pivotValue\n\n  // we handle whiskers separately to render max row, min row, and avg in three\n  // passes. this reduces subpixel rendering issues. note: for stylistic\n  // reasons, clipping indicator is only drawn for score, not min/max score\n  if (summaryScoreMode === 'whiskers') {\n    let lastCol: string | undefined\n    let lastMix: string | undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      if (feature.get('summary')) {\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const max = feature.get('maxScore')\n        const c = colorCallback(feature, max)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = lighten(colord(c), 0.4).toHex())\n        fillRectCtx(leftPx, toY(max), w, getHeight(max), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n    lastMix = undefined\n    lastCol = undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const score = feature.get('score')\n      const max = feature.get('maxScore')\n      const min = feature.get('minScore')\n      const summary = feature.get('summary')\n      const c = colorCallback(feature, score)\n      const effectiveC =\n        crossingOrigin && summary\n          ? c === lastCol\n            ? lastMix\n            : (lastMix = colord(colorCallback(feature, max))\n                .mix(colord(colorCallback(feature, min)))\n                .toString())\n          : c\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n      if (\n        Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n        rightPx - leftPx > 1\n      ) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, effectiveC)\n      lastCol = c\n    }\n    lastMix = undefined\n    lastCol = undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n\n      if (feature.get('summary')) {\n        const min = feature.get('minScore')\n        const c = colorCallback(feature, min)\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = darken(colord(c), 0.4).toHex())\n\n        fillRectCtx(leftPx, toY(min), w, getHeight(min), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n  } else {\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      if (\n        Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n        rightPx - leftPx > 1\n      ) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n\n      const score = feature.get('score')\n      const c = colorCallback(feature, score)\n\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n\n      if (summaryScoreMode === 'max') {\n        const s = feature.get('summary') ? feature.get('maxScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else if (summaryScoreMode === 'min') {\n        const s = feature.get('summary') ? feature.get('minScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else {\n        fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, c)\n      }\n    }\n  }\n\n  // second pass: draw clipping\n  // avoid persisting the red fillstyle with save/restore\n  ctx.save()\n  if (hasClipping) {\n    ctx.fillStyle = clipColor\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const w = rightPx - leftPx + fudgeFactor\n      const score = feature.get('score')\n      if (score > niceMax) {\n        fillRectCtx(leftPx, offset, w, clipHeight, ctx)\n      } else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n        fillRectCtx(leftPx, unadjustedHeight, w, clipHeight, ctx)\n      }\n    }\n  }\n  ctx.restore()\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    for (const tick of ticks.values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n\n  return {\n    reducedFeatures,\n  }\n}\n"],"names":["async","renderMultiRowXYPlot","renderProps","features","sources","height","regions","bpPerPx","stopToken","statusCallback","region","width","end","start","rowHeight","length","lastCheck","createStopTokenChecker","reducedFeatures","rest","updateStatus","renderToAbstractCanvas","ctx","groups","groupBy","f","get","allReducedFeatures","save","source","reduced","drawXY","name","colorCallback","color","concat","strokeStyle","beginPath","moveTo","lineTo","stroke","translate","restore","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables","lighten","amount","hslColor","toHsl","l","colord","clamp","darken","fudgeFactor","props","scaleOpts","unadjustedHeight","config","ticks","displayCrossHatches","offset","inverted","regionStart","regionEnd","regionReversed","reversed","filled","readConfObject","clipColor","summaryScoreMode","pivotValue","minSize","scale","getScale","range","originY","getOrigin","scaleType","domain","niceMin","niceMax","isLog","log2","Math","log","domainSpan","linearRatio","logMin","logSpan","logRatio","rangeFlipped","toY","n","scaled","result","getHeight","toOrigin","max","inverseBpPerPx","hasClipping","prevLeftPx","Number","NEGATIVE_INFINITY","crossingOrigin","lastCol","lastMix","feature","values","checkStopToken2","fStart","fEnd","leftPx","rightPx","w","c","effectiveC","toHex","fillRectCtx","undefined","score","min","summary","mix","toString","floor","push","s","fillStyle","lineWidth","tick","round"],"sourceRoot":""}