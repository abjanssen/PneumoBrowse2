{"version":3,"file":"static/js/9978.f234013c.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/shared/drawAlleleCount.ts","../../../plugins/variants/src/shared/drawPhased.ts","../../../plugins/variants/src/shared/util.ts","../../../plugins/variants/src/shared/constants.ts","../../../plugins/variants/src/MultiLinearVariantRenderer/makeImageData.ts"],"sourcesContent":["import { colord } from '@jbrowse/core/util/colord'\n\nimport { f2 } from './constants'\n\nexport function getColorAlleleCount(\n  ref: number,\n  alt: number,\n  alt2: number,\n  uncalled: number,\n  total: number,\n  drawReference = true,\n) {\n  if (ref === total) {\n    // empty string is not defined, but signals no draw\n    return drawReference ? '#ccc' : ''\n  } else {\n    let a1\n    if (alt) {\n      a1 = colord(`hsl(200,50%,${80 - (alt / total) * 50}%)`)\n    }\n    if (alt2) {\n      const l = `hsla(0,100%,20%,${alt2 / total})`\n      // @ts-ignore\n      a1 = a1 ? a1.mix(l) : colord(l)\n    }\n    if (uncalled) {\n      const l = `hsl(50,50%,50%,${uncalled / total})`\n      // @ts-ignore\n      a1 = a1 ? a1.mix(l) : colord(l)\n    }\n    return a1?.toHex() || 'black'\n  }\n}\n\nexport function drawColorAlleleCount(\n  c: string,\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  featureType = '',\n  featureStrand?: number,\n  alpha = 1,\n) {\n  ctx.fillStyle = alpha !== 1 ? colord(c).alpha(alpha).toHex() : c\n  if (featureType === 'inversion') {\n    // draw triangle pointing to the right\n    if (featureStrand === 1) {\n      ctx.beginPath()\n      ctx.moveTo(x - f2, y - f2) // left top\n      ctx.lineTo(x - f2, y + h + f2) // left bottom\n      ctx.lineTo(x + w + f2, y + h / 2) // right middle\n      ctx.closePath()\n      ctx.fill()\n    } else {\n      // draw triangle pointing to the left\n      ctx.beginPath()\n      ctx.moveTo(x + w + f2, y - f2) // right top\n      ctx.lineTo(x + w + f2, y + h + f2) // right bottom\n      ctx.lineTo(x - f2, y + h / 2) // left middle\n      ctx.closePath()\n      ctx.fill()\n    }\n  } else {\n    ctx.fillRect(x - f2, y - f2, w + f2, h + f2)\n  }\n}\n","import { set1 } from '@jbrowse/core/ui/colors'\nimport { colord } from '@jbrowse/core/util/colord'\n\nimport { f2 } from './constants'\nimport { colorify } from './util'\n\nfunction getColorPhased(alleles: string[], HP: number, drawReference = true) {\n  const c = +alleles[HP]!\n  return c ? set1[c - 1] || 'black' : drawReference ? '#ccc' : undefined\n}\n\nfunction getColorPhasedWithPhaseSet(\n  alleles: string[],\n  HP: number,\n  PS: string,\n  drawReference = true,\n) {\n  const c = +alleles[HP]!\n  return c ? colorify(+PS) || 'black' : drawReference ? '#ccc' : undefined\n}\n\nexport function drawPhased(\n  alleles: string[],\n  ctx: CanvasRenderingContext2D,\n  x: number,\n  y: number,\n  w: number,\n  h: number,\n  HP: number,\n  PS?: string,\n  drawReference = true,\n  alpha = 1,\n) {\n  const c =\n    PS !== undefined\n      ? getColorPhasedWithPhaseSet(alleles, HP, PS, drawReference)\n      : getColorPhased(alleles, HP, drawReference)\n  if (c) {\n    ctx.fillStyle = alpha !== 1 ? colord(c).alpha(alpha).toHex() : c\n    ctx.fillRect(x - f2, y - f2, w + f2, h + f2)\n  }\n  return c\n}\n","// avoid drawing negative width features for SVG exports\nexport function fillRectCtx(\n  x: number,\n  y: number,\n  width: number,\n  height: number,\n  ctx: CanvasRenderingContext2D,\n  color?: string,\n) {\n  if (width < 0) {\n    x += width\n    width = -width\n  }\n  if (height < 0) {\n    y += height\n    height = -height\n  }\n\n  if (color) {\n    ctx.fillStyle = color\n  }\n  ctx.fillRect(x, y, width, height)\n}\n\nexport function randomColor(str: string) {\n  let sum = 0\n\n  for (let i = 0; i < str.length; i++) {\n    sum += str.charCodeAt(i)\n  }\n  return colorify(sum * 10)\n}\n\nexport function colorify(n: number) {\n  return `hsl(${n % 255}, 50%, 50%)`\n}\n","export const fudgeFactor = 0.6\nexport const f2 = fudgeFactor / 2\n","import {\n  featureSpanPx,\n  forEachWithStopTokenCheck,\n  updateStatus,\n} from '@jbrowse/core/util'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\nimport RBush from 'rbush'\n\nimport { f2 } from '../shared/constants'\nimport {\n  drawColorAlleleCount,\n  getColorAlleleCount,\n} from '../shared/drawAlleleCount'\nimport { drawPhased } from '../shared/drawPhased'\nimport { getFeaturesThatPassMinorAlleleFrequencyFilter } from '../shared/minorAlleleFrequencyUtils'\n\nimport type { MultiRenderArgsDeserialized } from './types'\n\nexport async function makeImageData(\n  ctx: CanvasRenderingContext2D,\n  props: MultiRenderArgsDeserialized,\n) {\n  const {\n    scrollTop,\n    minorAlleleFrequencyFilter,\n    sources,\n    rowHeight,\n    features,\n    regions,\n    bpPerPx,\n    renderingMode,\n    stopToken,\n    lengthCutoffFilter,\n    referenceDrawingMode,\n  } = props\n  const region = regions[0]!\n  const { statusCallback = () => {} } = props\n  checkStopToken(stopToken)\n  const mafs = await updateStatus('Calculating stats', statusCallback, () =>\n    getFeaturesThatPassMinorAlleleFrequencyFilter({\n      stopToken,\n      features: features.values(),\n      minorAlleleFrequencyFilter,\n      lengthCutoffFilter,\n    }),\n  )\n  checkStopToken(stopToken)\n  const rbush = new RBush()\n\n  await updateStatus('Drawing variants', statusCallback, () => {\n    forEachWithStopTokenCheck(\n      mafs,\n      stopToken,\n      ({ mostFrequentAlt, feature }) => {\n        const [leftPx, rightPx] = featureSpanPx(feature, region, bpPerPx)\n        const flen = feature.get('end') - feature.get('start')\n        const w = Math.max(Math.round(rightPx - leftPx), 2)\n        const samp = feature.get('genotypes') as Record<string, string>\n        let y = -scrollTop\n\n        const s = sources.length\n        if (renderingMode === 'phased') {\n          for (let j = 0; j < s; j++) {\n            const { name, HP } = sources[j]!\n            const genotype = samp[name]\n            const x = Math.floor(leftPx)\n            const h = Math.max(rowHeight, 1)\n            if (genotype) {\n              const isPhased = genotype.includes('|')\n              if (isPhased) {\n                const alleles = genotype.split('|')\n                if (\n                  drawPhased(\n                    alleles,\n                    ctx,\n                    x,\n                    y,\n                    w,\n                    h,\n                    HP!,\n                    undefined,\n                    referenceDrawingMode === 'draw',\n                  )\n                ) {\n                  rbush.insert({\n                    minX: x,\n                    maxX: x + w,\n                    minY: y,\n                    maxY: y + h,\n                    genotype,\n                    name,\n                    featureId: feature.id(),\n                  })\n                }\n              } else {\n                ctx.fillStyle = 'black'\n                ctx.fillRect(x - f2, y - f2, w + f2, h + f2)\n              }\n            }\n            y += rowHeight\n          }\n        } else {\n          const colorCache = {} as Record<string, string | undefined>\n          for (let j = 0; j < s; j++) {\n            const { name } = sources[j]!\n            const genotype = samp[name]\n            const x = Math.floor(leftPx)\n            const h = Math.max(rowHeight, 1)\n            if (genotype) {\n              let c = colorCache[genotype]\n              if (c === undefined) {\n                let alt = 0\n                let uncalled = 0\n                let alt2 = 0\n                let ref = 0\n                const alleles = genotype.split(/[/|]/)\n                const total = alleles.length\n\n                for (let i = 0; i < total; i++) {\n                  const allele = alleles[i]!\n                  if (allele === mostFrequentAlt) {\n                    alt++\n                  } else if (allele === '0') {\n                    ref++\n                  } else if (allele === '.') {\n                    uncalled++\n                  } else {\n                    alt2++\n                  }\n                }\n                c = getColorAlleleCount(\n                  ref,\n                  alt,\n                  alt2,\n                  uncalled,\n                  total,\n                  referenceDrawingMode === 'draw',\n                )\n                colorCache[genotype] = c\n              }\n              if (c) {\n                drawColorAlleleCount(\n                  c,\n                  ctx,\n                  x,\n                  y,\n                  w,\n                  h,\n                  feature.get('type'),\n                  feature.get('strand'),\n                  flen > 5 ? 0.75 : 1,\n                )\n                rbush.insert({\n                  minX: x,\n                  maxX: x + w,\n                  minY: y,\n                  maxY: y + h,\n                  genotype,\n                  name,\n                  featureId: feature.id(),\n                })\n              }\n            }\n            y += rowHeight\n          }\n        }\n      },\n    )\n  })\n\n  return {\n    rbush: rbush.toJSON(),\n    featureGenotypeMap: Object.fromEntries(\n      mafs.map(({ feature }) => [\n        feature.id(),\n        {\n          alt: feature.get('ALT'),\n          ref: feature.get('REF'),\n          name: feature.get('name'),\n          description: feature.get('description'),\n          length: feature.get('end') - feature.get('start'),\n        },\n      ]),\n    ),\n  }\n}\n"],"names":["getColorAlleleCount","ref","alt","alt2","uncalled","total","drawReference","a1","colord","l","mix","toHex","drawColorAlleleCount","c","ctx","x","y","w","h","featureType","featureStrand","alpha","fillStyle","beginPath","moveTo","f2","lineTo","closePath","fill","fillRect","drawPhased","alleles","HP","PS","undefined","colorify","getColorPhasedWithPhaseSet","set1","getColorPhased","randomColor","str","sum","i","length","charCodeAt","n","fudgeFactor","async","makeImageData","props","scrollTop","minorAlleleFrequencyFilter","sources","rowHeight","features","regions","bpPerPx","renderingMode","stopToken","lengthCutoffFilter","referenceDrawingMode","region","statusCallback","checkStopToken","mafs","updateStatus","getFeaturesThatPassMinorAlleleFrequencyFilter","values","rbush","RBush","forEachWithStopTokenCheck","mostFrequentAlt","feature","leftPx","rightPx","featureSpanPx","flen","get","Math","max","round","samp","s","j","name","genotype","floor","includes","split","insert","minX","maxX","minY","maxY","featureId","id","colorCache","allele","toJSON","featureGenotypeMap","Object","fromEntries","map","description"],"sourceRoot":""}