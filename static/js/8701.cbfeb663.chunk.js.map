{"version":3,"file":"static/js/8701.cbfeb663.chunk.js","mappings":"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","sources":["../../../plugins/variants/src/MultiLinearVariantMatrixRenderer/components/MultiLinearVariantMatrixRendering.tsx","../../../plugins/variants/src/VcfFeature/util.ts"],"sourcesContent":["import { useCallback, useRef } from 'react'\n\nimport { PrerenderedCanvas } from '@jbrowse/core/ui'\nimport { getBpDisplayStr } from '@jbrowse/core/util'\nimport { observer } from 'mobx-react'\n\nimport { makeSimpleAltString } from '../../VcfFeature/util.ts'\n\nimport type { MultiVariantBaseModel } from '../../shared/MultiVariantBaseModel.ts'\n\ninterface FeatureData {\n  alt: string[]\n  ref: string\n  name: string\n  description: string\n  length: number\n}\n\nconst MultiLinearVariantMatrixRendering = observer(\n  function MultiLinearVariantMatrixRendering(props: {\n    width: number\n    height: number\n    displayModel: MultiVariantBaseModel\n    arr: string[][]\n    featureData: FeatureData[]\n    rowHeight: number\n    origScrollTop: number\n    totalHeight: number\n  }) {\n    const {\n      arr,\n      width,\n      displayModel,\n      featureData,\n      totalHeight,\n      origScrollTop,\n      rowHeight,\n    } = props\n    const ref = useRef<HTMLDivElement>(null)\n    const lastHoveredRef = useRef<string | undefined>(undefined)\n\n    const getFeatureUnderMouse = useCallback(\n      (eventClientX: number, eventClientY: number) => {\n        if (!ref.current) {\n          return\n        }\n        const r = ref.current.getBoundingClientRect()\n        const offsetX = eventClientX - r.left\n        const offsetY = eventClientY - r.top\n\n        const { sources } = displayModel\n\n        // Canvas is positioned at top=origScrollTop, so adjust mouse position\n        // relative to canvas top\n        const canvasOffsetY = offsetY - origScrollTop\n        // The first row in the canvas corresponds to source at index startRow\n        const startRow = Math.floor(origScrollTop / rowHeight)\n        const visibleRowIdx = Math.floor(canvasOffsetY / rowHeight)\n        const sourceIdx = startRow + visibleRowIdx\n        const name = sources?.[sourceIdx]?.name\n        const featureIdx = Math.floor((offsetX / width) * arr.length)\n        const genotype = arr[featureIdx]?.[visibleRowIdx]\n        const feature = featureData[featureIdx]\n\n        if (genotype && name && feature) {\n          const { ref, alt, name: featureName, description, length } = feature\n          const alleles = makeSimpleAltString(genotype, ref, alt)\n          return {\n            name,\n            genotype,\n            alleles,\n            featureName,\n            description: alt.length >= 3 ? 'multiple ALT alleles' : description,\n            length: getBpDisplayStr(length),\n          }\n        }\n        return undefined\n      },\n      [arr, width, displayModel, featureData, origScrollTop, rowHeight],\n    )\n\n    const handleMouseMove = useCallback(\n      (e: React.MouseEvent) => {\n        const result = getFeatureUnderMouse(e.clientX, e.clientY)\n        const key = result ? `${result.name}:${result.genotype}` : undefined\n        if (key !== lastHoveredRef.current) {\n          lastHoveredRef.current = key\n          displayModel.setHoveredGenotype(result)\n        }\n      },\n      [getFeatureUnderMouse, displayModel],\n    )\n\n    const handleMouseLeave = useCallback(() => {\n      if (lastHoveredRef.current !== undefined) {\n        lastHoveredRef.current = undefined\n        displayModel.setHoveredGenotype(undefined)\n      }\n    }, [displayModel])\n\n    return (\n      <div\n        ref={ref}\n        onMouseMove={handleMouseMove}\n        onMouseLeave={handleMouseLeave}\n        onMouseOut={handleMouseLeave}\n        style={{\n          overflow: 'visible',\n          position: 'relative',\n          height: totalHeight,\n        }}\n      >\n        <PrerenderedCanvas\n          {...props}\n          style={{\n            position: 'absolute',\n            left: 0,\n            top: origScrollTop,\n          }}\n        />\n      </div>\n    )\n  },\n)\n\nexport default MultiLinearVariantMatrixRendering\n","import { parseBreakend } from '@gmod/vcf'\nimport { getBpDisplayStr } from '@jbrowse/core/util'\n\nimport type VCF from '@gmod/vcf'\n\nconst genotypeDelimRegex = /[/|]/\n\nfunction isBreakend(alt: string) {\n  return (\n    alt.includes('[') ||\n    alt.includes(']') ||\n    alt.startsWith('.') ||\n    alt.endsWith('.')\n  )\n}\n\nfunction isSymbolic(alt: string) {\n  return alt.startsWith('<') || isBreakend(alt)\n}\n\nfunction isInversion(ref: string, alt: string) {\n  return ref.split('').reverse().join('') === alt\n}\n\nconst altTypeToSO: Record<string, string> = {\n  '<DEL>': 'deletion',\n  '<INS>': 'insertion',\n  '<DUP>': 'duplication',\n  '<INV>': 'inversion',\n  '<INVDUP>': 'inverted_duplication',\n  '<CNV>': 'copy_number_variation',\n  '<TRA>': 'translocation',\n  '<DUP:TANDEM>': 'tandem_duplication',\n  '<NON_REF>': 'sequence_variant',\n  '<*>': 'sequence_variant',\n}\n\nexport function getSOTermAndDescription(\n  ref: string,\n  alt: string[] | undefined,\n  parser: VCF,\n): string[] {\n  if (!alt || alt.length === 0) {\n    return ['remark', 'no alternative alleles']\n  }\n\n  const soTerms = alt.map(a => getSOTerm(a, ref, parser))\n  const uniqueSoTerms = [...new Set(soTerms)]\n  const description = formatGroupDescription(ref, alt)\n\n  return [uniqueSoTerms.join(','), description]\n}\n\nfunction getSOTerm(alt: string, ref: string, parser: VCF): string {\n  // Symbolic alleles\n  if (alt.startsWith('<')) {\n    return findSOTerm(alt, parser) ?? 'variant'\n  }\n\n  // Breakends\n  if (isBreakend(alt) && parseBreakend(alt)) {\n    return 'breakend'\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n\n  if (lenRef === 1 && lenAlt === 1) {\n    return 'SNV'\n  } else if (lenRef === lenAlt) {\n    return isInversion(ref, alt) ? 'inversion' : 'substitution'\n  } else {\n    return lenRef < lenAlt ? 'insertion' : 'deletion'\n  }\n}\n\nfunction formatGroupDescription(ref: string, alts: string[]): string {\n  if (alts.every(isSymbolic)) {\n    return alts.join(',')\n  }\n\n  const lenRef = ref.length\n\n  return `${ref.length > 10 ? getBpDisplayStr(lenRef) : ref} -> ${alts.map(a => (a.length > 10 ? getBpDisplayStr(a.length) : a)).join(',')}`\n}\n\nfunction findSOTerm(alt: string, parser: VCF): string | undefined {\n  if (altTypeToSO[alt]) {\n    return altTypeToSO[alt]\n  }\n  if (parser.getMetadata('ALT', alt)) {\n    return 'sequence_variant'\n  }\n  // Try parent term by stripping last component, e.g. '<INS:ME>' -> '<INS>'\n  const parts = alt.slice(1, -1).split(':')\n  return parts.length > 1\n    ? findSOTerm(`<${parts.slice(0, -1).join(':')}>`, parser)\n    : undefined\n}\n\nexport function getSOAndDescFromAltDefs(alt: string, parser: VCF): string[] {\n  if (!alt.startsWith('<')) {\n    return []\n  }\n\n  const soTerm = findSOTerm(alt, parser)\n  return [soTerm ?? 'variant', alt]\n}\n\nexport function getMinimalDesc(ref: string, alt: string) {\n  if (isSymbolic(alt) || (ref.length === 1 && alt.length === 1)) {\n    return alt\n  }\n\n  const lenRef = ref.length\n  const lenAlt = alt.length\n  const isLong = lenRef > 5 || lenAlt > 5\n\n  return isLong\n    ? `${getBpDisplayStr(lenRef)} -> ${getBpDisplayStr(lenAlt)}`\n    : `${ref} -> ${alt}`\n}\n\nexport function makeSimpleAltString(\n  genotype: string,\n  ref: string,\n  alt: string[],\n) {\n  return genotype\n    .split(genotypeDelimRegex)\n    .map(r =>\n      r === '.'\n        ? '.'\n        : +r === 0\n          ? `ref(${ref.length < 10 ? ref : getBpDisplayStr(ref.length)})`\n          : getMinimalDesc(ref, alt[+r - 1] || ''),\n    )\n    .join(genotype.includes('|') ? '|' : '/')\n}\n"],"names":["observer","props","arr","width","displayModel","featureData","totalHeight","origScrollTop","rowHeight","ref","useRef","lastHoveredRef","undefined","getFeatureUnderMouse","useCallback","eventClientX","eventClientY","current","r","getBoundingClientRect","offsetX","left","offsetY","top","sources","canvasOffsetY","startRow","Math","floor","visibleRowIdx","sourceIdx","name","featureIdx","length","genotype","feature","alt","featureName","description","alleles","makeSimpleAltString","getBpDisplayStr","handleMouseMove","e","result","clientX","clientY","key","setHoveredGenotype","handleMouseLeave","_jsx","onMouseMove","onMouseLeave","onMouseOut","style","overflow","position","height","children","PrerenderedCanvas","genotypeDelimRegex","isBreakend","includes","startsWith","endsWith","isSymbolic","altTypeToSO","getSOTermAndDescription","parser","soTerms","map","a","findSOTerm","parseBreakend","lenRef","lenAlt","split","reverse","join","isInversion","getSOTerm","uniqueSoTerms","Set","alts","every","formatGroupDescription","getMetadata","parts","slice","getMinimalDesc"],"ignoreList":[],"sourceRoot":""}