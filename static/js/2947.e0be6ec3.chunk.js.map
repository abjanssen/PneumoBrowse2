{"version":3,"file":"static/js/2947.e0be6ec3.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/ModificationParser/getModPositions.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processDepth.ts","../../../plugins/alignments/src/SNPCoverageAdapter/util.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processMismatches.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processModifications.ts","../../../plugins/alignments/src/SNPCoverageAdapter/processReferenceCpGs.ts","../../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts","../../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBins.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts","../../../plugins/alignments/src/ModificationParser/getModProbabilities.ts","../../../plugins/alignments/src/ModificationParser/getMethBins.ts"],"sourcesContent":["import { revcom } from '@jbrowse/core/util'\n\nimport { modificationRegex } from './consts'\n\n/**\n * Parse MM tag to extract modification positions on the read sequence.\n *\n *\n * @param mm - MM tag string (e.g., \"C+m,2,2,1;A+a,0,3\")\n * @param fseq - Read sequence\n * @param fstrand - Read strand (-1, 0, or 1)\n * @returns Array of modification objects with positions\n */\nexport function getModPositions(mm: string, fseq: string, fstrand: number) {\n  const seq = fstrand === -1 ? revcom(fseq) : fseq\n  const seqLength = seq.length\n  const mods = mm.split(';')\n  const result = []\n\n  for (const mod of mods) {\n    // Empty string\n    if (mod === '') {\n      continue\n    }\n\n    const split = mod.split(',')\n    const basemod = split[0]!\n    const matches = modificationRegex.exec(basemod)\n    if (!matches) {\n      throw new Error(`bad format for MM tag: \"${mod}\"`)\n    }\n    const [, base, strand, typestr] = matches\n\n    // can be a multi e.g. C+mh for both meth (m) and hydroxymeth (h) so split,\n    // and they can also be chemical codes (ChEBI) e.g. C+16061\n    const types = typestr!.split(/(\\d+|.)/)\n\n    // Note: Negative strand modifications (e.g., T-a) are now supported\n    // They are processed the same way as positive strand modifications\n    // The strand information is preserved for simplex/duplex detection\n\n    // this logic based on parse_mm.pl from hts-specs\n    for (const type of types) {\n      if (type === '') {\n        continue\n      }\n\n      const splitLength = split.length\n      let currPos = 0\n\n      // For reverse strand, pre-allocate array and fill backwards to avoid reverse()\n      // This is worthwhile because we avoid an O(n) reverse() operation\n      const positions = fstrand === -1 ? new Array(splitLength - 1) : []\n      let writeIndex = fstrand === -1 ? splitLength - 2 : 0\n\n      for (let i = 1; i < splitLength; i++) {\n        let delta = +split[i]!\n        do {\n          if (base === 'N' || base === seq[currPos]) {\n            delta--\n          }\n          currPos++\n        } while (delta >= 0 && currPos < seqLength)\n\n        // Calculate and store position\n        if (fstrand === -1) {\n          const pos = seqLength - currPos\n          if (pos >= 0) {\n            // avoid negative-number-positions in array, seen in #4629 cause\n            // unknown, could warrant some further investigation\n            positions[writeIndex--] = pos\n          } else {\n            // Position is negative (edge case from #4629)\n            // Don't write anything, don't decrement writeIndex\n            // This leaves a gap at the beginning of the array that we'll slice off\n          }\n        } else {\n          positions[writeIndex++] = currPos - 1\n        }\n      }\n\n      // For reverse strand, slice off any unfilled slots at the beginning\n      // (happens when some positions were negative and skipped)\n      const validPositions =\n        fstrand === -1 ? positions.slice(writeIndex + 1) : positions\n\n      result.push({\n        type,\n        base: base!,\n        strand: strand!,\n        positions: validPositions,\n      })\n    }\n  }\n\n  return result\n}\n","import type { PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion } from '@jbrowse/core/util/types'\n\nexport function processDepth({\n  feature,\n  bins,\n  region,\n}: {\n  feature: Feature\n  bins: PreBaseCoverageBin[]\n  region: AugmentedRegion\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const regionLength = region.end - region.start\n  for (let j = fstart; j < fend + 1; j++) {\n    const i = j - region.start\n    if (i >= 0 && i < regionLength) {\n      if (bins[i] === undefined) {\n        bins[i] = {\n          depth: 0,\n          readsCounted: 0,\n          ref: {\n            probabilities: [],\n            entryDepth: 0,\n            '-1': 0,\n            0: 0,\n            1: 0,\n          },\n          snps: {},\n          mods: {},\n          nonmods: {},\n          delskips: {},\n          noncov: {},\n        }\n      }\n      if (j !== fend) {\n        bins[i].depth++\n        bins[i].readsCounted++\n        bins[i].ref.entryDepth++\n        bins[i].ref[fstrand]++\n      }\n    }\n  }\n}\n","import type {\n  ColorBy,\n  Mismatch,\n  PreBaseCoverageBin,\n  PreBaseCoverageBinSubtypes,\n} from '../shared/types'\n\nexport interface Opts {\n  bpPerPx?: number\n  colorBy?: ColorBy\n  stopToken?: string\n}\n\nexport function mismatchLen(mismatch: Mismatch) {\n  return !isInterbase(mismatch.type) ? mismatch.length : 1\n}\n\nexport function isInterbase(type: string) {\n  return type === 'softclip' || type === 'hardclip' || type === 'insertion'\n}\n\nexport function inc(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin[strand]++\n}\n\nexport function incWithProbabilities(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  probability: number,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin.probabilities.push(probability)\n  thisBin[strand]++\n}\n","import { inc, isInterbase, mismatchLen } from './util'\n\nimport type { Mismatch, PreBaseCoverageBin, SkipMap } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion } from '@jbrowse/core/util/types'\n\nexport function processMismatches({\n  feature,\n  region,\n  bins,\n  skipmap,\n}: {\n  region: AugmentedRegion\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  skipmap: SkipMap\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n\n  // normal SNP based coloring\n  for (const mismatch of mismatches) {\n    const mstart = fstart + mismatch.start\n    const mlen = mismatchLen(mismatch)\n    const mend = mstart + mlen\n    for (let j = mstart; j < mstart + mlen; j++) {\n      const epos = j - region.start\n      if (epos >= 0 && epos < bins.length) {\n        const bin = bins[epos]!\n        const { base, altbase, type } = mismatch\n        const interbase = isInterbase(type)\n\n        if (type === 'deletion' || type === 'skip') {\n          inc(bin, fstrand, 'delskips', type)\n          bin.depth--\n        } else if (!interbase) {\n          inc(bin, fstrand, 'snps', base)\n          bin.ref.entryDepth--\n          bin.ref[fstrand]--\n          bin.refbase = altbase\n        } else {\n          inc(bin, fstrand, 'noncov', type)\n        }\n      }\n    }\n\n    if (mismatch.type === 'skip') {\n      // for upper case XS and TS: reports the literal strand of the genomic\n      // transcript\n      const tags = feature.get('tags')\n      const xs = tags?.XS || tags?.TS\n      // for lower case ts from minimap2: genomic transcript flipped by read\n      // strand\n      const ts = tags?.ts\n      const effectiveStrand =\n        xs === '+'\n          ? 1\n          : xs === '-'\n            ? -1\n            : (ts === '+' ? 1 : xs === '-' ? -1 : 0) * fstrand\n      const hash = `${mstart}_${mend}_${effectiveStrand}`\n      if (skipmap[hash] === undefined) {\n        skipmap[hash] = {\n          feature: feature,\n          start: mstart,\n          end: mend,\n          strand: fstrand,\n          effectiveStrand,\n          score: 0,\n        }\n      }\n      skipmap[hash].score++\n    }\n  }\n}\n","import { max, sum } from '@jbrowse/core/util'\n\nimport { incWithProbabilities } from './util'\nimport { parseCigar } from '../MismatchParser'\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition'\n\nimport type { ColorBy, PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport function processModifications({\n  feature,\n  colorBy,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  colorBy?: ColorBy\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const fend = feature.get('end')\n  const twoColor = colorBy?.modifications?.twoColor\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  const seq = feature.get('seq') as string | undefined\n  const modificationThreshold = colorBy?.modifications?.threshold ?? 10\n  const thresholdFraction = modificationThreshold / 100\n\n  if (!seq) {\n    return\n  }\n\n  const cigarOps = parseCigar(feature.get('CIGAR'))\n\n  // Get only the maximum probability modification at each position\n  // this is a hole-y array, does not work with normal for loop\n  // eslint-disable-next-line unicorn/no-array-for-each\n  getMaxProbModAtEachPosition(feature, cigarOps)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      if (isolatedModification && type !== isolatedModification) {\n        return\n      }\n\n      // Check if modification probability exceeds threshold\n      if (prob < thresholdFraction) {\n        return\n      }\n\n      const epos = pos + fstart - region.start\n      if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n        if (bins[epos] === undefined) {\n          bins[epos] = {\n            depth: 0,\n            readsCounted: 0,\n            snps: {},\n            ref: {\n              probabilities: [],\n              entryDepth: 0,\n              '-1': 0,\n              0: 0,\n              1: 0,\n            },\n            mods: {},\n            nonmods: {},\n            delskips: {},\n            noncov: {},\n          }\n        }\n\n        const bin = bins[epos]\n        bin.refbase = regionSequence[epos]\n\n        const s = 1 - sum(allProbs)\n        if (twoColor && s > max(allProbs)) {\n          incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s)\n        } else {\n          incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob)\n        }\n      }\n    },\n  )\n}\n","import { doesIntersect2 } from '@jbrowse/core/util'\n\nimport { parseCigar } from '../MismatchParser'\nimport { incWithProbabilities } from './util'\nimport { getMethBins } from '../ModificationParser/getMethBins'\n\nimport type { Mismatch, PreBaseCoverageBin } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport function processReferenceCpGs({\n  feature,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n  const r = regionSequence.toLowerCase()\n  if (seq) {\n    const cigarOps = parseCigar(feature.get('CIGAR'))\n    const { methBins, methProbs } = getMethBins(feature, cigarOps)\n    const dels = mismatches.filter(f => f.type === 'deletion')\n\n    // methylation based coloring takes into account both reference sequence\n    // CpG detection and reads\n    for (let i = 0; i < fend - fstart; i++) {\n      const j = i + fstart\n      const l1 = r[j - region.start + 1]\n      const l2 = r[j - region.start + 2]\n      if (l1 === 'c' && l2 === 'g') {\n        const bin0 = bins[j - region.start]\n        const bin1 = bins[j - region.start + 1]\n        const b0 = methBins[i]\n        const b1 = methBins[i + 1]\n        const p0 = methProbs[i]\n        const p1 = methProbs[i + 1]\n\n        // color\n        if (\n          (b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n          (b1 && (p1 !== undefined ? p1 > 0.5 : true))\n        ) {\n          if (bin0) {\n            incWithProbabilities(bin0, fstrand, 'mods', 'cpg_meth', p0 || 0)\n            bin0.ref.entryDepth--\n            bin0.ref[fstrand]--\n          }\n          if (bin1) {\n            incWithProbabilities(bin1, fstrand, 'mods', 'cpg_meth', p1 || 0)\n            bin1.ref.entryDepth--\n            bin1.ref[fstrand]--\n          }\n        } else {\n          if (bin0) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j,\n                  j + 1,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin0,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p0 || 0),\n              )\n              bin0.ref.entryDepth--\n              bin0.ref[fstrand]--\n            }\n          }\n          if (bin1) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j + 1,\n                  j + 2,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin1,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p1 || 0),\n              )\n              bin1.ref.entryDepth--\n              bin1.ref[fstrand]--\n            }\n          }\n        }\n      }\n    }\n  }\n}\n","import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { firstValueFrom } from 'rxjs'\nimport { toArray } from 'rxjs/operators'\n\nimport { fetchSequence } from '../util'\nimport { generateCoverageBins } from './generateCoverageBins'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  protected async configure() {\n    const subadapterConfig = this.getConf('subadapter')\n    const sequenceConf = subadapterConfig.sequenceAdapter\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfig)\n\n    const sequenceAdapter = sequenceConf\n      ? await this.getSubAdapter?.(sequenceConf)\n      : undefined\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    return {\n      subadapter: dataAdapter.dataAdapter as BaseFeatureDataAdapter,\n      sequenceAdapter: sequenceAdapter?.dataAdapter as\n        | BaseFeatureDataAdapter\n        | undefined,\n    }\n  }\n\n  async fetchSequence(region: Region) {\n    const { sequenceAdapter } = await this.configure()\n    if (!sequenceAdapter) {\n      return undefined\n    }\n    return fetchSequence(region, sequenceAdapter)\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { subadapter } = await this.configure()\n      const features = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n\n      const { bins, skipmap } = await generateCoverageBins({\n        features,\n        region,\n        opts,\n        fetchSequence: (region: Region) => this.fetchSequence(region),\n      })\n\n      let index = 0\n      for (const bin of bins) {\n        // bins is a holey array\n        // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n        if (bin) {\n          const start = region.start + index\n          observer.next(\n            new SimpleFeature({\n              id: `${this.id}-${start}`,\n              data: {\n                score: bin.depth,\n                snpinfo: bin,\n                start,\n                end: start + 1,\n                refName: region.refName,\n              },\n            }),\n          )\n        }\n        index++\n      }\n\n      // make fake features from the coverage\n      for (const [key, skip] of Object.entries(skipmap)) {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              effectiveStrand: skip.effectiveStrand,\n            },\n          }),\n        )\n      }\n\n      observer.complete()\n    }, opts.stopToken)\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n}\n","import { sum } from '@jbrowse/core/util'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport { processDepth } from './processDepth'\nimport { processMismatches } from './processMismatches'\nimport { processModifications } from './processModifications'\nimport { processReferenceCpGs } from './processReferenceCpGs'\n\nimport type { Opts } from './util'\nimport type { PreBaseCoverageBin, SkipMap } from '../shared/types'\nimport type { Feature } from '@jbrowse/core/util'\nimport type { AugmentedRegion as Region } from '@jbrowse/core/util/types'\n\nexport async function generateCoverageBins({\n  fetchSequence,\n  features,\n  region,\n  opts,\n}: {\n  features: Feature[]\n  region: Region\n  opts: Opts\n  fetchSequence: (arg: Region) => Promise<string>\n}) {\n  const { stopToken, colorBy } = opts\n  const skipmap = {} as SkipMap\n  const bins = [] as PreBaseCoverageBin[]\n  const start2 = Math.max(0, region.start - 1)\n  const diff = region.start - start2\n\n  let regionSequence\n  let start = performance.now()\n  for (const feature of features) {\n    if (performance.now() - start > 400) {\n      checkStopToken(stopToken)\n      start = performance.now()\n    }\n    processDepth({\n      feature,\n      bins,\n      region,\n    })\n\n    if (colorBy?.type === 'modifications') {\n      regionSequence ??=\n        (await fetchSequence({\n          ...region,\n          start: start2,\n          end: region.end + 1,\n        })) || ''\n\n      processModifications({\n        feature,\n        colorBy,\n        bins,\n        region,\n        regionSequence: regionSequence.slice(diff),\n      })\n    } else if (colorBy?.type === 'methylation') {\n      regionSequence ??=\n        (await fetchSequence({\n          ...region,\n          start: start2,\n          end: region.end + 1,\n        })) || ''\n\n      processReferenceCpGs({\n        feature,\n        bins,\n        region,\n        regionSequence,\n      })\n    }\n    processMismatches({ feature, skipmap, bins, region })\n  }\n\n  for (const bin of bins) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (bin) {\n      bin.mods = Object.fromEntries(\n        Object.entries(bin.mods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n      bin.nonmods = Object.fromEntries(\n        Object.entries(bin.nonmods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n    }\n  }\n\n  return {\n    bins,\n    skipmap,\n  }\n}\n","import { getNextRefPos, parseCigar } from '../MismatchParser'\nimport { getModPositions } from '../ModificationParser/getModPositions'\nimport { getModProbabilities } from '../ModificationParser/getModProbabilities'\nimport { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  cigarOps?: string[],\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const ops = cigarOps || parseCigar(feature.get('CIGAR'))\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n","import { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getModProbabilities(feature: Feature) {\n  // ML stores probabilities as array of numerics and MP is scaled phred scores\n  // https://github.com/samtools/hts-specs/pull/418/files#diff-e765c6479316309f56b636f88189cdde8c40b854c7bdcce9ee7fe87a4e76febcR596\n  //\n  // - if we have ML or Ml, it is an 8bit probability, divide by 255\n  //\n  // - if we have MP or Mp it is phred scaled ASCII, which can go up to 90 but\n  // has very high likelihood basecalls at that point, we really only care about\n  // low qual calls <20 approx\n  const m = (getTagAlt(feature, 'ML', 'Ml') as number[] | string) || []\n  if (m) {\n    const result = []\n    if (typeof m === 'string') {\n      const parts = m.split(',')\n      for (let i = 0, l = parts.length; i < l; i++) {\n        result.push(+parts[i]! / 255)\n      }\n    } else {\n      for (let i = 0, l = m.length; i < l; i++) {\n        result.push(m[i]! / 255)\n      }\n    }\n    return result\n  } else {\n    const mp = getTagAlt(feature, 'MP', 'Mp') as string | undefined\n    if (mp) {\n      const result = []\n      for (let i = 0, l = mp.length; i < l; i++) {\n        const phred = mp.charCodeAt(i) - 33\n        result.push(Math.min(1, phred / 50))\n      }\n      return result\n    }\n    return undefined\n  }\n}\n","import { getNextRefPos } from '../MismatchParser'\nimport { getModPositions } from './getModPositions'\nimport { getModProbabilities } from './getModProbabilities'\nimport { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getMethBins(feature: Feature, cigarOps: string[]) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const flen = fend - fstart\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string | undefined) || ''\n  const methBins = []\n  const hydroxyMethBins = []\n  const methProbs = []\n  const hydroxyMethProbs = []\n  const seq = feature.get('seq') as string | undefined\n  if (seq) {\n    const probabilities = getModProbabilities(feature)\n    const modifications = getModPositions(mm, seq, fstrand)\n    let probIndex = 0\n\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(cigarOps, positions)) {\n        // Skip positions outside the feature bounds\n        if (ref < 0 || ref >= flen) {\n          continue\n        }\n\n        // Calculate probability index based on strand\n        const isReverseStrand = fstrand === -1\n        const idx2 =\n          probIndex + (isReverseStrand ? positions.length - 1 - idx : idx)\n        const prob = probabilities?.[idx2] || 0\n\n        // Store modification data in appropriate bins\n        if (type === 'm') {\n          methBins[ref] = 1\n          methProbs[ref] = prob\n        } else if (type === 'h') {\n          hydroxyMethBins[ref] = 1\n          hydroxyMethProbs[ref] = prob\n        }\n      }\n      probIndex += positions.length\n    }\n  }\n  return {\n    methBins,\n    hydroxyMethBins,\n    methProbs,\n    hydroxyMethProbs,\n  }\n}\n"],"names":["getModPositions","mm","fseq","fstrand","seq","revcom","seqLength","length","mods","split","result","mod","basemod","matches","modificationRegex","exec","Error","base","strand","typestr","types","type","splitLength","currPos","positions","Array","writeIndex","i","delta","pos","validPositions","slice","push","processDepth","feature","bins","region","fstart","get","fend","regionLength","end","start","j","undefined","depth","readsCounted","ref","probabilities","entryDepth","snps","nonmods","delskips","noncov","mismatchLen","mismatch","isInterbase","inc","bin","field","thisBin","incWithProbabilities","probability","processMismatches","skipmap","mismatches","mstart","mlen","mend","epos","altbase","interbase","refbase","tags","xs","XS","TS","ts","effectiveStrand","hash","score","processModifications","colorBy","regionSequence","twoColor","modifications","isolatedModification","thresholdFraction","threshold","cigarOps","parseCigar","getMaxProbModAtEachPosition","forEach","allProbs","prob","s","sum","max","processReferenceCpGs","r","toLowerCase","methBins","methProbs","getMethBins","dels","filter","f","l1","l2","bin0","bin1","b0","b1","p0","p1","some","d","doesIntersect2","SNPCoverageAdapter","BaseFeatureDataAdapter","configure","subadapterConfig","this","getConf","sequenceConf","sequenceAdapter","dataAdapter","getSubAdapter","subadapter","fetchSequence","getFeatures","opts","ObservableCreate","async","features","firstValueFrom","pipe","toArray","stopToken","start2","Math","diff","performance","now","checkStopToken","Object","fromEntries","entries","map","key","val","avgProbability","generateCoverageBins","index","observer","next","SimpleFeature","id","data","snpinfo","refName","skip","complete","getMultiRegionFeatureDensityStats","regions","getRefNames","getTagAlt","ops","getModProbabilities","maxProbModForPosition","probIndex","idx","getNextRefPos","old","m","parts","l","mp","phred","charCodeAt","min","flen","hydroxyMethBins","hydroxyMethProbs","idx2"],"sourceRoot":""}