{"version":3,"file":"static/js/4058.5dd49043.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedGraphAdapter/BedGraphAdapter.ts"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { SimpleFeature, fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nexport default class BedGraphAdapter extends BaseFeatureDataAdapter {\n  protected bedFeatures?: Promise<{\n    header: string\n    features: Record<string, string[]>\n    columnNames: string[]\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree | undefined> | undefined\n  > = {}\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { features } = await this.loadData()\n    const lines = features[refName]\n    if (!lines) {\n      return undefined\n    }\n    const names = (await this.getNames())?.slice(3) || []\n    const intervalTree = new IntervalTree()\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i]!\n      const [refName, s, e, ...rest] = line.split('\\t')\n      // eslint-disable-next-line unicorn/no-for-loop\n      for (let j = 0; j < rest.length; j++) {\n        const uniqueId = `${this.id}-${refName}-${i}-${j}`\n        const start = +s!\n        const end = +e!\n        const score = +rest[j]!\n        const source = names[j] || `col${j}`\n        if (score) {\n          intervalTree.insert(\n            [start, end],\n            new SimpleFeature({\n              id: uniqueId,\n              data: {\n                refName,\n                start,\n                end,\n                score,\n                source,\n              },\n            }),\n          )\n        }\n      }\n    }\n\n    return intervalTree\n  }\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { features } = await this.loadData(opts)\n    return Object.keys(features)\n  }\n  private async loadDataP(opts: BaseOptions = {}) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedGraphLocation')\n    const buffer = await fetchAndMaybeUnzip(openLocation(bedLoc, pm), opts)\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n    const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const headerLines = []\n    let i = 0\n    for (; i < lines.length && lines[i]!.startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n    const features = {} as Record<string, string[]>\n    for (; i < lines.length; i++) {\n      const line = lines[i]!\n      const tab = line.indexOf('\\t')\n      const refName = line.slice(0, tab)\n      if (!features[refName]) {\n        features[refName] = []\n      }\n      features[refName].push(line)\n    }\n\n    const columnNames = this.getConf('columnNames')\n\n    return {\n      header,\n      features,\n      columnNames,\n    }\n  }\n\n  async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch((e: unknown) => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  async loadData(opts: BaseOptions = {}) {\n    if (!this.bedFeatures) {\n      this.bedFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedFeatures\n  }\n  public getFeatures(query: Region, _opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureIntervalTree(refName)\n      for (const feature of intervalTree?.search([start, end]) || []) {\n        observer.next(feature)\n      }\n      observer.complete()\n    })\n  }\n}\n"],"names":["BedGraphAdapter","BaseFeatureDataAdapter","intervalTrees","getNames","header","columnNames","this","loadData","length","defline","split","filter","f","at","includes","slice","map","field","trim","undefined","loadFeatureIntervalTreeHelper","refName","features","lines","names","intervalTree","IntervalTree","i","line","s","e","rest","j","uniqueId","id","start","end","score","source","insert","SimpleFeature","data","getRefNames","opts","Object","keys","loadDataP","pm","pluginManager","bedLoc","getConf","buffer","fetchAndMaybeUnzip","openLocation","Error","TextDecoder","fatal","decode","headerLines","startsWith","push","join","tab","indexOf","loadFeatureIntervalTree","catch","bedFeatures","getFeatures","query","_opts","ObservableCreate","async","feature","search","observer","next","complete"],"sourceRoot":""}