{"version":3,"file":"static/js/6310.7c3b010f.chunk.js","mappings":"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","sources":["../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/BedImport.ts","../../../plugins/spreadsheet-view/src/SpreadsheetView/importAdapters/ImportUtils.ts"],"sourcesContent":["import { ParseOptions, parseTsvBuffer } from './ImportUtils'\nimport type { Buffer } from 'buffer'\n\nconst browserBytes = 'browser '.split('').map(c => c.charCodeAt(0))\nconst trackBytes = 'track '.split('').map(c => c.charCodeAt(0))\nconst commentBytes = '#'.split('').map(c => c.charCodeAt(0))\n\nfunction bytesAreFoundAt(position: number, buffer: Buffer, bytes: number[]) {\n  let i = 0\n  for (; i < bytes.length; i += 1) {\n    if (buffer[position + i] !== bytes[i]) {\n      return false\n    }\n  }\n  return true\n}\n\nexport function removeBedHeaders(buffer: Buffer) {\n  // slice off the first lines of the buffer if it starts with one or more\n  // header lines\n  let i = 0\n  for (; i < buffer.length; i += 1) {\n    if (\n      bytesAreFoundAt(i, buffer, browserBytes) ||\n      bytesAreFoundAt(i, buffer, trackBytes) ||\n      bytesAreFoundAt(i, buffer, commentBytes)\n    ) {\n      // consume up to the next newline\n      do {\n        i += 1\n      } while (buffer[i] !== 10)\n    } else {\n      // end of headers, return\n      break\n    }\n  }\n  if (i) {\n    return buffer.subarray(i)\n  }\n  return buffer\n}\n\nexport async function parseBedBuffer(buffer: Buffer, options: ParseOptions) {\n  const b = removeBedHeaders(buffer)\n  const data = await parseTsvBuffer(b)\n\n  const bedColumns = [\n    { name: 'chrom', dataType: { type: 'LocRef' } },\n    { name: 'chromStart', dataType: { type: 'LocStart' } },\n    { name: 'chromEnd', dataType: { type: 'LocEnd' } },\n    { name: 'name', dataType: { type: 'Text' } },\n    { name: 'score', dataType: { type: 'Number' } },\n    { name: 'strand', dataType: { type: 'Text' } },\n  ] as const\n\n  data.columns.forEach((col, colNumber) => {\n    const bedColumn = bedColumns[colNumber]\n    if (bedColumn) {\n      col.name = bedColumn.name\n      col.dataType = bedColumn.dataType\n    }\n  })\n  data.hasColumnNames = true\n  data.assemblyName = options.selectedAssemblyName\n\n  data.columnDisplayOrder.push(data.columnDisplayOrder.length)\n  data.columns.unshift({\n    name: 'Location',\n    dataType: { type: 'LocString' },\n    isDerived: true,\n    derivationFunctionText: `jexl:{text:row.cells[0].text+':'+row.cells[1].text+'..'+row.cells[2].text,\\n\n    extendedData: {refName: row.cells.ref.text, start: parseInt(row.cells.start.text,10), end: parseInt(row.cells.end.text,10)}}`,\n  })\n  return data\n}\n\nexport async function parseBedPEBuffer(buffer: Buffer, options: ParseOptions) {\n  const b = removeBedHeaders(buffer)\n  const data = await parseTsvBuffer(b)\n  interface BedColumn {\n    name: string\n    dataType: {\n      type: string\n    }\n    featureField: string[]\n  }\n  const bedColumns: BedColumn[] = [\n    { name: 'chrom1', dataType: { type: 'Text' }, featureField: ['refName'] },\n    { name: 'start1', dataType: { type: 'Number' }, featureField: ['start'] },\n    { name: 'end1', dataType: { type: 'Number' }, featureField: ['end'] },\n    {\n      name: 'chrom2',\n      dataType: { type: 'Text' },\n      featureField: ['mate', 'refName'],\n    },\n    {\n      name: 'start2',\n      dataType: { type: 'Number' },\n      featureField: ['mate', 'start'],\n    },\n    {\n      name: 'end2',\n      dataType: { type: 'Number' },\n      featureField: ['mate', 'end'],\n    },\n    { name: 'name', dataType: { type: 'Text' }, featureField: ['name'] },\n    { name: 'score', dataType: { type: 'Number' }, featureField: ['score'] },\n    { name: 'strand1', dataType: { type: 'Text' }, featureField: ['strand'] },\n    {\n      name: 'strand2',\n      dataType: { type: 'Text' },\n      featureField: ['mate', 'strand'],\n    },\n  ] as const\n  data.columns.forEach((col, colNumber) => {\n    const bedColumn = bedColumns[colNumber]\n    if (bedColumn) {\n      col.name = bedColumn.name\n      col.dataType = bedColumn.dataType\n    }\n  })\n  data.hasColumnNames = true\n\n  // decorate each row with a feature object in its extendedData\n  data.rowSet.rows.forEach((row, rowNumber) => {\n    const featureData: Record<string, any> = {}\n    row.cells.forEach(({ text }, columnNumber) => {\n      const bedColumn = bedColumns[columnNumber]\n      const val =\n        bedColumn && bedColumn.dataType.type === 'Number' && text\n          ? Number.parseFloat(text)\n          : text\n      if (bedColumn) {\n        // a predefined column\n        if (bedColumn.featureField.length === 2) {\n          if (!featureData[bedColumn.featureField[0]!]) {\n            featureData[bedColumn.featureField[0]!] = {}\n          }\n          featureData[bedColumn.featureField[0]!][bedColumn.featureField[1]!] =\n            val\n        } else {\n          featureData[bedColumn.featureField[0]!] = val\n        }\n      } else {\n        // some other column\n        featureData[`column${columnNumber + 1}`] = val\n      }\n    })\n    featureData.uniqueId = `bedpe-${rowNumber}`\n    row.extendedData = {\n      feature: featureData,\n    }\n  })\n\n  data.assemblyName = options.selectedAssemblyName\n\n  return data\n}\n","import { ParsedLocString, parseLocString } from '@jbrowse/core/util'\nimport type { Buffer } from 'buffer'\n\nexport function bufferToString(buffer: Buffer) {\n  return new TextDecoder('utf8', { fatal: true }).decode(buffer)\n}\n\nasync function parseWith(buffer: Buffer, options = {}) {\n  const csv = await import('csvtojson').then(module => module.default)\n  return csv({ noheader: true, output: 'csv', ...options }).fromString(\n    bufferToString(buffer),\n  )\n}\n\nexport interface Row {\n  id: string\n\n  extendedData?: any\n  cells: {\n    text: string\n\n    extendedData?: any\n  }[]\n}\n\nexport interface RowSet {\n  isLoaded: boolean\n  rows: Row[]\n}\n\nexport interface ParseOptions {\n  hasColumnNameLine?: boolean\n  columnNameLineNumber?: number\n  selectedAssemblyName?: string\n  isValidRefName?: (refName: string, assemblyName?: string) => boolean\n}\n\nexport interface Column {\n  name: string\n  dataType: { type: string }\n  isDerived?: boolean\n  derivationFunctionText?: string\n}\n\nfunction guessColumnType(\n  rowSet: RowSet,\n  columnNumber: number,\n  isValidRefName: (refName: string, assemblyName?: string) => boolean,\n) {\n  const text = rowSet.rows[0]!.cells[columnNumber]!.text || ''\n\n  let guessedType = 'Text'\n\n  let parsedLoc: ParsedLocString | undefined\n  try {\n    parsedLoc = parseLocString(text, isValidRefName)\n  } catch (error) {\n    //\n  }\n  if (parsedLoc?.refName && typeof parsedLoc.start === 'number') {\n    guessedType = 'LocString'\n  } else if (/^\\d+(\\.\\d+)?$/.test(text)) {\n    guessedType = 'Number'\n  }\n\n  // MAYBE TODO: iterate over the rest of the rows to confirm\n  // the type for all the rows\n\n  return guessedType\n}\n\nfunction dataToSpreadsheetSnapshot(\n  rows: string[][],\n  options: ParseOptions = {},\n) {\n  const {\n    hasColumnNameLine = false,\n    columnNameLineNumber = 1,\n    isValidRefName = () => false,\n    selectedAssemblyName,\n  } = options\n  // rows is an array of row objects and columnNames\n  // is an array of column names (in import order)\n  let maxCols = 0\n  const rowSet: RowSet = {\n    isLoaded: true,\n    rows: rows.map((row, rowNumber) => {\n      const id = rowNumber + (hasColumnNameLine ? 0 : 1)\n      if (row.length > maxCols) {\n        maxCols = row.length\n      }\n      return {\n        id: String(id),\n        cells: row.map((text, columnNumber) => {\n          return { columnNumber, text }\n        }),\n      }\n    }),\n  }\n\n  // process the column names row if present\n  const columnNames: Record<string, string> = {}\n  // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n  if (hasColumnNameLine && columnNameLineNumber !== undefined) {\n    const [colNamesRow] = rowSet.rows.splice(columnNameLineNumber - 1, 1)\n\n    if (colNamesRow) {\n      colNamesRow.cells.forEach((cell, columnNumber) => {\n        columnNames[columnNumber] = cell.text || ''\n      })\n    }\n  }\n\n  // make our column definitions\n  const columns: Column[] = []\n  const columnDisplayOrder = []\n  for (let columnNumber = 0; columnNumber < maxCols; columnNumber += 1) {\n    columnDisplayOrder.push(columnNumber)\n    const guessedType = guessColumnType(rowSet, columnNumber, isValidRefName)\n\n    // store extendeddata for LocString column\n    if (guessedType === 'LocString') {\n      for (const row of rowSet.rows) {\n        const cell = row.cells[columnNumber]!\n        cell.extendedData = parseLocString(cell.text, isValidRefName)\n      }\n    }\n\n    columns[columnNumber] = {\n      name: columnNames[columnNumber]!,\n      dataType: {\n        type: guessedType,\n      },\n    }\n  }\n\n  return {\n    rowSet,\n    columnDisplayOrder,\n    hasColumnNames: !!hasColumnNameLine,\n    columns,\n    assemblyName: selectedAssemblyName,\n  }\n}\n\nexport async function parseCsvBuffer(buffer: Buffer, options?: ParseOptions) {\n  const rows = await parseWith(buffer)\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n\nexport async function parseTsvBuffer(buffer: Buffer, options?: ParseOptions) {\n  const rows = await parseWith(buffer, { delimiter: '\\t' })\n  return dataToSpreadsheetSnapshot(rows, options)\n}\n"],"names":["browserBytes","split","map","c","charCodeAt","trackBytes","commentBytes","bytesAreFoundAt","position","buffer","bytes","i","length","removeBedHeaders","subarray","async","parseBedBuffer","options","b","data","parseTsvBuffer","bedColumns","name","dataType","type","columns","forEach","col","colNumber","bedColumn","hasColumnNames","assemblyName","selectedAssemblyName","columnDisplayOrder","push","unshift","isDerived","derivationFunctionText","parseBedPEBuffer","featureField","rowSet","rows","row","rowNumber","featureData","cells","text","columnNumber","val","Number","parseFloat","uniqueId","extendedData","feature","bufferToString","TextDecoder","fatal","decode","parseWith","then","module","default","noheader","output","fromString","guessColumnType","isValidRefName","parsedLoc","guessedType","parseLocString","error","refName","start","test","dataToSpreadsheetSnapshot","hasColumnNameLine","columnNameLineNumber","maxCols","isLoaded","id","String","columnNames","undefined","colNamesRow","splice","cell","parseCsvBuffer","delimiter"],"sourceRoot":""}