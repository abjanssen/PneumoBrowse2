{"version":3,"file":"static/js/6214.0ed0ac32.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedTabixAdapter/BedTabixAdapter.ts","../../../plugins/bed/src/util.ts"],"sourcesContent":["import BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { FileLocation, Region, Feature } from '@jbrowse/core/util'\nimport { TabixIndexedFile } from '@gmod/tabix'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\n\n// locals\nimport { featureData } from '../util'\n\nexport default class BedTabixAdapter extends BaseFeatureDataAdapter {\n  private parser: BED\n\n  protected bed: TabixIndexedFile\n\n  protected columnNames: string[]\n\n  protected scoreColumn: string\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  public constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const bedGzLoc = this.getConf('bedGzLocation') as FileLocation\n    const type = this.getConf(['index', 'indexType'])\n    const loc = this.getConf(['index', 'location'])\n    const autoSql = this.getConf('autoSql')\n    const pm = this.pluginManager\n\n    this.bed = new TabixIndexedFile({\n      filehandle: openLocation(bedGzLoc, pm),\n      csiFilehandle: type === 'CSI' ? openLocation(loc, pm) : undefined,\n      tbiFilehandle: type !== 'CSI' ? openLocation(loc, pm) : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n    this.columnNames = this.getConf('columnNames')\n    this.scoreColumn = this.getConf('scoreColumn')\n    this.parser = new BED({ autoSql })\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    return this.bed.getReferenceSequenceNames(opts)\n  }\n\n  async getHeader() {\n    return this.bed.getHeader()\n  }\n\n  async getNames() {\n    if (this.columnNames.length) {\n      return this.columnNames\n    }\n    const header = await this.bed.getHeader()\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(f => f.trim())\n      : undefined\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const meta = await this.bed.getMetadata()\n      const { columnNumbers } = meta\n      const colRef = columnNumbers.ref - 1\n      const colStart = columnNumbers.start - 1\n      const colEnd = columnNumbers.end - 1\n      // colSame handles special case for tabix where a single column is both\n      // the start and end, this is assumed to be covering the base at this\n      // position (e.g. tabix -s 1 -b 2 -e 2) begin and end are same\n      const names = await this.getNames()\n      await this.bed.getLines(query.refName, query.start, query.end, {\n        lineCallback: (line, fileOffset) => {\n          observer.next(\n            featureData(\n              line,\n              colRef,\n              colStart,\n              colEnd,\n              this.scoreColumn,\n              this.parser,\n              `${this.id}-${fileOffset}`,\n              names,\n            ),\n          )\n        },\n        signal: opts.signal,\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","import BED from '@gmod/bed'\nimport { SimpleFeature } from '@jbrowse/core/util'\n\nexport interface MinimalFeature {\n  type: string\n  start: number\n  end: number\n  refName: string\n  [key: string]: unknown\n}\nexport interface TranscriptFeat extends MinimalFeature {\n  thickStart: number\n  thickEnd: number\n  blockCount: number\n  blockSizes: number[]\n  chromStarts: number[]\n  refName: string\n  strand?: number\n  subfeatures: MinimalFeature[]\n}\n\nexport function ucscProcessedTranscript(feature: TranscriptFeat) {\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    blockSizes,\n    chromStarts,\n    refName,\n    strand = 0,\n    ...rest\n  } = feature\n\n  if (!thickStart || !thickEnd || !strand) {\n    return feature\n  }\n\n  const subfeatures: MinimalFeature[] = []\n  oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n    .forEach(block => {\n      const start = block.start\n      const end = block.end\n      if (thickStart >= end) {\n        // left-side UTR\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n        // UTR | CDS\n        const prime = strand > 0 ? 'five' : 'three'\n        subfeatures.push(\n          {\n            type: `${prime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            start: thickStart,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd >= end) {\n        // CDS\n        subfeatures.push({\n          type: 'CDS',\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd < end) {\n        // UTR | CDS | UTR\n        const leftPrime = strand > 0 ? 'five' : 'three'\n        const rightPrime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: `${leftPrime}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            start: thickStart,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${rightPrime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n        // CDS | UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push(\n          {\n            type: 'CDS',\n            start,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${prime}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickEnd <= start) {\n        // right-side UTR\n        const prime = strand > 0 ? 'three' : 'five'\n        subfeatures.push({\n          type: `${prime}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      }\n    })\n\n  return { ...rest, strand, type: 'mRNA', refName, subfeatures }\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  const obj = Object.fromEntries(\n    line.split('\\t').map((f, i) => [fields[i]!, f] as const),\n  )\n  const {\n    blockStarts,\n    blockCount,\n    chromStarts,\n    thickEnd,\n    thickStart,\n    blockSizes,\n    ...rest\n  } = obj\n\n  return {\n    ...rest,\n    blockStarts: blockStarts?.split(',').map(r => +r),\n    chromStarts: chromStarts?.split(',').map(r => +r),\n    blockSizes: blockSizes?.split(',').map(r => +r),\n    thickStart: thickStart ? +thickStart : undefined,\n    thickEnd: thickEnd ? +thickEnd : undefined,\n    blockCount: blockCount ? +blockCount : undefined,\n  } as Record<string, unknown>\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes: number[]\n  blockStarts?: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts || blockStarts || []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] || 0) + start\n    const bmax = bmin + (blockSizes[b] || 0)\n    subfeatures.push({\n      uniqueId: `${uniqueId}-${b}`,\n      start: bmin,\n      end: bmax,\n      refName,\n      type: 'block',\n    })\n  }\n  return subfeatures\n}\nexport function featureData(\n  line: string,\n  colRef: number,\n  colStart: number,\n  colEnd: number,\n  scoreColumn: string,\n  parser: BED,\n  uniqueId: string,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const refName = l[colRef]!\n  const start = +l[colStart]!\n  const colSame = colStart === colEnd ? 1 : 0\n  const end = +l[colEnd]! + colSame\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n\n  const {\n    blockCount,\n    blockSizes,\n    blockStarts,\n    chromStarts,\n    thickStart,\n    thickEnd,\n    type,\n    score,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n  const subfeatures = blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts,\n        blockCount,\n        blockSizes,\n        blockStarts,\n      })\n    : []\n  const f = {\n    ...rest,\n    type,\n    score: scoreColumn ? +data[scoreColumn] : score,\n    start,\n    end,\n    refName,\n    uniqueId,\n    subfeatures,\n  }\n  return new SimpleFeature({\n    id: uniqueId,\n    data: isUcscProcessedTranscript(data)\n      ? ucscProcessedTranscript({\n          thickStart: thickStart!,\n          thickEnd: thickEnd!,\n          blockCount: blockCount!,\n          blockSizes: blockSizes!,\n          chromStarts: chromStarts,\n          ...f,\n        })\n      : f,\n  })\n}\n\nexport function isUcscProcessedTranscript(f: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return f.thickStart && f.blockCount && f.strand !== 0\n}\n"],"names":["BedTabixAdapter","BaseFeatureDataAdapter","constructor","config","getSubAdapter","pluginManager","super","bedGzLoc","this","getConf","type","loc","autoSql","pm","bed","TabixIndexedFile","filehandle","openLocation","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","columnNames","scoreColumn","parser","BED","getRefNames","opts","getReferenceSequenceNames","getHeader","getNames","length","defline","split","filter","f","at","includes","slice","map","trim","getFeatures","query","ObservableCreate","async","meta","getMetadata","columnNumbers","colRef","ref","colStart","start","colEnd","end","names","getLines","refName","lineCallback","line","fileOffset","observer","next","featureData","id","signal","complete","freeResources","ucscProcessedTranscript","feature","subfeatures","oldSubfeatures","thickStart","thickEnd","blockCount","blockSizes","chromStarts","strand","rest","child","sort","a","b","forEach","block","prime","push","leftPrime","rightPrime","makeBlocks","uniqueId","blockStarts","starts","bmin","bmax","l","colSame","data","fields","obj","Object","fromEntries","i","r","defaultParser","parseLine","score","chrom","_1","chromStart","_2","chromEnd","_3","SimpleFeature","isUcscProcessedTranscript"],"sourceRoot":""}