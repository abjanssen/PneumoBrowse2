{"version":3,"file":"static/js/4864.726356ac.chunk.js","mappings":"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","sources":["../../../packages/core/util/parseLineByLine.ts","../../../plugins/bed/src/generateRepeatMaskerFeature.ts","../../../plugins/bed/src/util.ts","../../../plugins/bed/src/generateBedMethylFeature.ts","../../../plugins/bed/src/generateUcscTranscript.ts","../../../plugins/bed/src/BedAdapter/BedAdapter.ts"],"sourcesContent":["import { getProgressDisplayStr } from './index'\n\nexport type StatusCallback = (arg: string) => void\nexport type LineCallback = (\n  line: string,\n  lineIndex: number,\n) => boolean | undefined\n\n/**\n * Parse buffer line by line, calling a callback for each line\n * @param buffer - The buffer to parse\n * @param lineCallback - Callback function called for each line. Return false to stop parsing.\n * @param statusCallback - Optional callback for progress updates\n */\nexport function parseLineByLine(\n  buffer: Uint8Array,\n  lineCallback: LineCallback,\n  statusCallback: StatusCallback = () => {},\n) {\n  const decoder = new TextDecoder('utf8')\n  let blockStart = 0\n  let i = 0\n\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf(10, blockStart)\n    // could be a non-newline ended file, so subarray to end of file if n===-1\n    const lineEnd = n === -1 ? buffer.length : n\n    const b = buffer.subarray(blockStart, lineEnd)\n    const line = decoder.decode(b).trim()\n\n    if (line) {\n      const shouldContinue = lineCallback(line, i)\n      if (shouldContinue === false) {\n        break\n      }\n    }\n\n    if (i++ % 10_000 === 0) {\n      statusCallback(\n        `Loading ${getProgressDisplayStr(blockStart, buffer.length)}`,\n      )\n    }\n\n    // If no newline found, we've reached the end\n    blockStart = lineEnd + 1\n  }\n}\n","export function isRepeatMaskerDescriptionField(desc?: string): desc is string {\n  const ret = desc?.trim().split(' ')\n  return [0, 1, 2, 3, 5, 6].every(s =>\n    ret?.[s] !== undefined ? !Number.isNaN(+ret[s]) : false,\n  )\n}\n\nfunction makeRepeatTrackDescription(description?: string) {\n  if (isRepeatMaskerDescriptionField(description)) {\n    const [\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    ] = description.trim().split(' ')\n    return {\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    }\n  }\n  return { description }\n}\n\nexport function generateRepeatMaskerFeature({\n  uniqueId,\n  refName,\n  start,\n  end,\n  description,\n  ...rest\n}: {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  description: string\n  [key: string]: unknown\n}) {\n  const { subfeatures, ...rest2 } = rest\n  return {\n    ...rest2,\n    ...makeRepeatTrackDescription(description),\n    uniqueId,\n    refName,\n    start,\n    end,\n  }\n}\n","import {\n  generateBedMethylFeature,\n  isBedMethylFeature,\n} from './generateBedMethylFeature'\nimport {\n  generateRepeatMaskerFeature,\n  isRepeatMaskerDescriptionField,\n} from './generateRepeatMaskerFeature'\nimport {\n  generateUcscTranscript,\n  isUcscTranscript,\n} from './generateUcscTranscript'\n\nimport type BED from '@gmod/bed'\n\nfunction defaultParser(fields: string[], splitLine: string[]) {\n  let hasBlockCount = false\n  const r = [] as [string, string][]\n\n  // eslint-disable-next-line unicorn/no-for-loop\n  for (let i = 0; i < splitLine.length; i++) {\n    if (fields[i] === 'blockCount') {\n      hasBlockCount = true\n    }\n    r.push([fields[i]!, splitLine[i]!] as const)\n  }\n  // heuristically try to determine whether to follow 'slow path' as there can\n  // be many features in e.g. GWAS type data\n  const obj = Object.fromEntries(r)\n  // slow path\n  if (hasBlockCount) {\n    const {\n      blockStarts,\n      blockCount,\n      chromStarts,\n      thickEnd,\n      thickStart,\n      blockSizes,\n      ...rest\n    } = obj\n\n    return {\n      ...rest,\n      blockStarts: arrayify(blockStarts),\n      chromStarts: arrayify(chromStarts),\n      blockSizes: arrayify(blockSizes),\n      thickStart: thickStart ? +thickStart : undefined,\n      thickEnd: thickEnd ? +thickEnd : undefined,\n      blockCount: blockCount ? +blockCount : undefined,\n    } as Record<string, unknown>\n  }\n\n  // fast path\n  else {\n    return obj\n  }\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes?: number[]\n  blockStarts?: number[]\n}) {\n  const subfeatures = []\n  const starts = chromStarts || blockStarts || []\n  for (let b = 0; b < blockCount; b++) {\n    const bmin = (starts[b] || 0) + start\n    const bsize = blockSizes?.[b]\n    if (bsize && bsize > 0) {\n      const bmax = bmin + bsize\n      subfeatures.push({\n        uniqueId: `${uniqueId}-${b}`,\n        start: bmin,\n        end: bmax,\n        refName,\n        type: 'block',\n      })\n    }\n  }\n  return subfeatures\n}\n\nexport function featureData({\n  line,\n  colRef,\n  colStart,\n  colEnd,\n  scoreColumn,\n  parser,\n  uniqueId,\n  names,\n}: {\n  line: string\n  colRef: number\n  colStart: number\n  colEnd: number\n  scoreColumn: string\n  parser: BED\n  uniqueId: string\n  names?: string[]\n}) {\n  const splitLine = line.split('\\t')\n  const refName = splitLine[colRef]!\n  const start = Number.parseInt(splitLine[colStart]!, 10)\n  const end =\n    Number.parseInt(splitLine[colEnd]!, 10) + (colStart === colEnd ? 1 : 0)\n\n  return featureData2({\n    splitLine,\n    refName,\n    start,\n    end,\n    parser,\n    uniqueId,\n    scoreColumn,\n    names,\n  })\n}\n\nexport function featureData2({\n  splitLine,\n  refName,\n  start,\n  end,\n  parser,\n  uniqueId,\n  scoreColumn,\n  names,\n}: {\n  splitLine: string[]\n  refName: string\n  start: number\n  end: number\n  parser: BED\n  uniqueId: string\n  scoreColumn: string\n  names?: string[]\n}) {\n  const data = names\n    ? defaultParser(names, splitLine)\n    : parser.parseLine(splitLine, { uniqueId })\n  const {\n    strand: strand2,\n    score: score2,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n\n  const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined\n  const strand =\n    typeof strand2 === 'string' ? (strand2 === '-' ? -1 : 1) : strand2\n\n  const subfeatures = rest.blockCount\n    ? makeBlocks({\n        start,\n        uniqueId,\n        refName,\n        chromStarts: rest.chromStarts,\n        blockCount: rest.blockCount,\n        blockSizes: rest.blockSizes,\n        blockStarts: rest.blockStarts,\n      })\n    : undefined\n\n  if (isBedMethylFeature({ splitLine, start, end })) {\n    return generateBedMethylFeature({\n      splitLine,\n      uniqueId,\n      refName,\n      start,\n      end,\n    })\n  } else if (isRepeatMaskerDescriptionField(rest.description)) {\n    const {\n      chromStarts,\n      blockSizes,\n      blockStarts,\n      type,\n      blockCount,\n      thickStart,\n      thickEnd,\n      description,\n      ...rest2\n    } = rest\n    return generateRepeatMaskerFeature({\n      ...rest2,\n      uniqueId,\n      description,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    })\n  } else if (\n    subfeatures &&\n    isUcscTranscript({\n      strand,\n      blockCount: rest.blockCount,\n      thickStart: rest.thickStart,\n    })\n  ) {\n    const {\n      chromStarts,\n      blockSizes,\n      type,\n      blockCount,\n      thickStart,\n      thickEnd,\n      description,\n    } = rest\n    return generateUcscTranscript({\n      ...rest,\n      description,\n      chromStarts,\n      thickStart,\n      thickEnd,\n      blockSizes,\n      blockCount,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      uniqueId,\n      subfeatures,\n    })\n  } else {\n    return {\n      ...rest,\n      uniqueId,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    }\n  }\n}\n\nexport function arrayify(f?: string | number[]) {\n  return f !== undefined\n    ? typeof f === 'string'\n      ? f.split(',').map(f => +f)\n      : f\n    : undefined\n}\n","// this uses modkit bedMethyl. unclear how to reliably detect minimal 9+2 bedMethyl\nexport function isBedMethylFeature({\n  splitLine,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  start: number\n  end: number\n}) {\n  return (\n    +(splitLine[6] || 0) === start &&\n    +(splitLine[7] || 0) === end &&\n    [9, 10, 11, 12, 13, 14, 15, 16, 17].every(\n      r => splitLine[r] && !Number.isNaN(+splitLine[r]),\n    )\n  )\n}\n\nexport function generateBedMethylFeature({\n  splitLine,\n  uniqueId,\n  refName,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n}) {\n  // see\n  // https://github.com/nanoporetech/modkit?tab=readme-ov-file#description-of-bedmethyl-output\n  const [\n    ,\n    ,\n    ,\n    code,\n    ,\n    strand,\n    ,\n    ,\n    color,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  ] = splitLine\n\n  return {\n    uniqueId,\n    refName,\n    start,\n    end,\n    code,\n    score: +fraction_modified! || 0,\n    strand,\n    color,\n    source: code,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  }\n}\n","import type { MinimalFeature, TranscriptFeat } from './types'\n\nexport function isUcscTranscript({\n  thickStart,\n  blockCount,\n  strand,\n}: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return thickStart && blockCount && strand !== 0\n}\n\nexport function generateUcscTranscript(data: TranscriptFeat) {\n  const {\n    strand = 0,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    chromStarts,\n    blockStarts,\n    blockSizes,\n    uniqueId,\n    ...rest\n  } = data\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    refName,\n    ...rest2\n  } = rest\n\n  const subfeatures: MinimalFeature[] = []\n  const feats = oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n\n  const { cdsEndStat, cdsStartStat } = rest2\n  if (cdsStartStat === 'none' && cdsEndStat === 'none') {\n    return {\n      ...rest2,\n      uniqueId,\n      strand,\n      type: 'transcript',\n      refName,\n      subfeatures: feats.map(e => ({\n        ...e,\n        type: 'exon',\n      })),\n    }\n  } else {\n    for (const block of feats) {\n      const start = block.start\n      const end = block.end\n      if (thickStart >= end) {\n        // left-side UTR\n        subfeatures.push({\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n        // UTR | CDS\n        subfeatures.push(\n          {\n            type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            phase: 0,\n            start: thickStart,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd >= end) {\n        // CDS\n        subfeatures.push({\n          type: 'CDS',\n          phase: 0,\n          start,\n          end,\n          refName,\n        })\n      } else if (thickStart > start && thickStart < end && thickEnd < end) {\n        // UTR | CDS | UTR\n        subfeatures.push(\n          {\n            type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n            start,\n            end: thickStart,\n            refName,\n          },\n          {\n            type: 'CDS',\n            phase: 0,\n            start: thickStart,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n        // CDS | UTR\n        subfeatures.push(\n          {\n            type: 'CDS',\n            phase: 0,\n            start,\n            end: thickEnd,\n            refName,\n          },\n          {\n            type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n            start: thickEnd,\n            end,\n            refName,\n          },\n        )\n      } else if (thickEnd <= start) {\n        // right-side UTR\n        subfeatures.push({\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start,\n          end,\n          refName,\n        })\n      }\n    }\n    return {\n      ...rest2,\n      uniqueId,\n      strand,\n      type: 'mRNA',\n      refName,\n      subfeatures,\n    }\n  }\n\n  return {\n    ...rest2,\n    uniqueId,\n    strand,\n    type: 'mRNA',\n    refName,\n    subfeatures,\n  }\n}\n","import IntervalTree from '@flatten-js/interval-tree'\nimport BED from '@gmod/bed'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { SimpleFeature, fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { parseLineByLine } from '@jbrowse/core/util/parseLineByLine'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport { featureData } from '../util'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\nexport default class BedAdapter extends BaseFeatureDataAdapter {\n  protected bedFeatures?: Promise<{\n    header: string\n    features: Record<string, string[]>\n    parser: BED\n    columnNames: string[]\n    scoreColumn: string\n    colRef: number\n    colStart: number\n    colEnd: number\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree | undefined> | undefined\n  > = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts?: BaseOptions) {\n    const bedLoc = this.getConf('bedLocation')\n    const buffer = await fetchAndMaybeUnzip(\n      openLocation(bedLoc, this.pluginManager),\n      opts,\n    )\n\n    const headerLines = [] as string[]\n    const features = {} as Record<string, string[]>\n    parseLineByLine(\n      buffer,\n      line => {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else {\n          const tab = line.indexOf('\\t')\n          const refName = line.slice(0, tab)\n          if (!features[refName]) {\n            features[refName] = []\n          }\n          features[refName].push(line)\n        }\n        return true\n      },\n      opts?.statusCallback,\n    )\n\n    const header = headerLines.join('\\n')\n    const autoSql = this.getConf('autoSql') as string\n    const parser = new BED({ autoSql })\n    const columnNames = this.getConf('columnNames')\n    const scoreColumn = this.getConf('scoreColumn')\n    const colRef = this.getConf('colRef')\n    const colStart = this.getConf('colStart')\n    const colEnd = this.getConf('colEnd')\n\n    return {\n      header,\n      features,\n      parser,\n      columnNames,\n      scoreColumn,\n      colRef,\n      colStart,\n      colEnd,\n    }\n  }\n\n  async loadData(opts: BaseOptions = {}) {\n    if (!this.bedFeatures) {\n      this.bedFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { features } = await this.loadData(opts)\n    return Object.keys(features)\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureIntervalTreeHelper(refName: string) {\n    const { colRef, colStart, colEnd, features, parser, scoreColumn } =\n      await this.loadData()\n    const lines = features[refName]\n    if (!lines) {\n      return undefined\n    }\n    const names = await this.getNames()\n\n    const intervalTree = new IntervalTree()\n    // eslint-disable-next-line unicorn/no-for-loop\n    for (let i = 0; i < lines.length; i++) {\n      const line = lines[i]!\n      const uniqueId = `${this.id}-${refName}-${i}`\n      const feat = new SimpleFeature(\n        featureData({\n          line,\n          colRef,\n          colStart,\n          colEnd,\n          scoreColumn,\n          parser,\n          uniqueId,\n          names,\n        }),\n      )\n      intervalTree.insert([feat.get('start'), feat.get('end')], feat)\n    }\n\n    return intervalTree\n  }\n\n  async loadFeatureIntervalTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureIntervalTreeHelper(\n        refName,\n      ).catch((e: unknown) => {\n        this.intervalTrees[refName] = undefined\n        throw e\n      })\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureIntervalTree(refName)\n      const features = intervalTree?.search([start, end])\n      if (features) {\n        for (const f of features) {\n          observer.next(f)\n        }\n      }\n      observer.complete()\n    }, opts.stopToken)\n  }\n}\n"],"names":["parseLineByLine","buffer","lineCallback","statusCallback","decoder","TextDecoder","blockStart","i","length","n","indexOf","lineEnd","b","subarray","line","decode","trim","getProgressDisplayStr","isRepeatMaskerDescriptionField","desc","ret","split","every","s","undefined","Number","isNaN","makeRepeatTrackDescription","description","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","featureData","colRef","colStart","colEnd","scoreColumn","parser","uniqueId","names","splitLine","featureData2","refName","start","parseInt","end","data","fields","hasBlockCount","r","push","obj","Object","fromEntries","blockStarts","blockCount","chromStarts","thickEnd","thickStart","blockSizes","rest","arrayify","defaultParser","parseLine","strand","strand2","score","score2","chrom","_1","chromStart","_2","chromEnd","_3","subfeatures","starts","bmin","bsize","bmax","type","makeBlocks","isBedMethylFeature","code","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","source","generateBedMethylFeature","rest2","generateRepeatMaskerFeature","isUcscTranscript","oldSubfeatures","feats","filter","child","sort","a","cdsEndStat","cdsStartStat","map","e","block","phase","generateUcscTranscript","f","BedAdapter","BaseFeatureDataAdapter","intervalTrees","loadDataP","opts","bedLoc","this","getConf","fetchAndMaybeUnzip","openLocation","pluginManager","headerLines","features","startsWith","tab","slice","header","join","autoSql","BED","columnNames","loadData","bedFeatures","catch","getRefNames","keys","getHeader","getNames","defline","at","includes","field","loadFeatureIntervalTreeHelper","lines","intervalTree","IntervalTree","id","feat","SimpleFeature","insert","get","loadFeatureIntervalTree","getFeatures","query","ObservableCreate","async","search","observer","next","complete","stopToken"],"sourceRoot":""}