{"version":3,"file":"static/js/5461.5c8cf5d1.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBins.ts","../../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts"],"sourcesContent":["import { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { getTag, getTagAlt, shouldFetchReferenceSequence } from '../util'\nimport {\n  parseCigar,\n  getNextRefPos,\n  getModificationPositions,\n  getMethBins,\n  Mismatch,\n} from '../MismatchParser'\nimport { doesIntersect2 } from '@jbrowse/core/util'\nimport { Bin, SkipMap } from './util'\n\nfunction mismatchLen(mismatch: Mismatch) {\n  return !isInterbase(mismatch.type) ? mismatch.length : 1\n}\n\nfunction isInterbase(type: string) {\n  return type === 'softclip' || type === 'hardclip' || type === 'insertion'\n}\n\nfunction inc(bin: any, strand: number, type: string, field: string) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      total: 0,\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.total++\n  thisBin[strand]++\n}\n\nexport default async function generateCoverageBins(\n  features: Feature[],\n  region: Region,\n  opts: { bpPerPx?: number; colorBy?: { type: string; tag?: string } },\n  fetchSequence: (arg: Region) => Promise<string>,\n) {\n  const { colorBy } = opts\n  const extendedRegion = {\n    ...region,\n    start: Math.max(0, region.start - 1),\n    end: region.end + 1,\n  }\n  const binMax = Math.ceil(extendedRegion.end - extendedRegion.start)\n  const skipmap = {} as SkipMap\n  const regionSequence =\n    features.length && shouldFetchReferenceSequence(opts.colorBy?.type)\n      ? await fetchSequence(region)\n      : undefined\n\n  const bins = [] as Bin[]\n\n  for (const feature of features) {\n    const fstart = feature.get('start')\n    const fend = feature.get('end')\n    const fstrand = feature.get('strand') as -1 | 0 | 1\n    const mismatches =\n      (feature.get('mismatches') as Mismatch[] | undefined) || []\n\n    for (let j = fstart; j < fend + 1; j++) {\n      const i = j - region.start\n      if (i >= 0 && i < binMax) {\n        if (bins[i] === undefined) {\n          bins[i] = {\n            total: 0,\n            all: 0,\n            ref: 0,\n            '-1': 0,\n            '0': 0,\n            '1': 0,\n            lowqual: {},\n            cov: {},\n            delskips: {},\n            noncov: {},\n          }\n        }\n        if (j !== fend) {\n          bins[i].total++\n          bins[i].all++\n          bins[i].ref++\n          bins[i][fstrand]++\n        }\n      }\n    }\n\n    if (colorBy?.type === 'modifications') {\n      const seq = feature.get('seq') as string | undefined\n      const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n      const ops = parseCigar(feature.get('CIGAR'))\n      const fend = feature.get('end')\n      if (seq) {\n        const modifications = getModificationPositions(mm, seq, fstrand)\n        for (const { type, positions } of modifications) {\n          const mod = `mod_${type}`\n          for (const pos of getNextRefPos(ops, positions)) {\n            const epos = pos + fstart - region.start\n            if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n              if (bins[epos] === undefined) {\n                bins[epos] = {\n                  total: 0,\n                  all: 0,\n                  ref: 0,\n                  '-1': 0,\n                  '0': 0,\n                  '1': 0,\n                  lowqual: {},\n                  cov: {},\n                  delskips: {},\n                  noncov: {},\n                }\n              }\n              const bin = bins[epos]\n              inc(bin, fstrand, 'cov', mod)\n            }\n          }\n        }\n      }\n    }\n\n    if (colorBy?.type === 'methylation') {\n      if (!regionSequence) {\n        throw new Error(\n          'no region sequence detected, need sequenceAdapter configuration',\n        )\n      }\n      const seq = feature.get('seq') as string | undefined\n      if (!seq) {\n        continue\n      }\n      const { methBins, methProbs } = getMethBins(feature)\n      const dels = mismatches.filter(f => f.type === 'deletion')\n\n      // methylation based coloring takes into account both reference sequence\n      // CpG detection and reads\n      for (let i = 0; i < fend - fstart; i++) {\n        const j = i + fstart\n        const l1 = regionSequence[j - region.start + 1]?.toLowerCase()\n        const l2 = regionSequence[j - region.start + 2]?.toLowerCase()\n        if (l1 === 'c' && l2 === 'g') {\n          const bin0 = bins[j - region.start]\n          const bin1 = bins[j - region.start + 1]\n          const b0 = methBins[i]\n          const b1 = methBins[i + 1]\n          const p0 = methProbs[i]\n          const p1 = methProbs[i + 1]\n\n          // color\n          if (\n            (b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n            (b1 && (p1 !== undefined ? p1 > 0.5 : true))\n          ) {\n            if (bin0) {\n              inc(bin0, fstrand, 'cov', 'meth')\n              bin0.ref--\n              bin0[fstrand]--\n            }\n            if (bin1) {\n              inc(bin1, fstrand, 'cov', 'meth')\n              bin1.ref--\n              bin1[fstrand]--\n            }\n          } else {\n            if (bin0) {\n              if (\n                !dels.some(d =>\n                  doesIntersect2(\n                    j,\n                    j + 1,\n                    d.start + fstart,\n                    d.start + fstart + d.length,\n                  ),\n                )\n              ) {\n                inc(bin0, fstrand, 'cov', 'unmeth')\n                bin0.ref--\n                bin0[fstrand]--\n              }\n            }\n            if (bin1) {\n              if (\n                !dels.some(d =>\n                  doesIntersect2(\n                    j + 1,\n                    j + 2,\n                    d.start + fstart,\n                    d.start + fstart + d.length,\n                  ),\n                )\n              ) {\n                inc(bin1, fstrand, 'cov', 'unmeth')\n                bin1.ref--\n                bin1[fstrand]--\n              }\n            }\n          }\n        }\n      }\n    }\n\n    // normal SNP based coloring\n    const colorSNPs =\n      colorBy?.type !== 'modifications' && colorBy?.type !== 'methylation'\n\n    for (const mismatch of mismatches) {\n      const mstart = fstart + mismatch.start\n      const mlen = mismatchLen(mismatch)\n      const mend = mstart + mlen\n      for (let j = mstart; j < mstart + mlen; j++) {\n        const epos = j - region.start\n        if (epos >= 0 && epos < bins.length) {\n          const bin = bins[epos]!\n          const { base, type } = mismatch\n          const interbase = isInterbase(type)\n          if (!interbase) {\n            bin.ref--\n            bin[fstrand]--\n          } else {\n            inc(bin, fstrand, 'noncov', type)\n          }\n\n          if (type === 'deletion' || type === 'skip') {\n            inc(bin, fstrand, 'delskips', type)\n            bin.total--\n          } else if (!interbase && colorSNPs) {\n            inc(bin, fstrand, 'cov', base)\n            bin.refbase = mismatch.altbase\n          }\n        }\n      }\n\n      if (mismatch.type === 'skip') {\n        const hash = `${mstart}_${mend}_${fstrand}`\n        if (skipmap[hash] === undefined) {\n          skipmap[hash] = {\n            feature: feature,\n            start: mstart,\n            end: mend,\n            strand: fstrand,\n            xs: getTag(feature, 'XS') || getTag(feature, 'TS'),\n            score: 0,\n          }\n        }\n        skipmap[hash].score++\n      }\n    }\n  }\n\n  return { bins, skipmap }\n}\n","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\n\n// locals\nimport generateCoverageBins from './generateCoverageBins'\nimport { fetchSequence } from '../util'\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  protected async configure() {\n    const subadapterConfig = this.getConf('subadapter')\n    const sequenceConf = subadapterConfig.sequenceAdapter\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfig)\n\n    const sequenceAdapter = sequenceConf\n      ? await this.getSubAdapter?.(sequenceConf)\n      : undefined\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    return {\n      subadapter: dataAdapter.dataAdapter as BaseFeatureDataAdapter,\n      sequenceAdapter: sequenceAdapter?.dataAdapter as\n        | BaseFeatureDataAdapter\n        | undefined,\n    }\n  }\n\n  async fetchSequence(region: Region) {\n    const { sequenceAdapter } = await this.configure()\n    if (!sequenceAdapter) {\n      return undefined\n    }\n\n    return fetchSequence(region, sequenceAdapter)\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { subadapter } = await this.configure()\n      const feats = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n\n      const { bins, skipmap } = await generateCoverageBins(\n        feats,\n        region,\n        opts,\n        arg => this.fetchSequence(arg),\n      )\n\n      bins.forEach((bin, index) => {\n        const start = region.start + index\n        observer.next(\n          new SimpleFeature({\n            id: `${this.id}-${start}`,\n            data: {\n              score: bin.total,\n              snpinfo: bin,\n              start,\n              end: start + 1,\n              refName: region.refName,\n            },\n          }),\n        )\n      })\n\n      // make fake features from the coverage\n      Object.entries(skipmap).forEach(([key, skip]) => {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              xs: skip.xs,\n            },\n          }),\n        )\n      })\n\n      observer.complete()\n    }, opts.signal)\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n\n  freeResources(/* { region } */): void {}\n}\n"],"names":["mismatchLen","mismatch","isInterbase","type","length","inc","bin","strand","field","thisBin","undefined","total","SNPCoverageAdapter","BaseFeatureDataAdapter","configure","subadapterConfig","this","getConf","sequenceConf","sequenceAdapter","dataAdapter","getSubAdapter","Error","subadapter","fetchSequence","region","getFeatures","opts","ObservableCreate","async","feats","firstValueFrom","pipe","toArray","bins","skipmap","features","colorBy","extendedRegion","start","Math","max","end","binMax","ceil","regionSequence","shouldFetchReferenceSequence","feature","fstart","get","fend","fstrand","mismatches","j","i","all","ref","lowqual","cov","delskips","noncov","seq","mm","getTagAlt","ops","parseCigar","modifications","getModificationPositions","positions","mod","pos","getNextRefPos","epos","methBins","methProbs","getMethBins","dels","filter","f","l1","toLowerCase","l2","bin0","bin1","b0","b1","p0","p1","some","d","doesIntersect2","colorSNPs","mstart","mlen","mend","base","interbase","refbase","altbase","hash","xs","getTag","score","generateCoverageBins","arg","forEach","index","observer","next","SimpleFeature","id","data","snpinfo","refName","Object","entries","key","skip","complete","signal","getMultiRegionFeatureDensityStats","regions","getRefNames","freeResources"],"sourceRoot":""}