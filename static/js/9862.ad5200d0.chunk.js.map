{"version":3,"file":"static/js/9862.ad5200d0.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/alignments/src/LinearReadCloudDisplay/afterAttachRPC.tsx","webpack://@jbrowse/web/../../plugins/alignments/src/shared/createRPCRenderingSetup.ts","webpack://@jbrowse/web/../../plugins/alignments/src/shared/setupModificationsAutorun.ts"],"sourcesContent":["import { getContainingView } from '@jbrowse/core/util'\nimport { isAlive } from '@jbrowse/mobx-state-tree'\n\nimport {\n  buildFlatbushIndex,\n  buildMismatchFlatbushIndex,\n} from '../RenderLinearReadCloudDisplayRPC/drawFeatsCommon.ts'\nimport {\n  createRPCRenderFunction,\n  setupCanvasRenderingAutorun,\n} from '../shared/createRPCRenderingSetup.ts'\nimport { setupModificationsAutorun } from '../shared/setupModificationsAutorun.ts'\nimport { createAutorun } from '../util.ts'\n\nimport type { LinearReadCloudDisplayModel } from './model.ts'\nimport type { FlatbushItem } from '../PileupRenderer/types.ts'\nimport type { FlatbushEntry } from '../shared/flatbushType.ts'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\ninterface CloudRenderResult {\n  layoutHeight?: number\n  cloudMaxDistance?: number\n  featuresForFlatbush?: FlatbushEntry[]\n  mismatchFlatbush?: ArrayBuffer\n  mismatchItems?: FlatbushItem[]\n}\n\nexport function doAfterAttachRPC(self: LinearReadCloudDisplayModel) {\n  const createCloudRender = (drawCloud: boolean) =>\n    createRPCRenderFunction({\n      self,\n      rpcMethodName: 'RenderLinearReadCloudDisplay',\n      getRPCParams: () => ({\n        ...self.renderProps(),\n        drawCloud,\n        ...(drawCloud && { cloudModeHeight: self.height }),\n      }),\n      onResult: (result: CloudRenderResult) => {\n        if (!drawCloud && result.layoutHeight !== undefined) {\n          self.setLayoutHeight(result.layoutHeight)\n        }\n        if (drawCloud && result.cloudMaxDistance !== undefined) {\n          self.setCloudMaxDistance(result.cloudMaxDistance)\n        }\n        if (result.featuresForFlatbush) {\n          buildFlatbushIndex(result.featuresForFlatbush, self)\n        }\n        if (result.mismatchFlatbush && result.mismatchItems) {\n          buildMismatchFlatbushIndex(\n            result.mismatchFlatbush,\n            result.mismatchItems,\n            self,\n          )\n        }\n      },\n    })\n\n  const performCloudRender = createCloudRender(true)\n  const performStackRender = createCloudRender(false)\n\n  createAutorun(\n    self,\n    async () => {\n      if (!self.drawCloud || !isAlive(self)) {\n        return\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      performCloudRender()\n    },\n    {\n      delay: 1000,\n      name: 'CloudRender',\n    },\n  )\n\n  createAutorun(\n    self,\n    async () => {\n      if (self.drawCloud || !isAlive(self)) {\n        return\n      }\n      // eslint-disable-next-line @typescript-eslint/no-floating-promises\n      performStackRender()\n    },\n    {\n      delay: 1000,\n      name: 'StackRender',\n    },\n  )\n\n  setupCanvasRenderingAutorun(self)\n\n  setupModificationsAutorun(self, () => {\n    const view = getContainingView(self) as LGV\n    return view.initialized && self.featureDensityStatsReadyAndRegionNotTooLarge\n  })\n}\n","import {\n  getContainingView,\n  getSession,\n  isAbortException,\n} from '@jbrowse/core/util'\nimport { createStopToken, stopStopToken } from '@jbrowse/core/util/stopToken'\nimport { getRpcSessionId } from '@jbrowse/core/util/tracks'\nimport { getSnapshot, isAlive } from '@jbrowse/mobx-state-tree'\nimport { drawCanvasImageData } from '@jbrowse/plugin-linear-genome-view'\nimport { untracked } from 'mobx'\n\nimport { createAutorun } from '../util.ts'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { StopToken } from '@jbrowse/core/util/stopToken'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface RPCRenderableModel {\n  id: string\n  error: unknown\n  featureDensityStatsReadyAndRegionNotTooLarge: boolean\n  effectiveRpcDriverName: string\n  adapterConfig: unknown\n  configuration: AnyConfigurationModel\n  renderingStopToken?: StopToken\n  setRenderingStopToken: (token?: StopToken) => void\n  setLoading: (loading: boolean) => void\n  setError: (error: unknown) => void\n  setRenderingImageData: (imageData: ImageBitmap | undefined) => void\n  setLastDrawnOffsetPx: (offsetPx: number) => void\n  setLastDrawnBpPerPx: (bpPerPx: number) => void\n  ref: HTMLCanvasElement | null\n  renderingImageData?: ImageBitmap\n  setStatusMessage?: (msg: string) => void\n  setCanvasDrawn?: (drawn: boolean) => void\n}\n\nexport interface RPCRenderSetupParams<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n> {\n  self: T\n  rpcMethodName: string\n  getRPCParams: (params: {\n    view: LGV\n    session: ReturnType<typeof getSession>\n    sequenceAdapter: unknown\n    stopToken: StopToken\n  }) => Record<string, unknown>\n  onResult: (result: R) => void\n}\n\nexport function createRPCRenderFunction<\n  T extends RPCRenderableModel,\n  R = Record<string, unknown>,\n>({ self, rpcMethodName, getRPCParams, onResult }: RPCRenderSetupParams<T, R>) {\n  return async () => {\n    const view = getContainingView(self) as LGV\n\n    if (\n      !view.initialized ||\n      self.error ||\n      !self.featureDensityStatsReadyAndRegionNotTooLarge\n    ) {\n      return\n    }\n\n    const { bpPerPx } = view\n\n    try {\n      const session = getSession(self)\n      const { rpcManager, assemblyManager } = session\n      const assemblyName = view.assemblyNames[0]\n      if (!assemblyName) {\n        return\n      }\n\n      const assembly = assemblyManager.get(assemblyName)\n      const sequenceAdapterConfig = assembly?.configuration?.sequence?.adapter\n      const sequenceAdapter = sequenceAdapterConfig\n        ? getSnapshot(sequenceAdapterConfig)\n        : undefined\n\n      const previousToken = untracked(() => self.renderingStopToken)\n      if (previousToken) {\n        stopStopToken(previousToken)\n      }\n\n      const stopToken = createStopToken()\n      self.setRenderingStopToken(stopToken)\n      self.setLoading(true)\n      self.setCanvasDrawn?.(false)\n\n      const viewSnapshot = {\n        displayedRegions: structuredClone(view.displayedRegions),\n        bpPerPx: view.bpPerPx,\n        offsetPx: view.offsetPx,\n        interRegionPaddingWidth: view.interRegionPaddingWidth,\n        minimumBlockWidth: view.minimumBlockWidth,\n        width: view.width,\n      }\n\n      const sessionId = getRpcSessionId(self)\n      const adapterConfig = self.adapterConfig\n      const config = getSnapshot(self.configuration)\n      const result = (await rpcManager.call(sessionId, rpcMethodName, {\n        sessionId,\n        view: viewSnapshot,\n        adapterConfig,\n        sequenceAdapter,\n        config,\n        statusCallback: (msg: string) => {\n          if (isAlive(self)) {\n            self.setStatusMessage?.(msg)\n          }\n        },\n        stopToken,\n        ...getRPCParams({ view, session, sequenceAdapter, stopToken }),\n      })) as R & { imageData?: ImageBitmap; offsetPx?: number }\n\n      if (result.imageData) {\n        self.setRenderingImageData(result.imageData)\n        if (result.offsetPx !== undefined) {\n          self.setLastDrawnOffsetPx(result.offsetPx)\n        }\n        onResult(result)\n      }\n\n      self.setLastDrawnBpPerPx(bpPerPx)\n    } catch (error) {\n      if (!isAbortException(error)) {\n        console.error(error)\n        self.setError(error)\n      }\n    } finally {\n      self.setRenderingStopToken(undefined)\n      self.setLoading(false)\n    }\n  }\n}\n\nexport function setupCanvasRenderingAutorun<T extends RPCRenderableModel>(\n  self: T,\n) {\n  createAutorun(\n    self,\n    async () => {\n      const success = drawCanvasImageData(self.ref, self.renderingImageData)\n      if (isAlive(self)) {\n        self.setCanvasDrawn?.(success)\n      }\n    },\n    {\n      name: 'CanvasRenderAutorun',\n    },\n  )\n}\n","import { getContainingView } from '@jbrowse/core/util'\nimport { isAlive } from '@jbrowse/mobx-state-tree'\n\nimport { getUniqueModifications } from './getUniqueModifications.ts'\nimport { createAutorun } from '../util.ts'\n\nimport type { ModificationType } from './types.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { LinearGenomeViewModel } from '@jbrowse/plugin-linear-genome-view'\n\ntype LGV = LinearGenomeViewModel\n\nexport interface ModificationsAutorunModel {\n  adapterConfig: AnyConfigurationModel\n  updateVisibleModifications: (arg: ModificationType[]) => void\n  setSimplexModifications: (arg: string[]) => void\n  setModificationsReady: (arg: boolean) => void\n  setStatusMessage: (arg: string) => void\n  effectiveRpcDriverName?: string\n}\n\nexport function setupModificationsAutorun(\n  model: ModificationsAutorunModel,\n  isReady: () => boolean,\n) {\n  createAutorun(\n    model,\n    async () => {\n      if (!isReady()) {\n        return\n      }\n      const view = getContainingView(model) as LGV\n      const { adapterConfig } = model\n      const { staticBlocks } = view\n      const { modifications, simplexModifications } =\n        await getUniqueModifications({\n          model,\n          adapterConfig,\n          blocks: staticBlocks,\n        })\n      if (isAlive(model)) {\n        model.updateVisibleModifications(modifications)\n        model.setSimplexModifications(simplexModifications)\n        model.setModificationsReady(true)\n      }\n    },\n    {\n      delay: 1000,\n      name: 'GetModInfo',\n    },\n  )\n}\n"],"names":["doAfterAttachRPC","self","createCloudRender","drawCloud","createRPCRenderFunction","rpcMethodName","getRPCParams","renderProps","cloudModeHeight","height","onResult","result","undefined","layoutHeight","setLayoutHeight","cloudMaxDistance","setCloudMaxDistance","featuresForFlatbush","buildFlatbushIndex","mismatchFlatbush","mismatchItems","buildMismatchFlatbushIndex","performCloudRender","performStackRender","createAutorun","async","isAlive","delay","name","setupCanvasRenderingAutorun","setupModificationsAutorun","getContainingView","initialized","featureDensityStatsReadyAndRegionNotTooLarge","view","error","bpPerPx","session","getSession","rpcManager","assemblyManager","assemblyName","assemblyNames","assembly","get","sequenceAdapterConfig","configuration","sequence","adapter","sequenceAdapter","getSnapshot","previousToken","untracked","renderingStopToken","stopStopToken","stopToken","createStopToken","setRenderingStopToken","setLoading","setCanvasDrawn","viewSnapshot","displayedRegions","structuredClone","offsetPx","interRegionPaddingWidth","minimumBlockWidth","width","sessionId","getRpcSessionId","adapterConfig","config","call","statusCallback","msg","setStatusMessage","imageData","setRenderingImageData","setLastDrawnOffsetPx","setLastDrawnBpPerPx","isAbortException","console","setError","success","drawCanvasImageData","ref","renderingImageData","model","isReady","staticBlocks","modifications","simplexModifications","getUniqueModifications","blocks","updateVisibleModifications","setSimplexModifications","setModificationsReady"],"sourceRoot":""}