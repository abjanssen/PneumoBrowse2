"use strict";(globalThis.webpackChunk_jbrowse_web=globalThis.webpackChunk_jbrowse_web||[]).push([[8120],{47046:(e,t,n)=>{n.d(t,{A:()=>s});class r{}class i{constructor(){this.signals=new Set,this.abortController=new AbortController}addSignal(e=new r){if(this.signal.aborted)throw new Error("cannot add a signal, already aborted!");this.signals.add(e),e.aborted?this.handleAborted(e):"function"==typeof e.addEventListener&&e.addEventListener("abort",(()=>{this.handleAborted(e)}))}handleAborted(e){this.signals.delete(e),0===this.signals.size&&this.abortController.abort()}get signal(){return this.abortController.signal}abort(){this.abortController.abort()}}class a{constructor(){this.callbacks=new Set}addCallback(e=()=>{}){this.callbacks.add(e),e(this.currentMessage)}callback(e){this.currentMessage=e;for(const t of this.callbacks)t(e)}}class s{constructor({fill:e,cache:t}){if("function"!=typeof e)throw new TypeError("must pass a fill function");if("object"!=typeof t)throw new TypeError("must pass a cache object");if("function"!=typeof t.get||"function"!=typeof t.set||"function"!=typeof t.delete)throw new TypeError("cache must implement get(key), set(key, val), and and delete(key)");this.cache=t,this.fillCallback=e}static isAbortException(e){return"AbortError"===e.name||"ERR_ABORTED"===e.code||"AbortError: aborted"===e.message||"Error: aborted"===e.message}evict(e,t){this.cache.get(e)===t&&this.cache.delete(e)}fill(e,t,n,r){const s=new i,o=new a;o.addCallback(r);const l={aborter:s,promise:this.fillCallback(t,s.signal,(e=>{o.callback(e)})),settled:!1,statusReporter:o,get aborted(){return this.aborter.signal.aborted}};l.aborter.addSignal(n),l.aborter.signal.addEventListener("abort",(()=>{l.settled||this.evict(e,l)})),l.promise.then((()=>{l.settled=!0}),(()=>{l.settled=!0,this.evict(e,l)})).catch((e=>{throw console.error(e),e})),this.cache.set(e,l)}static checkSinglePromise(e,t){function n(){if(null==t?void 0:t.aborted)throw Object.assign(new Error("aborted"),{code:"ERR_ABORTED"})}return e.then((e=>(n(),e)),(e=>{throw n(),e}))}has(e){return this.cache.has(e)}get(e,t,n,r){if(!n&&t instanceof AbortSignal)throw new TypeError("second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?");const i=this.cache.get(e);return i?i.aborted&&!i.settled?(this.evict(e,i),this.get(e,t,n,r)):i.settled?i.promise:(i.aborter.addSignal(n),i.statusReporter.addCallback(r),s.checkSinglePromise(i.promise,n)):(this.fill(e,t,n,r),s.checkSinglePromise(this.cache.get(e).promise,n))}delete(e){const t=this.cache.get(e);t&&(t.settled||t.aborter.abort(),this.cache.delete(e))}clear(){const e=this.cache.keys();let t=0;for(let n=e.next();!n.done;n=e.next())this.delete(n.value),t+=1;return t}}},68120:(e,t,n)=>{n.d(t,{wD:()=>S});var r=n(47046),i=n(16308),a=n.n(i),s=n(35451),o=n(45834),l=n(70798);function c(e){if(e.greaterThan(Number.MAX_SAFE_INTEGER)||e.lessThan(Number.MIN_SAFE_INTEGER))throw new Error("integer overflow");return e.toNumber()}class d extends Error{}function h(e){if(e&&e.aborted){if("undefined"!=typeof DOMException)throw new DOMException("aborted","AbortError");{const e=new d("aborted");throw e.code="ERR_ABORTED",e}}}function f(e,t){const n=[];let r=null;return 0===e.length?e:(e.sort((function(e,t){const n=e.minv.blockPosition-t.minv.blockPosition;return 0!==n?n:e.minv.dataPosition-t.minv.dataPosition})),e.forEach((e=>{var i,a;(!t||e.maxv.compareTo(t)>0)&&(null===r?(n.push(e),r=e):(i=r,(a=e).minv.blockPosition-i.maxv.blockPosition<65e3&&a.maxv.blockPosition-i.minv.blockPosition<5e6?e.maxv.compareTo(r.maxv)>0&&(r.maxv=e.maxv):(n.push(e),r=e)))})),n)}var u=n(59086),m=n.n(u);class b{constructor(e,t){this.blockPosition=e,this.dataPosition=t}toString(){return`${this.blockPosition}:${this.dataPosition}`}compareTo(e){return this.blockPosition-e.blockPosition||this.dataPosition-e.dataPosition}}function p(e,t=0,n=!1){if(n)throw new Error("big-endian virtual file offsets not implemented");return new b(1099511627776*e[t+7]+4294967296*e[t+6]+16777216*e[t+5]+65536*e[t+4]+256*e[t+3]+e[t+2],e[t+1]<<8|e[t])}class w{constructor(e,t,n,r=void 0){this.minv=e,this.maxv=t,this.bin=n,this._fetchedSize=r}toUniqueString(){return`${this.minv}..${this.maxv} (bin ${this.bin}, fetchedSize ${this.fetchedSize()})`}toString(){return this.toUniqueString()}compareTo(e){return this.minv.compareTo(e.minv)||this.maxv.compareTo(e.maxv)||this.bin-e.bin}fetchedSize(){return void 0!==this._fetchedSize?this._fetchedSize:this.maxv.blockPosition+65536-this.minv.blockPosition}}class g{constructor({filehandle:e,renameRefSeqs:t=e=>e}){this.filehandle=e,this.renameRefSeq=t}async getMetadata(e={}){const{indices:t,...n}=await this.parse(e);return n}_findFirstData(e,t){return e?e.compareTo(t)>0?t:e:t}async parse(e={}){return this.parseP||(this.parseP=this._parse(e).catch((e=>{throw this.parseP=void 0,e}))),this.parseP}async hasRefSeq(e,t={}){var n;return!!(null===(n=(await this.parse(t)).indices[e])||void 0===n?void 0:n.binIndex)}}class x extends g{async lineCount(e,t={}){const n=await this.parse(t),r=n.refNameToId[e];if(void 0===r)return-1;if(!n.indices[r])return-1;const{stats:i}=n.indices[r];return i?i.lineCount:-1}async _parse(e={}){const t=await this.filehandle.readFile(e),n=await(0,l.$1)(t);if(h(e.signal),21578324!==n.readUInt32LE(0))throw new Error("Not a TBI file");const r=n.readInt32LE(4),i=n.readInt32LE(8),a=65536&i?"zero-based-half-open":"1-based-closed",s={0:"generic",1:"SAM",2:"VCF"}[15&i];if(!s)throw new Error(`invalid Tabix preset format flags ${i}`);const o={ref:n.readInt32LE(12),start:n.readInt32LE(16),end:n.readInt32LE(20)},c=n.readInt32LE(24),d=c?String.fromCharCode(c):null,f=n.readInt32LE(28),u=n.readInt32LE(32),{refNameToId:m,refIdToName:b}=this._parseNameBytes(n.slice(36,36+u));let g,x=36+u;return{indices:new Array(r).fill(0).map((()=>{const e=n.readInt32LE(x);x+=4;const t={};let r;for(let i=0;i<e;i+=1){const e=n.readUInt32LE(x);if(x+=4,e>37450)throw new Error("tabix index contains too many bins, please use a CSI index");if(37450===e){const e=n.readInt32LE(x);x+=4,2===e&&(r=this.parsePseudoBin(n,x)),x+=16*e}else{const r=n.readInt32LE(x);x+=4;const i=new Array(r);for(let t=0;t<r;t+=1){const r=p(n,x),a=p(n,x+8);x+=16,g=this._findFirstData(g,r),i[t]=new w(r,a,e)}t[e]=i}}const i=n.readInt32LE(x);x+=4;const a=new Array(i);for(let e=0;e<i;e+=1)a[e]=p(n,x),x+=8,g=this._findFirstData(g,a[e]);return{binIndex:t,linearIndex:a,stats:r}})),metaChar:d,maxBinNumber:37449,maxRefLength:536870912,skipLines:f,firstDataLine:g,columnNumbers:o,coordinateType:a,format:s,refIdToName:b,refNameToId:m,maxBlockSize:65536}}parsePseudoBin(e,t){return{lineCount:c(m().fromBytesLE(e.slice(t+16,t+24),!0))}}_parseNameBytes(e){let t=0,n=0;const r=[],i={};for(let a=0;a<e.length;a+=1)if(!e[a]){if(n<a){let s=e.toString("utf8",n,a);s=this.renameRefSeq(s),r[t]=s,i[s]=t}n=a+1,t+=1}return{refNameToId:i,refIdToName:r}}async blocksForRange(e,t,n,r={}){t<0&&(t=0);const i=await this.parse(r),a=i.refNameToId[e];if(void 0===a)return[];const s=i.indices[a];if(!s)return[];(s.linearIndex.length?s.linearIndex[t>>14>=s.linearIndex.length?s.linearIndex.length-1:t>>14]:new b(0,0))||console.warn("querying outside of possible tabix range");const o=(l=t,c=n,[[0,0],[1+((l+=1)>>26),1+((c-=1)>>26)],[9+(l>>23),9+(c>>23)],[73+(l>>20),73+(c>>20)],[585+(l>>17),585+(c>>17)],[4681+(l>>14),4681+(c>>14)]]);var l,c;const d=[];for(const[e,t]of o)for(let n=e;n<=t;n++)if(s.binIndex[n])for(const e of s.binIndex[n])d.push(new w(e.minv,e.maxv,n));const h=s.linearIndex.length;let u=null;const m=Math.min(t>>14,h-1),p=Math.min(n>>14,h-1);for(let e=m;e<=p;++e){const t=s.linearIndex[e];t&&(!u||t.compareTo(u)<0)&&(u=t)}return f(d,u)}}function E(e,t){return Math.floor(e/2**t)}class v extends g{constructor(e){super(e),this.maxBinNumber=0,this.depth=0,this.minShift=0}async lineCount(e,t={}){const n=await this.parse(t),r=n.refNameToId[e];if(void 0===r)return-1;if(!n.indices[r])return-1;const{stats:i}=n.indices[r];return i?i.lineCount:-1}indexCov(){throw new Error("CSI indexes do not support indexcov")}parseAuxData(e,t){const n=e.readInt32LE(t),r=65536&n?"zero-based-half-open":"1-based-closed",i={0:"generic",1:"SAM",2:"VCF"}[15&n];if(!i)throw new Error(`invalid Tabix preset format flags ${n}`);const a={ref:e.readInt32LE(t+4),start:e.readInt32LE(t+8),end:e.readInt32LE(t+12)},s=e.readInt32LE(t+16),o=s?String.fromCharCode(s):null,l=e.readInt32LE(t+20),c=e.readInt32LE(t+24),{refIdToName:d,refNameToId:h}=this._parseNameBytes(e.slice(t+28,t+28+c));return{refIdToName:d,refNameToId:h,skipLines:l,metaChar:o,columnNumbers:a,format:i,coordinateType:r}}_parseNameBytes(e){let t=0,n=0;const r=[],i={};for(let a=0;a<e.length;a+=1)if(!e[a]){if(n<a){let s=e.toString("utf8",n,a);s=this.renameRefSeq(s),r[t]=s,i[s]=t}n=a+1,t+=1}return{refNameToId:i,refIdToName:r}}async _parse(e={}){const t=await(0,l.$1)(await this.filehandle.readFile(e));let n;if(21582659===t.readUInt32LE(0))n=1;else{if(38359875!==t.readUInt32LE(0))throw new Error("Not a CSI file");n=2}this.minShift=t.readInt32LE(4),this.depth=t.readInt32LE(8),this.maxBinNumber=((1<<3*(this.depth+1))-1)/7;const r=2**(this.minShift+3*this.depth),i=t.readInt32LE(12),a=i&&i>=30?this.parseAuxData(t,16):{refIdToName:[],refNameToId:{},metaChar:null,columnNumbers:{ref:0,start:1,end:2},coordinateType:"zero-based-half-open",format:"generic"},s=t.readInt32LE(16+i);let o,c=16+i+4;const d=new Array(s).fill(0).map((()=>{const e=t.readInt32LE(c);c+=4;const n={};let r;for(let i=0;i<e;i+=1){const e=t.readUInt32LE(c);if(e>this.maxBinNumber)r=this.parsePseudoBin(t,c+4),c+=48;else{const r=p(t,c+4);o=this._findFirstData(o,r);const i=t.readInt32LE(c+12);c+=16;const a=new Array(i);for(let n=0;n<i;n+=1){const r=p(t,c),i=p(t,c+8);c+=16,a[n]=new w(r,i,e)}n[e]=a}}return{binIndex:n,stats:r}}));return{...a,csi:!0,refCount:s,maxBlockSize:65536,firstDataLine:o,csiVersion:n,indices:d,depth:this.depth,maxBinNumber:this.maxBinNumber,maxRefLength:r}}parsePseudoBin(e,t){return{lineCount:c(m().fromBytesLE(e.slice(t+28,t+36),!0))}}async blocksForRange(e,t,n,r={}){t<0&&(t=0);const i=await this.parse(r),a=i.refNameToId[e];if(void 0===a)return[];const s=i.indices[a];if(!s)return[];const o=this.reg2bins(t,n),l=[];for(const[e,t]of o)for(let n=e;n<=t;n++)if(s.binIndex[n])for(const e of s.binIndex[n])l.push(new w(e.minv,e.maxv,n));return f(l,new b(0,0))}reg2bins(e,t){(e-=1)<1&&(e=1),t>2**50&&(t=2**34),t-=1;let n=0,r=0,i=this.minShift+3*this.depth;const a=[];for(;n<=this.depth;i-=3,r+=1*2**(3*n),n+=1){const n=r+E(e,i),s=r+E(t,i);if(s-n+a.length>this.maxBinNumber)throw new Error(`query ${e}-${t} is too large for current binning scheme (shift ${this.minShift}, depth ${this.depth}), try a smaller query or a coarser index binning scheme`);a.push([n,s])}return a}}function I(e){return/^[\u0000-\u007F]*$/.test(e)}const y="undefined"!=typeof TextDecoder?new TextDecoder("utf8"):void 0;class S{constructor({path:e,filehandle:t,url:n,tbiPath:i,tbiUrl:s,tbiFilehandle:l,csiPath:c,csiUrl:d,csiFilehandle:h,renameRefSeqs:f=e=>e,chunkCacheSize:u=5242880}){if(t)this.filehandle=t;else if(e)this.filehandle=new o.EY(e);else{if(!n)throw new TypeError("must provide either filehandle or path");this.filehandle=new o.Tx(n)}if(l)this.index=new x({filehandle:l,renameRefSeqs:f});else if(h)this.index=new v({filehandle:h,renameRefSeqs:f});else if(i)this.index=new x({filehandle:new o.EY(i),renameRefSeqs:f});else if(c)this.index=new v({filehandle:new o.EY(c),renameRefSeqs:f});else if(e)this.index=new x({filehandle:new o.EY(`${e}.tbi`),renameRefSeqs:f});else if(d)this.index=new v({filehandle:new o.Tx(d)});else if(s)this.index=new x({filehandle:new o.Tx(s)});else{if(!n)throw new TypeError("must provide one of tbiFilehandle, tbiPath, csiFilehandle, csiPath, tbiUrl, csiUrl");this.index=new x({filehandle:new o.Tx(`${n}.tbi`)})}this.renameRefSeq=f,this.chunkCache=new r.A({cache:new(a())({maxSize:Math.floor(u/65536)}),fill:(e,t)=>this.readChunk(e,{signal:t})})}async getLines(e,t,n,r){var i,a;let s,o,l={};"function"==typeof r?o=r:(l=r,o=r.lineCallback,s=r.signal);const c=await this.index.getMetadata(l);h(s);const d=null!=t?t:0,f=null!=n?n:c.maxRefLength;if(!(d<=f))throw new TypeError("invalid start and end coordinates. start must be less than or equal to end");if(d===f)return;const u=await this.index.blocksForRange(e,d,f,l);h(s);for(const t of u){const{buffer:n,cpositions:r,dpositions:l}=await this.chunkCache.get(t.toString(),t,s);h(s);let u=0,m=0;const b=null!==(i=null==y?void 0:y.decode(n))&&void 0!==i?i:n.toString(),p=n.length<5e8&&I(b);for(;u<b.length;){let i,s;if(p){if(s=b.indexOf("\n",u),-1===s)break;i=b.slice(u,s)}else{if(s=n.indexOf("\n",u),-1===s)break;const e=n.slice(u,s);i=null!==(a=null==y?void 0:y.decode(e))&&void 0!==a?a:e.toString()}if(l){for(;u+t.minv.dataPosition>=l[m++];);m--}const{startCoordinate:h,overlaps:w}=this.checkLine(c,e,d,f,i);if(w)o(i,256*r[m]+(u-l[m])+t.minv.dataPosition+1);else if(void 0!==h&&h>=f)return;u=s+1}}}async getMetadata(e={}){return this.index.getMetadata(e)}async getHeaderBuffer(e={}){const{firstDataLine:t,metaChar:n,maxBlockSize:r}=await this.getMetadata(e);h(e.signal);const i=((null==t?void 0:t.blockPosition)||0)+r,a=await this._readRegion(0,i,e),s=await(0,l.$1)(a);if(n){let e=-1;const t="\n".charCodeAt(0),r=n.charCodeAt(0);for(let n=0;n<s.length&&(n!==e+1||s[n]===r);n+=1)s[n]===t&&(e=n);return s.subarray(0,e+1)}return s}async getHeader(e={}){return(await this.getHeaderBuffer(e)).toString("utf8")}async getReferenceSequenceNames(e={}){return(await this.getMetadata(e)).refIdToName}checkLine(e,t,n,r,i){const{columnNumbers:a,metaChar:s,coordinateType:o,format:l}=e;if(s&&i.startsWith(s))return{overlaps:!1};let{ref:c,start:d,end:h}=a;c||(c=0),d||(d=0),h||(h=0),"VCF"===l&&(h=8);const f=Math.max(c,d,h);let u=1,m=0,b="",p=-1/0;const w=i.length;for(let e=0;e<w+1;e++)if("\t"===i[e]||e===w){if(u===c){if(this.renameRefSeq(i.slice(m,e))!==t)return{overlaps:!1}}else if(u===d){if(p=parseInt(i.slice(m,e),10),"1-based-closed"===o&&(p-=1),p>=r)return{startCoordinate:p,overlaps:!1};if((0===h||h===d)&&p+1<=n)return{startCoordinate:p,overlaps:!1}}else if("VCF"===l&&4===u)b=i.slice(m,e);else if(u===h&&("VCF"===l?this._getVcfEnd(p,b,i.slice(m,e)):Number.parseInt(i.slice(m,e),10))<=n)return{overlaps:!1};if(m=e+1,u+=1,u>f)break}return{startCoordinate:p,overlaps:!0}}_getVcfEnd(e,t,n){let r=e+t.length;const i=n.includes("SVTYPE=TRA");if("."===n[0]||i){if(i)return e+1}else{let e=";";for(let t=0;t<n.length;t+=1){if(";"===e&&"END="===n.slice(t,t+4)){let e=n.indexOf(";",t);-1===e&&(e=n.length),r=parseInt(n.slice(t+4,e),10);break}e=n[t]}}return r}async lineCount(e,t={}){return this.index.lineCount(e,t)}async _readRegion(e,t,n={}){const r=s.hp.alloc(t),{bytesRead:i,buffer:a}=await this.filehandle.read(r,0,t,e,n);return a.subarray(0,i)}async readChunk(e,t={}){const n=await this._readRegion(e.minv.blockPosition,e.fetchedSize(),t);return(0,l.i2)(n,e)}}}}]);
//# sourceMappingURL=8120.9abafb5b.chunk.js.map