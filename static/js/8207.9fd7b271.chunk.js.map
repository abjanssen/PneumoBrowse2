{"version":3,"file":"static/js/8207.9fd7b271.chunk.js","mappings":"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","sources":["../../../plugins/wiggle/src/drawXY.ts","../../../plugins/wiggle/src/XYPlotRenderer/renderXYPlot.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\nimport { clamp } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\nimport {\n  checkStopToken2,\n  createStopTokenChecker,\n} from '@jbrowse/core/util/stopToken'\n\nimport { fillRectCtx, getOrigin, getScale } from './util.ts'\n\nimport type { ScaleOpts } from './util.ts'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature, Region } from '@jbrowse/core/util'\nimport type { Colord } from '@jbrowse/core/util/colord'\nimport type {\n  LastStopTokenCheck,\n  StopToken,\n} from '@jbrowse/core/util/stopToken'\n\nfunction lighten(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 + amount)\n  return colord({\n    ...hslColor,\n    l: clamp(l, 0, 100),\n  })\n}\n\nfunction darken(color: Colord, amount: number) {\n  const hslColor = color.toHsl()\n  const l = hslColor.l * (1 - amount)\n  return colord({\n    ...hslColor,\n    l: clamp(l, 0, 100),\n  })\n}\n\nconst fudgeFactor = 0.3\nconst clipHeight = 2\n\nexport function drawXY(\n  ctx: CanvasRenderingContext2D,\n  props: {\n    features: Map<string, Feature> | Feature[]\n    bpPerPx: number\n    regions: Region[]\n    scaleOpts: ScaleOpts\n    height: number\n    ticks: { values: number[] }\n    config: AnyConfigurationModel\n    displayCrossHatches: boolean\n    inverted: boolean\n    offset?: number\n    lastCheck?: LastStopTokenCheck\n    stopToken?: StopToken\n    colorCallback: (f: Feature, score: number) => string\n  },\n) {\n  const {\n    features,\n    bpPerPx,\n    regions,\n    scaleOpts,\n    height: unadjustedHeight,\n    config,\n    ticks,\n    displayCrossHatches,\n    offset = 0,\n    colorCallback,\n    inverted,\n    stopToken,\n    lastCheck = createStopTokenChecker(stopToken),\n  } = props\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n\n  // Extract region values once to avoid repeated property access in hot loop\n  const regionStart = region.start\n  const regionEnd = region.end\n  const regionReversed = region.reversed\n\n  // the adjusted height takes into account YSCALEBAR_LABEL_OFFSET from the\n  // wiggle display, and makes the height of the actual drawn area add\n  // \"padding\" to the top and bottom of the display\n  const height = unadjustedHeight - offset * 2\n\n  const filled = readConfObject(config, 'filled')\n  const clipColor = readConfObject(config, 'clipColor')\n  const summaryScoreMode = readConfObject(config, 'summaryScoreMode')\n  const pivotValue = readConfObject(config, 'bicolorPivotValue')\n  const minSize = readConfObject(config, 'minSize')\n\n  const scale = getScale({ ...scaleOpts, range: [0, height], inverted })\n  const originY = getOrigin(scaleOpts.scaleType)\n  const domain = scale.domain()\n  const niceMin = domain[0]!\n  const niceMax = domain[1]!\n\n  // Precompute scale values for fast toY calculation\n  const isLog = scaleOpts.scaleType === 'log'\n  const log2 = Math.log(2)\n  const domainSpan = niceMax - niceMin\n  const linearRatio = domainSpan !== 0 ? height / domainSpan : 0\n  const logMin = isLog ? Math.log(niceMin) / log2 : 0\n  const logMax = isLog ? Math.log(niceMax) / log2 : 0\n  const logSpan = logMax - logMin\n  const logRatio = logSpan !== 0 ? height / logSpan : 0\n  const effectiveRange = inverted ? [height, 0] : [0, height]\n  const rangeFlipped = effectiveRange[0] === height\n\n  // Inlined toY - avoids d3-scale function call overhead\n  const toY = isLog\n    ? (n: number) => {\n        const logVal = Math.log(n) / log2\n        const scaled = (logVal - logMin) * logRatio\n        const result = rangeFlipped ? scaled : height - scaled\n        return clamp(result, 0, height) + offset\n      }\n    : (n: number) => {\n        const scaled = (n - niceMin) * linearRatio\n        const result = rangeFlipped ? scaled : height - scaled\n        return clamp(result, 0, height) + offset\n      }\n\n  const toOrigin = (n: number) => toY(originY) - toY(n)\n  const getHeight = (n: number) => (filled ? toOrigin(n) : Math.max(minSize, 1))\n\n  // Precompute for inline px calculation (avoids featureSpanPx function call overhead)\n  const inverseBpPerPx = 1 / bpPerPx\n\n  let hasClipping = false\n\n  let prevLeftPx = Number.NEGATIVE_INFINITY\n  const reducedFeatures = []\n  const crossingOrigin = niceMin < pivotValue && niceMax > pivotValue\n\n  // we handle whiskers separately to render max row, min row, and avg in three\n  // passes. this reduces subpixel rendering issues. note: for stylistic\n  // reasons, clipping indicator is only drawn for score, not min/max score\n  if (summaryScoreMode === 'whiskers') {\n    let lastCol: string | undefined\n    let lastMix: string | undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      if (feature.get('summary')) {\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const max = feature.get('maxScore')\n        const c = colorCallback(feature, max)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = lighten(colord(c), 0.4).toHex())\n        fillRectCtx(leftPx, toY(max), w, getHeight(max), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n    lastMix = undefined\n    lastCol = undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const score = feature.get('score')\n      const max = feature.get('maxScore')\n      const min = feature.get('minScore')\n      const summary = feature.get('summary')\n      const c = colorCallback(feature, score)\n      const effectiveC =\n        crossingOrigin && summary\n          ? c === lastCol\n            ? lastMix\n            : (lastMix = colord(colorCallback(feature, max))\n                .mix(colord(colorCallback(feature, min)))\n                .toString())\n          : c\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n      if (\n        Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n        rightPx - leftPx > 1\n      ) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, effectiveC)\n      lastCol = c\n    }\n    lastMix = undefined\n    lastCol = undefined\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n\n      if (feature.get('summary')) {\n        const min = feature.get('minScore')\n        const c = colorCallback(feature, min)\n        const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n        const effectiveC = crossingOrigin\n          ? c\n          : c === lastCol\n            ? lastMix\n            : (lastMix = darken(colord(c), 0.4).toHex())\n\n        fillRectCtx(leftPx, toY(min), w, getHeight(min), ctx, effectiveC)\n        lastCol = c\n      }\n    }\n  } else {\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n\n      // create reduced features, avoiding multiple features per px\n      if (\n        Math.floor(leftPx) !== Math.floor(prevLeftPx) ||\n        rightPx - leftPx > 1\n      ) {\n        reducedFeatures.push(feature)\n        prevLeftPx = leftPx\n      }\n\n      const score = feature.get('score')\n      const c = colorCallback(feature, score)\n\n      hasClipping = hasClipping || score < niceMin || score > niceMax\n      const w = Math.max(rightPx - leftPx + fudgeFactor, minSize)\n\n      if (summaryScoreMode === 'max') {\n        const s = feature.get('summary') ? feature.get('maxScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else if (summaryScoreMode === 'min') {\n        const s = feature.get('summary') ? feature.get('minScore') : score\n        fillRectCtx(leftPx, toY(s), w, getHeight(s), ctx, c)\n      } else {\n        fillRectCtx(leftPx, toY(score), w, getHeight(score), ctx, c)\n      }\n    }\n  }\n\n  // second pass: draw clipping\n  // avoid persisting the red fillstyle with save/restore\n  ctx.save()\n  if (hasClipping) {\n    ctx.fillStyle = clipColor\n    for (const feature of features.values()) {\n      checkStopToken2(lastCheck)\n      const fStart = feature.get('start')\n      const fEnd = feature.get('end')\n      const leftPx = regionReversed\n        ? (regionEnd - fEnd) * inverseBpPerPx\n        : (fStart - regionStart) * inverseBpPerPx\n      const rightPx = regionReversed\n        ? (regionEnd - fStart) * inverseBpPerPx\n        : (fEnd - regionStart) * inverseBpPerPx\n      const w = rightPx - leftPx + fudgeFactor\n      const score = feature.get('score')\n      if (score > niceMax) {\n        fillRectCtx(leftPx, offset, w, clipHeight, ctx)\n      } else if (score < niceMin && scaleOpts.scaleType !== 'log') {\n        fillRectCtx(leftPx, unadjustedHeight, w, clipHeight, ctx)\n      }\n    }\n  }\n  ctx.restore()\n\n  if (displayCrossHatches) {\n    ctx.lineWidth = 1\n    ctx.strokeStyle = 'rgba(200,200,200,0.5)'\n    for (const tick of ticks.values) {\n      ctx.beginPath()\n      ctx.moveTo(0, Math.round(toY(tick)))\n      ctx.lineTo(width, Math.round(toY(tick)))\n      ctx.stroke()\n    }\n  }\n\n  return {\n    reducedFeatures,\n  }\n}\n","import { renderToAbstractCanvas, updateStatus } from '@jbrowse/core/util'\nimport { rpcResult } from '@jbrowse/core/util/librpc'\nimport { collectTransferables } from '@jbrowse/core/util/offscreenCanvasPonyfill'\n\nimport { drawXY } from '../drawXY.ts'\nimport { getColorCallback, serializeWiggleFeature } from '../util.ts'\n\nimport type { RenderArgsDeserialized } from '../types.ts'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport async function renderXYPlot(\n  renderProps: RenderArgsDeserialized,\n  features: Feature[],\n) {\n  const {\n    config,\n    height,\n    regions,\n    bpPerPx,\n    statusCallback = () => {},\n  } = renderProps\n\n  const region = regions[0]!\n  const width = (region.end - region.start) / bpPerPx\n  const colorCallback = getColorCallback(config)\n\n  const { reducedFeatures, ...rest } = await updateStatus(\n    'Rendering plot',\n    statusCallback,\n    () =>\n      renderToAbstractCanvas(width, height, renderProps, ctx =>\n        drawXY(ctx, {\n          ...renderProps,\n          colorCallback,\n          features,\n        }),\n      ),\n  )\n\n  const serialized = {\n    ...rest,\n    features: reducedFeatures.map(serializeWiggleFeature),\n    height,\n    width,\n  }\n\n  return rpcResult(serialized, collectTransferables(rest))\n}\n"],"names":["lighten","color","amount","hslColor","toHsl","l","colord","clamp","darken","fudgeFactor","drawXY","ctx","props","features","bpPerPx","regions","scaleOpts","height","unadjustedHeight","config","ticks","displayCrossHatches","offset","colorCallback","inverted","stopToken","lastCheck","createStopTokenChecker","region","width","end","start","regionStart","regionEnd","regionReversed","reversed","filled","readConfObject","clipColor","summaryScoreMode","pivotValue","minSize","scale","getScale","range","originY","getOrigin","scaleType","domain","niceMin","niceMax","isLog","log2","Math","log","domainSpan","linearRatio","logMin","logSpan","logRatio","rangeFlipped","toY","n","scaled","result","getHeight","toOrigin","max","inverseBpPerPx","hasClipping","prevLeftPx","Number","NEGATIVE_INFINITY","reducedFeatures","crossingOrigin","lastCol","lastMix","feature","values","checkStopToken2","fStart","get","fEnd","leftPx","rightPx","w","c","effectiveC","toHex","fillRectCtx","undefined","score","min","summary","mix","toString","floor","push","s","save","fillStyle","restore","lineWidth","strokeStyle","tick","beginPath","moveTo","round","lineTo","stroke","async","renderXYPlot","renderProps","statusCallback","getColorCallback","rest","updateStatus","renderToAbstractCanvas","serialized","map","serializeWiggleFeature","rpcResult","collectTransferables"],"ignoreList":[],"sourceRoot":""}