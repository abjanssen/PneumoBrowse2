{"version":3,"file":"static/js/8343.9f3b631d.chunk.js","mappings":"uOAce,MAAMA,UAAmBC,EAAAA,uBACtCC,0BAA0D,CAAC,EAQ3D,oBAA6B,CAAC,cAAe,eAE7C,eAAaC,GACX,MAAM,OAAEC,SAAiBC,KAAKC,QAC9B,OAAOF,CACT,CAEA,iBAAMG,GACJ,MAAM,OAAEC,SAAiBH,KAAKC,QAC9B,OAAOE,EAAOD,aAChB,CAEA,YAAaE,CAAOC,GAClB,MAAM,eAAEC,EAAiBA,QAAaD,GAAQ,CAAC,EACzCE,GAAMC,EAAAA,EAAAA,cAAaR,KAAKS,QAAQ,eAAgBT,KAAKU,eACrDC,QAAeC,EAAAA,EAAAA,oBAAmBL,EAAKF,GACvCQ,EAAc,GACdC,EAAa,CAAC,EACpB,IAAIC,EAAa,EAEjB,MAAMC,EAAU,IAAIC,YAAY,QAChC,IAAIC,EAAI,EACR,KAAOH,EAAaJ,EAAOQ,QAAQ,CACjC,MAAMC,EAAIT,EAAOU,QAAQ,GAAIN,GAEvBO,GACG,IAAPF,EAAWT,EAAOY,SAASR,GAAcJ,EAAOY,SAASR,EAAYK,GACjEI,EAAOR,EAAQS,OAAOH,GAAGI,OAC/B,GAAIF,EACF,GAAIA,EAAKG,WAAW,KAClBd,EAAYe,KAAKJ,OACZ,CACL,MAAMK,EAAML,EAAKH,QAAQ,MACnBS,EAAUN,EAAKO,MAAM,EAAGF,GACzBf,EAAWgB,KACdhB,EAAWgB,GAAW,IAExBhB,EAAWgB,GAASF,KAAKJ,EAC3B,CAEEN,IAAM,KAAW,GACnBZ,EACE,WAAW0B,KAAKC,MAAMlB,EAAa,KAAWmB,eAAe,YAAYF,KAAKC,MAAMtB,EAAOQ,OAAS,KAAWe,eAAe,eAIlInB,EAAaK,EAAI,CACnB,CAEA,MAAMrB,EAASc,EAAYsB,KAAK,MAC1BhC,EAAS,IAAIiC,EAAAA,EAAU,CAAErC,WAEzBsC,EAAkBC,OAAOC,YAC7BD,OAAOE,QAAQ1B,GAAY2B,KAAI,EAAEX,EAASY,KAAW,CACnDZ,EACCa,IACC,IAAK3C,KAAKH,0BAA0BiC,GAAU,CAC5Ca,IAAK,oBACL,IAAIC,EAAM,EACV,MAAMC,EAAe,IAAIC,EAAAA,GACzB,IAAK,MAAMtB,KAAQkB,EAAO,CACxB,MAAMK,EAAI,IAAIC,EAAAA,EAAW,CACvBC,QAAS9C,EAAO+C,UAAU1B,GAC1BrB,SACAgD,GAAI,GAAGnD,KAAKmD,MAAMrB,KAAWc,QAE/BC,EAAaO,OAAO,CAACL,EAAEM,IAAI,SAAUN,EAAEM,IAAI,QAASN,EACtD,CACA/C,KAAKH,0BAA0BiC,GAAWe,CAC5C,CACA,OAAO7C,KAAKH,0BAA0BiC,EAAQ,MAKpD,MAAO,CACL/B,SACAI,SACAkC,kBAEJ,CAEA,WAAapC,GAOX,OANKD,KAAKsD,cACRtD,KAAKsD,YAActD,KAAKI,SAASmD,OAAOC,IAEtC,MADAxD,KAAKsD,iBAAcG,EACbD,CAAC,KAGJxD,KAAKsD,WACd,CAEA,iBAAaI,CAAYC,EAAiB,CAAC,GACzC,MAAM,gBAAEtB,SAA0BrC,KAAKC,QACvC,OAAOqC,OAAOsB,KAAKvB,EACrB,CAEOwB,WAAAA,CAAYC,EAAgBzD,EAAoB,CAAC,GACtD,OAAO0D,EAAAA,EAAAA,mBAA0BC,UAC/B,IACE,MAAM,MAAEC,EAAK,IAAEC,EAAG,QAAEpC,GAAYgC,GAC1B,gBAAEzB,SAA0BrC,KAAKC,QACvCoC,EAAgBP,KAAWzB,EAAKC,gBAC7B6D,OAAO,CAACF,EAAOC,IACfE,SAAQrB,IACPsB,EAASC,KAAKvB,EAAE,IAEpBsB,EAASE,UACX,CAAE,MAAOf,GACPa,EAASG,MAAMhB,EACjB,IACCnD,EAAKoE,UACV,CAEA,gBAAMC,GACJ,MAAMC,EAAO3E,KAAKS,QAAQ,sBAC1B,GAAiB,KAAbkE,EAAKC,KAA2B,yBAAbD,EAAKC,IAAgC,CAC1D,MAAM,OAAEzE,SAAiBH,KAAKC,QAC9B,OAAOE,EAAO0E,QAAQpC,KAAIqC,IAAQ,CAChCA,UAEJ,CAAO,CACL,MACMpC,SADYlC,EAAAA,EAAAA,cAAamE,GAAMI,SAAS,SAC5BC,MAAM,cAClBjF,EAAS2C,EAAM,GAAIsC,MAAM,OACzB,OAAE7E,SAAiBH,KAAKC,QACxBgF,EAAI,IAAIC,IAAI/E,EAAO0E,SACzB,OAAOnC,EACJX,MAAM,GACNU,KAAIjB,IACH,MAAM2D,EAAO3D,EAAKwD,MAAM,MACxB,MAAO,CACLF,KAAMK,EAAK,MACR7C,OAAOC,YAER4C,EAAKpD,MAAM,GAAGU,KAAI,CAAC2C,EAAGxC,IAAQ,CAAC7C,EAAO6C,EAAM,GAAKwC,MAEpD,IAEFC,QAAOtC,GAAKkC,EAAEK,IAAIvC,EAAE+B,OACzB,CACF,CACOS,aAAAA,GAAuB,E","sources":["../../../plugins/variants/src/VcfAdapter/VcfAdapter.ts"],"sourcesContent":["import IntervalTree from '@flatten-js/interval-tree'\nimport VcfParser from '@gmod/vcf'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\n\nimport VcfFeature from '../VcfFeature'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature, Region } from '@jbrowse/core/util'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class VcfAdapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  vcfFeatures?: Promise<{\n    header: string\n    parser: VcfParser\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  public async getHeader() {\n    const { header } = await this.setup()\n    return header\n  }\n\n  async getMetadata() {\n    const { parser } = await this.setup()\n    return parser.getMetadata()\n  }\n\n  public async setupP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const loc = openLocation(this.getConf('vcfLocation'), this.pluginManager)\n    const buffer = await fetchAndMaybeUnzip(loc, opts)\n    const headerLines = []\n    const featureMap = {} as Record<string, string[]>\n    let blockStart = 0\n\n    const decoder = new TextDecoder('utf8')\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf(10, blockStart)\n      // could be a non-newline ended file, so slice to end of file if n===-1\n      const b =\n        n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n)\n      const line = decoder.decode(b).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = []\n          }\n          featureMap[refName].push(line)\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${Math.floor(blockStart / 1_000_000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1_000_000).toLocaleString('en-US')} MB`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const header = headerLines.join('\\n')\n    const parser = new VcfParser({ header })\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing VCF data')\n            let idx = 0\n            const intervalTree = new IntervalTree()\n            for (const line of lines) {\n              const f = new VcfFeature({\n                variant: parser.parseLine(line),\n                parser,\n                id: `${this.id}-${refName}-${idx++}`,\n              })\n              intervalTree.insert([f.get('start'), f.get('end')], f)\n            }\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header,\n      parser,\n      intervalTreeMap,\n    }\n  }\n\n  public async setup() {\n    if (!this.vcfFeatures) {\n      this.vcfFeatures = this.setupP().catch((e: unknown) => {\n        this.vcfFeatures = undefined\n        throw e\n      })\n    }\n    return this.vcfFeatures\n  }\n\n  public async getRefNames(_: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.setup()\n    return Object.keys(intervalTreeMap)\n  }\n\n  public getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = region\n        const { intervalTreeMap } = await this.setup()\n        intervalTreeMap[refName]?.(opts.statusCallback)\n          .search([start, end])\n          .forEach(f => {\n            observer.next(f)\n          })\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.stopToken)\n  }\n\n  async getSources() {\n    const conf = this.getConf('samplesTsvLocation')\n    if (conf.uri === '' || conf.uri === '/path/to/samples.tsv') {\n      const { parser } = await this.setup()\n      return parser.samples.map(name => ({\n        name,\n      }))\n    } else {\n      const txt = await openLocation(conf).readFile('utf8')\n      const lines = txt.split(/\\n|\\r\\n|\\r/)\n      const header = lines[0]!.split('\\t')\n      const { parser } = await this.setup()\n      const s = new Set(parser.samples)\n      return lines\n        .slice(1)\n        .map(line => {\n          const cols = line.split('\\t')\n          return {\n            name: cols[0]!,\n            ...Object.fromEntries(\n              // force col 0 to be called name\n              cols.slice(1).map((c, idx) => [header[idx + 1]!, c] as const),\n            ),\n          }\n        })\n        .filter(f => s.has(f.name))\n    }\n  }\n  public freeResources(): void {}\n}\n"],"names":["VcfAdapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","getHeader","header","this","setup","getMetadata","parser","setupP","opts","statusCallback","loc","openLocation","getConf","pluginManager","buffer","fetchAndMaybeUnzip","headerLines","featureMap","blockStart","decoder","TextDecoder","i","length","n","indexOf","b","subarray","line","decode","trim","startsWith","push","ret","refName","slice","Math","floor","toLocaleString","join","VcfParser","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","idx","intervalTree","IntervalTree","f","VcfFeature","variant","parseLine","id","insert","get","vcfFeatures","catch","e","undefined","getRefNames","_","keys","getFeatures","region","ObservableCreate","async","start","end","search","forEach","observer","next","complete","error","stopToken","getSources","conf","uri","samples","name","readFile","split","s","Set","cols","c","filter","has","freeResources"],"sourceRoot":""}