{"version":3,"file":"static/js/9280.6e897b98.chunk.js","mappings":"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","sources":["../../../node_modules/@gmod/twobit/src/bigint-polyfill/pure.ts","../../../node_modules/@gmod/twobit/src/bigint-polyfill/polyfill.ts","../../../node_modules/@gmod/twobit/src/twoBitFile.ts","../../../plugins/sequence/src/TwoBitAdapter/TwoBitAdapter.ts"],"sourcesContent":["const BigInt32 = BigInt(32)\n\nexport function getBigInt64(\n  dataView: DataView,\n  byteOffset: number,\n  littleEndian: boolean | undefined,\n): bigint {\n  const littleEndianMask = Number(!!littleEndian)\n  const bigEndianMask = Number(!littleEndian)\n\n  return (\n    (BigInt(\n      dataView.getInt32(byteOffset, littleEndian) * bigEndianMask +\n        dataView.getInt32(byteOffset + 4, littleEndian) * littleEndianMask,\n    ) <<\n      BigInt32) |\n    BigInt(\n      dataView.getUint32(byteOffset, littleEndian) * littleEndianMask +\n        dataView.getUint32(byteOffset + 4, littleEndian) * bigEndianMask,\n    )\n  )\n}\n\nexport function getBigUint64(\n  dataView: DataView,\n  byteOffset: number,\n  littleEndian: boolean | undefined,\n): bigint {\n  const a = dataView.getUint32(byteOffset, littleEndian)\n  const b = dataView.getUint32(byteOffset + 4, littleEndian)\n\n  const littleEndianMask = Number(!!littleEndian)\n  const bigEndianMask = Number(!littleEndian)\n\n  // This branch-less optimization is 77x faster than normal ternary operator.\n  // and only 3% slower than native implementation\n  // https://jsbench.me/p8kyhg1eqv/1\n  return (\n    (BigInt(a * bigEndianMask + b * littleEndianMask) << BigInt32) |\n    BigInt(a * littleEndianMask + b * bigEndianMask)\n  )\n}\n","import { getBigInt64, getBigUint64 } from './pure'\n\nif (!('getBigInt64' in DataView)) {\n  DataView.prototype.getBigInt64 = function (byteOffset, littleEndian) {\n    return getBigInt64(this, byteOffset, littleEndian)\n  }\n}\n\nif (!('getBigUint64' in DataView)) {\n  DataView.prototype.getBigUint64 = function (byteOffset, littleEndian) {\n    return getBigUint64(this, byteOffset, littleEndian)\n  }\n}\n","import { LocalFile, GenericFilehandle } from 'generic-filehandle'\nimport { Buffer } from 'buffer'\n\nconst TWOBIT_MAGIC = 0x1a412743\n\nfunction tinyMemoize(_class: any, methodName: string) {\n  const method = _class.prototype[methodName]\n  const memoAttributeName = `_memo_${methodName}`\n  _class.prototype[methodName] = function _tinyMemoized() {\n    if (!(memoAttributeName in this)) {\n      this[memoAttributeName] = method.call(this)\n    }\n    return this[memoAttributeName]\n  }\n}\n\nconst twoBit = ['T', 'C', 'A', 'G']\n// byteTo4Bases is an array of byteValue -> 'ACTG'\nconst byteTo4Bases = [] as string[]\nfor (let index = 0; index < 256; index++) {\n  byteTo4Bases.push(\n    twoBit[(index >> 6) & 3] +\n      twoBit[(index >> 4) & 3] +\n      twoBit[(index >> 2) & 3] +\n      twoBit[index & 3],\n  )\n}\n\nconst maskedByteTo4Bases = byteTo4Bases.map(bases => bases.toLowerCase())\n\nexport default class TwoBitFile {\n  private filehandle: GenericFilehandle\n  private version?: number\n\n  /**\n   * @param {object} args\n   * @param {string} [args.path] filesystem path for the .2bit file to open\n   * @param {Filehandle} [args.filehandle] node fs.promises-like filehandle for the .2bit file.\n   *  Only needs to support `filehandle.read(buffer, offset, length, position)`\n   */\n  constructor({\n    filehandle,\n    path,\n  }: {\n    filehandle?: GenericFilehandle\n    path?: string\n  }) {\n    if (filehandle) {\n      this.filehandle = filehandle\n    } else if (path) {\n      this.filehandle = new LocalFile(path)\n    } else {\n      throw new Error('must supply path or filehandle')\n    }\n  }\n\n  async _detectEndianness() {\n    const returnValue = await this.filehandle.read(\n      Buffer.allocUnsafe(8),\n      0,\n      8,\n      0,\n    )\n    const { buffer } = returnValue\n    if (buffer.readInt32LE(0) === TWOBIT_MAGIC) {\n      this.version = buffer.readInt32LE(4)\n    } else if (buffer.readInt32BE(0) === TWOBIT_MAGIC) {\n      throw new Error('big endian not supported')\n    } else {\n      throw new Error('not a 2bit file')\n    }\n  }\n\n  // memoize\n  /**\n   * @returns {Promise} for object with the file's header information, like\n   *  `{ magic: 0x1a412743, version: 0, sequenceCount: 42, reserved: 0 }`\n   */\n  async getHeader() {\n    await this._detectEndianness()\n\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(16),\n      0,\n      16,\n      0,\n    )\n\n    const b = buffer\n    const le = true\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    let offset = 0\n    const magic = dataView.getInt32(offset, le)\n    offset += 4\n    if (magic !== 0x1a412743) {\n      throw new Error(`Wrong magic number ${magic}`)\n    }\n    const version = dataView.getInt32(offset, le)\n    offset += 4\n    const sequenceCount = dataView.getUint32(offset, le)\n    offset += 4\n    const reserved = dataView.getUint32(offset, le)\n\n    return { version, magic, sequenceCount, reserved }\n  }\n\n  // memoize\n  /**\n   * @returns {Promise} for object with the file's index of offsets, like `{ seqName: fileOffset, ...}`\n   */\n  async getIndex() {\n    const header = await this.getHeader()\n    const maxIndexLength =\n      8 + header.sequenceCount * (1 + 256 + (this.version === 1 ? 8 : 4))\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(maxIndexLength),\n      0,\n      maxIndexLength,\n      8,\n    )\n\n    const le = true\n    const b = buffer\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n    let offset = 0\n    const sequenceCount = dataView.getUint32(offset, le)\n    offset += 4\n    // const reserved = dataView.getUint32(offset, le)\n    offset += 4\n    const indexData = []\n    for (let i = 0; i < sequenceCount; i++) {\n      const nameLength = dataView.getUint8(offset)\n      offset += 1\n      const name = buffer.subarray(offset, offset + nameLength).toString()\n      offset += nameLength\n      if (header.version === 1) {\n        const dataOffset = Number(dataView.getBigUint64(offset, le))\n        offset += 8\n        indexData.push({ offset: dataOffset, name })\n      } else {\n        const dataOffset = dataView.getUint32(offset, le)\n        offset += 4\n        indexData.push({ offset: dataOffset, name })\n      }\n    }\n\n    return Object.fromEntries(\n      indexData.map(({ name, offset }) => [name, offset]),\n    )\n  }\n\n  /**\n   * @returns {Promise} for an array of string sequence names that are found in the file\n   */\n  async getSequenceNames() {\n    const index = await this.getIndex()\n    return Object.keys(index)\n  }\n\n  /**\n   * @returns {Promise} for an object listing the lengths of all sequences like\n   * `{seqName: length, ...}`.\n   *\n   * note: this is a relatively slow operation especially if there are many\n   * refseqs in the file, if you can get this information from a different file\n   * e.g. a chrom.sizes file, it will be much faster\n   */\n  async getSequenceSizes() {\n    const index = await this.getIndex()\n    const seqNames = Object.keys(index)\n    const sizePromises = Object.values(index).map(offset =>\n      this._getSequenceSize(offset),\n    )\n    const sizes = await Promise.all(sizePromises)\n    const returnObject = {} as Record<string, number>\n    for (const [index_, seqName] of seqNames.entries()) {\n      returnObject[seqName] = sizes[index_]\n    }\n    return returnObject\n  }\n\n  /**\n   * @param {string} seqName name of the sequence\n   * @returns {Promise} for the sequence's length, or undefined if it is not in the file\n   */\n  async getSequenceSize(seqName: string) {\n    const index = await this.getIndex()\n    const offset = index[seqName]\n    if (!offset) {\n      return undefined\n    }\n    return this._getSequenceSize(offset)\n  }\n\n  async _getSequenceSize(offset: number) {\n    return this._record1(offset).then(f => f.dnaSize)\n  }\n\n  async _record1(offset2: number, len = 8) {\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(len),\n      0,\n      len,\n      offset2,\n    )\n    const b = buffer\n    const le = true\n    let offset = 0\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n\n    const dnaSize = dataView.getUint32(offset, le)\n    offset += 4\n    const nBlockCount = dataView.getUint32(offset, le)\n    offset += 4\n    return { dnaSize, nBlockCount }\n  }\n\n  async _record2(offset2: number, len: number) {\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(len),\n      0,\n      len,\n      offset2,\n    )\n    const b = buffer\n    const le = true\n    let offset = 0\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n\n    const nBlockCount = dataView.getUint32(offset, le)\n    offset += 4\n    const nBlockStarts = [] as number[]\n    for (let i = 0; i < nBlockCount; i++) {\n      const elt = dataView.getUint32(offset, le)\n      offset += 4\n      nBlockStarts.push(elt)\n    }\n    const nBlockSizes = [] as number[]\n    for (let i = 0; i < nBlockCount; i++) {\n      const elt = dataView.getUint32(offset, le)\n      offset += 4\n      nBlockSizes.push(elt)\n    }\n    const maskBlockCount = dataView.getUint32(offset, le)\n    return {\n      maskBlockCount,\n      nBlockSizes,\n      nBlockStarts,\n    }\n  }\n  async _record3(offset2: number, len: number) {\n    const { buffer } = await this.filehandle.read(\n      Buffer.allocUnsafe(len),\n      0,\n      len,\n      offset2,\n    )\n    const b = buffer\n    const le = true\n    let offset = 0\n    const dataView = new DataView(b.buffer, b.byteOffset, b.length)\n\n    const maskBlockCount = dataView.getUint32(offset, le)\n    offset += 4\n    const maskBlockStarts = [] as number[]\n    for (let i = 0; i < maskBlockCount; i++) {\n      const elt = dataView.getUint32(offset, le)\n      offset += 4\n      maskBlockStarts.push(elt)\n    }\n    const maskBlockSizes = [] as number[]\n    for (let i = 0; i < maskBlockCount; i++) {\n      const elt = dataView.getUint32(offset, le)\n      offset += 4\n      maskBlockSizes.push(elt)\n    }\n    const reserved = dataView.getInt32(offset, le)\n    return {\n      maskBlockCount,\n      maskBlockSizes,\n      maskBlockStarts,\n      reserved,\n    }\n  }\n\n  async _getSequenceRecord(offset: number) {\n    const rec1 = await this._record1(offset)\n    const rec2DataLen = rec1.nBlockCount * 8 + 8\n    const rec2 = await this._record2(offset + 4, rec2DataLen)\n    const rec3DataLen = rec2.maskBlockCount * 8 + 8\n    const rec3 = await this._record3(offset + 4 + rec2DataLen - 4, rec3DataLen)\n\n    const rec = {\n      dnaSize: rec1.dnaSize,\n      nBlocks: {\n        starts: rec2.nBlockStarts,\n        sizes: rec2.nBlockSizes,\n      },\n      maskBlocks: {\n        starts: rec3.maskBlockStarts,\n        sizes: rec3.maskBlockSizes,\n      },\n      dnaPosition: offset + 4 + rec2DataLen - 4 + rec3DataLen,\n    }\n    return rec\n  }\n\n  /**\n   * @param {string} seqName name of the sequence you want\n   * @param {number} [regionStart] optional 0-based half-open start of the sequence region to fetch.\n   * @param {number} [regionEnd] optional 0-based half-open end of the sequence region to fetch. defaults to end of the sequence\n   * @returns {Promise} for a string of sequence bases\n   */\n  async getSequence(\n    seqName: string,\n    regionStart = 0,\n    regionEnd = Number.POSITIVE_INFINITY,\n  ) {\n    const index = await this.getIndex()\n    const offset = index[seqName]\n    if (!offset) {\n      return undefined\n    }\n    // fetch the record for the seq\n    const record = await this._getSequenceRecord(offset)\n\n    if (regionStart < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    // end defaults to the end of the sequence\n    if (regionEnd === undefined || regionEnd > record.dnaSize) {\n      regionEnd = record.dnaSize\n    }\n\n    const nBlocks = this._getOverlappingBlocks(\n      regionStart,\n      regionEnd,\n      record.nBlocks.starts,\n      record.nBlocks.sizes,\n    )\n    const maskBlocks = this._getOverlappingBlocks(\n      regionStart,\n      regionEnd,\n      record.maskBlocks.starts,\n      record.maskBlocks.sizes,\n    )\n\n    const baseBytes = Buffer.allocUnsafe(\n      Math.ceil((regionEnd - regionStart) / 4) + 1,\n    )\n    const baseBytesOffset = Math.floor(regionStart / 4)\n    const { buffer } = await this.filehandle.read(\n      baseBytes,\n      0,\n      baseBytes.length,\n      record.dnaPosition + baseBytesOffset,\n    )\n\n    let sequenceBases = ''\n    for (\n      let genomicPosition = regionStart;\n      genomicPosition < regionEnd;\n      genomicPosition += 1\n    ) {\n      // check whether we are currently masked\n      while (maskBlocks.length > 0 && maskBlocks[0].end <= genomicPosition) {\n        maskBlocks.shift()\n      }\n      const baseIsMasked =\n        maskBlocks[0] &&\n        maskBlocks[0].start <= genomicPosition &&\n        maskBlocks[0].end > genomicPosition\n\n      // process the N block if we have one\n      if (\n        nBlocks[0] &&\n        genomicPosition >= nBlocks[0].start &&\n        genomicPosition < nBlocks[0].end\n      ) {\n        const currentNBlock = nBlocks.shift()\n        for (\n          ;\n          genomicPosition < currentNBlock.end && genomicPosition < regionEnd;\n          genomicPosition += 1\n        ) {\n          sequenceBases += baseIsMasked ? 'n' : 'N'\n        }\n        genomicPosition -= 1\n      } else {\n        const bytePosition = Math.floor(genomicPosition / 4) - baseBytesOffset\n        const subPosition = genomicPosition % 4\n        const byte = buffer[bytePosition]\n        sequenceBases += baseIsMasked\n          ? maskedByteTo4Bases[byte][subPosition]\n          : byteTo4Bases[byte][subPosition]\n      }\n    }\n\n    return sequenceBases\n  }\n\n  _getOverlappingBlocks(\n    regionStart: number,\n    regionEnd: number,\n    blockStarts: number[],\n    blockSizes: number[],\n  ) {\n    // find the start and end indexes of the blocks that match\n    let startIndex: number | undefined\n    let endIndex: number | undefined\n    for (const [index, blockStart] of blockStarts.entries()) {\n      const blockSize = blockSizes[index]\n      if (regionStart >= blockStart + blockSize || regionEnd <= blockStart) {\n        // block does not overlap the region\n        if (startIndex !== undefined) {\n          endIndex = index\n          break\n        }\n      } else if (startIndex === undefined) {\n        startIndex = index\n      } // block does overlap the region, record this if it is the first\n    }\n\n    if (startIndex === undefined) {\n      return []\n    }\n\n    // now format some block objects to return\n    if (endIndex === undefined) {\n      endIndex = blockStarts.length\n    }\n\n    const blocks = new Array(endIndex - startIndex)\n    for (\n      let blockNumber = startIndex;\n      blockNumber < endIndex;\n      blockNumber += 1\n    ) {\n      blocks[blockNumber - startIndex] = {\n        start: blockStarts[blockNumber],\n        end: blockStarts[blockNumber] + blockSizes[blockNumber],\n        size: blockSizes[blockNumber],\n      }\n    }\n    return blocks\n  }\n}\n\ntinyMemoize(TwoBitFile, 'getIndex')\ntinyMemoize(TwoBitFile, 'getHeader')\n","import { BaseSequenceAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { TwoBitFile } from '@gmod/twobit'\nimport { readConfObject } from '@jbrowse/core/configuration'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\n\nexport default class TwoBitAdapter extends BaseSequenceAdapter {\n  private twobit: TwoBitFile\n\n  // the chromSizesData can be used to speed up loading since TwoBit has to do\n  // many range requests at startup to perform the getRegions request\n  protected chromSizesData: Promise<Record<string, number> | undefined>\n\n  private async initChromSizes() {\n    const conf = readConfObject(this.config, 'chromSizesLocation')\n    // check against default and empty in case someone makes the field blank in\n    // config editor, may want better way to check \"optional config slots\" in\n    // future\n    if (conf.uri !== '/path/to/default.chrom.sizes' && conf.uri !== '') {\n      const file = openLocation(conf, this.pluginManager)\n      const data = await file.readFile('utf8')\n      return Object.fromEntries(\n        data\n          .split(/\\n|\\r\\n|\\r/)\n          .filter(line => !!line.trim())\n          .map(line => {\n            const [name, length] = line.split('\\t')\n            return [name!, +length!]\n          }),\n      )\n    }\n    return undefined\n  }\n\n  constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const pm = this.pluginManager\n    this.chromSizesData = this.initChromSizes()\n    this.twobit = new TwoBitFile({\n      filehandle: openLocation(this.getConf('twoBitLocation'), pm),\n    })\n  }\n\n  public async getRefNames() {\n    const chromSizesData = await this.chromSizesData\n    if (chromSizesData) {\n      return Object.keys(chromSizesData)\n    }\n    return this.twobit.getSequenceNames()\n  }\n\n  public async getRegions(): Promise<NoAssemblyRegion[]> {\n    const chromSizesData = await this.chromSizesData\n    if (chromSizesData) {\n      return Object.keys(chromSizesData).map(refName => ({\n        refName,\n        start: 0,\n        end: chromSizesData[refName]!,\n      }))\n    }\n    const refSizes = await this.twobit.getSequenceSizes()\n    return Object.keys(refSizes).map(refName => ({\n      refName,\n      start: 0,\n      end: refSizes[refName]!,\n    }))\n  }\n\n  /**\n   * Fetch features for a certain region\n   * @param param -\n   * @returns Observable of Feature objects in the region\n   */\n  public getFeatures({ refName, start, end }: NoAssemblyRegion) {\n    return ObservableCreate<Feature>(async observer => {\n      const size = await this.twobit.getSequenceSize(refName)\n      const regionEnd = size !== undefined ? Math.min(size, end) : end\n      const seq = await this.twobit.getSequence(refName, start, regionEnd)\n      if (seq) {\n        observer.next(\n          new SimpleFeature({\n            id: `${refName} ${start}-${regionEnd}`,\n            data: { refName, start, end: regionEnd, seq },\n          }),\n        )\n      }\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n  public freeResources(/* { region } */): void {}\n}\n"],"names":["BigInt32","BigInt","DataView","prototype","getBigInt64","byteOffset","littleEndian","dataView","littleEndianMask","Number","bigEndianMask","getInt32","getUint32","this","getBigUint64","a","b","TWOBIT_MAGIC","tinyMemoize","_class","methodName","method","memoAttributeName","call","twoBit","byteTo4Bases","index","push","maskedByteTo4Bases","map","bases","toLowerCase","TwoBitFile","constructor","filehandle","path","Error","_detectEndianness","returnValue","read","allocUnsafe","buffer","readInt32LE","readInt32BE","version","getHeader","le","length","offset","magic","sequenceCount","reserved","getIndex","header","maxIndexLength","indexData","i","nameLength","getUint8","name","subarray","toString","dataOffset","Object","fromEntries","getSequenceNames","keys","getSequenceSizes","seqNames","sizePromises","values","_getSequenceSize","sizes","Promise","all","returnObject","index_","seqName","entries","getSequenceSize","_record1","then","f","dnaSize","offset2","len","nBlockCount","_record2","nBlockStarts","elt","nBlockSizes","maskBlockCount","_record3","maskBlockStarts","maskBlockSizes","_getSequenceRecord","rec1","rec2DataLen","rec2","rec3DataLen","rec3","nBlocks","starts","maskBlocks","dnaPosition","getSequence","regionStart","regionEnd","POSITIVE_INFINITY","record","TypeError","undefined","_getOverlappingBlocks","baseBytes","Math","ceil","baseBytesOffset","floor","sequenceBases","genomicPosition","end","shift","baseIsMasked","start","currentNBlock","subPosition","byte","blockStarts","blockSizes","startIndex","endIndex","blockStart","blocks","Array","blockNumber","size","TwoBitAdapter","BaseSequenceAdapter","initChromSizes","conf","readConfObject","config","uri","file","openLocation","pluginManager","data","readFile","split","filter","line","trim","getSubAdapter","super","pm","chromSizesData","twobit","getConf","getRefNames","getRegions","refName","refSizes","getFeatures","ObservableCreate","async","min","seq","observer","next","SimpleFeature","id","complete","freeResources"],"sourceRoot":""}