{"version":3,"file":"static/js/7409.02d616d6.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3TabixAdapter/Gff3TabixAdapter.ts","../../../plugins/gff3/src/featureData.ts"],"sourcesContent":["import { TabixIndexedFile } from '@gmod/tabix'\nimport { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { updateStatus } from '@jbrowse/core/util'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { doesIntersect2 } from '@jbrowse/core/util/range'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport SimpleFeature from '@jbrowse/core/util/simpleFeature'\nimport { parseStringSync } from 'gff-nostream'\n\nimport { featureData } from '../featureData'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util/simpleFeature'\nimport type { Region } from '@jbrowse/core/util/types'\nimport type { Observer } from 'rxjs'\n\ninterface LineFeature {\n  start: number\n  end: number\n  lineHash: number\n  fields: string[]\n}\n\nexport default class Gff3TabixAdapter extends BaseFeatureDataAdapter {\n  private configured?: Promise<{\n    gff: TabixIndexedFile\n    dontRedispatch: string[]\n  }>\n\n  private async configurePre(_opts?: BaseOptions) {\n    const gffGzLocation = this.getConf('gffGzLocation')\n    const indexType = this.getConf(['index', 'indexType'])\n    const loc = this.getConf(['index', 'location'])\n    const dontRedispatch = this.getConf('dontRedispatch')\n    const gff = new TabixIndexedFile({\n      filehandle: openLocation(gffGzLocation, this.pluginManager),\n      csiFilehandle:\n        indexType === 'CSI' ? openLocation(loc, this.pluginManager) : undefined,\n      tbiFilehandle:\n        indexType !== 'CSI' ? openLocation(loc, this.pluginManager) : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n      renameRefSeqs: (n: string) => n,\n    })\n\n    return {\n      gff,\n      dontRedispatch,\n      header: await gff.getHeader(),\n    }\n  }\n\n  protected async configurePre2() {\n    if (!this.configured) {\n      this.configured = this.configurePre().catch((e: unknown) => {\n        this.configured = undefined\n        throw e\n      })\n    }\n    return this.configured\n  }\n\n  async configure(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    return updateStatus('Downloading index', statusCallback, () =>\n      this.configurePre2(),\n    )\n  }\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { gff } = await this.configure(opts)\n    return gff.getReferenceSequenceNames(opts)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { gff } = await this.configure(opts)\n    return gff.getHeader()\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { gff } = await this.configure(opts)\n      const metadata = await gff.getMetadata()\n      await this.getFeaturesHelper(query, opts, metadata, observer, true)\n    }, opts.stopToken)\n  }\n\n  private async getFeaturesHelper(\n    query: Region,\n    opts: BaseOptions,\n    metadata: { columnNumbers: { start: number; end: number } },\n    observer: Observer<Feature>,\n    allowRedispatch: boolean,\n    originalQuery = query,\n  ) {\n    const { statusCallback = () => {} } = opts\n    try {\n      const lines: LineFeature[] = []\n\n      const { dontRedispatch, gff } = await this.configure(opts)\n      await updateStatus('Downloading features', statusCallback, () =>\n        gff.getLines(\n          query.refName,\n          query.start,\n          query.end,\n          (line, fileOffset) => {\n            lines.push(this.parseLine(metadata.columnNumbers, line, fileOffset))\n          },\n        ),\n      )\n      if (allowRedispatch && lines.length) {\n        let minStart = Number.POSITIVE_INFINITY\n        let maxEnd = Number.NEGATIVE_INFINITY\n        for (const line of lines) {\n          const featureType = line.fields[2]!\n          // only expand redispatch range if feature is not a \"dontRedispatch\"\n          // type skips large regions like chromosome,region\n          if (!dontRedispatch.includes(featureType)) {\n            const start = line.start - 1 // gff is 1-based\n            if (start < minStart) {\n              minStart = start\n            }\n            if (line.end > maxEnd) {\n              maxEnd = line.end\n            }\n          }\n        }\n        if (maxEnd > query.end || minStart < query.start) {\n          // make a new feature callback to only return top-level features\n          // in the original query range\n          await this.getFeaturesHelper(\n            { ...query, start: minStart, end: maxEnd },\n            opts,\n            metadata,\n            observer,\n            false,\n            query,\n          )\n          return\n        }\n      }\n\n      const gff3 = lines\n        .map(lineRecord => {\n          if (lineRecord.fields[8] && lineRecord.fields[8] !== '.') {\n            if (!lineRecord.fields[8].includes('_lineHash')) {\n              lineRecord.fields[8] += `;_lineHash=${lineRecord.lineHash}`\n            }\n          } else {\n            lineRecord.fields[8] = `_lineHash=${lineRecord.lineHash}`\n          }\n          return lineRecord.fields.join('\\t')\n        })\n        .join('\\n')\n\n      for (const featureLocs of parseStringSync(gff3)) {\n        for (const featureLoc of featureLocs) {\n          const f = new SimpleFeature({\n            data: featureData(featureLoc),\n            id: `${this.id}-offset-${featureLoc.attributes?._lineHash?.[0]}`,\n          })\n          if (\n            doesIntersect2(\n              f.get('start'),\n              f.get('end'),\n              originalQuery.start,\n              originalQuery.end,\n            )\n          ) {\n            observer.next(f)\n          }\n        }\n      }\n      observer.complete()\n    } catch (e) {\n      observer.error(e)\n    }\n  }\n\n  private parseLine(\n    columnNumbers: { start: number; end: number },\n    line: string,\n    fileOffset: number,\n  ) {\n    const fields = line.split('\\t')\n\n    // note: index column numbers are 1-based\n    return {\n      start: +fields[columnNumbers.start - 1]!,\n      end: +fields[columnNumbers.end - 1]!,\n      lineHash: fileOffset,\n      fields,\n    }\n  }\n}\n","import type { GFF3FeatureLineWithRefs } from 'gff-nostream'\n\ninterface GFF3Feature {\n  start: number\n  end: number\n  strand?: number\n  type: string | null\n  source: string | null\n  refName: string\n  derived_features: unknown[] | null\n  phase?: number\n  score?: number\n  subfeatures: GFF3Feature[] | undefined\n  [key: string]: unknown\n}\n\nexport function featureData(data: GFF3FeatureLineWithRefs): GFF3Feature {\n  const {\n    end,\n    start,\n    child_features,\n    derived_features,\n    attributes,\n    type,\n    source,\n    phase,\n    seq_id,\n    score,\n    strand,\n  } = data\n\n  let strand2: number | undefined\n  if (strand === '+') {\n    strand2 = 1\n  } else if (strand === '-') {\n    strand2 = -1\n  } else if (strand === '.') {\n    strand2 = 0\n  }\n\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_id',\n    'score',\n    'type',\n    'source',\n    'phase',\n    'strand',\n  ])\n  const dataAttributes = attributes || {}\n  const resultAttributes = {} as Record<string, unknown>\n  for (const a of Object.keys(dataAttributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (dataAttributes[a] && a !== '_lineHash') {\n      let attr: string | string[] | undefined = dataAttributes[a]\n      if (Array.isArray(attr) && attr.length === 1) {\n        ;[attr] = attr\n      }\n      resultAttributes[b] = attr\n    }\n  }\n\n  return {\n    ...resultAttributes,\n    start: start! - 1,\n    end: end!,\n    strand: strand2,\n    type,\n    source,\n    refName: seq_id!,\n    derived_features,\n    phase: phase === null ? undefined : Number(phase),\n    score: score === null ? undefined : score,\n    subfeatures: child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    ),\n  }\n}\n"],"names":["Gff3TabixAdapter","BaseFeatureDataAdapter","configurePre","_opts","gffGzLocation","this","getConf","indexType","loc","dontRedispatch","gff","TabixIndexedFile","filehandle","openLocation","pluginManager","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","renameRefSeqs","n","header","getHeader","configurePre2","configured","catch","e","configure","opts","statusCallback","updateStatus","getRefNames","getReferenceSequenceNames","getFeatures","query","ObservableCreate","async","metadata","getMetadata","getFeaturesHelper","observer","stopToken","allowRedispatch","originalQuery","lines","getLines","refName","start","end","line","fileOffset","push","parseLine","columnNumbers","length","minStart","Number","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","featureType","fields","includes","gff3","map","lineRecord","lineHash","join","featureLocs","parseStringSync","featureLoc","f","SimpleFeature","data","featureData","id","attributes","_lineHash","doesIntersect2","get","next","complete","error","split","child_features","derived_features","type","source","phase","seq_id","score","strand","strand2","defaultFields","Set","dataAttributes","resultAttributes","a","Object","keys","b","toLowerCase","has","attr","Array","isArray","subfeatures","flatMap","childLocs","childLoc"],"sourceRoot":""}