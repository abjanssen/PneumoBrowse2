{"version":3,"file":"static/js/4993.6e36dfaf.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../node_modules/.pnpm/@jbrowse+mobx-state-tree@5.5.0_mobx@6.15.0/node_modules/@jbrowse/mobx-state-tree/dist/mobx-state-tree.module.js","webpack://@jbrowse/web/../../node_modules/.pnpm/mobx-react-lite@4.1.1_mobx@6.15.0_react-dom@19.2.4_react@19.2.4__react@19.2.4/node_modules/mobx-react-lite/src/observer.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@gmod+abortable-promise-cache@3.0.4/node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/Extension.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/FileCopy.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/GetApp.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/Launch.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/Publish.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/Redo.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/Settings.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/Share.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/SpaceDashboard.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/Storage.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+icons-material@7.3.8_@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2._eea1b8ae36d0998f6630ee1e4377c145/node_modules/@mui/icons-material/esm/Undo.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2.14_react@19.2.4__@emotion+_faf77c2f6537e1ec3a7af49b152bf606/node_modules/@mui/material/esm/AppBar/appBarClasses.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2.14_react@19.2.4__@emotion+_faf77c2f6537e1ec3a7af49b152bf606/node_modules/@mui/material/esm/AppBar/AppBar.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2.14_react@19.2.4__@emotion+_faf77c2f6537e1ec3a7af49b152bf606/node_modules/@mui/material/esm/CssBaseline/CssBaseline.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2.14_react@19.2.4__@emotion+_faf77c2f6537e1ec3a7af49b152bf606/node_modules/@mui/material/esm/Fab/Fab.js","webpack://@jbrowse/web/../../node_modules/.pnpm/@mui+material@7.3.8_@emotion+react@11.14.0_@types+react@19.2.14_react@19.2.4__@emotion+_faf77c2f6537e1ec3a7af49b152bf606/node_modules/@mui/material/esm/Fab/fabClasses.js","webpack://@jbrowse/web/../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/serializeError/index.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/client.ts","webpack://@jbrowse/web/../../node_modules/.pnpm/librpc-web-mod@2.1.1/node_modules/librpc-web-mod/src/server.ts"],"sourcesContent":["import { isComputedProp, isObservableProp, createAtom, action, computed, _allowStateChangesInsideComputed, reaction, runInAction, observable, values, entries, isObservableArray, _getGlobalState, isObservableObject, defineProperty as defineProperty$1, _interceptReads, intercept, observe, ObservableMap, _getAdministration, set, makeObservable, getAtom, when } from 'mobx';\n\nlet livelinessChecking = \"warn\";\n/**\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelinessChecking(mode) {\n    livelinessChecking = mode;\n}\n/**\n * Returns the current liveliness checking mode.\n *\n * @returns `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction getLivelinessChecking() {\n    return livelinessChecking;\n}\n/**\n * @deprecated use setLivelinessChecking instead\n * @hidden\n *\n * Defines what MST should do when running into reads / writes to objects that have died.\n * By default it will print a warning.\n * Use the `\"error\"` option to easy debugging to see where the error was thrown and when the offending read / write took place\n *\n * @param mode `\"warn\"`, `\"error\"` or `\"ignore\"`\n */\nfunction setLivelynessChecking(mode) {\n    setLivelinessChecking(mode);\n}\n\n/**\n * @hidden\n */\nvar Hook;\n(function (Hook) {\n    Hook[\"afterCreate\"] = \"afterCreate\";\n    Hook[\"afterAttach\"] = \"afterAttach\";\n    Hook[\"afterCreationFinalization\"] = \"afterCreationFinalization\";\n    Hook[\"beforeDetach\"] = \"beforeDetach\";\n    Hook[\"beforeDestroy\"] = \"beforeDestroy\";\n})(Hook || (Hook = {}));\n\n/**\n * Returns the _actual_ type of the given tree node. (Or throws)\n *\n * @param object\n * @returns\n */\nfunction getType(object) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).type;\n}\n/**\n * Returns the _declared_ type of the given sub property of an object, array or map.\n * In the case of arrays and maps the property name is optional and will be ignored.\n *\n * Example:\n * ```ts\n * const Box = types.model({ x: 0, y: 0 })\n * const box = Box.create()\n *\n * console.log(getChildType(box, \"x\").name) // 'number'\n * ```\n *\n * @param object\n * @param propertyName\n * @returns\n */\nfunction getChildType(object, propertyName) {\n    assertIsStateTreeNode(object, 1);\n    return getStateTreeNode(object).getChildType(propertyName);\n}\n/**\n * Registers a function that will be invoked for each mutation that is applied to the provided model instance, or to any of its children.\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details. onPatch events are emitted immediately and will not await the end of a transaction.\n * Patches can be used to deeply observe a model tree.\n *\n * @param target the model instance from which to receive patches\n * @param callback the callback that is invoked for each patch. The reversePatch is a patch that would actually undo the emitted patch\n * @returns function to remove the listener\n */\nfunction onPatch(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onPatch(callback);\n}\n/**\n * Registers a function that is invoked whenever a new snapshot for the given model instance is available.\n * The listener will only be fire at the end of the current MobX (trans)action.\n * See [snapshots](https://github.com/mobxjs/mobx-state-tree#snapshots) for more details.\n *\n * @param target\n * @param callback\n * @returns\n */\nfunction onSnapshot(target, callback) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(callback, 2);\n    return getStateTreeNode(target).onSnapshot(callback);\n}\n/**\n * Applies a JSON-patch to the given model instance or bails out if the patch couldn't be applied\n * See [patches](https://github.com/mobxjs/mobx-state-tree#patches) for more details.\n *\n * Can apply a single past, or an array of patches.\n *\n * @param target\n * @param patch\n * @returns\n */\nfunction applyPatch(target, patch) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(patch, p => typeof p === \"object\", \"object or array\", 2);\n    getStateTreeNode(target).applyPatches(asArray(patch));\n}\n/**\n * Small abstraction around `onPatch` and `applyPatch`, attaches a patch listener to a tree and records all the patches.\n * Returns a recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IPatchRecorder {\n *      // the recorded patches\n *      patches: IJsonPatch[]\n *      // the inverse of the recorded patches\n *      inversePatches: IJsonPatch[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording patches\n *      stop(): void\n *      // resume recording patches\n *      resume(): void\n *      // apply all the recorded patches on the given target (the original subject if omitted)\n *      replay(target?: IAnyStateTreeNode): void\n *      // reverse apply the recorded patches on the given target  (the original subject if omitted)\n *      // stops the recorder if not already stopped\n *      undo(): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain patches.\n *\n * @param subject\n * @param filter\n * @returns\n */\nfunction recordPatches(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    const data = {\n        patches: [],\n        inversePatches: []\n    };\n    // we will generate the immutable copy of patches on demand for public consumption\n    const publicData = {};\n    let disposer;\n    const recorder = {\n        get recording() {\n            return !!disposer;\n        },\n        get patches() {\n            if (!publicData.patches) {\n                publicData.patches = data.patches.slice();\n            }\n            return publicData.patches;\n        },\n        get reversedInversePatches() {\n            if (!publicData.reversedInversePatches) {\n                publicData.reversedInversePatches = data.inversePatches\n                    .slice()\n                    .reverse();\n            }\n            return publicData.reversedInversePatches;\n        },\n        get inversePatches() {\n            if (!publicData.inversePatches) {\n                publicData.inversePatches = data.inversePatches.slice();\n            }\n            return publicData.inversePatches;\n        },\n        stop() {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume() {\n            if (disposer) {\n                return;\n            }\n            disposer = onPatch(subject, (patch, inversePatch) => {\n                // skip patches that are asked to be filtered if there's a filter in place\n                if (filter && !filter(patch, inversePatch, getRunningActionContext())) {\n                    return;\n                }\n                data.patches.push(patch);\n                data.inversePatches.push(inversePatch);\n                // mark immutable public patches as dirty\n                publicData.patches = undefined;\n                publicData.inversePatches = undefined;\n                publicData.reversedInversePatches = undefined;\n            });\n        },\n        replay(target) {\n            applyPatch(target || subject, data.patches);\n        },\n        undo(target) {\n            applyPatch(target || subject, data.inversePatches.slice().reverse());\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * The inverse of `unprotect`.\n *\n * @param target\n */\nfunction protect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (!node.isRoot) {\n        throw fail(\"`protect` can only be invoked on root nodes\");\n    }\n    node.isProtectionEnabled = true;\n}\n/**\n * By default it is not allowed to directly modify a model. Models can only be modified through actions.\n * However, in some cases you don't care about the advantages (like replayability, traceability, etc) this yields.\n * For example because you are building a PoC or don't have any middleware attached to your tree.\n *\n * In that case you can disable this protection by calling `unprotect` on the root of your tree.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *     done: false\n * }).actions(self => ({\n *     toggle() {\n *         self.done = !self.done\n *     }\n * }))\n *\n * const todo = Todo.create()\n * todo.done = true // throws!\n * todo.toggle() // OK\n * unprotect(todo)\n * todo.done = false // OK\n * ```\n */\nfunction unprotect(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (!node.isRoot) {\n        throw fail(\"`unprotect` can only be invoked on root nodes\");\n    }\n    node.isProtectionEnabled = false;\n}\n/**\n * Returns true if the object is in protected mode, @see protect\n */\nfunction isProtected(target) {\n    return getStateTreeNode(target).isProtected;\n}\n/**\n * Applies a snapshot to a given model instances. Patch and snapshot listeners will be invoked as usual.\n *\n * @param target\n * @param snapshot\n * @returns\n */\nfunction applySnapshot(target, snapshot) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).applySnapshot(snapshot);\n}\n/**\n * Calculates a snapshot from the given model instance. The snapshot will always reflect the latest state but use\n * structural sharing where possible. Doesn't require MobX transactions to be completed.\n *\n * @param target\n * @param applyPostProcess If true (the default) then postProcessSnapshot gets applied.\n * @returns\n */\nfunction getSnapshot(target, applyPostProcess = true) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (applyPostProcess) {\n        return node.snapshot;\n    }\n    return freeze(node.type.getSnapshot(node, false));\n}\n/**\n * Given a model instance, returns `true` if the object has a parent, that is, is part of another object, map or array.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction hasParent(target, depth = 1) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--depth === 0) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the immediate parent of this object, or throws.\n *\n * Note that the immediate parent can be either an object, map or array, and\n * doesn't necessarily refer to the parent model.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @param depth How far should we look upward? 1 by default.\n * @returns\n */\nfunction getParent(target, depth = 1) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsNumber(depth, 2, 0);\n    let d = depth;\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (--d === 0) {\n            return parent.storedValue;\n        }\n        parent = parent.parent;\n    }\n    throw fail(`Failed to find the parent of ${getStateTreeNode(target)} at depth ${depth}`);\n}\n/**\n * Given a model instance, returns `true` if the object has a parent of given type, that is, is part of another object, map or array\n *\n * @param target\n * @param type\n * @returns\n */\nfunction hasParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue)) {\n            return true;\n        }\n        parent = parent.parent;\n    }\n    return false;\n}\n/**\n * Returns the target's parent of a given type, or throws.\n *\n * @param target\n * @param type\n * @returns\n */\nfunction getParentOfType(target, type) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsType(type, 2);\n    let parent = getStateTreeNode(target).parent;\n    while (parent) {\n        if (type.is(parent.storedValue)) {\n            return parent.storedValue;\n        }\n        parent = parent.parent;\n    }\n    throw fail(`Failed to find the parent of ${getStateTreeNode(target)} of a given type`);\n}\n/**\n * Given an object in a model tree, returns the root object of that tree.\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired.\n *\n * @param target\n * @returns\n */\nfunction getRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).root.storedValue;\n}\n/**\n * Returns the path of the given object in the model tree\n *\n * @param target\n * @returns\n */\nfunction getPath(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).path;\n}\n/**\n * Returns the path of the given object as unescaped string array.\n *\n * @param target\n * @returns\n */\nfunction getPathParts(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return splitJsonPath(getStateTreeNode(target).path);\n}\n/**\n * Returns true if the given object is the root of a model tree.\n *\n * @param target\n * @returns\n */\nfunction isRoot(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).isRoot;\n}\n/**\n * Resolves a path relatively to a given object.\n * Returns undefined if no value can be found.\n *\n * @param target\n * @param path escaped json path\n * @returns\n */\nfunction resolvePath(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    const node = resolveNodeByPath(getStateTreeNode(target), path);\n    return node ? node.value : undefined;\n}\n/**\n * Resolves a model instance given a root target, the type and the identifier you are searching for.\n * Returns undefined if no value can be found.\n *\n * @param type\n * @param target\n * @param identifier\n * @returns\n */\nfunction resolveIdentifier(type, target, identifier) {\n    // check all arguments\n    assertIsType(type, 1);\n    assertIsStateTreeNode(target, 2);\n    assertIsValidIdentifier(identifier, 3);\n    const node = getStateTreeNode(target).root.identifierCache.resolve(type, normalizeIdentifier(identifier));\n    return node?.value;\n}\n/**\n * Returns the identifier of the target node.\n * This is the *string normalized* identifier, which might not match the type of the identifier attribute\n *\n * @param target\n * @returns\n */\nfunction getIdentifier(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).identifier;\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns such reference if the check passes,\n * else it returns undefined.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction tryReference(getter, checkIfAlive = true) {\n    try {\n        const node = getter();\n        if (node === undefined || node === null) {\n            return undefined;\n        }\n        else if (isStateTreeNode(node)) {\n            if (!checkIfAlive) {\n                return node;\n            }\n            else {\n                return isAlive(node) ? node : undefined;\n            }\n        }\n        else {\n            throw fail(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return undefined;\n        }\n        throw e;\n    }\n}\n/**\n * Tests if a reference is valid (pointing to an existing node and optionally if alive) and returns if the check passes or not.\n *\n * @param getter Function to access the reference.\n * @param checkIfAlive true to also make sure the referenced node is alive (default), false to skip this check.\n * @returns\n */\nfunction isValidReference(getter, checkIfAlive = true) {\n    try {\n        const node = getter();\n        if (node === undefined || node === null) {\n            return false;\n        }\n        else if (isStateTreeNode(node)) {\n            return checkIfAlive ? isAlive(node) : true;\n        }\n        else {\n            throw fail(\"The reference to be checked is not one of node, null or undefined\");\n        }\n    }\n    catch (e) {\n        if (e instanceof InvalidReferenceError) {\n            return false;\n        }\n        throw e;\n    }\n}\n/**\n * Try to resolve a given path relative to a given node.\n *\n * @param target\n * @param path\n * @returns\n */\nfunction tryResolve(target, path) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsString(path, 2);\n    const node = resolveNodeByPath(getStateTreeNode(target), path, false);\n    if (node === undefined) {\n        return undefined;\n    }\n    try {\n        return node.value;\n    }\n    catch (e) {\n        // For what ever reason not resolvable (e.g. totally not existing path, or value that cannot be fetched)\n        // see test / issue: 'try resolve doesn't work #686'\n        return undefined;\n    }\n}\n/**\n * Given two state tree nodes that are part of the same tree,\n * returns the shortest jsonpath needed to navigate from the one to the other\n *\n * @param base\n * @param target\n * @returns\n */\nfunction getRelativePath(base, target) {\n    // check all arguments\n    assertIsStateTreeNode(base, 1);\n    assertIsStateTreeNode(target, 2);\n    return getRelativePathBetweenNodes(getStateTreeNode(base), getStateTreeNode(target));\n}\n/**\n * Returns a deep copy of the given state tree node as new tree.\n * Shorthand for `snapshot(x) = getType(x).create(getSnapshot(x))`\n *\n * _Tip: clone will create a literal copy, including the same identifiers. To modify identifiers etc. during cloning, don't use clone but take a snapshot of the tree, modify it, and create new instance_\n *\n * @param source\n * @param keepEnvironment indicates whether the clone should inherit the same environment (`true`, the default), or not have an environment (`false`). If an object is passed in as second argument, that will act as the environment for the cloned tree.\n * @returns\n */\nfunction clone(source, keepEnvironment = true) {\n    // check all arguments\n    assertIsStateTreeNode(source, 1);\n    const node = getStateTreeNode(source);\n    return node.type.create(node.snapshot, keepEnvironment === true\n        ? node.root.environment\n        : keepEnvironment === false\n            ? undefined\n            : keepEnvironment); // it's an object or something else\n}\n/**\n * Removes a model element from the state tree, and let it live on as a new state tree\n */\nfunction detach(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    getStateTreeNode(target).detach();\n    return target;\n}\n/**\n * Removes a model element from the state tree, and mark it as end-of-life; the element should not be used anymore\n */\nfunction destroy(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    if (node.isRoot) {\n        node.die();\n    }\n    else {\n        node.parent.removeChild(node.subpath);\n    }\n}\n/**\n * Returns true if the given state tree node is not killed yet.\n * This means that the node is still a part of a tree, and that `destroy`\n * has not been called. If a node is not alive anymore, the only thing one can do with it\n * is requesting it's last path and snapshot\n *\n * @param target\n * @returns\n */\nfunction isAlive(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).observableIsAlive;\n}\n/**\n * Use this utility to register a function that should be called whenever the\n * targeted state tree node is destroyed. This is a useful alternative to managing\n * cleanup methods yourself using the `beforeDestroy` hook.\n *\n * This methods returns the same disposer that was passed as argument.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string\n * }).actions(self => ({\n *   afterCreate() {\n *     const autoSaveDisposer = reaction(\n *       () => getSnapshot(self),\n *       snapshot => sendSnapshotToServerSomehow(snapshot)\n *     )\n *     // stop sending updates to server if this\n *     // instance is destroyed\n *     addDisposer(self, autoSaveDisposer)\n *   }\n * }))\n * ```\n *\n * @param target\n * @param disposer\n * @returns The same disposer that was passed as argument\n */\nfunction addDisposer(target, disposer) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(disposer, 2);\n    const node = getStateTreeNode(target);\n    node.addDisposer(disposer);\n    return disposer;\n}\n/**\n * Returns the environment of the current state tree. For more info on environments,\n * see [Dependency injection](https://github.com/mobxjs/mobx-state-tree#dependency-injection)\n *\n * Please note that in child nodes access to the root is only possible\n * once the `afterAttach` hook has fired\n *\n * Returns an empty environment if the tree wasn't initialized with an environment\n *\n * @param target\n * @returns\n */\nfunction getEnv(target) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    const node = getStateTreeNode(target);\n    const env = node.root.environment;\n    if (!env) {\n        return EMPTY_OBJECT;\n    }\n    return env;\n}\n/**\n * Performs a depth first walk through a tree.\n */\nfunction walk(target, processor) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertIsFunction(processor, 2);\n    const node = getStateTreeNode(target);\n    // tslint:disable-next-line:no_unused-variable\n    node.getChildren().forEach(child => {\n        if (isStateTreeNode(child.storedValue)) {\n            walk(child.storedValue, processor);\n        }\n    });\n    processor(node.storedValue);\n}\n/**\n * Returns a reflection of the model type properties and name for either a model type or model node.\n *\n * @param typeOrNode\n * @returns\n */\nfunction getPropertyMembers(typeOrNode) {\n    let type;\n    if (isStateTreeNode(typeOrNode)) {\n        type = getType(typeOrNode);\n    }\n    else {\n        type = typeOrNode;\n    }\n    assertArg(type, t => isModelType(t), \"model type or model instance\", 1);\n    return {\n        name: type.name,\n        properties: { ...type.properties }\n    };\n}\n/**\n * Returns a reflection of the model node, including name, properties, views, volatile state,\n * and actions. `flowActions` is also provided as a separate array of names for any action that\n * came from a flow generator as well.\n *\n * In the case where a model has two actions: `doSomething` and `doSomethingWithFlow`, where\n * `doSomethingWithFlow` is a flow generator, the `actions` array will contain both actions,\n * i.e. [\"doSomething\", \"doSomethingWithFlow\"], and the `flowActions` array will contain only\n * the flow action, i.e. [\"doSomethingWithFlow\"].\n *\n * @param target\n * @returns\n */\nfunction getMembers(target) {\n    const type = getStateTreeNode(target).type;\n    const reflected = {\n        ...getPropertyMembers(type),\n        actions: [],\n        volatile: [],\n        views: [],\n        flowActions: []\n    };\n    const props = Object.getOwnPropertyNames(target);\n    props.forEach(key => {\n        if (key in reflected.properties) {\n            return;\n        }\n        const descriptor = Object.getOwnPropertyDescriptor(target, key);\n        if (descriptor.get) {\n            if (isComputedProp(target, key)) {\n                reflected.views.push(key);\n            }\n            else {\n                reflected.volatile.push(key);\n            }\n            return;\n        }\n        if (descriptor.value._isFlowAction === true) {\n            reflected.flowActions.push(key);\n        }\n        if (descriptor.value._isMSTAction === true) {\n            reflected.actions.push(key);\n        }\n        else if (isObservableProp(target, key)) {\n            reflected.volatile.push(key);\n        }\n        else {\n            reflected.views.push(key);\n        }\n    });\n    return reflected;\n}\n/**\n * Casts a node snapshot or instance type to an instance type so it can be assigned to a type instance.\n * Note that this is just a cast for the type system, this is, it won't actually convert a snapshot to an instance,\n * but just fool typescript into thinking so.\n * Either way, casting when outside an assignation operation won't compile.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * }).actions(self => ({\n *   someAction() {\n *     // this will allow the compiler to assign a snapshot to the property\n *     self.innerModel = cast({ a: 5 })\n *   }\n * }))\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object cast as an instance\n */\nfunction cast(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a snapshot type so it can be assigned to a type snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   innerModel: ModelA\n * })\n *\n * const a = ModelA.create({ n: 5 });\n * // this will allow the compiler to use a model as if it were a snapshot\n * const b = ModelB.create({ innerModel: castToSnapshot(a)})\n * ```\n *\n * @param snapshotOrInstance Snapshot or instance\n * @returns The same object cast as an input (creation) snapshot\n */\nfunction castToSnapshot(snapshotOrInstance) {\n    return snapshotOrInstance;\n}\n/**\n * Casts a node instance type to a reference snapshot type so it can be assigned to a reference snapshot (e.g. to be used inside a create call).\n * Note that this is just a cast for the type system, this is, it won't actually convert an instance to a reference snapshot,\n * but just fool typescript into thinking so.\n *\n * Example:\n * ```ts\n * const ModelA = types.model({\n *   id: types.identifier,\n *   n: types.number\n * }).actions(self => ({\n *   setN(aNumber: number) {\n *     self.n = aNumber\n *   }\n * }))\n *\n * const ModelB = types.model({\n *   refA: types.reference(ModelA)\n * })\n *\n * const a = ModelA.create({ id: 'someId', n: 5 });\n * // this will allow the compiler to use a model as if it were a reference snapshot\n * const b = ModelB.create({ refA: castToReferenceSnapshot(a)})\n * ```\n *\n * @param instance Instance\n * @returns The same object cast as a reference snapshot (string or number)\n */\nfunction castToReferenceSnapshot(instance) {\n    return instance;\n}\n/**\n * Returns the unique node id (not to be confused with the instance identifier) for a\n * given instance.\n * This id is a number that is unique for each instance.\n *\n * @export\n * @param target\n * @returns\n */\nfunction getNodeId(target) {\n    assertIsStateTreeNode(target, 1);\n    return getStateTreeNode(target).nodeId;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass BaseNode {\n    type;\n    environment;\n    _escapedSubpath;\n    _subpath;\n    get subpath() {\n        return this._subpath;\n    }\n    _subpathUponDeath;\n    get subpathUponDeath() {\n        return this._subpathUponDeath;\n    }\n    _pathUponDeath;\n    get pathUponDeath() {\n        return this._pathUponDeath;\n    }\n    storedValue; // usually the same type as the value, but not always (such as with references)\n    get value() {\n        return this.type.getValue(this);\n    }\n    aliveAtom;\n    _state = NodeLifeCycle.INITIALIZING;\n    get state() {\n        return this._state;\n    }\n    set state(val) {\n        const wasAlive = this.isAlive;\n        this._state = val;\n        const isAlive = this.isAlive;\n        if (this.aliveAtom && wasAlive !== isAlive) {\n            this.aliveAtom.reportChanged();\n        }\n    }\n    _hookSubscribers;\n    fireInternalHook(name) {\n        if (this._hookSubscribers) {\n            this._hookSubscribers.emit(name, this, name);\n        }\n    }\n    registerHook(hook, hookHandler) {\n        if (!this._hookSubscribers) {\n            this._hookSubscribers = new EventHandlers();\n        }\n        return this._hookSubscribers.register(hook, hookHandler);\n    }\n    _parent;\n    get parent() {\n        return this._parent;\n    }\n    constructor(type, parent, subpath, environment) {\n        this.type = type;\n        this.environment = environment;\n        this.environment = environment;\n        this.baseSetParent(parent, subpath);\n    }\n    getReconciliationType() {\n        return this.type;\n    }\n    pathAtom;\n    baseSetParent(parent, subpath) {\n        this._parent = parent;\n        this._subpath = subpath;\n        this._escapedSubpath = undefined; // regenerate when needed\n        if (this.pathAtom) {\n            this.pathAtom.reportChanged();\n        }\n    }\n    /*\n     * Returns (escaped) path representation as string\n     */\n    get path() {\n        return this.getEscapedPath(true);\n    }\n    getEscapedPath(reportObserved) {\n        if (reportObserved) {\n            if (!this.pathAtom) {\n                this.pathAtom = createAtom(`path`);\n            }\n            this.pathAtom.reportObserved();\n        }\n        if (!this.parent) {\n            return \"\";\n        }\n        // regenerate escaped subpath if needed\n        if (this._escapedSubpath === undefined) {\n            this._escapedSubpath = !this._subpath ? \"\" : escapeJsonPath(this._subpath);\n        }\n        return (this.parent.getEscapedPath(reportObserved) + \"/\" + this._escapedSubpath);\n    }\n    get isRoot() {\n        return this.parent === null;\n    }\n    get isAlive() {\n        return this.state !== NodeLifeCycle.DEAD;\n    }\n    get isDetaching() {\n        return this.state === NodeLifeCycle.DETACHING;\n    }\n    get observableIsAlive() {\n        if (!this.aliveAtom) {\n            this.aliveAtom = createAtom(`alive`);\n        }\n        this.aliveAtom.reportObserved();\n        return this.isAlive;\n    }\n    baseFinalizeCreation(whenFinalized) {\n        if (devMode()) {\n            if (!this.isAlive) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: cannot finalize the creation of a node that is already dead\");\n            }\n        }\n        // goal: afterCreate hooks runs depth-first. After attach runs parent first, so on afterAttach the parent has completed already\n        if (this.state === NodeLifeCycle.CREATED) {\n            if (this.parent) {\n                if (this.parent.state !== NodeLifeCycle.FINALIZED) {\n                    // parent not ready yet, postpone\n                    return;\n                }\n                this.fireHook(Hook.afterAttach);\n            }\n            this.state = NodeLifeCycle.FINALIZED;\n            if (whenFinalized) {\n                whenFinalized();\n            }\n        }\n    }\n    baseFinalizeDeath() {\n        if (this._hookSubscribers) {\n            this._hookSubscribers.clearAll();\n        }\n        this._subpathUponDeath = this._subpath;\n        this._pathUponDeath = this.getEscapedPath(false);\n        this.baseSetParent(null, \"\");\n        this.state = NodeLifeCycle.DEAD;\n    }\n    baseAboutToDie() {\n        this.fireHook(Hook.beforeDestroy);\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nclass ScalarNode extends BaseNode {\n    constructor(simpleType, parent, subpath, environment, initialSnapshot) {\n        super(simpleType, parent, subpath, environment);\n        try {\n            this.storedValue = simpleType.createNewInstance(initialSnapshot);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        this.state = NodeLifeCycle.CREATED;\n        // for scalar nodes there's no point in firing this event since it would fire on the constructor, before\n        // anybody can actually register for/listen to it\n        // this.fireHook(Hook.AfterCreate)\n        this.finalizeCreation();\n    }\n    get root() {\n        // future optimization: store root ref in the node and maintain it\n        if (!this.parent) {\n            throw fail(`This scalar node is not part of a tree`);\n        }\n        return this.parent.root;\n    }\n    setParent(newParent, subpath) {\n        const parentChanged = this.parent !== newParent;\n        const subpathChanged = this.subpath !== subpath;\n        if (!parentChanged && !subpathChanged) {\n            return;\n        }\n        if (devMode()) {\n            if (!subpath) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: subpath expected\");\n            }\n            if (!newParent) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: parent expected\");\n            }\n            if (parentChanged) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: scalar nodes cannot change their parent\");\n            }\n        }\n        this.environment = undefined; // use parent's\n        this.baseSetParent(this.parent, subpath);\n    }\n    get snapshot() {\n        return freeze(this.getSnapshot());\n    }\n    getSnapshot() {\n        return this.type.getSnapshot(this);\n    }\n    toString() {\n        const path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n        return `${this.type.name}@${path}${this.isAlive ? \"\" : \" [dead]\"}`;\n    }\n    die() {\n        if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) {\n            return;\n        }\n        this.aboutToDie();\n        this.finalizeDeath();\n    }\n    finalizeCreation() {\n        this.baseFinalizeCreation();\n    }\n    aboutToDie() {\n        this.baseAboutToDie();\n    }\n    finalizeDeath() {\n        this.baseFinalizeDeath();\n    }\n    fireHook(name) {\n        this.fireInternalHook(name);\n    }\n}\nScalarNode.prototype.die = action(ScalarNode.prototype.die);\n\n// noinspection ES6UnusedImports\nlet nextNodeId = 1;\nconst snapshotReactionOptions = {\n    onError(e) {\n        throw e;\n    }\n};\n/**\n * @internal\n * @hidden\n */\nclass ObjectNode extends BaseNode {\n    nodeId = ++nextNodeId;\n    identifierAttribute;\n    identifier; // Identifier is always normalized to string, even if the identifier property isn't\n    unnormalizedIdentifier;\n    identifierCache;\n    isProtectionEnabled = true;\n    middlewares;\n    hasSnapshotPostProcessor = false;\n    _applyPatches;\n    applyPatches(patches) {\n        this.createObservableInstanceIfNeeded();\n        this._applyPatches(patches);\n    }\n    _applySnapshot;\n    applySnapshot(snapshot) {\n        this.createObservableInstanceIfNeeded();\n        this._applySnapshot(snapshot);\n    }\n    _autoUnbox = true; // unboxing is disabled when reading child nodes\n    _isRunningAction = false; // only relevant for root\n    _hasSnapshotReaction = false;\n    _observableInstanceState = 0 /* ObservableInstanceLifecycle.UNINITIALIZED */;\n    _childNodes;\n    _initialSnapshot;\n    _cachedInitialSnapshot;\n    _cachedInitialSnapshotCreated = false;\n    _snapshotComputed;\n    constructor(complexType, parent, subpath, environment, initialValue) {\n        super(complexType, parent, subpath, environment);\n        this._snapshotComputed = computed(() => freeze(this.getSnapshot()));\n        this.unbox = this.unbox.bind(this);\n        this._initialSnapshot = freeze(initialValue);\n        this.identifierAttribute = complexType.identifierAttribute;\n        if (!parent) {\n            this.identifierCache = new IdentifierCache();\n        }\n        this._childNodes = complexType.initializeChildNodes(this, this._initialSnapshot);\n        // identifier can not be changed during lifecycle of a node\n        // so we safely can read it from initial snapshot\n        this.identifier = null;\n        this.unnormalizedIdentifier = null;\n        if (this.identifierAttribute && this._initialSnapshot) {\n            let id = this._initialSnapshot[this.identifierAttribute];\n            if (id === undefined) {\n                // try with the actual node if not (for optional identifiers)\n                const childNode = this._childNodes[this.identifierAttribute];\n                if (childNode) {\n                    id = childNode.value;\n                }\n            }\n            if (typeof id !== \"string\" && typeof id !== \"number\") {\n                throw fail(`Instance identifier '${this.identifierAttribute}' for type '${this.type.name}' must be a string or a number`);\n            }\n            // normalize internal identifier to string\n            this.identifier = normalizeIdentifier(id);\n            this.unnormalizedIdentifier = id;\n        }\n        if (!parent) {\n            this.identifierCache.addNodeToCache(this);\n        }\n        else {\n            parent.root.identifierCache.addNodeToCache(this);\n        }\n    }\n    createObservableInstanceIfNeeded(fireHooks = true) {\n        if (this._observableInstanceState ===\n            0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            this.createObservableInstance(fireHooks);\n        }\n    }\n    createObservableInstance(fireHooks = true) {\n        if (devMode()) {\n            if (this.state !== NodeLifeCycle.INITIALIZING) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: the creation of the observable instance must be done on the initializing phase\");\n            }\n        }\n        this._observableInstanceState = 1 /* ObservableInstanceLifecycle.CREATING */;\n        // make sure the parent chain is created as well\n        // array with parent chain from parent to child\n        const parentChain = [];\n        let parent = this.parent;\n        // for performance reasons we never go back further than the most direct\n        // uninitialized parent\n        // this is done to avoid traversing the whole tree to the root when using\n        // the same reference again\n        while (parent &&\n            parent._observableInstanceState ===\n                0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            parentChain.unshift(parent);\n            parent = parent.parent;\n        }\n        // initialize the uninitialized parent chain from parent to child\n        for (const p of parentChain) {\n            // delay firing hooks until after all parents have been created\n            p.createObservableInstanceIfNeeded(false);\n        }\n        const type = this.type;\n        try {\n            // @ts-expect-error\n            this.storedValue = type.createNewInstance(this._childNodes);\n            this.preboot();\n            this._isRunningAction = true;\n            type.finalizeNewInstance(this, this.storedValue);\n        }\n        catch (e) {\n            // short-cut to die the instance, to avoid the snapshot computed starting to throw...\n            this.state = NodeLifeCycle.DEAD;\n            throw e;\n        }\n        finally {\n            this._isRunningAction = false;\n        }\n        this._observableInstanceState = 2 /* ObservableInstanceLifecycle.CREATED */;\n        this._snapshotComputed.trackAndCompute();\n        if (this.isRoot) {\n            this._addSnapshotReaction();\n        }\n        this._childNodes = EMPTY_OBJECT;\n        this.state = NodeLifeCycle.CREATED;\n        if (fireHooks) {\n            this.fireHook(Hook.afterCreate);\n            // Note that the parent might not be finalized at this point\n            // so afterAttach won't be called until later in that case\n            this.finalizeCreation();\n            // fire the hooks of the parents that we created\n            for (const p of parentChain.reverse()) {\n                p.fireHook(Hook.afterCreate);\n                // This will call afterAttach on the child if necessary\n                p.finalizeCreation();\n            }\n        }\n    }\n    get root() {\n        const parent = this.parent;\n        return parent ? parent.root : this;\n    }\n    clearParent() {\n        if (!this.parent) {\n            return;\n        }\n        // detach if attached\n        this.fireHook(Hook.beforeDetach);\n        const previousState = this.state;\n        this.state = NodeLifeCycle.DETACHING;\n        const root = this.root;\n        const newEnv = root.environment;\n        const newIdCache = root.identifierCache.splitCache(this);\n        try {\n            this.parent.removeChild(this.subpath);\n            this.baseSetParent(null, \"\");\n            this.environment = newEnv;\n            this.identifierCache = newIdCache;\n        }\n        finally {\n            this.state = previousState;\n        }\n    }\n    setParent(newParent, subpath) {\n        const parentChanged = newParent !== this.parent;\n        const subpathChanged = subpath !== this.subpath;\n        if (!parentChanged && !subpathChanged) {\n            return;\n        }\n        if (devMode()) {\n            if (!subpath) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: subpath expected\");\n            }\n            if (!newParent) {\n                // istanbul ignore next\n                throw fail(\"assertion failed: new parent expected\");\n            }\n            if (this.parent && parentChanged) {\n                throw fail(`A node cannot exists twice in the state tree. Failed to add ${this} to path '${newParent.path}/${subpath}'.`);\n            }\n            if (!this.parent && newParent.root === this) {\n                throw fail(`A state tree is not allowed to contain itself. Cannot assign ${this} to path '${newParent.path}/${subpath}'`);\n            }\n            if (!this.parent &&\n                !!this.environment &&\n                this.environment !== newParent.root.environment) {\n                throw fail(`A state tree cannot be made part of another state tree as long as their environments are different.`);\n            }\n        }\n        if (parentChanged) {\n            // attach to new parent\n            this.environment = undefined; // will use root's\n            newParent.root.identifierCache.mergeCache(this);\n            this.baseSetParent(newParent, subpath);\n            this.fireHook(Hook.afterAttach);\n        }\n        else if (subpathChanged) {\n            // moving to a new subpath on the same parent\n            this.baseSetParent(this.parent, subpath);\n        }\n    }\n    fireHook(name) {\n        this.fireInternalHook(name);\n        const fn = this.storedValue &&\n            typeof this.storedValue === \"object\" &&\n            this.storedValue[name];\n        if (typeof fn === \"function\") {\n            // we check for it to allow old mobx peer dependencies that don't have the method to work (even when still bugged)\n            if (_allowStateChangesInsideComputed) {\n                _allowStateChangesInsideComputed(() => {\n                    fn.apply(this.storedValue);\n                });\n            }\n            else {\n                fn.apply(this.storedValue);\n            }\n        }\n    }\n    _snapshotUponDeath;\n    // advantage of using computed for a snapshot is that nicely respects transactions etc.\n    get snapshot() {\n        if (this.hasSnapshotPostProcessor) {\n            this.createObservableInstanceIfNeeded();\n        }\n        return this._snapshotComputed.get();\n    }\n    // NOTE: we use this method to get snapshot without creating @computed overhead\n    getSnapshot() {\n        if (!this.isAlive) {\n            return this._snapshotUponDeath;\n        }\n        return this._observableInstanceState === 2 /* ObservableInstanceLifecycle.CREATED */\n            ? this._getActualSnapshot()\n            : this._getCachedInitialSnapshot();\n    }\n    _getActualSnapshot() {\n        return this.type.getSnapshot(this);\n    }\n    _getCachedInitialSnapshot() {\n        if (!this._cachedInitialSnapshotCreated) {\n            const type = this.type;\n            const childNodes = this._childNodes;\n            const snapshot = this._initialSnapshot;\n            this._cachedInitialSnapshot = type.processInitialSnapshot(childNodes, snapshot);\n            this._cachedInitialSnapshotCreated = true;\n        }\n        return this._cachedInitialSnapshot;\n    }\n    isRunningAction() {\n        if (this._isRunningAction) {\n            return true;\n        }\n        if (this.isRoot) {\n            return false;\n        }\n        return this.parent.isRunningAction();\n    }\n    assertAlive(context) {\n        const livelinessChecking = getLivelinessChecking();\n        if (!this.isAlive && livelinessChecking !== \"ignore\") {\n            const error = this._getAssertAliveError(context);\n            switch (livelinessChecking) {\n                case \"error\":\n                    throw fail(error);\n                case \"warn\":\n                    warnError(error);\n            }\n        }\n    }\n    _getAssertAliveError(context) {\n        const escapedPath = this.getEscapedPath(false) || this.pathUponDeath || \"\";\n        const subpath = (context.subpath && escapeJsonPath(context.subpath)) || \"\";\n        let actionContext = context.actionContext || getCurrentActionContext();\n        // try to use a real action context if possible since it includes the action name\n        if (actionContext &&\n            actionContext.type !== \"action\" &&\n            actionContext.parentActionEvent) {\n            actionContext = actionContext.parentActionEvent;\n        }\n        let actionFullPath = \"\";\n        if (actionContext && actionContext.name != null) {\n            // try to use the context, and if it not available use the node one\n            const actionPath = (actionContext &&\n                actionContext.context &&\n                getPath(actionContext.context)) ||\n                escapedPath;\n            actionFullPath = `${actionPath}.${actionContext.name}()`;\n        }\n        return `You are trying to read or write to an object that is no longer part of a state tree. (Object type: '${this.type.name}', Path upon death: '${escapedPath}', Subpath: '${subpath}', Action: '${actionFullPath}'). Either detach nodes first, or don't use objects after removing / replacing them in the tree.`;\n    }\n    getChildNode(subpath) {\n        this.assertAlive({\n            subpath\n        });\n        this._autoUnbox = false;\n        try {\n            return this._observableInstanceState ===\n                2 /* ObservableInstanceLifecycle.CREATED */\n                ? this.type.getChildNode(this, subpath)\n                : this._childNodes[subpath];\n        }\n        finally {\n            this._autoUnbox = true;\n        }\n    }\n    getChildren() {\n        this.assertAlive(EMPTY_OBJECT);\n        this._autoUnbox = false;\n        try {\n            return this._observableInstanceState ===\n                2 /* ObservableInstanceLifecycle.CREATED */\n                ? this.type.getChildren(this)\n                : convertChildNodesToArray(this._childNodes);\n        }\n        finally {\n            this._autoUnbox = true;\n        }\n    }\n    getChildType(propertyName) {\n        return this.type.getChildType(propertyName);\n    }\n    get isProtected() {\n        return this.root.isProtectionEnabled;\n    }\n    assertWritable(context) {\n        this.assertAlive(context);\n        if (!this.isRunningAction() && this.isProtected) {\n            throw fail(`Cannot modify '${this}', the object is protected and can only be modified by using an action.`);\n        }\n    }\n    removeChild(subpath) {\n        this.type.removeChild(this, subpath);\n    }\n    // bound on the constructor\n    unbox(childNode) {\n        if (!childNode) {\n            return childNode;\n        }\n        this.assertAlive({\n            subpath: childNode.subpath || childNode.subpathUponDeath\n        });\n        return this._autoUnbox ? childNode.value : childNode;\n    }\n    toString() {\n        const path = (this.isAlive ? this.path : this.pathUponDeath) || \"<root>\";\n        const identifier = this.identifier ? `(id: ${this.identifier})` : \"\";\n        return `${this.type.name}@${path}${identifier}${this.isAlive ? \"\" : \" [dead]\"}`;\n    }\n    finalizeCreation() {\n        this.baseFinalizeCreation(() => {\n            for (const child of this.getChildren()) {\n                child.finalizeCreation();\n            }\n            this.fireInternalHook(Hook.afterCreationFinalization);\n        });\n    }\n    detach() {\n        if (!this.isAlive) {\n            throw fail(`Error while detaching, node is not alive.`);\n        }\n        this.clearParent();\n    }\n    preboot() {\n        const self = this;\n        this._applyPatches = createActionInvoker(this.storedValue, \"@APPLY_PATCHES\", (patches) => {\n            patches.forEach(patch => {\n                if (!patch.path) {\n                    self.type.applySnapshot(self, patch.value);\n                    return;\n                }\n                const parts = splitJsonPath(patch.path);\n                const node = resolveNodeByPathParts(self, parts.slice(0, -1));\n                node.applyPatchLocally(parts[parts.length - 1], patch);\n            });\n        });\n        this._applySnapshot = createActionInvoker(this.storedValue, \"@APPLY_SNAPSHOT\", (snapshot) => {\n            // if the snapshot is the same as the current one, avoid performing a reconcile\n            if (snapshot === self.snapshot) {\n                return;\n            }\n            // else, apply it by calling the type logic\n            return self.type.applySnapshot(self, snapshot);\n        });\n        addHiddenFinalProp(this.storedValue, \"$treenode\", this);\n        addHiddenFinalProp(this.storedValue, \"toJSON\", toJSON);\n    }\n    die() {\n        if (!this.isAlive || this.state === NodeLifeCycle.DETACHING) {\n            return;\n        }\n        this.aboutToDie();\n        this.finalizeDeath();\n    }\n    aboutToDie() {\n        if (this._observableInstanceState ===\n            0 /* ObservableInstanceLifecycle.UNINITIALIZED */) {\n            return;\n        }\n        this.getChildren().forEach(node => {\n            node.aboutToDie();\n        });\n        // beforeDestroy should run before the disposers since else we could end up in a situation where\n        // a disposer added with addDisposer at this stage (beforeDestroy) is actually never released\n        this.baseAboutToDie();\n        this._internalEventsEmit(\"dispose\" /* InternalEvents.Dispose */);\n        this._internalEventsClear(\"dispose\" /* InternalEvents.Dispose */);\n    }\n    finalizeDeath() {\n        // invariant: not called directly but from \"die\"\n        this.getChildren().forEach(node => {\n            node.finalizeDeath();\n        });\n        this.root.identifierCache.notifyDied(this);\n        // \"kill\" the computed prop and just store the last snapshot\n        const snapshot = this.snapshot;\n        this._snapshotUponDeath = snapshot;\n        this._internalEventsClearAll();\n        this.baseFinalizeDeath();\n    }\n    onSnapshot(onChange) {\n        this._addSnapshotReaction();\n        return this._internalEventsRegister(\"snapshot\" /* InternalEvents.Snapshot */, onChange);\n    }\n    emitSnapshot(snapshot) {\n        this._internalEventsEmit(\"snapshot\" /* InternalEvents.Snapshot */, snapshot);\n    }\n    onPatch(handler) {\n        return this._internalEventsRegister(\"patch\" /* InternalEvents.Patch */, handler);\n    }\n    emitPatch(basePatch, source) {\n        if (this._internalEventsHasSubscribers(\"patch\" /* InternalEvents.Patch */)) {\n            const localizedPatch = extend({}, basePatch, {\n                path: source.path.substr(this.path.length) + \"/\" + basePatch.path // calculate the relative path of the patch\n            });\n            const [patch, reversePatch] = splitPatch(localizedPatch);\n            this._internalEventsEmit(\"patch\" /* InternalEvents.Patch */, patch, reversePatch);\n        }\n        if (this.parent) {\n            this.parent.emitPatch(basePatch, source);\n        }\n    }\n    hasDisposer(disposer) {\n        return this._internalEventsHas(\"dispose\" /* InternalEvents.Dispose */, disposer);\n    }\n    addDisposer(disposer) {\n        if (!this.hasDisposer(disposer)) {\n            this._internalEventsRegister(\"dispose\" /* InternalEvents.Dispose */, disposer, true);\n            return;\n        }\n        throw fail(\"cannot add a disposer when it is already registered for execution\");\n    }\n    removeDisposer(disposer) {\n        if (!this._internalEventsHas(\"dispose\" /* InternalEvents.Dispose */, disposer)) {\n            throw fail(\"cannot remove a disposer which was never registered for execution\");\n        }\n        this._internalEventsUnregister(\"dispose\" /* InternalEvents.Dispose */, disposer);\n    }\n    removeMiddleware(middleware) {\n        if (this.middlewares) {\n            const index = this.middlewares.indexOf(middleware);\n            if (index >= 0) {\n                this.middlewares.splice(index, 1);\n            }\n        }\n    }\n    addMiddleWare(handler, includeHooks = true) {\n        const middleware = { handler, includeHooks };\n        if (!this.middlewares) {\n            this.middlewares = [middleware];\n        }\n        else {\n            this.middlewares.push(middleware);\n        }\n        return () => {\n            this.removeMiddleware(middleware);\n        };\n    }\n    applyPatchLocally(subpath, patch) {\n        this.assertWritable({\n            subpath\n        });\n        this.createObservableInstanceIfNeeded();\n        this.type.applyPatchLocally(this, subpath, patch);\n    }\n    _addSnapshotReaction() {\n        if (!this._hasSnapshotReaction) {\n            const snapshotDisposer = reaction(() => this.snapshot, snapshot => this.emitSnapshot(snapshot), snapshotReactionOptions);\n            this.addDisposer(snapshotDisposer);\n            this._hasSnapshotReaction = true;\n        }\n    }\n    // #region internal event handling\n    _internalEvents;\n    // we proxy the methods to avoid creating an EventHandlers instance when it is not needed\n    _internalEventsHasSubscribers(event) {\n        return !!this._internalEvents && this._internalEvents.hasSubscribers(event);\n    }\n    _internalEventsRegister(event, eventHandler, atTheBeginning = false) {\n        if (!this._internalEvents) {\n            this._internalEvents = new EventHandlers();\n        }\n        return this._internalEvents.register(event, eventHandler, atTheBeginning);\n    }\n    _internalEventsHas(event, eventHandler) {\n        return (!!this._internalEvents && this._internalEvents.has(event, eventHandler));\n    }\n    _internalEventsUnregister(event, eventHandler) {\n        if (this._internalEvents) {\n            this._internalEvents.unregister(event, eventHandler);\n        }\n    }\n    _internalEventsEmit(event, ...args) {\n        if (this._internalEvents) {\n            this._internalEvents.emit(event, ...args);\n        }\n    }\n    _internalEventsClear(event) {\n        if (this._internalEvents) {\n            this._internalEvents.clear(event);\n        }\n    }\n    _internalEventsClearAll() {\n        if (this._internalEvents) {\n            this._internalEvents.clearAll();\n        }\n    }\n}\nObjectNode.prototype.createObservableInstance = action(ObjectNode.prototype.createObservableInstance);\nObjectNode.prototype.detach = action(ObjectNode.prototype.detach);\nObjectNode.prototype.die = action(ObjectNode.prototype.die);\n\n// Cache for validation results to avoid re-validating the same object against the same type\n// Uses WeakMap so cached objects can be garbage collected\nconst validationCache = new WeakMap();\n/**\n * @internal\n * @hidden\n */\nvar TypeFlags;\n(function (TypeFlags) {\n    TypeFlags[TypeFlags[\"String\"] = 1] = \"String\";\n    TypeFlags[TypeFlags[\"Number\"] = 2] = \"Number\";\n    TypeFlags[TypeFlags[\"Boolean\"] = 4] = \"Boolean\";\n    TypeFlags[TypeFlags[\"Date\"] = 8] = \"Date\";\n    TypeFlags[TypeFlags[\"Literal\"] = 16] = \"Literal\";\n    TypeFlags[TypeFlags[\"Array\"] = 32] = \"Array\";\n    TypeFlags[TypeFlags[\"Map\"] = 64] = \"Map\";\n    TypeFlags[TypeFlags[\"Object\"] = 128] = \"Object\";\n    TypeFlags[TypeFlags[\"Frozen\"] = 256] = \"Frozen\";\n    TypeFlags[TypeFlags[\"Optional\"] = 512] = \"Optional\";\n    TypeFlags[TypeFlags[\"Reference\"] = 1024] = \"Reference\";\n    TypeFlags[TypeFlags[\"Identifier\"] = 2048] = \"Identifier\";\n    TypeFlags[TypeFlags[\"Late\"] = 4096] = \"Late\";\n    TypeFlags[TypeFlags[\"Refinement\"] = 8192] = \"Refinement\";\n    TypeFlags[TypeFlags[\"Union\"] = 16384] = \"Union\";\n    TypeFlags[TypeFlags[\"Null\"] = 32768] = \"Null\";\n    TypeFlags[TypeFlags[\"Undefined\"] = 65536] = \"Undefined\";\n    TypeFlags[TypeFlags[\"Integer\"] = 131072] = \"Integer\";\n    TypeFlags[TypeFlags[\"Custom\"] = 262144] = \"Custom\";\n    TypeFlags[TypeFlags[\"SnapshotProcessor\"] = 524288] = \"SnapshotProcessor\";\n    TypeFlags[TypeFlags[\"Lazy\"] = 1048576] = \"Lazy\";\n    TypeFlags[TypeFlags[\"Finite\"] = 2097152] = \"Finite\";\n    TypeFlags[TypeFlags[\"Float\"] = 4194304] = \"Float\";\n})(TypeFlags || (TypeFlags = {}));\n/**\n * @internal\n * @hidden\n */\nconst cannotDetermineSubtype = \"cannotDetermine\";\n/** @hidden */\nconst $type = Symbol(\"$type\");\n/**\n * A base type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nclass BaseType {\n    [$type];\n    // these are just to make inner types avaialable to inherited classes\n    C;\n    S;\n    T;\n    N;\n    isType = true;\n    name;\n    constructor(name) {\n        this.name = name;\n    }\n    create(snapshot, environment) {\n        typecheckInternal(this, snapshot);\n        return this.instantiate(null, \"\", environment, snapshot).value;\n    }\n    getSnapshot(node, applyPostProcess) {\n        // istanbul ignore next\n        throw fail(\"unimplemented method\");\n    }\n    isAssignableFrom(type) {\n        return type === this;\n    }\n    validate(value, context) {\n        const node = getStateTreeNodeSafe(value);\n        if (node) {\n            const valueType = getType(value);\n            return this.isAssignableFrom(valueType)\n                ? typeCheckSuccess()\n                : typeCheckFailure(context, value);\n            // it is tempting to compare snapshots, but in that case we should always clone on assignments...\n        }\n        // check cache for object values (only at root level to avoid context mismatches)\n        if (typeof value === \"object\" && value !== null && context.length === 1) {\n            const typeCache = validationCache.get(value);\n            if (typeCache) {\n                const cached = typeCache.get(this);\n                if (cached !== undefined) {\n                    return cached;\n                }\n            }\n        }\n        const result = this.isValidSnapshot(value, context);\n        // cache result for object values (only at root level)\n        if (typeof value === \"object\" && value !== null && context.length === 1) {\n            let typeCache = validationCache.get(value);\n            if (!typeCache) {\n                typeCache = new WeakMap();\n                validationCache.set(value, typeCache);\n            }\n            typeCache.set(this, result);\n        }\n        return result;\n    }\n    is(thing) {\n        return this.validate(thing, [{ path: \"\", type: this }]).length === 0;\n    }\n    get Type() {\n        // istanbul ignore next\n        throw fail(\"Factory.Type should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.Type`\");\n    }\n    get TypeWithoutSTN() {\n        // istanbul ignore next\n        throw fail(\"Factory.TypeWithoutSTN should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.TypeWithoutSTN`\");\n    }\n    get SnapshotType() {\n        // istanbul ignore next\n        throw fail(\"Factory.SnapshotType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.SnapshotType`\");\n    }\n    get CreationType() {\n        // istanbul ignore next\n        throw fail(\"Factory.CreationType should not be actually called. It is just a Type signature that can be used at compile time with Typescript, by using `typeof type.CreationType`\");\n    }\n}\nBaseType.prototype.create = action(BaseType.prototype.create);\n/**\n * A complex type produces a MST node (Node in the state tree)\n *\n * @internal\n * @hidden\n */\nclass ComplexType extends BaseType {\n    identifierAttribute;\n    constructor(name) {\n        super(name);\n    }\n    create(snapshot = this.getDefaultSnapshot(), environment) {\n        return super.create(snapshot, environment);\n    }\n    getValue(node) {\n        node.createObservableInstanceIfNeeded();\n        return node.storedValue;\n    }\n    isMatchingSnapshotId(current, snapshot) {\n        return (!current.identifierAttribute ||\n            current.identifier ===\n                normalizeIdentifier(snapshot[current.identifierAttribute]));\n    }\n    tryToReconcileNode(current, newValue) {\n        if (current.isDetaching) {\n            return false;\n        }\n        if (current.snapshot === newValue) {\n            // newValue is the current snapshot of the node, noop\n            return true;\n        }\n        if (isStateTreeNode(newValue) && getStateTreeNode(newValue) === current) {\n            // the current node is the same as the new one\n            return true;\n        }\n        if (current.type === this &&\n            isMutable(newValue) &&\n            !isStateTreeNode(newValue) &&\n            this.isMatchingSnapshotId(current, newValue)) {\n            // the newValue has no node, so can be treated like a snapshot\n            // we can reconcile\n            current.applySnapshot(newValue);\n            return true;\n        }\n        return false;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const nodeReconciled = this.tryToReconcileNode(current, newValue);\n        if (nodeReconciled) {\n            current.setParent(parent, subpath);\n            return current;\n        }\n        // current node cannot be recycled in any way\n        current.die(); // noop if detaching\n        // attempt to reuse the new one\n        if (isStateTreeNode(newValue) && this.isAssignableFrom(getType(newValue))) {\n            // newValue is a Node as well, move it here..\n            const newNode = getStateTreeNode(newValue);\n            newNode.setParent(parent, subpath);\n            return newNode;\n        }\n        // nothing to do, we have to create a new node\n        return this.instantiate(parent, subpath, undefined, newValue);\n    }\n    getSubTypes() {\n        return null;\n    }\n}\nComplexType.prototype.create = action(ComplexType.prototype.create);\n/**\n * @internal\n * @hidden\n */\nclass SimpleType extends BaseType {\n    createNewInstance(snapshot) {\n        return snapshot;\n    }\n    getValue(node) {\n        // if we ever find a case where scalar nodes can be accessed without iterating through its parent\n        // uncomment this to make sure the parent chain is created when this is accessed\n        // if (node.parent) {\n        //     node.parent.createObservableInstanceIfNeeded()\n        // }\n        return node.storedValue;\n    }\n    getSnapshot(node) {\n        return node.storedValue;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        // reconcile only if type and value are still the same, and only if the node is not detaching\n        if (!current.isDetaching &&\n            current.type === this &&\n            current.storedValue === newValue) {\n            return current;\n        }\n        const res = this.instantiate(parent, subpath, undefined, newValue);\n        current.die(); // noop if detaching\n        return res;\n    }\n    getSubTypes() {\n        return null;\n    }\n}\n/**\n * Returns if a given value represents a type.\n *\n * @param value Value to check.\n * @returns `true` if the value is a type.\n */\nfunction isType(value) {\n    return typeof value === \"object\" && value && value.isType === true;\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsType(type, argNumber) {\n    assertArg(type, isType, \"mobx-state-tree type\", argNumber);\n}\n\nconst runningActions = new Map();\n/**\n * Note: Consider migrating to `createActionTrackingMiddleware2`, it is easier to use.\n *\n * Convenience utility to create action based middleware that supports async processes more easily.\n * All hooks are called for both synchronous and asynchronous actions. Except that either `onSuccess` or `onFail` is called\n *\n * The create middleware tracks the process of an action (assuming it passes the `filter`).\n * `onResume` can return any value, which will be passed as second argument to any other hook. This makes it possible to keep state during a process.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware(hooks) {\n    return function actionTrackingMiddleware(call, next, abort) {\n        switch (call.type) {\n            case \"action\": {\n                if (!hooks.filter || hooks.filter(call) === true) {\n                    const context = hooks.onStart(call);\n                    hooks.onResume(call, context);\n                    runningActions.set(call.id, {\n                        call,\n                        context,\n                        async: false\n                    });\n                    try {\n                        const res = next(call);\n                        hooks.onSuspend(call, context);\n                        if (runningActions.get(call.id).async === false) {\n                            runningActions.delete(call.id);\n                            hooks.onSuccess(call, context, res);\n                        }\n                        return res;\n                    }\n                    catch (e) {\n                        runningActions.delete(call.id);\n                        hooks.onFail(call, context, e);\n                        throw e;\n                    }\n                }\n                else {\n                    return next(call);\n                }\n            }\n            case \"flow_spawn\": {\n                const root = runningActions.get(call.rootId);\n                root.async = true;\n                return next(call);\n            }\n            case \"flow_resume\":\n            case \"flow_resume_error\": {\n                const root = runningActions.get(call.rootId);\n                hooks.onResume(call, root.context);\n                try {\n                    return next(call);\n                }\n                finally {\n                    hooks.onSuspend(call, root.context);\n                }\n            }\n            case \"flow_throw\": {\n                const root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onFail(call, root.context, call.args[0]);\n                return next(call);\n            }\n            case \"flow_return\": {\n                const root = runningActions.get(call.rootId);\n                runningActions.delete(call.rootId);\n                hooks.onSuccess(call, root.context, call.args[0]);\n                return next(call);\n            }\n        }\n    };\n}\n\nclass RunningAction {\n    hooks;\n    call;\n    flowsPending = 0;\n    running = true;\n    constructor(hooks, call) {\n        this.hooks = hooks;\n        this.call = call;\n        if (hooks) {\n            hooks.onStart(call);\n        }\n    }\n    finish(error) {\n        if (this.running) {\n            this.running = false;\n            if (this.hooks) {\n                this.hooks.onFinish(this.call, error);\n            }\n        }\n    }\n    incFlowsPending() {\n        this.flowsPending++;\n    }\n    decFlowsPending() {\n        this.flowsPending--;\n    }\n    get hasFlowsPending() {\n        return this.flowsPending > 0;\n    }\n}\n/**\n * Convenience utility to create action based middleware that supports async processes more easily.\n * The flow is like this:\n * - for each action: if filter passes -> `onStart` -> (inner actions recursively) -> `onFinish`\n *\n * Example: if we had an action `a` that called inside an action `b1`, then `b2` the flow would be:\n * - `filter(a)`\n * - `onStart(a)`\n *   - `filter(b1)`\n *   - `onStart(b1)`\n *   - `onFinish(b1)`\n *   - `filter(b2)`\n *   - `onStart(b2)`\n *   - `onFinish(b2)`\n * - `onFinish(a)`\n *\n * The flow is the same no matter if the actions are sync or async.\n *\n * See the `atomic` middleware for an example\n *\n * @param hooks\n * @returns\n */\nfunction createActionTrackingMiddleware2(middlewareHooks) {\n    const runningActions = new Map();\n    return function actionTrackingMiddleware(call, next) {\n        // find parentRunningAction\n        const parentRunningAction = call.parentActionEvent\n            ? runningActions.get(call.parentActionEvent.id)\n            : undefined;\n        if (call.type === \"action\") {\n            const newCall = {\n                ...call,\n                // make a shallow copy of the parent action env\n                env: parentRunningAction && parentRunningAction.call.env,\n                parentCall: parentRunningAction && parentRunningAction.call\n            };\n            const passesFilter = !middlewareHooks.filter || middlewareHooks.filter(newCall);\n            const hooks = passesFilter ? middlewareHooks : undefined;\n            const runningAction = new RunningAction(hooks, newCall);\n            runningActions.set(call.id, runningAction);\n            let res;\n            try {\n                res = next(call);\n            }\n            catch (e) {\n                runningActions.delete(call.id);\n                runningAction.finish(e);\n                throw e;\n            }\n            // sync action finished\n            if (!runningAction.hasFlowsPending) {\n                runningActions.delete(call.id);\n                runningAction.finish();\n            }\n            return res;\n        }\n        else {\n            if (!parentRunningAction) {\n                return next(call);\n            }\n            switch (call.type) {\n                case \"flow_spawn\": {\n                    parentRunningAction.incFlowsPending();\n                    return next(call);\n                }\n                case \"flow_resume\":\n                case \"flow_resume_error\": {\n                    return next(call);\n                }\n                case \"flow_throw\": {\n                    const error = call.args[0];\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            runningActions.delete(call.parentActionEvent.id);\n                            parentRunningAction.finish(error);\n                        }\n                    }\n                }\n                case \"flow_return\": {\n                    try {\n                        return next(call);\n                    }\n                    finally {\n                        parentRunningAction.decFlowsPending();\n                        if (!parentRunningAction.hasFlowsPending) {\n                            runningActions.delete(call.parentActionEvent.id);\n                            parentRunningAction.finish();\n                        }\n                    }\n                }\n            }\n        }\n    };\n}\n\nfunction serializeArgument(node, actionName, index, arg) {\n    if (arg instanceof Date) {\n        return { $MST_DATE: arg.getTime() };\n    }\n    if (isPrimitive(arg)) {\n        return arg;\n    }\n    // We should not serialize MST nodes, even if we can, because we don't know if the receiving party can handle a raw snapshot instead of an\n    // MST type instance. So if one wants to serialize a MST node that was pass in, either explitly pass: 1: an id, 2: a (relative) path, 3: a snapshot\n    if (isStateTreeNode(arg)) {\n        return serializeTheUnserializable(`[MSTNode: ${getType(arg).name}]`);\n    }\n    if (typeof arg === \"function\") {\n        return serializeTheUnserializable(`[function]`);\n    }\n    if (typeof arg === \"object\" && !isPlainObject(arg) && !isArray(arg)) {\n        return serializeTheUnserializable(`[object ${(arg && arg.constructor && arg.constructor.name) ||\n            \"Complex Object\"}]`);\n    }\n    try {\n        // Check if serializable, cycle free etc...\n        // MWE: there must be a better way....\n        JSON.stringify(arg); // or throws\n        return arg;\n    }\n    catch (e) {\n        return serializeTheUnserializable(\"\" + e);\n    }\n}\nfunction deserializeArgument(adm, value) {\n    if (value && typeof value === \"object\" && \"$MST_DATE\" in value) {\n        return new Date(value[\"$MST_DATE\"]);\n    }\n    return value;\n}\nfunction serializeTheUnserializable(baseType) {\n    return {\n        $MST_UNSERIALIZABLE: true,\n        type: baseType\n    };\n}\n/**\n * Applies an action or a series of actions in a single MobX transaction.\n * Does not return any value\n * Takes an action description as produced by the `onAction` middleware.\n *\n * @param target\n * @param actions\n */\nfunction applyAction(target, actions) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    assertArg(actions, a => typeof a === \"object\", \"object or array\", 2);\n    runInAction(() => {\n        asArray(actions).forEach(action => baseApplyAction(target, action));\n    });\n}\nfunction baseApplyAction(target, action) {\n    const resolvedTarget = tryResolve(target, action.path || \"\");\n    if (!resolvedTarget) {\n        throw fail(`Invalid action path: ${action.path || \"\"}`);\n    }\n    const node = getStateTreeNode(resolvedTarget);\n    // Reserved functions\n    if (action.name === \"@APPLY_PATCHES\") {\n        return applyPatch.call(null, resolvedTarget, action.args[0]);\n    }\n    if (action.name === \"@APPLY_SNAPSHOT\") {\n        return applySnapshot.call(null, resolvedTarget, action.args[0]);\n    }\n    if (!(typeof resolvedTarget[action.name] === \"function\")) {\n        throw fail(`Action '${action.name}' does not exist in '${node.path}'`);\n    }\n    return resolvedTarget[action.name].apply(resolvedTarget, action.args ? action.args.map(v => deserializeArgument(node, v)) : []);\n}\n/**\n * Small abstraction around `onAction` and `applyAction`, attaches an action listener to a tree and records all the actions emitted.\n * Returns an recorder object with the following signature:\n *\n * Example:\n * ```ts\n * export interface IActionRecorder {\n *      // the recorded actions\n *      actions: ISerializedActionCall[]\n *      // true if currently recording\n *      recording: boolean\n *      // stop recording actions\n *      stop(): void\n *      // resume recording actions\n *      resume(): void\n *      // apply all the recorded actions on the given object\n *      replay(target: IAnyStateTreeNode): void\n * }\n * ```\n *\n * The optional filter function allows to skip recording certain actions.\n *\n * @param subject\n * @returns\n */\nfunction recordActions(subject, filter) {\n    // check all arguments\n    assertIsStateTreeNode(subject, 1);\n    const actions = [];\n    const listener = (call) => {\n        const recordThis = filter ? filter(call, getRunningActionContext()) : true;\n        if (recordThis) {\n            actions.push(call);\n        }\n    };\n    let disposer;\n    const recorder = {\n        actions,\n        get recording() {\n            return !!disposer;\n        },\n        stop() {\n            if (disposer) {\n                disposer();\n                disposer = undefined;\n            }\n        },\n        resume() {\n            if (disposer) {\n                return;\n            }\n            disposer = onAction(subject, listener);\n        },\n        replay(target) {\n            applyAction(target, actions);\n        }\n    };\n    recorder.resume();\n    return recorder;\n}\n/**\n * Registers a function that will be invoked for each action that is called on the provided model instance, or to any of its children.\n * See [actions](https://github.com/mobxjs/mobx-state-tree#actions) for more details. onAction events are emitted only for the outermost called action in the stack.\n * Action can also be intercepted by middleware using addMiddleware to change the function call before it will be run.\n *\n * Not all action arguments might be serializable. For unserializable arguments, a struct like `{ $MST_UNSERIALIZABLE: true, type: \"someType\" }` will be generated.\n * MST Nodes are considered non-serializable as well (they could be serialized as there snapshot, but it is uncertain whether an replaying party will be able to handle such a non-instantiated snapshot).\n * Rather, when using `onAction` middleware, one should consider in passing arguments which are 1: an id, 2: a (relative) path, or 3: a snapshot. Instead of a real MST node.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * }).actions(self => ({\n *   add(todo) {\n *     self.todos.push(todo);\n *   }\n * }))\n *\n * const s = TodoStore.create({ todos: [] })\n *\n * let disposer = onAction(s, (call) => {\n *   console.log(call);\n * })\n *\n * s.add({ task: \"Grab a coffee\" })\n * // Logs: { name: \"add\", path: \"\", args: [{ task: \"Grab a coffee\" }] }\n * ```\n *\n * @param target\n * @param listener\n * @param attachAfter (default false) fires the listener *after* the action has executed instead of before.\n * @returns\n */\nfunction onAction(target, listener, attachAfter = false) {\n    // check all arguments\n    assertIsStateTreeNode(target, 1);\n    if (devMode()) {\n        if (!isRoot(target)) {\n            warnError(\"Warning: Attaching onAction listeners to non root nodes is dangerous: No events will be emitted for actions initiated higher up in the tree.\");\n        }\n        if (!isProtected(target)) {\n            warnError(\"Warning: Attaching onAction listeners to non protected nodes is dangerous: No events will be emitted for direct modifications without action.\");\n        }\n    }\n    return addMiddleware(target, function handler(rawCall, next) {\n        if (rawCall.type === \"action\" && rawCall.id === rawCall.rootId) {\n            const sourceNode = getStateTreeNode(rawCall.context);\n            const info = {\n                name: rawCall.name,\n                path: getRelativePathBetweenNodes(getStateTreeNode(target), sourceNode),\n                args: rawCall.args.map((arg, index) => serializeArgument(sourceNode, rawCall.name, index, arg))\n            };\n            if (attachAfter) {\n                const res = next(rawCall);\n                listener(info);\n                return res;\n            }\n            else {\n                listener(info);\n                return next(rawCall);\n            }\n        }\n        else {\n            return next(rawCall);\n        }\n    });\n}\n\nlet nextActionId = 1;\nlet currentActionContext;\n/**\n * @internal\n * @hidden\n */\nfunction getCurrentActionContext() {\n    return currentActionContext;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getNextActionId() {\n    return nextActionId++;\n}\n// TODO: optimize away entire action context if there is no middleware in tree?\n/**\n * @internal\n * @hidden\n */\nfunction runWithActionContext(context, fn) {\n    const node = getStateTreeNode(context.context);\n    if (context.type === \"action\") {\n        node.assertAlive({\n            actionContext: context\n        });\n    }\n    const baseIsRunningAction = node._isRunningAction;\n    node._isRunningAction = true;\n    const previousContext = currentActionContext;\n    currentActionContext = context;\n    try {\n        return runMiddleWares(node, context, fn);\n    }\n    finally {\n        currentActionContext = previousContext;\n        node._isRunningAction = baseIsRunningAction;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction getParentActionContext(parentContext) {\n    if (!parentContext) {\n        return undefined;\n    }\n    if (parentContext.type === \"action\") {\n        return parentContext;\n    }\n    return parentContext.parentActionEvent;\n}\n/**\n * @internal\n * @hidden\n */\nfunction createActionInvoker(target, name, fn) {\n    const res = function () {\n        const id = getNextActionId();\n        const parentContext = currentActionContext;\n        const parentActionContext = getParentActionContext(parentContext);\n        return runWithActionContext({\n            type: \"action\",\n            name,\n            id,\n            args: argsToArray(arguments),\n            context: target,\n            tree: getRoot(target),\n            rootId: parentContext ? parentContext.rootId : id,\n            parentId: parentContext ? parentContext.id : 0,\n            allParentIds: parentContext\n                ? [...parentContext.allParentIds, parentContext.id]\n                : [],\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        }, fn);\n    };\n    res._isMSTAction = true;\n    res._isFlowAction = fn._isFlowAction;\n    return res;\n}\n/**\n * Middleware can be used to intercept any action is invoked on the subtree where it is attached.\n * If a tree is protected (by default), this means that any mutation of the tree will pass through your middleware.\n *\n * For more details, see the [middleware docs](concepts/middleware.md)\n *\n * @param target Node to apply the middleware to.\n * @param middleware Middleware to apply.\n * @returns A callable function to dispose the middleware.\n */\nfunction addMiddleware(target, handler, includeHooks = true) {\n    const node = getStateTreeNode(target);\n    if (devMode()) {\n        if (!node.isProtectionEnabled) {\n            warnError(\"It is recommended to protect the state tree before attaching action middleware, as otherwise it cannot be guaranteed that all changes are passed through middleware. See `protect`\");\n        }\n    }\n    return node.addMiddleWare(handler, includeHooks);\n}\n/**\n * Binds middleware to a specific action.\n *\n * Example:\n * ```ts\n * type.actions(self => {\n *   function takeA____() {\n *       self.toilet.donate()\n *       self.wipe()\n *       self.wipe()\n *       self.toilet.flush()\n *   }\n *   return {\n *     takeA____: decorate(atomic, takeA____)\n *   }\n * })\n * ```\n *\n * @param handler\n * @param fn\n * @param includeHooks\n * @returns The original function\n */\nfunction decorate(handler, fn, includeHooks = true) {\n    const middleware = { handler, includeHooks };\n    fn.$mst_middleware = fn.$mst_middleware || [];\n    fn.$mst_middleware.push(middleware);\n    return fn;\n}\nclass CollectedMiddlewares {\n    arrayIndex = 0;\n    inArrayIndex = 0;\n    middlewares = [];\n    constructor(node, fn) {\n        // we just push middleware arrays into an array of arrays to avoid making copies\n        if (fn.$mst_middleware) {\n            this.middlewares.push(fn.$mst_middleware);\n        }\n        let n = node;\n        // Find all middlewares. Optimization: cache this?\n        while (n) {\n            if (n.middlewares) {\n                this.middlewares.push(n.middlewares);\n            }\n            n = n.parent;\n        }\n    }\n    get isEmpty() {\n        return this.middlewares.length <= 0;\n    }\n    getNextMiddleware() {\n        const array = this.middlewares[this.arrayIndex];\n        if (!array) {\n            return undefined;\n        }\n        const item = array[this.inArrayIndex++];\n        if (!item) {\n            this.arrayIndex++;\n            this.inArrayIndex = 0;\n            return this.getNextMiddleware();\n        }\n        return item;\n    }\n}\nfunction runMiddleWares(node, baseCall, originalFn) {\n    const middlewares = new CollectedMiddlewares(node, originalFn);\n    // Short circuit\n    if (middlewares.isEmpty) {\n        return action(originalFn).apply(null, baseCall.args);\n    }\n    let result = null;\n    function runNextMiddleware(call) {\n        const middleware = middlewares.getNextMiddleware();\n        const handler = middleware && middleware.handler;\n        if (!handler) {\n            return action(originalFn).apply(null, call.args);\n        }\n        // skip hooks if asked to\n        if (!middleware.includeHooks && Hook[call.name]) {\n            return runNextMiddleware(call);\n        }\n        let nextInvoked = false;\n        function next(call2, callback) {\n            nextInvoked = true;\n            // the result can contain\n            // - the non manipulated return value from an action\n            // - the non manipulated abort value\n            // - one of the above but manipulated through the callback function\n            result = runNextMiddleware(call2);\n            if (callback) {\n                result = callback(result);\n            }\n        }\n        let abortInvoked = false;\n        function abort(value) {\n            abortInvoked = true;\n            // overwrite the result\n            // can be manipulated through middlewares earlier in the queue using the callback fn\n            result = value;\n        }\n        handler(call, next, abort);\n        if (devMode()) {\n            if (!nextInvoked && !abortInvoked) {\n                const node2 = getStateTreeNode(call.tree);\n                throw fail(`Neither the next() nor the abort() callback within the middleware ${handler.name} for the action: \"${call.name}\" on the node: ${node2.type.name} was invoked.`);\n            }\n            else if (nextInvoked && abortInvoked) {\n                const node2 = getStateTreeNode(call.tree);\n                throw fail(`The next() and abort() callback within the middleware ${handler.name} for the action: \"${call.name}\" on the node: ${node2.type.name} were invoked.`);\n            }\n        }\n        return result;\n    }\n    return runNextMiddleware(baseCall);\n}\n\n/**\n * Returns the currently executing MST action context, or undefined if none.\n */\nfunction getRunningActionContext() {\n    let current = getCurrentActionContext();\n    while (current && current.type !== \"action\") {\n        current = current.parentActionEvent;\n    }\n    return current;\n}\nfunction _isActionContextThisOrChildOf(actionContext, sameOrParent, includeSame) {\n    const parentId = typeof sameOrParent === \"number\" ? sameOrParent : sameOrParent.id;\n    let current = includeSame\n        ? actionContext\n        : actionContext.parentActionEvent;\n    while (current) {\n        if (current.id === parentId) {\n            return true;\n        }\n        current = current.parentActionEvent;\n    }\n    return false;\n}\n/**\n * Returns if the given action context is a parent of this action context.\n */\nfunction isActionContextChildOf(actionContext, parent) {\n    return _isActionContextThisOrChildOf(actionContext, parent, false);\n}\n/**\n * Returns if the given action context is this or a parent of this action context.\n */\nfunction isActionContextThisOrChildOf(actionContext, parentOrThis) {\n    return _isActionContextThisOrChildOf(actionContext, parentOrThis, true);\n}\n\nfunction safeStringify(value) {\n    try {\n        return JSON.stringify(value);\n    }\n    catch (e) {\n        // istanbul ignore next\n        return `<Unserializable: ${e}>`;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction prettyPrintValue(value) {\n    return typeof value === \"function\"\n        ? `<function${value.name ? \" \" + value.name : \"\"}>`\n        : isStateTreeNode(value)\n            ? `<${value}>`\n            : `\\`${safeStringify(value)}\\``;\n}\nfunction shortenPrintValue(valueInString) {\n    return valueInString.length < 280\n        ? valueInString\n        : `${valueInString.substring(0, 272)}......${valueInString.substring(valueInString.length - 8)}`;\n}\nfunction toErrorString(error) {\n    const { value } = error;\n    const type = error.context[error.context.length - 1].type;\n    const fullPath = error.context\n        .map(({ path }) => path)\n        .filter(path => path.length > 0)\n        .join(\"/\");\n    const pathPrefix = fullPath.length > 0 ? `at path \"/${fullPath}\" ` : ``;\n    const currentTypename = isStateTreeNode(value)\n        ? `value of type ${getStateTreeNode(value).type.name}:`\n        : isPrimitive(value)\n            ? \"value\"\n            : \"snapshot\";\n    const isSnapshotCompatible = type && isStateTreeNode(value) && type.is(getStateTreeNode(value).snapshot);\n    return (`${pathPrefix}${currentTypename} ${prettyPrintValue(value)} is not assignable ${type ? `to type: \\`${type.name}\\`` : ``}` +\n        (error.message ? ` (${error.message})` : \"\") +\n        (type\n            ? isPrimitiveType(type) || isPrimitive(value)\n                ? `.`\n                : `, expected an instance of \\`${type.name}\\` or a snapshot like \\`${type.describe()}\\` instead.` +\n                    (isSnapshotCompatible\n                        ? \" (Note that a snapshot of the provided value is compatible with the targeted type)\"\n                        : \"\")\n            : `.`));\n}\n/**\n * @internal\n * @hidden\n * Pushes a new entry onto the context array (mutates in place for performance).\n * Returns the same context array for chaining.\n */\nfunction getContextForPath(context, path, type) {\n    context.push({ path, type });\n    return context;\n}\n/**\n * @internal\n * @hidden\n * Pops the last entry from the context array (mutates in place).\n * Must be called after validation to restore context state.\n */\nfunction popContext(context) {\n    context.pop();\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckSuccess() {\n    return EMPTY_ARRAY;\n}\n/**\n * @internal\n * @hidden\n */\nfunction typeCheckFailure(context, value, message) {\n    // Clone context since it may be mutated after this error is created\n    return [{ context: context.slice(), value, message }];\n}\n/**\n * @internal\n * @hidden\n */\nfunction flattenTypeErrors(errors) {\n    return errors.flat();\n}\n// TODO; doublecheck: typecheck should only needed to be invoked from: type.create and array / map / value.property will change\n/**\n * @internal\n * @hidden\n */\nfunction typecheckInternal(type, value) {\n    // runs typeChecking if it is in dev-mode or through a process.env.ENABLE_TYPE_CHECK flag\n    if (isTypeCheckingEnabled()) {\n        typecheck(type, value);\n    }\n}\n/**\n * Run's the typechecker for the given type on the given value, which can be a snapshot or an instance.\n * Throws if the given value is not according the provided type specification.\n * Use this if you need typechecks even in a production build (by default all automatic runtime type checks will be skipped in production builds)\n *\n * @param type Type to check against.\n * @param value Value to be checked, either a snapshot or an instance.\n */\nfunction typecheck(type, value) {\n    const errors = type.validate(value, [{ path: \"\", type }]);\n    if (errors.length > 0) {\n        throw fail(validationErrorsToString(type, value, errors));\n    }\n}\nfunction validationErrorsToString(type, value, errors) {\n    if (errors.length === 0) {\n        return undefined;\n    }\n    return (`Error while converting ${shortenPrintValue(prettyPrintValue(value))} to \\`${type.name}\\`:\\n\\n    ` + errors.map(toErrorString).join(\"\\n    \"));\n}\n\nlet identifierCacheId = 0;\n/**\n * @internal\n * @hidden\n */\nclass IdentifierCache {\n    cacheId = identifierCacheId++;\n    // n.b. in cache all identifiers are normalized to strings\n    cache = observable.map();\n    // last time the cache (array) for a given time changed\n    // n.b. it is not really the time, but just an integer that gets increased after each modification to the array\n    lastCacheModificationPerId = observable.map();\n    constructor() { }\n    updateLastCacheModificationPerId(identifier) {\n        const lcm = this.lastCacheModificationPerId.get(identifier);\n        // we start at 1 since 0 means no update since cache creation\n        this.lastCacheModificationPerId.set(identifier, lcm === undefined ? 1 : lcm + 1);\n    }\n    getLastCacheModificationPerId(identifier) {\n        const modificationId = this.lastCacheModificationPerId.get(identifier) || 0;\n        return `${this.cacheId}-${modificationId}`;\n    }\n    addNodeToCache(node, lastCacheUpdate = true) {\n        if (node.identifierAttribute) {\n            const identifier = node.identifier;\n            if (!this.cache.has(identifier)) {\n                this.cache.set(identifier, observable.array([], mobxShallow));\n            }\n            const set = this.cache.get(identifier);\n            if (set.indexOf(node) !== -1) {\n                throw fail(`Already registered`);\n            }\n            set.push(node);\n            if (lastCacheUpdate) {\n                this.updateLastCacheModificationPerId(identifier);\n            }\n        }\n    }\n    mergeCache(node) {\n        values(node.identifierCache.cache).forEach(nodes => nodes.forEach(child => {\n            this.addNodeToCache(child);\n        }));\n    }\n    notifyDied(node) {\n        if (node.identifierAttribute) {\n            const id = node.identifier;\n            const set = this.cache.get(id);\n            if (set) {\n                set.remove(node);\n                // remove empty sets from cache\n                if (!set.length) {\n                    this.cache.delete(id);\n                }\n                this.updateLastCacheModificationPerId(node.identifier);\n            }\n        }\n    }\n    splitCache(splitNode) {\n        const newCache = new IdentifierCache();\n        // The slash is added here so we only match children of the splitNode. In version 5.1.8 and\n        // earlier there was no trailing slash, so non children that started with the same path string\n        // were being matched incorrectly.\n        const basePath = splitNode.path + \"/\";\n        entries(this.cache).forEach(([id, nodes]) => {\n            let modified = false;\n            for (let i = nodes.length - 1; i >= 0; i--) {\n                const node = nodes[i];\n                if (node === splitNode || node.path.indexOf(basePath) === 0) {\n                    newCache.addNodeToCache(node, false); // no need to update lastUpdated since it is a whole new cache\n                    nodes.splice(i, 1);\n                    // remove empty sets from cache\n                    if (!nodes.length) {\n                        this.cache.delete(id);\n                    }\n                    modified = true;\n                }\n            }\n            if (modified) {\n                this.updateLastCacheModificationPerId(id);\n            }\n        });\n        return newCache;\n    }\n    has(type, identifier) {\n        const set = this.cache.get(identifier);\n        if (!set) {\n            return false;\n        }\n        return set.some(candidate => type.isAssignableFrom(candidate.type));\n    }\n    resolve(type, identifier) {\n        const set = this.cache.get(identifier);\n        if (!set) {\n            return null;\n        }\n        const matches = set.filter(candidate => type.isAssignableFrom(candidate.type));\n        switch (matches.length) {\n            case 0:\n                return null;\n            case 1:\n                return matches[0];\n            default:\n                throw fail(`Cannot resolve a reference to type '${type.name}' with id: '${identifier}' unambigously, there are multiple candidates: ${matches\n                    .map(n => n.path)\n                    .join(\", \")}`);\n        }\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction createObjectNode(type, parent, subpath, environment, initialValue) {\n    const existingNode = getStateTreeNodeSafe(initialValue);\n    if (existingNode) {\n        if (existingNode.parent) {\n            // istanbul ignore next\n            throw fail(`Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '${parent ? parent.path : \"\"}/${subpath}', but it lives already at '${existingNode.path}'`);\n        }\n        if (parent) {\n            existingNode.setParent(parent, subpath);\n        }\n        // else it already has no parent since it is a pre-requisite\n        return existingNode;\n    }\n    // not a node, a snapshot\n    return new ObjectNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction createScalarNode(type, parent, subpath, environment, initialValue) {\n    return new ScalarNode(type, parent, subpath, environment, initialValue);\n}\n/**\n * @internal\n * @hidden\n */\nfunction isNode(value) {\n    return value instanceof ScalarNode || value instanceof ObjectNode;\n}\n\n/**\n * @internal\n * @hidden\n */\nvar NodeLifeCycle;\n(function (NodeLifeCycle) {\n    NodeLifeCycle[NodeLifeCycle[\"INITIALIZING\"] = 0] = \"INITIALIZING\";\n    NodeLifeCycle[NodeLifeCycle[\"CREATED\"] = 1] = \"CREATED\";\n    NodeLifeCycle[NodeLifeCycle[\"FINALIZED\"] = 2] = \"FINALIZED\";\n    NodeLifeCycle[NodeLifeCycle[\"DETACHING\"] = 3] = \"DETACHING\";\n    NodeLifeCycle[NodeLifeCycle[\"DEAD\"] = 4] = \"DEAD\"; // no coming back from this one\n})(NodeLifeCycle || (NodeLifeCycle = {}));\n/**\n * Returns true if the given value is a node in a state tree.\n * More precisely, that is, if the value is an instance of a\n * `types.model`, `types.array` or `types.map`.\n *\n * @param value\n * @returns true if the value is a state tree node.\n */\nfunction isStateTreeNode(value) {\n    return !!(value && value.$treenode);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsStateTreeNode(value, argNumber) {\n    assertArg(value, isStateTreeNode, \"mobx-state-tree node\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNode(value) {\n    if (!isStateTreeNode(value)) {\n        // istanbul ignore next\n        throw fail(`Value ${value} is no MST Node`);\n    }\n    return value.$treenode;\n}\n/**\n * @internal\n * @hidden\n */\nfunction getStateTreeNodeSafe(value) {\n    return (value && value.$treenode) || null;\n}\n/**\n * @internal\n * @hidden\n */\nfunction toJSON() {\n    return getStateTreeNode(this).snapshot;\n}\nconst doubleDot = (_) => \"..\";\n/**\n * @internal\n * @hidden\n */\nfunction getRelativePathBetweenNodes(base, target) {\n    // PRE condition target is (a child of) base!\n    if (base.root !== target.root) {\n        throw fail(`Cannot calculate relative path: objects '${base}' and '${target}' are not part of the same object tree`);\n    }\n    const baseParts = splitJsonPath(base.path);\n    const targetParts = splitJsonPath(target.path);\n    let common = 0;\n    for (; common < baseParts.length; common++) {\n        if (baseParts[common] !== targetParts[common]) {\n            break;\n        }\n    }\n    // TODO: assert that no targetParts paths are \"..\", \".\" or \"\"!\n    return (baseParts.slice(common).map(doubleDot).join(\"/\") +\n        joinJsonPath(targetParts.slice(common)));\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPath(base, path, failIfResolveFails = true) {\n    return resolveNodeByPathParts(base, splitJsonPath(path), failIfResolveFails);\n}\n/**\n * @internal\n * @hidden\n */\nfunction resolveNodeByPathParts(base, pathParts, failIfResolveFails = true) {\n    let current = base;\n    try {\n        for (let i = 0; i < pathParts.length; i++) {\n            const part = pathParts[i];\n            if (part === \"..\") {\n                current = current.parent;\n                if (current) {\n                    continue;\n                } // not everything has a parent\n            }\n            else if (part === \".\") {\n                continue;\n            }\n            else if (current) {\n                if (current instanceof ScalarNode) {\n                    // check if the value of a scalar resolves to a state tree node (e.g. references)\n                    // then we can continue resolving...\n                    const value = current.value;\n                    if (isStateTreeNode(value)) {\n                        current = getStateTreeNode(value);\n                        // fall through\n                    }\n                }\n                if (current instanceof ObjectNode) {\n                    const subType = current.getChildType(part);\n                    if (subType) {\n                        current = current.getChildNode(part);\n                        if (current) {\n                            continue;\n                        }\n                    }\n                }\n            }\n            throw fail(`Could not resolve '${part}' in path '${joinJsonPath(pathParts.slice(0, i)) || \"/\"}' while resolving '${joinJsonPath(pathParts)}'`);\n        }\n    }\n    catch (e) {\n        if (!failIfResolveFails) {\n            return undefined;\n        }\n        throw e;\n    }\n    return current;\n}\n/**\n * @internal\n * @hidden\n */\nfunction convertChildNodesToArray(childNodes) {\n    if (!childNodes) {\n        return EMPTY_ARRAY;\n    }\n    const keys = Object.keys(childNodes);\n    if (!keys.length) {\n        return EMPTY_ARRAY;\n    }\n    const result = new Array(keys.length);\n    keys.forEach((key, index) => {\n        result[index] = childNodes[key];\n    });\n    return result;\n}\n\n// based on: https://github.com/mobxjs/mobx-utils/blob/master/src/async-action.ts\n/*\n    All contents of this file are deprecated.\n\n    The term `process` has been replaced with `flow` to avoid conflicts with the\n    global `process` object.\n\n    Refer to `flow.ts` for any further changes to this implementation.\n*/\nconst DEPRECATION_MESSAGE = \"See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information. \" +\n    \"Note that the middleware event types starting with `process` now start with `flow`.\";\n/**\n * @hidden\n *\n * @deprecated has been renamed to `flow()`.\n * See https://github.com/mobxjs/mobx-state-tree/issues/399 for more information.\n * Note that the middleware event types starting with `process` now start with `flow`.\n *\n * @returns {Promise}\n */\nfunction process$1(asyncAction) {\n    deprecated(\"process\", \"`process()` has been renamed to `flow()`. \" + DEPRECATION_MESSAGE);\n    return flow(asyncAction);\n}\n\nconst plainObjectString = Object.toString();\n/**\n * @internal\n * @hidden\n */\nconst EMPTY_ARRAY = Object.freeze([]);\n/**\n * @internal\n * @hidden\n */\nconst EMPTY_OBJECT = Object.freeze({});\n/**\n * @internal\n * @hidden\n */\nconst mobxShallow = _getGlobalState().useProxies\n    ? { deep: false }\n    : { deep: false, proxy: false };\nObject.freeze(mobxShallow);\n/**\n * @internal\n * @hidden\n */\nfunction fail(message = \"Illegal state\") {\n    return new Error(\"[mobx-state-tree] \" + message);\n}\n/**\n * @internal\n * @hidden\n */\nfunction identity(_) {\n    return _;\n}\n/**\n * @internal\n * @hidden\n */\nconst isInteger = Number.isInteger;\n/**\n * @internal\n * @hidden\n */\nfunction isFloat(val) {\n    return Number(val) === val && val % 1 !== 0;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isFinite(val) {\n    return Number.isFinite(val);\n}\n/**\n * @internal\n * @hidden\n */\nfunction isArray(val) {\n    return Array.isArray(val) || isObservableArray(val);\n}\n/**\n * @internal\n * @hidden\n */\nfunction asArray(val) {\n    if (!val) {\n        return EMPTY_ARRAY;\n    }\n    if (isArray(val)) {\n        return val;\n    }\n    return [val];\n}\n/**\n * @internal\n * @hidden\n */\nfunction extend(a, ...b) {\n    for (let i = 0; i < b.length; i++) {\n        const current = b[i];\n        for (const key in current) {\n            a[key] = current[key];\n        }\n    }\n    return a;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPlainObject(value) {\n    if (value === null || typeof value !== \"object\") {\n        return false;\n    }\n    const proto = Object.getPrototypeOf(value);\n    if (proto == null) {\n        return true;\n    }\n    return proto.constructor?.toString() === plainObjectString;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isMutable(value) {\n    return (value !== null &&\n        typeof value === \"object\" &&\n        !(value instanceof Date) &&\n        !(value instanceof RegExp));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isPrimitive(value, includeDate = true) {\n    return (value === null ||\n        value === undefined ||\n        typeof value === \"string\" ||\n        typeof value === \"number\" ||\n        typeof value === \"boolean\" ||\n        (includeDate && value instanceof Date));\n}\n/**\n * @internal\n * @hidden\n * Freeze a value and return it (if not in production)\n */\nfunction freeze(value) {\n    if (!devMode()) {\n        return value;\n    }\n    return isPrimitive(value) || isObservableArray(value)\n        ? value\n        : Object.freeze(value);\n}\n/**\n * @internal\n * @hidden\n * Recursively freeze a value (if not in production)\n */\nfunction deepFreeze(value) {\n    if (!devMode()) {\n        return value;\n    }\n    freeze(value);\n    if (isPlainObject(value)) {\n        Object.keys(value).forEach(propKey => {\n            if (!isPrimitive(value[propKey]) &&\n                !Object.isFrozen(value[propKey])) {\n                deepFreeze(value[propKey]);\n            }\n        });\n    }\n    return value;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isSerializable(value) {\n    return typeof value !== \"function\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction defineProperty(object, key, descriptor) {\n    isObservableObject(object)\n        ? defineProperty$1(object, key, descriptor)\n        : Object.defineProperty(object, key, descriptor);\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenFinalProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: false,\n        configurable: true,\n        value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nfunction addHiddenWritableProp(object, propName, value) {\n    defineProperty(object, propName, {\n        enumerable: false,\n        writable: true,\n        configurable: true,\n        value\n    });\n}\n/**\n * @internal\n * @hidden\n */\nclass EventHandler {\n    handlers = [];\n    emitting = false;\n    pendingUnregisters = null;\n    get hasSubscribers() {\n        return this.handlers.length > 0;\n    }\n    register(fn, atTheBeginning = false) {\n        if (atTheBeginning) {\n            this.handlers.unshift(fn);\n        }\n        else {\n            this.handlers.push(fn);\n        }\n        return () => {\n            this.unregister(fn);\n        };\n    }\n    has(fn) {\n        return this.handlers.indexOf(fn) >= 0;\n    }\n    unregister(fn) {\n        if (this.emitting) {\n            // defer unregistration until emit is done\n            if (!this.pendingUnregisters) {\n                this.pendingUnregisters = [];\n            }\n            this.pendingUnregisters.push(fn);\n            return;\n        }\n        const index = this.handlers.indexOf(fn);\n        if (index >= 0) {\n            this.handlers.splice(index, 1);\n        }\n    }\n    clear() {\n        this.handlers.length = 0;\n    }\n    emit(...args) {\n        // use emitting flag to defer unregistrations instead of copying array\n        this.emitting = true;\n        try {\n            for (const f of this.handlers) {\n                f(...args);\n            }\n        }\n        finally {\n            this.emitting = false;\n            // process any deferred unregistrations\n            if (this.pendingUnregisters) {\n                for (const fn of this.pendingUnregisters) {\n                    const index = this.handlers.indexOf(fn);\n                    if (index >= 0) {\n                        this.handlers.splice(index, 1);\n                    }\n                }\n                this.pendingUnregisters = null;\n            }\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass EventHandlers {\n    eventHandlers;\n    hasSubscribers(event) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        return !!handler && handler.hasSubscribers;\n    }\n    register(event, fn, atTheBeginning = false) {\n        if (!this.eventHandlers) {\n            this.eventHandlers = {};\n        }\n        let handler = this.eventHandlers[event];\n        if (!handler) {\n            handler = this.eventHandlers[event] = new EventHandler();\n        }\n        return handler.register(fn, atTheBeginning);\n    }\n    has(event, fn) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        return !!handler && handler.has(fn);\n    }\n    unregister(event, fn) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        if (handler) {\n            handler.unregister(fn);\n        }\n    }\n    clear(event) {\n        if (this.eventHandlers) {\n            delete this.eventHandlers[event];\n        }\n    }\n    clearAll() {\n        this.eventHandlers = undefined;\n    }\n    emit(event, ...args) {\n        const handler = this.eventHandlers && this.eventHandlers[event];\n        if (handler) {\n            handler.emit(...args);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction argsToArray(args) {\n    const res = new Array(args.length);\n    for (let i = 0; i < args.length; i++) {\n        res[i] = args[i];\n    }\n    return res;\n}\n/**\n * @internal\n * @hidden\n */\nfunction stringStartsWith(str, beginning) {\n    return str.indexOf(beginning) === 0;\n}\n/**\n * @internal\n * @hidden\n */\nconst deprecated = function (id, message) {\n    // skip if running production\n    if (!devMode()) {\n        return;\n    }\n    // warn if hasn't been warned before\n    if (deprecated.ids && !deprecated.ids.hasOwnProperty(id)) {\n        warnError(\"Deprecation warning: \" + message);\n    }\n    // mark as warned to avoid duplicate warn message\n    if (deprecated.ids) {\n        deprecated.ids[id] = true;\n    }\n};\ndeprecated.ids = {};\n/**\n * @internal\n * @hidden\n */\nfunction warnError(msg) {\n    console.warn(new Error(`[mobx-state-tree] ${msg}`));\n}\n/**\n * @internal\n * @hidden\n */\nfunction isTypeCheckingEnabled() {\n    return (devMode() ||\n        (typeof process !== \"undefined\" &&\n            process.env &&\n            process.env.ENABLE_TYPE_CHECK === \"true\"));\n}\nlet _devMode = process.env.NODE_ENV !== \"production\";\n/**\n * @internal\n * @hidden\n */\nfunction devMode() {\n    return _devMode;\n}\n/**\n * @internal\n * @hidden\n */\nfunction setDevMode(value) {\n    _devMode = value;\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertArg(value, fn, typeName, argNumber) {\n    if (devMode()) {\n        if (!fn(value)) {\n            // istanbul ignore next\n            throw fail(`expected ${typeName} as argument ${asArray(argNumber).join(\" or \")}, got ${value} instead`);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsFunction(value, argNumber) {\n    assertArg(value, fn => typeof fn === \"function\", \"function\", argNumber);\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsNumber(value, argNumber, min, max) {\n    assertArg(value, n => typeof n === \"number\", \"number\", argNumber);\n    {\n        assertArg(value, n => n >= min, `number greater than ${min}`, argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsString(value, argNumber, canBeEmpty = true) {\n    assertArg(value, s => typeof s === \"string\", \"string\", argNumber);\n    if (!canBeEmpty) {\n        assertArg(value, s => s !== \"\", \"not empty string\", argNumber);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nfunction setImmediateWithFallback(fn) {\n    if (typeof queueMicrotask === \"function\") {\n        queueMicrotask(fn);\n    }\n    else if (typeof setImmediate === \"function\") {\n        setImmediate(fn);\n    }\n    else {\n        setTimeout(fn, 1);\n    }\n}\n\n/**\n * See [asynchronous actions](concepts/async-actions.md).\n *\n * @returns The flow as a promise.\n */\nfunction flow(generator) {\n    return createFlowSpawner(generator.name, generator);\n}\n/**\n * @deprecated Not needed since TS3.6.\n * Used for TypeScript to make flows that return a promise return the actual promise result.\n *\n * @param val\n * @returns\n */\nfunction castFlowReturn(val) {\n    return val;\n}\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise-returning function to a generator-returning one.\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n * const getDataGen = toGeneratorFunction(getDataAsync);\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* getDataGen(\"input value\");\n *     ...\n *   })\n * }))\n * ```\n */\nfunction toGeneratorFunction(p) {\n    return function* (...args) {\n        return (yield p(...args));\n    };\n}\n/**\n * @experimental\n * experimental api - might change on minor/patch releases\n *\n * Convert a promise to a generator yielding that promise\n * This is intended to allow for usage of `yield*` in async actions to\n * retain the promise return type.\n *\n * Example:\n * ```ts\n * function getDataAsync(input: string): Promise<number> { ... }\n *\n * const someModel.actions(self => ({\n *   someAction: flow(function*() {\n *     // value is typed as number\n *     const value = yield* toGenerator(getDataAsync(\"input value\"));\n *     ...\n *   })\n * }))\n * ```\n */\nfunction* toGenerator(p) {\n    return (yield p);\n}\n/**\n * @internal\n * @hidden\n */\nfunction createFlowSpawner(name, generator) {\n    const spawner = function flowSpawner() {\n        // Implementation based on https://github.com/tj/co/blob/master/index.js\n        const runId = getNextActionId();\n        const parentContext = getCurrentActionContext();\n        if (!parentContext) {\n            throw fail(\"a mst flow must always have a parent context\");\n        }\n        const parentActionContext = getParentActionContext(parentContext);\n        if (!parentActionContext) {\n            throw fail(\"a mst flow must always have a parent action context\");\n        }\n        const contextBase = {\n            name,\n            id: runId,\n            tree: parentContext.tree,\n            context: parentContext.context,\n            parentId: parentContext.id,\n            allParentIds: [...parentContext.allParentIds, parentContext.id],\n            rootId: parentContext.rootId,\n            parentEvent: parentContext,\n            parentActionEvent: parentActionContext\n        };\n        const args = arguments;\n        function wrap(fn, type, arg) {\n            fn.$mst_middleware = spawner.$mst_middleware; // pick up any middleware attached to the flow\n            return runWithActionContext({\n                ...contextBase,\n                type,\n                args: [arg]\n            }, fn);\n        }\n        return new Promise(function (resolve, reject) {\n            let gen;\n            const init = function asyncActionInit() {\n                gen = generator.apply(null, arguments);\n                onFulfilled(undefined); // kick off the flow\n            };\n            init.$mst_middleware = spawner.$mst_middleware;\n            runWithActionContext({\n                ...contextBase,\n                type: \"flow_spawn\",\n                args: argsToArray(args)\n            }, init);\n            function onFulfilled(res) {\n                let ret;\n                try {\n                    // prettier-ignore\n                    const cancelError = wrap((r) => { ret = gen.next(r); }, \"flow_resume\", res);\n                    if (cancelError instanceof Error) {\n                        ret = gen.throw(cancelError);\n                    }\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n                return;\n            }\n            function onRejected(err) {\n                let ret;\n                try {\n                    // prettier-ignore\n                    wrap((r) => { ret = gen.throw(r); }, \"flow_resume_error\", err); // or yieldError?\n                }\n                catch (e) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { reject(e); }, \"flow_throw\", e);\n                    });\n                    return;\n                }\n                next(ret);\n            }\n            function next(ret) {\n                if (ret.done) {\n                    // prettier-ignore\n                    setImmediateWithFallback(() => {\n                        wrap((r) => { resolve(r); }, \"flow_return\", ret.value);\n                    });\n                    return;\n                }\n                // TODO: support more type of values? See https://github.com/tj/co/blob/249bbdc72da24ae44076afd716349d2089b31c4c/index.js#L100\n                if (!ret.value || typeof ret.value.then !== \"function\") {\n                    // istanbul ignore next\n                    throw fail(\"Only promises can be yielded to `async`, got: \" + ret);\n                }\n                return ret.value.then(onFulfilled, onRejected);\n            }\n        });\n    };\n    spawner._isFlowAction = true;\n    return spawner;\n}\n\n/**\n * @internal\n * @hidden\n */\nfunction splitPatch(patch) {\n    if (!(\"oldValue\" in patch)) {\n        throw fail(`Patches without \\`oldValue\\` field cannot be inversed`);\n    }\n    return [stripPatch(patch), invertPatch(patch)];\n}\n/**\n * @internal\n * @hidden\n */\nfunction stripPatch(patch) {\n    // strips `oldvalue` information from the patch, so that it becomes a patch conform the json-patch spec\n    // this removes the ability to undo the patch\n    switch (patch.op) {\n        case \"add\":\n            return { op: \"add\", path: patch.path, value: patch.value };\n        case \"remove\":\n            return { op: \"remove\", path: patch.path };\n        case \"replace\":\n            return { op: \"replace\", path: patch.path, value: patch.value };\n    }\n}\nfunction invertPatch(patch) {\n    switch (patch.op) {\n        case \"add\":\n            return {\n                op: \"remove\",\n                path: patch.path\n            };\n        case \"remove\":\n            return {\n                op: \"add\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n        case \"replace\":\n            return {\n                op: \"replace\",\n                path: patch.path,\n                value: patch.oldValue\n            };\n    }\n}\n/**\n * Simple simple check to check it is a number.\n */\nfunction isNumber(x) {\n    return typeof x === \"number\";\n}\n/**\n * Escape slashes and backslashes.\n *\n * http://tools.ietf.org/html/rfc6901\n */\nfunction escapeJsonPath(path) {\n    if (isNumber(path) === true) {\n        return \"\" + path;\n    }\n    if (path.indexOf(\"/\") === -1 && path.indexOf(\"~\") === -1) {\n        return path;\n    }\n    return path.replace(/~/g, \"~0\").replace(/\\//g, \"~1\");\n}\n/**\n * Unescape slashes and backslashes.\n */\nfunction unescapeJsonPath(path) {\n    return path.replace(/~1/g, \"/\").replace(/~0/g, \"~\");\n}\n/**\n * Generates a json-path compliant json path from path parts.\n *\n * @param path\n * @returns\n */\nfunction joinJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    if (path.length === 0) {\n        return \"\";\n    }\n    const getPathStr = (p) => p.map(escapeJsonPath).join(\"/\");\n    if (path[0] === \".\" || path[0] === \"..\") {\n        // relative\n        return getPathStr(path);\n    }\n    else {\n        // absolute\n        return \"/\" + getPathStr(path);\n    }\n}\n/**\n * Splits and decodes a json path into several parts.\n *\n * @param path\n * @returns\n */\nfunction splitJsonPath(path) {\n    // `/` refers to property with an empty name, while `` refers to root itself!\n    const parts = path.split(\"/\").map(unescapeJsonPath);\n    const valid = path === \"\" ||\n        path === \".\" ||\n        path === \"..\" ||\n        stringStartsWith(path, \"/\") ||\n        stringStartsWith(path, \"./\") ||\n        stringStartsWith(path, \"../\");\n    if (!valid) {\n        throw fail(`a json path must be either rooted, empty or relative, but got '${path}'`);\n    }\n    // '/a/b/c' -> [\"a\", \"b\", \"c\"]\n    // '../../b/c' -> [\"..\", \"..\", \"b\", \"c\"]\n    // '' -> []\n    // '/' -> ['']\n    // './a' -> [\".\", \"a\"]\n    // /./a' -> [\".\", \"a\"] equivalent to './a'\n    if (parts[0] === \"\") {\n        parts.shift();\n    }\n    return parts;\n}\n\n/** @hidden */\nconst $preProcessorFailed = Symbol(\"$preProcessorFailed\");\nclass SnapshotProcessor extends BaseType {\n    _subtype;\n    _processors;\n    get flags() {\n        return this._subtype.flags | TypeFlags.SnapshotProcessor;\n    }\n    constructor(_subtype, _processors, name) {\n        super(name || _subtype.name);\n        this._subtype = _subtype;\n        this._processors = _processors;\n    }\n    describe() {\n        return `snapshotProcessor(${this._subtype.describe()})`;\n    }\n    preProcessSnapshot(sn) {\n        if (this._processors.preProcessor) {\n            return this._processors.preProcessor.call(null, sn);\n        }\n        return sn;\n    }\n    preProcessSnapshotSafe(sn) {\n        try {\n            return this.preProcessSnapshot(sn);\n        }\n        catch (e) {\n            return $preProcessorFailed;\n        }\n    }\n    postProcessSnapshot(sn, node) {\n        if (this._processors.postProcessor) {\n            return this._processors.postProcessor.call(null, sn, node.storedValue);\n        }\n        return sn;\n    }\n    _fixNode(node) {\n        // the node has to use these methods rather than the original type ones\n        proxyNodeTypeMethods(node.type, this, \"create\");\n        if (node instanceof ObjectNode) {\n            node.hasSnapshotPostProcessor = !!this._processors.postProcessor;\n        }\n        const oldGetSnapshot = node.getSnapshot;\n        node.getSnapshot = () => this.postProcessSnapshot(oldGetSnapshot.call(node), node);\n        if (!isUnionType(this._subtype)) {\n            node.getReconciliationType = () => {\n                return this;\n            };\n        }\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const processedInitialValue = isStateTreeNode(initialValue)\n            ? initialValue\n            : this.preProcessSnapshot(initialValue);\n        const node = this._subtype.instantiate(parent, subpath, environment, processedInitialValue);\n        this._fixNode(node);\n        return node;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const node = this._subtype.reconcile(current, isStateTreeNode(newValue) ? newValue : this.preProcessSnapshot(newValue), parent, subpath);\n        if (node !== current) {\n            this._fixNode(node);\n        }\n        return node;\n    }\n    getSnapshot(node, applyPostProcess = true) {\n        const sn = this._subtype.getSnapshot(node);\n        return applyPostProcess ? this.postProcessSnapshot(sn, node) : sn;\n    }\n    isValidSnapshot(value, context) {\n        const processedSn = this.preProcessSnapshotSafe(value);\n        if (processedSn === $preProcessorFailed) {\n            return typeCheckFailure(context, value, \"Failed to preprocess value\");\n        }\n        return this._subtype.validate(processedSn, context);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n    is(thing) {\n        const value = isType(thing)\n            ? this._subtype\n            : isStateTreeNode(thing)\n                ? getSnapshot(thing, false)\n                : this.preProcessSnapshotSafe(thing);\n        if (value === $preProcessorFailed) {\n            return false;\n        }\n        return (this._subtype.validate(value, [{ path: \"\", type: this._subtype }])\n            .length === 0);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    isMatchingSnapshotId(current, snapshot) {\n        if (!(this._subtype instanceof ComplexType)) {\n            return false;\n        }\n        const processedSn = this.preProcessSnapshot(snapshot);\n        return this._subtype.isMatchingSnapshotId(current, processedSn);\n    }\n}\nfunction proxyNodeTypeMethods(nodeType, snapshotProcessorType, ...methods) {\n    for (const method of methods) {\n        nodeType[method] = snapshotProcessorType[method].bind(snapshotProcessorType);\n    }\n}\n/**\n * `types.snapshotProcessor` - Runs a pre/post snapshot processor before/after serializing a given type.\n *\n * Example:\n * ```ts\n * const Todo1 = types.model({ text: types.string })\n * // in the backend the text type must be null when empty\n * interface BackendTodo {\n *     text: string | null\n * }\n *\n * const Todo2 = types.snapshotProcessor(Todo1, {\n *     // from snapshot to instance\n *     preProcessor(snapshot: BackendTodo) {\n *         return {\n *             text: sn.text || \"\";\n *         }\n *     },\n *\n *     // from instance to snapshot\n *     postProcessor(snapshot, node): BackendTodo {\n *         return {\n *             text: !sn.text ? null : sn.text\n *         }\n *     }\n * })\n * ```\n *\n * @param type Type to run the processors over.\n * @param processors Processors to run.\n * @param name Type name, or undefined to inherit the inner type one.\n * @returns\n */\nfunction snapshotProcessor(type, processors, name) {\n    assertIsType(type, 1);\n    if (devMode()) {\n        if (processors.postProcessor &&\n            typeof processors.postProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"postSnapshotProcessor must be a function\");\n        }\n        if (processors.preProcessor &&\n            typeof processors.preProcessor !== \"function\") {\n            // istanbul ignore next\n            throw fail(\"preSnapshotProcessor must be a function\");\n        }\n    }\n    return new SnapshotProcessor(type, processors, name);\n}\n\nconst needsIdentifierError = `Map.put can only be used to store complex values that have an identifier type attribute`;\nfunction tryCollectModelTypes(type, modelTypes) {\n    const subtypes = type.getSubTypes();\n    if (subtypes === cannotDetermineSubtype) {\n        return false;\n    }\n    if (subtypes) {\n        const subtypesArray = asArray(subtypes);\n        for (const subtype of subtypesArray) {\n            if (!tryCollectModelTypes(subtype, modelTypes)) {\n                return false;\n            }\n        }\n    }\n    if (type instanceof ModelType) {\n        modelTypes.push(type);\n    }\n    return true;\n}\n/**\n * @internal\n * @hidden\n */\nvar MapIdentifierMode;\n(function (MapIdentifierMode) {\n    MapIdentifierMode[MapIdentifierMode[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n    MapIdentifierMode[MapIdentifierMode[\"YES\"] = 1] = \"YES\";\n    MapIdentifierMode[MapIdentifierMode[\"NO\"] = 2] = \"NO\";\n})(MapIdentifierMode || (MapIdentifierMode = {}));\nclass MSTMap extends ObservableMap {\n    constructor(initialData, name) {\n        super(initialData, observable.ref.enhancer, name);\n    }\n    get(key) {\n        // maybe this is over-enthousiastic? normalize numeric keys to strings\n        return super.get(\"\" + key);\n    }\n    has(key) {\n        return super.has(\"\" + key);\n    }\n    delete(key) {\n        return super.delete(\"\" + key);\n    }\n    set(key, value) {\n        return super.set(\"\" + key, value);\n    }\n    put(value) {\n        if (!value) {\n            throw fail(`Map.put cannot be used to set empty values`);\n        }\n        if (isStateTreeNode(value)) {\n            const node = getStateTreeNode(value);\n            if (devMode()) {\n                if (!node.identifierAttribute) {\n                    throw fail(needsIdentifierError);\n                }\n            }\n            if (node.identifier === null) {\n                throw fail(needsIdentifierError);\n            }\n            this.set(node.identifier, value);\n            return value;\n        }\n        else if (!isMutable(value)) {\n            throw fail(`Map.put can only be used to store complex values`);\n        }\n        else {\n            const mapNode = getStateTreeNode(this);\n            const mapType = mapNode.type;\n            if (mapType.identifierMode !== MapIdentifierMode.YES) {\n                throw fail(needsIdentifierError);\n            }\n            const idAttr = mapType.mapIdentifierAttribute;\n            const id = value[idAttr];\n            if (!isValidIdentifier(id)) {\n                // try again but this time after creating a node for the value\n                // since it might be an optional identifier\n                const newNode = this.put(mapType.getChildType().create(value, mapNode.environment));\n                return this.put(getSnapshot(newNode));\n            }\n            const key = normalizeIdentifier(id);\n            this.set(key, value);\n            return this.get(key);\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass MapType extends ComplexType {\n    _subType;\n    identifierMode = MapIdentifierMode.UNKNOWN;\n    mapIdentifierAttribute = undefined;\n    flags = TypeFlags.Map;\n    hookInitializers = [];\n    constructor(name, _subType, hookInitializers = []) {\n        super(name);\n        this._subType = _subType;\n        this._determineIdentifierMode();\n        this.hookInitializers = hookInitializers;\n    }\n    hooks(hooks) {\n        const hookInitializers = this.hookInitializers.length > 0\n            ? this.hookInitializers.concat(hooks)\n            : [hooks];\n        return new MapType(this.name, this._subType, hookInitializers);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        this._determineIdentifierMode();\n        return createObjectNode(this, parent, subpath, environment, initialValue);\n    }\n    _determineIdentifierMode() {\n        if (this.identifierMode !== MapIdentifierMode.UNKNOWN) {\n            return;\n        }\n        const modelTypes = [];\n        if (tryCollectModelTypes(this._subType, modelTypes)) {\n            const identifierAttribute = modelTypes.reduce((current, type) => {\n                if (!type.identifierAttribute) {\n                    return current;\n                }\n                if (current && current !== type.identifierAttribute) {\n                    throw fail(`The objects in a map should all have the same identifier attribute, expected '${current}', but child of type '${type.name}' declared attribute '${type.identifierAttribute}' as identifier`);\n                }\n                return type.identifierAttribute;\n            }, undefined);\n            if (identifierAttribute) {\n                this.identifierMode = MapIdentifierMode.YES;\n                this.mapIdentifierAttribute = identifierAttribute;\n            }\n            else {\n                this.identifierMode = MapIdentifierMode.NO;\n            }\n        }\n    }\n    initializeChildNodes(objNode, initialSnapshot = {}) {\n        const subType = objNode.type._subType;\n        const result = {};\n        Object.keys(initialSnapshot).forEach(name => {\n            result[name] = subType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        return new MSTMap(childNodes, this.name);\n    }\n    finalizeNewInstance(node, instance) {\n        _interceptReads(instance, node.unbox);\n        const type = node.type;\n        type.hookInitializers.forEach(initializer => {\n            const hooks = initializer(instance);\n            Object.keys(hooks).forEach(name => {\n                const hook = hooks[name];\n                const actionInvoker = createActionInvoker(instance, name, hook);\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n            });\n        });\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    describe() {\n        return this.name;\n    }\n    getChildren(node) {\n        // return (node.storedValue as ObservableMap<any>).values()\n        return values(node.storedValue);\n    }\n    getChildNode(node, key) {\n        const childNode = node.storedValue.get(\"\" + key);\n        if (!childNode) {\n            throw fail(\"Not a child \" + key);\n        }\n        return childNode;\n    }\n    willChange(change) {\n        const node = getStateTreeNode(change.object);\n        const key = change.name;\n        node.assertWritable({ subpath: key });\n        const mapType = node.type;\n        const subType = mapType._subType;\n        switch (change.type) {\n            case \"update\":\n                {\n                    const { newValue } = change;\n                    const oldValue = change.object.get(key);\n                    if (newValue === oldValue) {\n                        return null;\n                    }\n                    typecheckInternal(subType, newValue);\n                    change.newValue = subType.reconcile(node.getChildNode(key), change.newValue, node, key);\n                    mapType.processIdentifier(key, change.newValue);\n                }\n                break;\n            case \"add\":\n                {\n                    typecheckInternal(subType, change.newValue);\n                    change.newValue = subType.instantiate(node, key, undefined, change.newValue);\n                    mapType.processIdentifier(key, change.newValue);\n                }\n                break;\n        }\n        return change;\n    }\n    processIdentifier(expected, node) {\n        if (this.identifierMode === MapIdentifierMode.YES &&\n            node instanceof ObjectNode) {\n            const identifier = node.identifier;\n            if (identifier !== expected) {\n                throw fail(`A map of objects containing an identifier should always store the object under their own identifier. Trying to store key '${identifier}', but expected: '${expected}'`);\n            }\n        }\n    }\n    getSnapshot(node) {\n        const res = {};\n        node.getChildren().forEach(childNode => {\n            res[childNode.subpath] = childNode.snapshot;\n        });\n        return res;\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = {};\n        Object.keys(childNodes).forEach(key => {\n            processed[key] = childNodes[key].getSnapshot();\n        });\n        return processed;\n    }\n    didChange(change) {\n        const node = getStateTreeNode(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: escapeJsonPath(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"add\":\n                return void node.emitPatch({\n                    op: \"add\",\n                    path: escapeJsonPath(change.name),\n                    value: change.newValue.snapshot,\n                    oldValue: undefined\n                }, node);\n            case \"delete\":\n                // a node got deleted, get the old snapshot and make the node die\n                const oldSnapshot = change.oldValue.snapshot;\n                change.oldValue.die();\n                // emit the patch\n                return void node.emitPatch({\n                    op: \"remove\",\n                    path: escapeJsonPath(change.name),\n                    oldValue: oldSnapshot\n                }, node);\n        }\n    }\n    applyPatchLocally(node, subpath, patch) {\n        const target = node.storedValue;\n        switch (patch.op) {\n            case \"add\":\n            case \"replace\":\n                target.set(subpath, patch.value);\n                break;\n            case \"remove\":\n                target.delete(subpath);\n                break;\n        }\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const target = node.storedValue;\n        const currentKeys = {};\n        Array.from(target.keys()).forEach(key => {\n            currentKeys[key] = false;\n        });\n        if (snapshot) {\n            // Don't use target.replace, as it will throw away all existing items first\n            for (const key in snapshot) {\n                target.set(key, snapshot[key]);\n                currentKeys[\"\" + key] = true;\n            }\n        }\n        Object.keys(currentKeys).forEach(key => {\n            if (currentKeys[key] === false) {\n                target.delete(key);\n            }\n        });\n    }\n    getChildType() {\n        return this._subType;\n    }\n    isValidSnapshot(value, context) {\n        if (!isPlainObject(value)) {\n            return typeCheckFailure(context, value, \"Value is not a plain object\");\n        }\n        for (const key of Object.keys(value)) {\n            getContextForPath(context, key, this._subType);\n            const errors = this._subType.validate(value[key], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    getDefaultSnapshot() {\n        return EMPTY_OBJECT;\n    }\n    removeChild(node, subpath) {\n        node.storedValue.delete(subpath);\n    }\n}\nMapType.prototype.applySnapshot = action(MapType.prototype.applySnapshot);\n/**\n * `types.map` - Creates a key based collection type who's children are all of a uniform declared type.\n * If the type stored in a map has an identifier, it is mandatory to store the child under that identifier in the map.\n *\n * This type will always produce [observable maps](https://mobx.js.org/api.html#observablemap)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   id: types.identifier,\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.map(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: {} })\n * unprotect(s)\n * s.todos.set(17, { task: \"Grab coffee\", id: 17 })\n * s.todos.put({ task: \"Grab cookie\", id: 18 }) // put will infer key from the identifier\n * console.log(s.todos.get(17).task) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction map(subtype) {\n    return new MapType(`Map<string, ${subtype.name}>`, subtype);\n}\n/**\n * Returns if a given value represents a map type.\n *\n * @param type\n * @returns `true` if it is a map type.\n */\nfunction isMapType(type) {\n    return isType(type) && (type.flags & TypeFlags.Map) > 0;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass ArrayType extends ComplexType {\n    _subType;\n    flags = TypeFlags.Array;\n    hookInitializers = [];\n    constructor(name, _subType, hookInitializers = []) {\n        super(name);\n        this._subType = _subType;\n        this.hookInitializers = hookInitializers;\n    }\n    hooks(hooks) {\n        const hookInitializers = this.hookInitializers.length > 0\n            ? this.hookInitializers.concat(hooks)\n            : [hooks];\n        return new ArrayType(this.name, this._subType, hookInitializers);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createObjectNode(this, parent, subpath, environment, initialValue);\n    }\n    initializeChildNodes(objNode, snapshot = []) {\n        const subType = objNode.type._subType;\n        const result = {};\n        snapshot.forEach((item, index) => {\n            const subpath = \"\" + index;\n            result[subpath] = subType.instantiate(objNode, subpath, undefined, item);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        const options = { ...mobxShallow, name: this.name };\n        return observable.array(convertChildNodesToArray(childNodes), options);\n    }\n    finalizeNewInstance(node, instance) {\n        _getAdministration(instance).dehancer = node.unbox;\n        const type = node.type;\n        type.hookInitializers.forEach(initializer => {\n            const hooks = initializer(instance);\n            Object.keys(hooks).forEach(name => {\n                const hook = hooks[name];\n                const actionInvoker = createActionInvoker(instance, name, hook);\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(instance, name, actionInvoker);\n            });\n        });\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    describe() {\n        return this.name;\n    }\n    getChildren(node) {\n        return node.storedValue.slice();\n    }\n    getChildNode(node, key) {\n        const index = Number(key);\n        if (index < node.storedValue.length) {\n            return node.storedValue[index];\n        }\n        throw fail(\"Not a child: \" + key);\n    }\n    willChange(change) {\n        const node = getStateTreeNode(change.object);\n        node.assertWritable({ subpath: \"\" + change.index });\n        const subType = node.type._subType;\n        const childNodes = node.getChildren();\n        switch (change.type) {\n            case \"update\":\n                {\n                    if (change.newValue === change.object[change.index]) {\n                        return null;\n                    }\n                    const updatedNodes = reconcileArrayChildren(node, subType, [childNodes[change.index]], [change.newValue], [change.index]);\n                    if (!updatedNodes) {\n                        return null;\n                    }\n                    change.newValue = updatedNodes[0];\n                }\n                break;\n            case \"splice\":\n                {\n                    const { index, removedCount, added } = change;\n                    const addedNodes = reconcileArrayChildren(node, subType, childNodes.slice(index, index + removedCount), added, added.map((_, i) => index + i));\n                    if (!addedNodes) {\n                        return null;\n                    }\n                    change.added = addedNodes;\n                    // update paths of remaining items\n                    for (let i = index + removedCount; i < childNodes.length; i++) {\n                        childNodes[i].setParent(node, \"\" + (i + added.length - removedCount));\n                    }\n                }\n                break;\n        }\n        return change;\n    }\n    getSnapshot(node) {\n        return node.getChildren().map(childNode => childNode.snapshot);\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = [];\n        Object.keys(childNodes).forEach(key => {\n            processed.push(childNodes[key].getSnapshot());\n        });\n        return processed;\n    }\n    didChange(change) {\n        const node = getStateTreeNode(change.object);\n        switch (change.type) {\n            case \"update\":\n                return void node.emitPatch({\n                    op: \"replace\",\n                    path: \"\" + change.index,\n                    value: change.newValue.snapshot,\n                    oldValue: change.oldValue ? change.oldValue.snapshot : undefined\n                }, node);\n            case \"splice\":\n                for (let i = change.removedCount - 1; i >= 0; i--) {\n                    node.emitPatch({\n                        op: \"remove\",\n                        path: \"\" + (change.index + i),\n                        oldValue: change.removed[i].snapshot\n                    }, node);\n                }\n                for (let i = 0; i < change.addedCount; i++) {\n                    node.emitPatch({\n                        op: \"add\",\n                        path: \"\" + (change.index + i),\n                        value: node.getChildNode(\"\" + (change.index + i)).snapshot,\n                        oldValue: undefined\n                    }, node);\n                }\n                return;\n        }\n    }\n    applyPatchLocally(node, subpath, patch) {\n        const target = node.storedValue;\n        const index = subpath === \"-\" ? target.length : Number(subpath);\n        switch (patch.op) {\n            case \"replace\":\n                target[index] = patch.value;\n                break;\n            case \"add\":\n                target.splice(index, 0, patch.value);\n                break;\n            case \"remove\":\n                target.splice(index, 1);\n                break;\n        }\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const target = node.storedValue;\n        target.replace(snapshot);\n    }\n    getChildType() {\n        return this._subType;\n    }\n    isValidSnapshot(value, context) {\n        if (!isArray(value)) {\n            return typeCheckFailure(context, value, \"Value is not an array\");\n        }\n        for (let i = 0; i < value.length; i++) {\n            getContextForPath(context, \"\" + i, this._subType);\n            const errors = this._subType.validate(value[i], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    getDefaultSnapshot() {\n        return EMPTY_ARRAY;\n    }\n    removeChild(node, subpath) {\n        node.storedValue.splice(Number(subpath), 1);\n    }\n}\nArrayType.prototype.applySnapshot = action(ArrayType.prototype.applySnapshot);\n/**\n * `types.array` - Creates an index based collection type who's children are all of a uniform declared type.\n *\n * This type will always produce [observable arrays](https://mobx.js.org/api.html#observablearray)\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   task: types.string\n * })\n *\n * const TodoStore = types.model({\n *   todos: types.array(Todo)\n * })\n *\n * const s = TodoStore.create({ todos: [] })\n * unprotect(s) // needed to allow modifying outside of an action\n * s.todos.push({ task: \"Grab coffee\" })\n * console.log(s.todos[0]) // prints: \"Grab coffee\"\n * ```\n *\n * @param subtype\n * @returns\n */\nfunction array(subtype) {\n    assertIsType(subtype, 1);\n    return new ArrayType(`${subtype.name}[]`, subtype);\n}\nfunction reconcileArrayChildren(parent, childType, oldNodes, newValues, newPaths) {\n    let nothingChanged = true;\n    for (let i = 0;; i++) {\n        const hasNewNode = i <= newValues.length - 1;\n        const oldNode = oldNodes[i];\n        let newValue = hasNewNode ? newValues[i] : undefined;\n        const newPath = \"\" + newPaths[i];\n        // for some reason, instead of newValue we got a node, fallback to the storedValue\n        // TODO: https://github.com/mobxjs/mobx-state-tree/issues/340#issuecomment-325581681\n        if (isNode(newValue)) {\n            newValue = newValue.storedValue;\n        }\n        if (!oldNode && !hasNewNode) {\n            // both are empty, end\n            break;\n        }\n        else if (!hasNewNode) {\n            // new one does not exists\n            nothingChanged = false;\n            oldNodes.splice(i, 1);\n            if (oldNode instanceof ObjectNode) {\n                // since it is going to be returned by pop/splice/shift better create it before killing it\n                // so it doesn't end up in an undead state\n                oldNode.createObservableInstanceIfNeeded();\n            }\n            oldNode.die();\n            i--;\n        }\n        else if (!oldNode) {\n            // there is no old node, create it\n            // check if already belongs to the same parent. if so, avoid pushing item in. only swapping can occur.\n            if (isStateTreeNode(newValue) &&\n                getStateTreeNode(newValue).parent === parent) {\n                // this node is owned by this parent, but not in the reconcilable set, so it must be double\n                throw fail(`Cannot add an object to a state tree if it is already part of the same or another state tree. Tried to assign an object to '${parent.path}/${newPath}', but it lives already at '${getStateTreeNode(newValue).path}'`);\n            }\n            nothingChanged = false;\n            const newNode = valueAsNode(childType, parent, newPath, newValue);\n            oldNodes.splice(i, 0, newNode);\n        }\n        else if (areSame(oldNode, newValue)) {\n            // both are the same, reconcile\n            oldNodes[i] = valueAsNode(childType, parent, newPath, newValue, oldNode);\n        }\n        else {\n            // nothing to do, try to reorder\n            let oldMatch = undefined;\n            // find a possible candidate to reuse\n            for (let j = i; j < oldNodes.length; j++) {\n                if (areSame(oldNodes[j], newValue)) {\n                    oldMatch = oldNodes.splice(j, 1)[0];\n                    break;\n                }\n            }\n            nothingChanged = false;\n            const newNode = valueAsNode(childType, parent, newPath, newValue, oldMatch);\n            oldNodes.splice(i, 0, newNode);\n        }\n    }\n    return nothingChanged ? null : oldNodes;\n}\n/**\n * Convert a value to a node at given parent and subpath. Attempts to reuse old node if possible and given.\n */\nfunction valueAsNode(childType, parent, subpath, newValue, oldNode) {\n    // ensure the value is valid-ish\n    typecheckInternal(childType, newValue);\n    function getNewNode() {\n        // the new value has a MST node\n        if (isStateTreeNode(newValue)) {\n            const childNode = getStateTreeNode(newValue);\n            childNode.assertAlive(EMPTY_OBJECT);\n            // the node lives here\n            if (childNode.parent !== null && childNode.parent === parent) {\n                childNode.setParent(parent, subpath);\n                return childNode;\n            }\n        }\n        // there is old node and new one is a value/snapshot\n        if (oldNode) {\n            return childType.reconcile(oldNode, newValue, parent, subpath);\n        }\n        // nothing to do, create from scratch\n        return childType.instantiate(parent, subpath, undefined, newValue);\n    }\n    const newNode = getNewNode();\n    if (oldNode && oldNode !== newNode) {\n        if (oldNode instanceof ObjectNode) {\n            // since it is going to be returned by pop/splice/shift better create it before killing it\n            // so it doesn't end up in an undead state\n            oldNode.createObservableInstanceIfNeeded();\n        }\n        oldNode.die();\n    }\n    return newNode;\n}\n/**\n * Check if a node holds a value.\n */\nfunction areSame(oldNode, newValue) {\n    // never consider dead old nodes for reconciliation\n    if (!oldNode.isAlive) {\n        return false;\n    }\n    // the new value has the same node\n    if (isStateTreeNode(newValue)) {\n        const newNode = getStateTreeNode(newValue);\n        return newNode.isAlive && newNode === oldNode;\n    }\n    // the provided value is the snapshot of the old node\n    if (oldNode.snapshot === newValue) {\n        return true;\n    }\n    // Non object nodes don't get reconciled\n    if (!(oldNode instanceof ObjectNode)) {\n        return false;\n    }\n    const oldNodeType = oldNode.getReconciliationType();\n    // new value is a snapshot with the correct identifier\n    return (oldNode.identifier !== null &&\n        oldNode.identifierAttribute &&\n        isPlainObject(newValue) &&\n        oldNodeType.is(newValue) &&\n        oldNodeType.isMatchingSnapshotId(oldNode, newValue));\n}\n/**\n * Returns if a given value represents an array type.\n *\n * @param type\n * @returns `true` if the type is an array type.\n */\nfunction isArrayType(type) {\n    return isType(type) && (type.flags & TypeFlags.Array) > 0;\n}\n\nconst PRE_PROCESS_SNAPSHOT = \"preProcessSnapshot\";\nconst POST_PROCESS_SNAPSHOT = \"postProcessSnapshot\";\nfunction objectTypeToString() {\n    return getStateTreeNode(this).toString();\n}\nconst defaultObjectOptions = {\n    name: \"AnonymousModel\",\n    properties: {},\n    initializers: EMPTY_ARRAY\n};\nfunction toPropertiesObject(declaredProps) {\n    const keysList = Object.keys(declaredProps);\n    const alreadySeenKeys = new Set();\n    keysList.forEach(key => {\n        if (alreadySeenKeys.has(key)) {\n            throw fail(`${key} is declared twice in the model. Model should not contain the same keys`);\n        }\n        alreadySeenKeys.add(key);\n    });\n    // loop through properties and ensures that all items are types\n    return keysList.reduce((props, key) => {\n        // warn if user intended a HOOK\n        if (key in Hook) {\n            throw fail(`Hook '${key}' was defined as property. Hooks should be defined as part of the actions`);\n        }\n        // the user intended to use a view\n        const descriptor = Object.getOwnPropertyDescriptor(declaredProps, key);\n        if (\"get\" in descriptor) {\n            throw fail(\"Getters are not supported as properties. Please use views instead\");\n        }\n        // undefined and null are not valid\n        const value = descriptor.value;\n        if (value === null || value === undefined) {\n            throw fail(\"The default value of an attribute cannot be null or undefined as the type cannot be inferred. Did you mean `types.maybe(someType)`?\");\n        }\n        // its a primitive, convert to its type\n        else if (isPrimitive(value)) {\n            props[key] = optional(getPrimitiveFactoryFromValue(value), value);\n        }\n        // map defaults to empty object automatically for models\n        else if (value instanceof MapType) {\n            props[key] = optional(value, {});\n        }\n        else if (value instanceof ArrayType) {\n            props[key] = optional(value, []);\n        }\n        // its already a type\n        else if (isType(value)) ;\n        // its a function, maybe the user wanted a view?\n        else if (devMode() && typeof value === \"function\") {\n            throw fail(`Invalid type definition for property '${key}', it looks like you passed a function. Did you forget to invoke it, or did you intend to declare a view / action?`);\n        }\n        // no other complex values\n        else if (devMode() && typeof value === \"object\") {\n            throw fail(`Invalid type definition for property '${key}', it looks like you passed an object. Try passing another model type or a types.frozen.`);\n        }\n        else {\n            throw fail(`Invalid type definition for property '${key}', cannot infer a type from a value like '${value}' (${typeof value})`);\n        }\n        return props;\n    }, { ...declaredProps });\n}\n/**\n * @internal\n * @hidden\n */\nclass ModelType extends ComplexType {\n    flags = TypeFlags.Object;\n    /*\n     * The original object definition\n     */\n    initializers;\n    properties;\n    preProcessor;\n    postProcessor;\n    propertyNames;\n    constructor(opts) {\n        super(opts.name || defaultObjectOptions.name);\n        Object.assign(this, defaultObjectOptions, opts);\n        // ensures that any default value gets converted to its related type\n        this.properties = toPropertiesObject(this.properties);\n        freeze(this.properties); // make sure nobody messes with it\n        this.propertyNames = Object.keys(this.properties);\n        this.identifierAttribute = this._getIdentifierAttribute();\n    }\n    _getIdentifierAttribute() {\n        let identifierAttribute = undefined;\n        this.forAllProps((propName, propType) => {\n            if (propType.flags & TypeFlags.Identifier) {\n                if (identifierAttribute) {\n                    throw fail(`Cannot define property '${propName}' as object identifier, property '${identifierAttribute}' is already defined as identifier property`);\n                }\n                identifierAttribute = propName;\n            }\n        });\n        return identifierAttribute;\n    }\n    cloneAndEnhance(opts) {\n        return new ModelType({\n            name: opts.name || this.name,\n            properties: Object.assign({}, this.properties, opts.properties),\n            initializers: this.initializers.concat(opts.initializers || []),\n            preProcessor: opts.preProcessor || this.preProcessor,\n            postProcessor: opts.postProcessor || this.postProcessor\n        });\n    }\n    actions(fn) {\n        const actionInitializer = (self) => {\n            this.instantiateActions(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [actionInitializer] });\n    }\n    instantiateActions(self, actions) {\n        // check if return is correct\n        if (!isPlainObject(actions)) {\n            throw fail(`actions initializer should return a plain object containing actions`);\n        }\n        // bind actions to the object created\n        Object.keys(actions).forEach(name => {\n            // warn if preprocessor was given\n            if (name === PRE_PROCESS_SNAPSHOT) {\n                throw fail(`Cannot define action '${PRE_PROCESS_SNAPSHOT}', it should be defined using 'type.preProcessSnapshot(fn)' instead`);\n            }\n            // warn if postprocessor was given\n            if (name === POST_PROCESS_SNAPSHOT) {\n                throw fail(`Cannot define action '${POST_PROCESS_SNAPSHOT}', it should be defined using 'type.postProcessSnapshot(fn)' instead`);\n            }\n            let action2 = actions[name];\n            // apply hook composition\n            const baseAction = self[name];\n            if (name in Hook && baseAction) {\n                const specializedAction = action2;\n                action2 = function () {\n                    baseAction.apply(null, arguments);\n                    specializedAction.apply(null, arguments);\n                };\n            }\n            // the goal of this is to make sure actions using \"this\" can call themselves,\n            // while still allowing the middlewares to register them\n            const middlewares = action2.$mst_middleware; // make sure middlewares are not lost\n            const boundAction = action2.bind(actions);\n            boundAction._isFlowAction =\n                action2._isFlowAction || false;\n            boundAction.$mst_middleware = middlewares;\n            const actionInvoker = createActionInvoker(self, name, boundAction);\n            actions[name] = actionInvoker;\n            (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, name, actionInvoker);\n        });\n    }\n    named = name => {\n        return this.cloneAndEnhance({ name });\n    };\n    props = properties => {\n        return this.cloneAndEnhance({ properties });\n    };\n    volatile(fn) {\n        if (typeof fn !== \"function\") {\n            throw fail(`You passed an ${typeof fn} to volatile state as an argument, when function is expected`);\n        }\n        const stateInitializer = (self) => {\n            this.instantiateVolatileState(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [stateInitializer] });\n    }\n    instantiateVolatileState(self, state) {\n        // check views return\n        if (!isPlainObject(state)) {\n            throw fail(`volatile state initializer should return a plain object containing state`);\n        }\n        set(self, state);\n    }\n    extend(fn) {\n        const initializer = (self) => {\n            const { actions, views, state, ...rest } = fn(self);\n            for (const key in rest) {\n                throw fail(`The \\`extend\\` function should return an object with a subset of the fields 'actions', 'views' and 'state'. Found invalid key '${key}'`);\n            }\n            if (state) {\n                this.instantiateVolatileState(self, state);\n            }\n            if (views) {\n                this.instantiateViews(self, views);\n            }\n            if (actions) {\n                this.instantiateActions(self, actions);\n            }\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [initializer] });\n    }\n    views(fn) {\n        const viewInitializer = (self) => {\n            this.instantiateViews(self, fn(self));\n            return self;\n        };\n        return this.cloneAndEnhance({ initializers: [viewInitializer] });\n    }\n    instantiateViews(self, views) {\n        // check views return\n        if (!isPlainObject(views)) {\n            throw fail(`views initializer should return a plain object containing views`);\n        }\n        Object.getOwnPropertyNames(views).forEach(key => {\n            // is this a computed property?\n            const descriptor = Object.getOwnPropertyDescriptor(views, key);\n            if (\"get\" in descriptor) {\n                defineProperty$1(self, key, descriptor);\n                makeObservable(self, { [key]: computed });\n            }\n            else if (typeof descriptor.value === \"function\") {\n                (!devMode() ? addHiddenFinalProp : addHiddenWritableProp)(self, key, descriptor.value);\n            }\n            else {\n                throw fail(`A view member should either be a function or getter based property`);\n            }\n        });\n    }\n    preProcessSnapshot = preProcessor => {\n        const currentPreprocessor = this.preProcessor;\n        if (!currentPreprocessor) {\n            return this.cloneAndEnhance({ preProcessor });\n        }\n        else {\n            return this.cloneAndEnhance({\n                preProcessor: snapshot => currentPreprocessor(preProcessor(snapshot))\n            });\n        }\n    };\n    postProcessSnapshot = postProcessor => {\n        const currentPostprocessor = this.postProcessor;\n        if (!currentPostprocessor) {\n            return this.cloneAndEnhance({ postProcessor });\n        }\n        else {\n            return this.cloneAndEnhance({\n                postProcessor: snapshot => postProcessor(currentPostprocessor(snapshot))\n            });\n        }\n    };\n    instantiate(parent, subpath, environment, initialValue) {\n        const value = isStateTreeNode(initialValue)\n            ? initialValue\n            : this.applySnapshotPreProcessor(initialValue);\n        return createObjectNode(this, parent, subpath, environment, value);\n        // Optimization: record all prop- view- and action names after first construction, and generate an optimal base class\n        // that pre-reserves all these fields for fast object-member lookups\n    }\n    initializeChildNodes(objNode, initialSnapshot = {}) {\n        const type = objNode.type;\n        const result = {};\n        type.forAllProps((name, childType) => {\n            result[name] = childType.instantiate(objNode, name, undefined, initialSnapshot[name]);\n        });\n        return result;\n    }\n    createNewInstance(childNodes) {\n        const options = { ...mobxShallow, name: this.name };\n        return observable.object(childNodes, EMPTY_OBJECT, options);\n    }\n    finalizeNewInstance(node, instance) {\n        addHiddenFinalProp(instance, \"toString\", objectTypeToString);\n        this.forAllProps(name => {\n            _interceptReads(instance, name, node.unbox);\n        });\n        this.initializers.reduce((self, fn) => fn(self), instance);\n        intercept(instance, this.willChange);\n        observe(instance, this.didChange);\n    }\n    willChange(chg) {\n        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n        const change = chg;\n        const node = getStateTreeNode(change.object);\n        const subpath = change.name;\n        node.assertWritable({ subpath });\n        const childType = node.type.properties[subpath];\n        // only properties are typed, state are stored as-is references\n        if (childType) {\n            typecheckInternal(childType, change.newValue);\n            change.newValue = childType.reconcile(node.getChildNode(subpath), change.newValue, node, subpath);\n        }\n        return change;\n    }\n    didChange(chg) {\n        // TODO: mobx typings don't seem to take into account that newValue can be set even when removing a prop\n        const change = chg;\n        const childNode = getStateTreeNode(change.object);\n        const childType = childNode.type.properties[change.name];\n        if (!childType) {\n            // don't emit patches for volatile state\n            return;\n        }\n        const oldChildValue = change.oldValue ? change.oldValue.snapshot : undefined;\n        childNode.emitPatch({\n            op: \"replace\",\n            path: escapeJsonPath(change.name),\n            value: change.newValue.snapshot,\n            oldValue: oldChildValue\n        }, childNode);\n    }\n    getChildren(node) {\n        const res = [];\n        this.forAllProps(name => {\n            res.push(this.getChildNode(node, name));\n        });\n        return res;\n    }\n    getChildNode(node, key) {\n        if (!(key in this.properties)) {\n            throw fail(\"Not a value property: \" + key);\n        }\n        const adm = _getAdministration(node.storedValue, key);\n        const childNode = adm.raw?.();\n        if (!childNode) {\n            throw fail(\"Node not available for property \" + key);\n        }\n        return childNode;\n    }\n    getSnapshot(node, applyPostProcess = true) {\n        const res = {};\n        this.forAllProps((name, type) => {\n            try {\n                // TODO: FIXME, make sure the observable ref is used!\n                const atom = getAtom(node.storedValue, name);\n                atom.reportObserved();\n            }\n            catch (e) {\n                throw fail(`${name} property is declared twice`);\n            }\n            res[name] = this.getChildNode(node, name).snapshot;\n        });\n        if (applyPostProcess) {\n            return this.applySnapshotPostProcessor(res);\n        }\n        return res;\n    }\n    processInitialSnapshot(childNodes) {\n        const processed = {};\n        Object.keys(childNodes).forEach(key => {\n            processed[key] = childNodes[key].getSnapshot();\n        });\n        return this.applySnapshotPostProcessor(processed);\n    }\n    applyPatchLocally(node, subpath, patch) {\n        if (!(patch.op === \"replace\" || patch.op === \"add\")) {\n            throw fail(`object does not support operation ${patch.op}`);\n        }\n        node.storedValue[subpath] = patch.value;\n    }\n    applySnapshot(node, snapshot) {\n        typecheckInternal(this, snapshot);\n        const preProcessedSnapshot = this.applySnapshotPreProcessor(snapshot);\n        this.forAllProps(name => {\n            node.storedValue[name] = preProcessedSnapshot[name];\n        });\n    }\n    applySnapshotPreProcessor(snapshot) {\n        const processor = this.preProcessor;\n        return processor ? processor.call(null, snapshot) : snapshot;\n    }\n    applySnapshotPostProcessor(snapshot) {\n        const postProcessor = this.postProcessor;\n        if (postProcessor) {\n            return postProcessor.call(null, snapshot);\n        }\n        return snapshot;\n    }\n    getChildType(propertyName) {\n        assertIsString(propertyName, 1);\n        return this.properties[propertyName];\n    }\n    isValidSnapshot(value, context) {\n        const snapshot = this.applySnapshotPreProcessor(value);\n        if (!isPlainObject(snapshot)) {\n            return typeCheckFailure(context, snapshot, \"Value is not a plain object\");\n        }\n        for (const key of this.propertyNames) {\n            const propType = this.properties[key];\n            getContextForPath(context, key, propType);\n            const errors = propType.validate(snapshot[key], context);\n            popContext(context);\n            if (errors.length > 0) {\n                return errors;\n            }\n        }\n        return typeCheckSuccess();\n    }\n    forAllProps(fn) {\n        this.propertyNames.forEach(key => fn(key, this.properties[key]));\n    }\n    describe() {\n        // optimization: cache\n        return (\"{ \" +\n            this.propertyNames\n                .map(key => key + \": \" + this.properties[key].describe())\n                .join(\"; \") +\n            \" }\");\n    }\n    getDefaultSnapshot() {\n        return EMPTY_OBJECT;\n    }\n    removeChild(node, subpath) {\n        node.storedValue[subpath] = undefined;\n    }\n}\nModelType.prototype.applySnapshot = action(ModelType.prototype.applySnapshot);\n/**\n * `types.model` - Creates a new model type by providing a name, properties, volatile state and actions.\n *\n * See the [model type](/concepts/trees#creating-models) description or the [getting started](intro/getting-started.md#getting-started-1) tutorial.\n */\nfunction model(...args) {\n    if (devMode() && typeof args[0] !== \"string\" && args[1]) {\n        throw fail(\"Model creation failed. First argument must be a string when two arguments are provided\");\n    }\n    const name = typeof args[0] === \"string\" ? args.shift() : \"AnonymousModel\";\n    const properties = args.shift() || {};\n    return new ModelType({ name, properties });\n}\n/**\n * `types.compose` - Composes a new model from one or more existing model types.\n * This method can be invoked in two forms:\n * Given 2 or more model types, the types are composed into a new Type.\n * Given first parameter as a string and 2 or more model types,\n * the types are composed into a new Type with the given name\n */\nfunction compose(...args) {\n    // TODO: just join the base type names if no name is provided\n    const hasTypename = typeof args[0] === \"string\";\n    const typeName = hasTypename ? args[0] : \"AnonymousModel\";\n    if (hasTypename) {\n        args.shift();\n    }\n    // check all parameters\n    if (devMode()) {\n        args.forEach((type, i) => {\n            assertArg(type, isModelType, \"mobx-state-tree model type\", hasTypename ? i + 2 : i + 1);\n        });\n    }\n    return args\n        .reduce((prev, cur) => prev.cloneAndEnhance({\n        name: prev.name + \"_\" + cur.name,\n        properties: cur.properties,\n        initializers: cur.initializers,\n        preProcessor: (snapshot) => cur.applySnapshotPreProcessor(prev.applySnapshotPreProcessor(snapshot)),\n        postProcessor: (snapshot) => cur.applySnapshotPostProcessor(prev.applySnapshotPostProcessor(snapshot))\n    }))\n        .named(typeName);\n}\n/**\n * Returns if a given value represents a model type.\n *\n * @param type\n * @returns\n */\nfunction isModelType(type) {\n    return isType(type) && (type.flags & TypeFlags.Object) > 0;\n}\n\n// TODO: implement CoreType using types.custom ?\n/**\n * @internal\n * @hidden\n */\nclass CoreType extends SimpleType {\n    flags;\n    checker;\n    initializer;\n    constructor(name, flags, checker, initializer = identity) {\n        super(name);\n        this.flags = flags;\n        this.checker = checker;\n        this.initializer = initializer;\n        this.flags = flags;\n    }\n    describe() {\n        return this.name;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    createNewInstance(snapshot) {\n        return this.initializer(snapshot);\n    }\n    isValidSnapshot(value, context) {\n        if (isPrimitive(value) && this.checker(value)) {\n            return typeCheckSuccess();\n        }\n        const typeName = this.name === \"Date\" ? \"Date or a unix milliseconds timestamp\" : this.name;\n        return typeCheckFailure(context, value, `Value is not a ${typeName}`);\n    }\n}\n/**\n * `types.string` - Creates a type that can only contain a string value.\n * This type is used for string values by default\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *   firstName: types.string,\n *   lastName: \"Doe\"\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst string = new CoreType(\"string\", TypeFlags.String, v => typeof v === \"string\");\n/**\n * `types.number` - Creates a type that can only contain a numeric value.\n * This type is used for numeric values by default\n *\n * Example:\n * ```ts\n * const Vector = types.model({\n *   x: types.number,\n *   y: 1.5\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst number = new CoreType(\"number\", TypeFlags.Number, v => typeof v === \"number\");\n/**\n * `types.integer` - Creates a type that can only contain an integer value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.integer,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst integer = new CoreType(\"integer\", TypeFlags.Integer, v => isInteger(v));\n/**\n * `types.float` - Creates a type that can only contain an float value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.float,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst float = new CoreType(\"float\", TypeFlags.Float, v => isFloat(v));\n/**\n * `types.finite` - Creates a type that can only contain an finite value.\n *\n * Example:\n * ```ts\n * const Size = types.model({\n *   width: types.finite,\n *   height: 10\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst finite = new CoreType(\"finite\", TypeFlags.Finite, v => isFinite(v));\n/**\n * `types.boolean` - Creates a type that can only contain a boolean value.\n * This type is used for boolean values by default\n *\n * Example:\n * ```ts\n * const Thing = types.model({\n *   isCool: types.boolean,\n *   isAwesome: false\n * })\n * ```\n */\n// tslint:disable-next-line:variable-name\nconst boolean = new CoreType(\"boolean\", TypeFlags.Boolean, v => typeof v === \"boolean\");\n/**\n * `types.null` - The type of the value `null`\n */\nconst nullType = new CoreType(\"null\", TypeFlags.Null, v => v === null);\n/**\n * `types.undefined` - The type of the value `undefined`\n */\nconst undefinedType = new CoreType(\"undefined\", TypeFlags.Undefined, v => v === undefined);\nconst _DatePrimitive = new CoreType(\"Date\", TypeFlags.Date, v => typeof v === \"number\" || v instanceof Date, v => (v instanceof Date ? v : new Date(v)));\n_DatePrimitive.getSnapshot = function (node) {\n    return node.storedValue.getTime();\n};\n/**\n * `types.Date` - Creates a type that can only contain a javascript Date value.\n *\n * Example:\n * ```ts\n * const LogLine = types.model({\n *   timestamp: types.Date,\n * })\n *\n * LogLine.create({ timestamp: new Date() })\n * ```\n */\nconst DatePrimitive = _DatePrimitive;\n/**\n * @internal\n * @hidden\n */\nfunction getPrimitiveFactoryFromValue(value) {\n    switch (typeof value) {\n        case \"string\":\n            return string;\n        case \"number\":\n            return number; // In the future, isInteger(value) ? integer : number would be interesting, but would be too breaking for now\n        case \"boolean\":\n            return boolean;\n        case \"object\":\n            if (value instanceof Date) {\n                return DatePrimitive;\n            }\n    }\n    throw fail(\"Cannot determine primitive type from value \" + value);\n}\n/**\n * Returns if a given value represents a primitive type.\n *\n * @param type\n * @returns\n */\nfunction isPrimitiveType(type) {\n    return (isType(type) &&\n        (type.flags &\n            (TypeFlags.String |\n                TypeFlags.Number |\n                TypeFlags.Integer |\n                TypeFlags.Boolean |\n                TypeFlags.Date)) >\n            0);\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Literal extends SimpleType {\n    value;\n    flags = TypeFlags.Literal;\n    constructor(value) {\n        super(JSON.stringify(value));\n        this.value = value;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    describe() {\n        return JSON.stringify(this.value);\n    }\n    isValidSnapshot(value, context) {\n        if (isPrimitive(value) && value === this.value) {\n            return typeCheckSuccess();\n        }\n        return typeCheckFailure(context, value, `Value is not a literal ${JSON.stringify(this.value)}`);\n    }\n}\n/**\n * `types.literal` - The literal type will return a type that will match only the exact given type.\n * The given value must be a primitive, in order to be serialized to a snapshot correctly.\n * You can use literal to match exact strings for example the exact male or female string.\n *\n * Example:\n * ```ts\n * const Person = types.model({\n *     name: types.string,\n *     gender: types.union(types.literal('male'), types.literal('female'))\n * })\n * ```\n *\n * @param value The value to use in the strict equal check\n * @returns\n */\nfunction literal(value) {\n    // check that the given value is a primitive\n    assertArg(value, isPrimitive, \"primitive\", 1);\n    return new Literal(value);\n}\n/**\n * Returns if a given value represents a literal type.\n *\n * @param type\n * @returns\n */\nfunction isLiteralType(type) {\n    return isType(type) && (type.flags & TypeFlags.Literal) > 0;\n}\n\nclass Refinement extends BaseType {\n    _subtype;\n    _predicate;\n    _message;\n    get flags() {\n        return this._subtype.flags | TypeFlags.Refinement;\n    }\n    constructor(name, _subtype, _predicate, _message) {\n        super(name);\n        this._subtype = _subtype;\n        this._predicate = _predicate;\n        this._message = _message;\n    }\n    describe() {\n        return this.name;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        // create the child type\n        return this._subtype.instantiate(parent, subpath, environment, initialValue);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    isValidSnapshot(value, context) {\n        const subtypeErrors = this._subtype.validate(value, context);\n        if (subtypeErrors.length > 0) {\n            return subtypeErrors;\n        }\n        const snapshot = isStateTreeNode(value)\n            ? getStateTreeNode(value).snapshot\n            : value;\n        if (!this._predicate(snapshot)) {\n            return typeCheckFailure(context, value, this._message(value));\n        }\n        return typeCheckSuccess();\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this._subtype.reconcile(current, newValue, parent, subpath);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n}\n/**\n * `types.refinement` - Creates a type that is more specific than the base type, e.g. `types.refinement(types.string, value => value.length > 5)` to create a type of strings that can only be longer then 5.\n *\n * @param name\n * @param type\n * @param predicate\n * @returns\n */\nfunction refinement(...args) {\n    const name = typeof args[0] === \"string\"\n        ? args.shift()\n        : isType(args[0])\n            ? args[0].name\n            : null;\n    const type = args[0];\n    const predicate = args[1];\n    const message = args[2]\n        ? args[2]\n        : (v) => \"Value does not respect the refinement predicate\";\n    // ensures all parameters are correct\n    assertIsType(type, [1, 2]);\n    assertIsString(name, 1);\n    assertIsFunction(predicate, [2, 3]);\n    assertIsFunction(message, [3, 4]);\n    return new Refinement(name, type, predicate, message);\n}\n/**\n * Returns if a given value is a refinement type.\n *\n * @param type\n * @returns\n */\nfunction isRefinementType(type) {\n    return (type.flags & TypeFlags.Refinement) > 0;\n}\n\n/**\n * `types.enumeration` - Can be used to create an string based enumeration.\n * (note: this methods is just sugar for a union of string literals)\n *\n * Example:\n * ```ts\n * const TrafficLight = types.model({\n *   color: types.enumeration(\"Color\", [\"Red\", \"Orange\", \"Green\"])\n * })\n * ```\n *\n * @param name descriptive name of the enumeration (optional)\n * @param options possible values this enumeration can have\n * @returns\n */\nfunction enumeration(name, options) {\n    const realOptions = typeof name === \"string\" ? options : name;\n    // check all options\n    if (devMode()) {\n        realOptions.forEach((option, i) => {\n            assertIsString(option, i + 1);\n        });\n    }\n    const type = union(...realOptions.map(option => literal(\"\" + option)));\n    if (typeof name === \"string\") {\n        type.name = name;\n    }\n    return type;\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Union extends BaseType {\n    _types;\n    _dispatcher;\n    _eager = true;\n    get flags() {\n        let result = TypeFlags.Union;\n        this._types.forEach(type => {\n            result |= type.flags;\n        });\n        return result;\n    }\n    constructor(name, _types, options) {\n        super(name);\n        this._types = _types;\n        options = {\n            eager: true,\n            dispatcher: undefined,\n            ...options\n        };\n        this._dispatcher = options.dispatcher;\n        if (!options.eager) {\n            this._eager = false;\n        }\n    }\n    isAssignableFrom(type) {\n        return this._types.some(subType => subType.isAssignableFrom(type));\n    }\n    describe() {\n        return (\"(\" + this._types.map(factory => factory.describe()).join(\" | \") + \")\");\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const type = this.determineType(initialValue, undefined);\n        if (!type) {\n            throw fail(\"No matching type for union \" + this.describe());\n        } // can happen in prod builds\n        return type.instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const type = this.determineType(newValue, current.getReconciliationType());\n        if (!type) {\n            throw fail(\"No matching type for union \" + this.describe());\n        } // can happen in prod builds\n        return type.reconcile(current, newValue, parent, subpath);\n    }\n    determineType(value, reconcileCurrentType) {\n        // try the dispatcher, if defined\n        if (this._dispatcher) {\n            return this._dispatcher(value);\n        }\n        // fast path: when type checking is disabled, try quick structural matching first\n        if (!isTypeCheckingEnabled()) {\n            const quickMatch = this.tryQuickMatch(value, reconcileCurrentType);\n            if (quickMatch) {\n                return quickMatch;\n            }\n            // for plain object snapshots that didn't match via quick path, try all types\n            // with quick matching before falling back to full validation\n            // (state tree nodes must go through full validation for type identity checks)\n            if (isPlainObject(value) && !isStateTreeNode(value)) {\n                for (const type of this._types) {\n                    if (this.snapshotLooksLikeType(value, type)) {\n                        return type;\n                    }\n                }\n            }\n        }\n        // find the most accomodating type\n        // if we are using reconciliation try the current node type first (fix for #1045)\n        if (reconcileCurrentType) {\n            if (reconcileCurrentType.is(value)) {\n                return reconcileCurrentType;\n            }\n            return this._types\n                .filter(t => t !== reconcileCurrentType)\n                .find(type => type.is(value));\n        }\n        else {\n            return this._types.find(type => type.is(value));\n        }\n    }\n    tryQuickMatch(value, reconcileCurrentType) {\n        // state tree nodes need full type compatibility checking\n        // (e.g., A.is(B.create()) must return false even if snapshots are compatible)\n        if (isStateTreeNode(value)) {\n            return undefined;\n        }\n        // for non-object values, try primitive matching\n        if (!isPlainObject(value)) {\n            return this.tryMatchPrimitive(value);\n        }\n        // for objects, try structural matching against model types\n        const typesToCheck = reconcileCurrentType\n            ? [\n                reconcileCurrentType,\n                ...this._types.filter(t => t !== reconcileCurrentType)\n            ]\n            : this._types;\n        for (const type of typesToCheck) {\n            if (this.snapshotLooksLikeType(value, type)) {\n                return type;\n            }\n        }\n        return undefined;\n    }\n    tryMatchPrimitive(value) {\n        const valueType = typeof value;\n        for (const type of this._types) {\n            const flags = type.flags;\n            if ((valueType === \"string\" && flags & TypeFlags.String) ||\n                (valueType === \"number\" &&\n                    flags &\n                        (TypeFlags.Number |\n                            TypeFlags.Integer |\n                            TypeFlags.Float |\n                            TypeFlags.Finite)) ||\n                (valueType === \"boolean\" && flags & TypeFlags.Boolean) ||\n                (value === null && flags & TypeFlags.Null) ||\n                (value === undefined && flags & TypeFlags.Undefined)) {\n                return type;\n            }\n            // for literals, check exact value match\n            if (flags & TypeFlags.Literal) {\n                if (type.is(value)) {\n                    return type;\n                }\n            }\n        }\n        return undefined;\n    }\n    snapshotLooksLikeType(value, type) {\n        // for model types, check if snapshot has all the required property keys\n        // and that any literal-typed properties match exactly\n        if (type instanceof ModelType) {\n            const props = type.properties;\n            // use cached propertyNames from ModelType instead of Object.keys()\n            for (const key of type.propertyNames) {\n                const propType = props[key];\n                const isOptional = propType.flags & TypeFlags.Optional;\n                const propValue = value[key];\n                // check required properties exist and are not undefined\n                // (unless the type accepts undefined, which Optional types do)\n                if (!isOptional) {\n                    if (!(key in value) || propValue === undefined) {\n                        return false;\n                    }\n                }\n                // for literal types, verify the value matches exactly\n                // this is critical for discriminated unions\n                if (propType.flags & TypeFlags.Literal) {\n                    if (!propType.is(propValue)) {\n                        return false;\n                    }\n                }\n            }\n            return true;\n        }\n        return false;\n    }\n    isValidSnapshot(value, context) {\n        if (this._dispatcher) {\n            return this._dispatcher(value).validate(value, context);\n        }\n        const allErrors = [];\n        let applicableTypes = 0;\n        for (let i = 0; i < this._types.length; i++) {\n            const type = this._types[i];\n            const errors = type.validate(value, context);\n            if (errors.length === 0) {\n                if (this._eager) {\n                    return typeCheckSuccess();\n                }\n                else {\n                    applicableTypes++;\n                }\n            }\n            else {\n                allErrors.push(errors);\n            }\n        }\n        if (applicableTypes === 1) {\n            return typeCheckSuccess();\n        }\n        return typeCheckFailure(context, value, \"No type is applicable for the union\").concat(flattenTypeErrors(allErrors));\n    }\n    getSubTypes() {\n        return this._types;\n    }\n}\n/**\n * `types.union` - Create a union of multiple types. If the correct type cannot be inferred unambiguously from a snapshot, provide a dispatcher function of the form `(snapshot) => Type`.\n *\n * @param optionsOrType\n * @param otherTypes\n * @returns\n */\nfunction union(optionsOrType, ...otherTypes) {\n    const options = isType(optionsOrType) ? undefined : optionsOrType;\n    const types = isType(optionsOrType)\n        ? [optionsOrType, ...otherTypes]\n        : otherTypes;\n    const name = \"(\" + types.map(type => type.name).join(\" | \") + \")\";\n    // check all options\n    if (devMode()) {\n        if (options) {\n            assertArg(options, o => isPlainObject(o), \"object { eager?: boolean, dispatcher?: Function }\", 1);\n        }\n        types.forEach((type, i) => {\n            assertIsType(type, options ? i + 2 : i + 1);\n        });\n    }\n    return new Union(name, types, options);\n}\n/**\n * Returns if a given value represents a union type.\n *\n * @param type\n * @returns\n */\nfunction isUnionType(type) {\n    return (type.flags & TypeFlags.Union) > 0;\n}\n\n/**\n * @hidden\n * @internal\n */\nclass OptionalValue extends BaseType {\n    _subtype;\n    _defaultValue;\n    optionalValues;\n    get flags() {\n        return this._subtype.flags | TypeFlags.Optional;\n    }\n    constructor(_subtype, _defaultValue, optionalValues) {\n        super(_subtype.name);\n        this._subtype = _subtype;\n        this._defaultValue = _defaultValue;\n        this.optionalValues = optionalValues;\n    }\n    describe() {\n        return this._subtype.describe() + \"?\";\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        if (this.optionalValues.indexOf(initialValue) >= 0) {\n            const defaultInstanceOrSnapshot = this.getDefaultInstanceOrSnapshot();\n            return this._subtype.instantiate(parent, subpath, environment, defaultInstanceOrSnapshot);\n        }\n        return this._subtype.instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this._subtype.reconcile(current, this.optionalValues.indexOf(newValue) < 0 && this._subtype.is(newValue)\n            ? newValue\n            : this.getDefaultInstanceOrSnapshot(), parent, subpath);\n    }\n    getDefaultInstanceOrSnapshot() {\n        const defaultInstanceOrSnapshot = typeof this._defaultValue === \"function\"\n            ? this._defaultValue()\n            : this._defaultValue;\n        // while static values are already snapshots and checked on types.optional\n        // generator functions must always be rechecked just in case\n        if (typeof this._defaultValue === \"function\") {\n            typecheckInternal(this, defaultInstanceOrSnapshot);\n        }\n        return defaultInstanceOrSnapshot;\n    }\n    isValidSnapshot(value, context) {\n        // defaulted values can be skipped\n        if (this.optionalValues.indexOf(value) >= 0) {\n            return typeCheckSuccess();\n        }\n        // bounce validation to the sub-type\n        return this._subtype.validate(value, context);\n    }\n    isAssignableFrom(type) {\n        return this._subtype.isAssignableFrom(type);\n    }\n    getSubTypes() {\n        return this._subtype;\n    }\n}\nfunction checkOptionalPreconditions(type, defaultValueOrFunction) {\n    // make sure we never pass direct instances\n    if (typeof defaultValueOrFunction !== \"function\" &&\n        isStateTreeNode(defaultValueOrFunction)) {\n        throw fail(\"default value cannot be an instance, pass a snapshot or a function that creates an instance/snapshot instead\");\n    }\n    assertIsType(type, 1);\n    if (devMode()) {\n        // we only check default values if they are passed directly\n        // if they are generator functions they will be checked once they are generated\n        // we don't check generator function results here to avoid generating a node just for type-checking purposes\n        // which might generate side-effects\n        if (typeof defaultValueOrFunction !== \"function\") {\n            typecheckInternal(type, defaultValueOrFunction);\n        }\n    }\n}\n/**\n * `types.optional` - Can be used to create a property with a default value.\n *\n * Depending on the third argument (`optionalValues`) there are two ways of operation:\n * - If the argument is not provided, then if a value is not provided in the snapshot (`undefined` or missing),\n *   it will default to the provided `defaultValue`\n * - If the argument is provided, then if the value in the snapshot matches one of the optional values inside the array then it will\n *   default to the provided `defaultValue`. Additionally, if one of the optional values inside the array is `undefined` then a missing\n *   property is also valid.\n *\n *   Note that it is also possible to include values of the same type as the intended subtype as optional values,\n *   in this case the optional value will be transformed into the `defaultValue` (e.g. `types.optional(types.string, \"unnamed\", [undefined, \"\"])`\n *   will transform the snapshot values `undefined` (and therefore missing) and empty strings into the string `\"unnamed\"` when it gets\n *   instantiated).\n *\n * If `defaultValue` is a function, the function will be invoked for every new instance.\n * Applying a snapshot in which the optional value is one of the optional values (or `undefined`/_not_ present if none are provided) causes the\n * value to be reset.\n *\n * Example:\n * ```ts\n * const Todo = types.model({\n *   title: types.string,\n *   subtitle1: types.optional(types.string, \"\", [null]),\n *   subtitle2: types.optional(types.string, \"\", [null, undefined]),\n *   done: types.optional(types.boolean, false),\n *   created: types.optional(types.Date, () => new Date()),\n * })\n *\n * // if done is missing / undefined it will become false\n * // if created is missing / undefined it will get a freshly generated timestamp\n * // if subtitle1 is null it will default to \"\", but it cannot be missing or undefined\n * // if subtitle2 is null or undefined it will default to \"\"; since it can be undefined it can also be missing\n * const todo = Todo.create({ title: \"Get coffee\", subtitle1: null })\n * ```\n *\n * @param type\n * @param defaultValueOrFunction\n * @param optionalValues an optional array with zero or more primitive values (string, number, boolean, null or undefined)\n *                       that will be converted into the default. `[ undefined ]` is assumed when none is provided\n * @returns\n */\nfunction optional(type, defaultValueOrFunction, optionalValues) {\n    checkOptionalPreconditions(type, defaultValueOrFunction);\n    return new OptionalValue(type, defaultValueOrFunction, optionalValues ? optionalValues : undefinedAsOptionalValues);\n}\nconst undefinedAsOptionalValues = [undefined];\n/**\n * Returns if a value represents an optional type.\n *\n * @template IT\n * @param type\n * @returns\n */\nfunction isOptionalType(type) {\n    return isType(type) && (type.flags & TypeFlags.Optional) > 0;\n}\n\nconst optionalUndefinedType = optional(undefinedType, undefined);\nconst optionalNullType = optional(nullType, null);\n/**\n * `types.maybe` - Maybe will make a type nullable, and also optional.\n * The value `undefined` will be used to represent nullability.\n *\n * @param type\n * @returns\n */\nfunction maybe(type) {\n    assertIsType(type, 1);\n    return union(type, optionalUndefinedType);\n}\n/**\n * `types.maybeNull` - Maybe will make a type nullable, and also optional.\n * The value `null` will be used to represent no value.\n *\n * @param type\n * @returns\n */\nfunction maybeNull(type) {\n    assertIsType(type, 1);\n    return union(type, optionalNullType);\n}\n\nclass Late extends BaseType {\n    _definition;\n    _subType;\n    get flags() {\n        return (this._subType ? this._subType.flags : 0) | TypeFlags.Late;\n    }\n    getSubType(mustSucceed) {\n        if (!this._subType) {\n            let t = undefined;\n            try {\n                t = this._definition();\n            }\n            catch (e) {\n                if (e instanceof ReferenceError) // can happen in strict ES5 code when a definition is self refering\n                 {\n                    t = undefined;\n                }\n                else {\n                    throw e;\n                }\n            }\n            if (mustSucceed && t === undefined) {\n                throw fail(\"Late type seems to be used too early, the definition (still) returns undefined\");\n            }\n            if (t) {\n                if (devMode() && !isType(t)) {\n                    throw fail(\"Failed to determine subtype, make sure types.late returns a type definition.\");\n                }\n                this._subType = t;\n            }\n        }\n        return this._subType;\n    }\n    constructor(name, _definition) {\n        super(name);\n        this._definition = _definition;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        return this.getSubType(true).instantiate(parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        return this.getSubType(true).reconcile(current, newValue, parent, subpath);\n    }\n    describe() {\n        const t = this.getSubType(false);\n        return t ? t.name : \"<uknown late type>\";\n    }\n    isValidSnapshot(value, context) {\n        const t = this.getSubType(false);\n        if (!t) {\n            // See #916; the variable the definition closure is pointing to wasn't defined yet, so can't be evaluted yet here\n            return typeCheckSuccess();\n        }\n        return t.validate(value, context);\n    }\n    isAssignableFrom(type) {\n        const t = this.getSubType(false);\n        return t ? t.isAssignableFrom(type) : false;\n    }\n    getSubTypes() {\n        const subtype = this.getSubType(false);\n        return subtype ? subtype : cannotDetermineSubtype;\n    }\n}\n/**\n * `types.late` - Defines a type that gets implemented later. This is useful when you have to deal with circular dependencies.\n * Please notice that when defining circular dependencies TypeScript isn't smart enough to inference them.\n *\n * Example:\n * ```ts\n *   // TypeScript isn't smart enough to infer self referencing types.\n *  const Node = types.model({\n *       children: types.array(types.late((): IAnyModelType => Node)) // then typecast each array element to Instance<typeof Node>\n *  })\n * ```\n *\n * @param name The name to use for the type that will be returned.\n * @param type A function that returns the type that will be defined.\n * @returns\n */\nfunction late(nameOrType, maybeType) {\n    const name = typeof nameOrType === \"string\"\n        ? nameOrType\n        : `late(${nameOrType.toString()})`;\n    const type = typeof nameOrType === \"string\" ? maybeType : nameOrType;\n    // checks that the type is actually a late type\n    if (devMode()) {\n        if (!(typeof type === \"function\" && type.length === 0)) {\n            throw fail(\"Invalid late type, expected a function with zero arguments that returns a type, got: \" +\n                type);\n        }\n    }\n    return new Late(name, type);\n}\n/**\n * Returns if a given value represents a late type.\n *\n * @param type\n * @returns\n */\nfunction isLateType(type) {\n    return isType(type) && (type.flags & TypeFlags.Late) > 0;\n}\n\nfunction lazy(name, options) {\n    // TODO: fix this unknown casting to be stricter\n    return new Lazy(name, options);\n}\n/**\n * @internal\n * @hidden\n */\nclass Lazy extends SimpleType {\n    options;\n    flags = TypeFlags.Lazy;\n    loadedType = null;\n    pendingNodeList = observable.array();\n    constructor(name, options) {\n        super(name);\n        this.options = options;\n        when(() => this.pendingNodeList.length > 0 &&\n            this.pendingNodeList.some(node => node.isAlive &&\n                this.options.shouldLoadPredicate(node.parent ? node.parent.value : null)), () => {\n            this.options.loadType().then(action((type) => {\n                this.loadedType = type;\n                this.pendingNodeList.forEach(node => {\n                    if (!node.parent) {\n                        return;\n                    }\n                    if (!this.loadedType) {\n                        return;\n                    }\n                    node.parent.applyPatches([\n                        {\n                            op: \"replace\",\n                            path: `/${node.subpath}`,\n                            value: node.snapshot\n                        }\n                    ]);\n                });\n            }));\n        });\n    }\n    describe() {\n        return `<lazy ${this.name}>`;\n    }\n    instantiate(parent, subpath, environment, value) {\n        if (this.loadedType) {\n            return this.loadedType.instantiate(parent, subpath, environment, value);\n        }\n        const node = createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n        this.pendingNodeList.push(node);\n        when(() => !node.isAlive, () => this.pendingNodeList.splice(this.pendingNodeList.indexOf(node), 1));\n        return node;\n    }\n    isValidSnapshot(value, context) {\n        if (this.loadedType) {\n            return this.loadedType.validate(value, context);\n        }\n        if (!isSerializable(value)) {\n            return typeCheckFailure(context, value, \"Value is not serializable and cannot be lazy\");\n        }\n        return typeCheckSuccess();\n    }\n    reconcile(current, value, parent, subpath) {\n        if (this.loadedType) {\n            current.die();\n            return this.loadedType.instantiate(parent, subpath, parent.environment, value);\n        }\n        return super.reconcile(current, value, parent, subpath);\n    }\n}\n\n/**\n * @internal\n * @hidden\n */\nclass Frozen extends SimpleType {\n    subType;\n    flags = TypeFlags.Frozen;\n    constructor(subType) {\n        super(subType ? `frozen(${subType.name})` : \"frozen\");\n        this.subType = subType;\n    }\n    describe() {\n        return \"<any immutable value>\";\n    }\n    instantiate(parent, subpath, environment, value) {\n        // create the node\n        return createScalarNode(this, parent, subpath, environment, deepFreeze(value));\n    }\n    isValidSnapshot(value, context) {\n        if (!isSerializable(value)) {\n            return typeCheckFailure(context, value, \"Value is not serializable and cannot be frozen\");\n        }\n        if (this.subType) {\n            return this.subType.validate(value, context);\n        }\n        return typeCheckSuccess();\n    }\n}\nconst untypedFrozenInstance = new Frozen();\n/**\n * `types.frozen` - Frozen can be used to store any value that is serializable in itself (that is valid JSON).\n * Frozen values need to be immutable or treated as if immutable. They need be serializable as well.\n * Values stored in frozen will snapshotted as-is by MST, and internal changes will not be tracked.\n *\n * This is useful to store complex, but immutable values like vectors etc. It can form a powerful bridge to parts of your application that should be immutable, or that assume data to be immutable.\n *\n * Note: if you want to store free-form state that is mutable, or not serializeable, consider using volatile state instead.\n *\n * Frozen properties can be defined in three different ways\n * 1. `types.frozen(SubType)` - provide a valid MST type and frozen will check if the provided data conforms the snapshot for that type\n * 2. `types.frozen({ someDefaultValue: true})` - provide a primitive value, object or array, and MST will infer the type from that object, and also make it the default value for the field\n * 3. `types.frozen<TypeScriptType>()` - provide a typescript type, to help in strongly typing the field (design time only)\n *\n * Example:\n * ```ts\n * const GameCharacter = types.model({\n *   name: string,\n *   location: types.frozen({ x: 0, y: 0})\n * })\n *\n * const hero = GameCharacter.create({\n *   name: \"Mario\",\n *   location: { x: 7, y: 4 }\n * })\n *\n * hero.location = { x: 10, y: 2 } // OK\n * hero.location.x = 7 // Not ok!\n * ```\n *\n * ```ts\n * type Point = { x: number, y: number }\n *    const Mouse = types.model({\n *         loc: types.frozen<Point>()\n *    })\n * ```\n *\n * @param defaultValueOrType\n * @returns\n */\nfunction frozen(arg) {\n    if (arguments.length === 0) {\n        return untypedFrozenInstance;\n    }\n    else if (isType(arg)) {\n        return new Frozen(arg);\n    }\n    else {\n        return optional(untypedFrozenInstance, arg);\n    }\n}\n/**\n * Returns if a given value represents a frozen type.\n *\n * @param type\n * @returns\n */\nfunction isFrozenType(type) {\n    return isType(type) && (type.flags & TypeFlags.Frozen) > 0;\n}\n\nfunction getInvalidationCause(hook) {\n    switch (hook) {\n        case Hook.beforeDestroy:\n            return \"destroy\";\n        case Hook.beforeDetach:\n            return \"detach\";\n        default:\n            return undefined;\n    }\n}\nclass StoredReference {\n    targetType;\n    identifier;\n    node;\n    resolvedReference;\n    constructor(value, targetType) {\n        this.targetType = targetType;\n        if (isValidIdentifier(value)) {\n            this.identifier = value;\n        }\n        else if (isStateTreeNode(value)) {\n            const targetNode = getStateTreeNode(value);\n            if (!targetNode.identifierAttribute) {\n                throw fail(`Can only store references with a defined identifier attribute.`);\n            }\n            const id = targetNode.unnormalizedIdentifier;\n            if (id === null || id === undefined) {\n                throw fail(`Can only store references to tree nodes with a defined identifier.`);\n            }\n            this.identifier = id;\n        }\n        else {\n            throw fail(`Can only store references to tree nodes or identifiers, got: '${value}'`);\n        }\n    }\n    updateResolvedReference(node) {\n        const normalizedId = normalizeIdentifier(this.identifier);\n        const root = node.root;\n        const lastCacheModification = root.identifierCache.getLastCacheModificationPerId(normalizedId);\n        if (!this.resolvedReference ||\n            this.resolvedReference.lastCacheModification !== lastCacheModification) {\n            const { targetType } = this;\n            // reference was initialized with the identifier of the target\n            const target = root.identifierCache.resolve(targetType, normalizedId);\n            if (!target) {\n                throw new InvalidReferenceError(`[mobx-state-tree] Failed to resolve reference '${this.identifier}' to type '${this.targetType.name}' (from node: ${node.path})`);\n            }\n            this.resolvedReference = {\n                node: target,\n                lastCacheModification: lastCacheModification\n            };\n        }\n    }\n    get resolvedValue() {\n        this.updateResolvedReference(this.node);\n        return this.resolvedReference.node.value;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass InvalidReferenceError extends Error {\n    constructor(m) {\n        super(m);\n        Object.setPrototypeOf(this, InvalidReferenceError.prototype);\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass BaseReferenceType extends SimpleType {\n    targetType;\n    onInvalidated;\n    flags = TypeFlags.Reference;\n    constructor(targetType, onInvalidated) {\n        super(`reference(${targetType.name})`);\n        this.targetType = targetType;\n        this.onInvalidated = onInvalidated;\n    }\n    describe() {\n        return this.name;\n    }\n    isAssignableFrom(type) {\n        return this.targetType.isAssignableFrom(type);\n    }\n    isValidSnapshot(value, context) {\n        return isValidIdentifier(value)\n            ? typeCheckSuccess()\n            : typeCheckFailure(context, value, \"Value is not a valid identifier, which is a string or a number\");\n    }\n    fireInvalidated(cause, storedRefNode, referenceId, refTargetNode) {\n        // to actually invalidate a reference we need an alive parent,\n        // since it is a scalar value (immutable-ish) and we need to change it\n        // from the parent\n        const storedRefParentNode = storedRefNode.parent;\n        if (!storedRefParentNode || !storedRefParentNode.isAlive) {\n            return;\n        }\n        const storedRefParentValue = storedRefParentNode.storedValue;\n        if (!storedRefParentValue) {\n            return;\n        }\n        this.onInvalidated({\n            cause,\n            parent: storedRefParentValue,\n            invalidTarget: refTargetNode ? refTargetNode.storedValue : undefined,\n            invalidId: referenceId,\n            replaceRef(newRef) {\n                applyPatch(storedRefNode.root.storedValue, {\n                    op: \"replace\",\n                    value: newRef,\n                    path: storedRefNode.path\n                });\n            },\n            removeRef() {\n                if (isModelType(storedRefParentNode.type)) {\n                    this.replaceRef(undefined);\n                }\n                else {\n                    applyPatch(storedRefNode.root.storedValue, {\n                        op: \"remove\",\n                        path: storedRefNode.path\n                    });\n                }\n            }\n        });\n    }\n    addTargetNodeWatcher(storedRefNode, referenceId) {\n        // this will make sure the target node becomes created\n        const refTargetValue = this.getValue(storedRefNode);\n        if (!refTargetValue) {\n            return undefined;\n        }\n        const refTargetNode = getStateTreeNode(refTargetValue);\n        const hookHandler = (_, refTargetNodeHook) => {\n            const cause = getInvalidationCause(refTargetNodeHook);\n            if (!cause) {\n                return;\n            }\n            this.fireInvalidated(cause, storedRefNode, referenceId, refTargetNode);\n        };\n        const refTargetDetachHookDisposer = refTargetNode.registerHook(Hook.beforeDetach, hookHandler);\n        const refTargetDestroyHookDisposer = refTargetNode.registerHook(Hook.beforeDestroy, hookHandler);\n        return () => {\n            refTargetDetachHookDisposer();\n            refTargetDestroyHookDisposer();\n        };\n    }\n    watchTargetNodeForInvalidations(storedRefNode, identifier, customGetSet) {\n        if (!this.onInvalidated) {\n            return;\n        }\n        let onRefTargetDestroyedHookDisposer;\n        // get rid of the watcher hook when the stored ref node is destroyed\n        // detached is ignored since scalar nodes (where the reference resides) cannot be detached\n        storedRefNode.registerHook(Hook.beforeDestroy, () => {\n            if (onRefTargetDestroyedHookDisposer) {\n                onRefTargetDestroyedHookDisposer();\n            }\n        });\n        const startWatching = (sync) => {\n            // re-create hook in case the stored ref gets reattached\n            if (onRefTargetDestroyedHookDisposer) {\n                onRefTargetDestroyedHookDisposer();\n            }\n            // make sure the target node is actually there and initialized\n            const storedRefParentNode = storedRefNode.parent;\n            const storedRefParentValue = storedRefParentNode && storedRefParentNode.storedValue;\n            if (storedRefParentNode &&\n                storedRefParentNode.isAlive &&\n                storedRefParentValue) {\n                let refTargetNodeExists;\n                if (customGetSet) {\n                    refTargetNodeExists = !!customGetSet.get(identifier, storedRefParentValue);\n                }\n                else {\n                    refTargetNodeExists = storedRefNode.root.identifierCache.has(this.targetType, normalizeIdentifier(identifier));\n                }\n                if (!refTargetNodeExists) {\n                    // we cannot change the reference in sync mode\n                    // since we are in the middle of a reconciliation/instantiation and the change would be overwritten\n                    // for those cases just let the wrong reference be assigned and fail upon usage\n                    // (like current references do)\n                    // this means that effectively this code will only run when it is created from a snapshot\n                    if (!sync) {\n                        this.fireInvalidated(\"invalidSnapshotReference\", storedRefNode, identifier, null);\n                    }\n                }\n                else {\n                    onRefTargetDestroyedHookDisposer = this.addTargetNodeWatcher(storedRefNode, identifier);\n                }\n            }\n        };\n        if (storedRefNode.state === NodeLifeCycle.FINALIZED) {\n            // already attached, so the whole tree is ready\n            startWatching(true);\n        }\n        else {\n            if (!storedRefNode.isRoot) {\n                // start watching once the whole tree is ready\n                storedRefNode.root.registerHook(Hook.afterCreationFinalization, () => {\n                    // make sure to attach it so it can start listening\n                    if (storedRefNode.parent) {\n                        storedRefNode.parent.createObservableInstanceIfNeeded();\n                    }\n                });\n            }\n            // start watching once the node is attached somewhere / parent changes\n            storedRefNode.registerHook(Hook.afterAttach, () => {\n                startWatching(false);\n            });\n        }\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierReferenceType extends BaseReferenceType {\n    constructor(targetType, onInvalidated) {\n        super(targetType, onInvalidated);\n    }\n    getValue(storedRefNode) {\n        if (!storedRefNode.isAlive) {\n            return undefined;\n        }\n        const storedRef = storedRefNode.storedValue;\n        return storedRef.resolvedValue;\n    }\n    getSnapshot(storedRefNode) {\n        const ref = storedRefNode.storedValue;\n        return ref.identifier;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const identifier = isStateTreeNode(initialValue)\n            ? getIdentifier(initialValue)\n            : initialValue;\n        const storedRef = new StoredReference(initialValue, this.targetType);\n        const storedRefNode = createScalarNode(this, parent, subpath, environment, storedRef);\n        storedRef.node = storedRefNode;\n        this.watchTargetNodeForInvalidations(storedRefNode, identifier, undefined);\n        return storedRefNode;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        if (!current.isDetaching && current.type === this) {\n            const compareByValue = isStateTreeNode(newValue);\n            const ref = current.storedValue;\n            if ((!compareByValue && ref.identifier === newValue) ||\n                (compareByValue && ref.resolvedValue === newValue)) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n        }\n        const newNode = this.instantiate(parent, subpath, undefined, newValue);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass CustomReferenceType extends BaseReferenceType {\n    options;\n    constructor(targetType, options, onInvalidated) {\n        super(targetType, onInvalidated);\n        this.options = options;\n    }\n    getValue(storedRefNode) {\n        if (!storedRefNode.isAlive) {\n            return undefined;\n        }\n        const referencedNode = this.options.get(storedRefNode.storedValue, storedRefNode.parent ? storedRefNode.parent.storedValue : null);\n        return referencedNode;\n    }\n    getSnapshot(storedRefNode) {\n        return storedRefNode.storedValue;\n    }\n    instantiate(parent, subpath, environment, newValue) {\n        const identifier = isStateTreeNode(newValue)\n            ? this.options.set(newValue, parent ? parent.storedValue : null)\n            : newValue;\n        const storedRefNode = createScalarNode(this, parent, subpath, environment, identifier);\n        this.watchTargetNodeForInvalidations(storedRefNode, identifier, this.options);\n        return storedRefNode;\n    }\n    reconcile(current, newValue, parent, subpath) {\n        const newIdentifier = isStateTreeNode(newValue)\n            ? this.options.set(newValue, current ? current.storedValue : null)\n            : newValue;\n        if (!current.isDetaching &&\n            current.type === this &&\n            current.storedValue === newIdentifier) {\n            current.setParent(parent, subpath);\n            return current;\n        }\n        const newNode = this.instantiate(parent, subpath, undefined, newIdentifier);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n/**\n * `types.reference` - Creates a reference to another type, which should have defined an identifier.\n * See also the [reference and identifiers](https://github.com/mobxjs/mobx-state-tree#references-and-identifiers) section.\n */\nfunction reference(subType, options) {\n    assertIsType(subType, 1);\n    if (devMode()) {\n        if (arguments.length === 2 && typeof arguments[1] === \"string\") {\n            // istanbul ignore next\n            throw fail(\"References with base path are no longer supported. Please remove the base path.\");\n        }\n    }\n    const getSetOptions = options\n        ? options\n        : undefined;\n    const onInvalidated = options\n        ? options.onInvalidated\n        : undefined;\n    if (getSetOptions && (getSetOptions.get || getSetOptions.set)) {\n        if (devMode()) {\n            if (!getSetOptions.get || !getSetOptions.set) {\n                throw fail(\"reference options must either contain both a 'get' and a 'set' method or none of them\");\n            }\n        }\n        return new CustomReferenceType(subType, {\n            get: getSetOptions.get,\n            set: getSetOptions.set\n        }, onInvalidated);\n    }\n    else {\n        return new IdentifierReferenceType(subType, onInvalidated);\n    }\n}\n/**\n * Returns if a given value represents a reference type.\n *\n * @param type\n * @returns\n */\nfunction isReferenceType(type) {\n    return (type.flags & TypeFlags.Reference) > 0;\n}\n/**\n * `types.safeReference` - A safe reference is like a standard reference, except that it accepts the undefined value by default\n * and automatically sets itself to undefined (when the parent is a model) / removes itself from arrays and maps\n * when the reference it is pointing to gets detached/destroyed.\n *\n * The optional options parameter object accepts a parameter named `acceptsUndefined`, which is set to true by default, so it is suitable\n * for model properties.\n * When used inside collections (arrays/maps), it is recommended to set this option to false so it can't take undefined as value,\n * which is usually the desired in those cases.\n * Additionally, the optional options parameter object accepts a parameter named `onInvalidated`, which will be called when the reference target node that the reference is pointing to is about to be detached/destroyed\n *\n * Strictly speaking it is a `types.maybe(types.reference(X))` (when `acceptsUndefined` is set to true, the default) and\n * `types.reference(X)` (when `acceptsUndefined` is set to false), both of them with a customized `onInvalidated` option.\n *\n * @param subType\n * @param options\n * @returns\n */\nfunction safeReference(subType, options) {\n    const refType = reference(subType, {\n        ...options,\n        onInvalidated(ev) {\n            if (options && options.onInvalidated) {\n                options.onInvalidated(ev);\n            }\n            ev.removeRef();\n        }\n    });\n    if (options && options.acceptsUndefined === false) {\n        return refType;\n    }\n    else {\n        return maybe(refType);\n    }\n}\n\nclass BaseIdentifierType extends SimpleType {\n    validType;\n    flags = TypeFlags.Identifier;\n    constructor(name, validType) {\n        super(name);\n        this.validType = validType;\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        if (!parent || !(parent.type instanceof ModelType)) {\n            throw fail(`Identifier types can only be instantiated as direct child of a model type`);\n        }\n        return createScalarNode(this, parent, subpath, environment, initialValue);\n    }\n    reconcile(current, newValue, parent, subpath) {\n        // we don't consider detaching here since identifier are scalar nodes, and scalar nodes cannot be detached\n        if (current.storedValue !== newValue) {\n            throw fail(`Tried to change identifier from '${current.storedValue}' to '${newValue}'. Changing identifiers is not allowed.`);\n        }\n        current.setParent(parent, subpath);\n        return current;\n    }\n    isValidSnapshot(value, context) {\n        if (typeof value !== this.validType) {\n            return typeCheckFailure(context, value, `Value is not a valid ${this.describe()}, expected a ${this.validType}`);\n        }\n        return typeCheckSuccess();\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierType extends BaseIdentifierType {\n    flags = TypeFlags.Identifier;\n    constructor() {\n        super(`identifier`, \"string\");\n    }\n    describe() {\n        return `identifier`;\n    }\n}\n/**\n * @internal\n * @hidden\n */\nclass IdentifierNumberType extends BaseIdentifierType {\n    constructor() {\n        super(\"identifierNumber\", \"number\");\n    }\n    getSnapshot(node) {\n        return node.storedValue;\n    }\n    describe() {\n        return `identifierNumber`;\n    }\n}\n/**\n * `types.identifier` - Identifiers are used to make references, lifecycle events and reconciling works.\n * Inside a state tree, for each type can exist only one instance for each given identifier.\n * For example there couldn't be 2 instances of user with id 1. If you need more, consider using references.\n * Identifier can be used only as type property of a model.\n * This type accepts as parameter the value type of the identifier field that can be either string or number.\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifier,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nconst identifier = new IdentifierType();\n/**\n * `types.identifierNumber` - Similar to `types.identifier`. This one will serialize from / to a number when applying snapshots\n *\n * Example:\n * ```ts\n *  const Todo = types.model(\"Todo\", {\n *      id: types.identifierNumber,\n *      title: types.string\n *  })\n * ```\n *\n * @returns\n */\nconst identifierNumber = new IdentifierNumberType();\n/**\n * Returns if a given value represents an identifier type.\n *\n * @param type\n * @returns\n */\nfunction isIdentifierType(type) {\n    return isType(type) && (type.flags & TypeFlags.Identifier) > 0;\n}\n/**\n * @internal\n * @hidden\n */\nfunction normalizeIdentifier(id) {\n    return \"\" + id;\n}\n/**\n * @internal\n * @hidden\n */\nfunction isValidIdentifier(id) {\n    return typeof id === \"string\" || typeof id === \"number\";\n}\n/**\n * @internal\n * @hidden\n */\nfunction assertIsValidIdentifier(id, argNumber) {\n    assertArg(id, isValidIdentifier, \"string or number (identifier)\", argNumber);\n}\n\n/**\n * `types.custom` - Creates a custom type. Custom types can be used for arbitrary immutable values, that have a serializable representation. For example, to create your own Date representation, Decimal type etc.\n *\n * The signature of the options is:\n * ```ts\n * export interface CustomTypeOptions<S, T> {\n *     // Friendly name\n *     name: string\n *     // given a serialized value and environment, how to turn it into the target type\n *     fromSnapshot(snapshot: S, env: any): T\n *     // return the serialization of the current value\n *     toSnapshot(value: T): S\n *     // if true, this is a converted value, if false, it's a snapshot\n *     isTargetType(value: T | S): value is T\n *     // a non empty string is assumed to be a validation error\n *     getValidationMessage?(snapshot: S): string\n * }\n * ```\n *\n * Example:\n * ```ts\n * const DecimalPrimitive = types.custom<string, Decimal>({\n *     name: \"Decimal\",\n *     fromSnapshot(value: string) {\n *         return new Decimal(value)\n *     },\n *     toSnapshot(value: Decimal) {\n *         return value.toString()\n *     },\n *     isTargetType(value: string | Decimal): boolean {\n *         return value instanceof Decimal\n *     },\n *     getValidationMessage(value: string): string {\n *         if (/^-?\\d+\\.\\d+$/.test(value)) return \"\" // OK\n *         return `'${value}' doesn't look like a valid decimal number`\n *     }\n * })\n *\n * const Wallet = types.model({\n *     balance: DecimalPrimitive\n * })\n * ```\n *\n * @param options\n * @returns\n */\nfunction custom(options) {\n    return new CustomType(options);\n}\n/**\n * @internal\n * @hidden\n */\nclass CustomType extends SimpleType {\n    options;\n    flags = TypeFlags.Custom;\n    constructor(options) {\n        super(options.name);\n        this.options = options;\n    }\n    describe() {\n        return this.name;\n    }\n    isValidSnapshot(value, context) {\n        if (this.options.isTargetType(value)) {\n            return typeCheckSuccess();\n        }\n        const typeError = this.options.getValidationMessage(value);\n        if (typeError) {\n            return typeCheckFailure(context, value, `Invalid value for type '${this.name}': ${typeError}`);\n        }\n        return typeCheckSuccess();\n    }\n    getSnapshot(node) {\n        return this.options.toSnapshot(node.storedValue);\n    }\n    instantiate(parent, subpath, environment, initialValue) {\n        const valueToStore = this.options.isTargetType(initialValue)\n            ? initialValue\n            : this.options.fromSnapshot(initialValue, parent && parent.root.environment);\n        return createScalarNode(this, parent, subpath, environment, valueToStore);\n    }\n    reconcile(current, value, parent, subpath) {\n        const isSnapshot = !this.options.isTargetType(value);\n        // in theory customs use scalar nodes which cannot be detached, but still...\n        if (!current.isDetaching) {\n            const unchanged = current.type === this &&\n                (isSnapshot\n                    ? value === current.snapshot\n                    : value === current.storedValue);\n            if (unchanged) {\n                current.setParent(parent, subpath);\n                return current;\n            }\n        }\n        const valueToStore = isSnapshot\n            ? this.options.fromSnapshot(value, parent.root.environment)\n            : value;\n        const newNode = this.instantiate(parent, subpath, undefined, valueToStore);\n        current.die(); // noop if detaching\n        return newNode;\n    }\n}\n\n// we import the types to re-export them inside types.\nconst types = {\n    enumeration,\n    model,\n    compose,\n    custom,\n    reference,\n    safeReference,\n    union,\n    optional,\n    literal,\n    maybe,\n    maybeNull,\n    refinement,\n    string,\n    boolean,\n    number,\n    integer,\n    float,\n    finite,\n    Date: DatePrimitive,\n    map,\n    array,\n    frozen,\n    identifier,\n    identifierNumber,\n    late,\n    lazy,\n    undefined: undefinedType,\n    null: nullType,\n    snapshotProcessor\n};\n\nexport { addDisposer, addMiddleware, applyAction, applyPatch, applySnapshot, cast, castFlowReturn, castToReferenceSnapshot, castToSnapshot, clone, createActionTrackingMiddleware, createActionTrackingMiddleware2, decorate, destroy, detach, escapeJsonPath, flow, getChildType, getEnv, getIdentifier, getLivelinessChecking, getMembers, getNodeId, getParent, getParentOfType, getPath, getPathParts, getPropertyMembers, getRelativePath, getRoot, getRunningActionContext, getSnapshot, getType, hasParent, hasParentOfType, isActionContextChildOf, isActionContextThisOrChildOf, isAlive, isArrayType, isFrozenType, isIdentifierType, isLateType, isLiteralType, isMapType, isModelType, isOptionalType, isPrimitiveType, isProtected, isReferenceType, isRefinementType, isRoot, isStateTreeNode, isType, isUnionType, isValidReference, joinJsonPath, onAction, onPatch, onSnapshot, process$1 as process, protect, recordActions, recordPatches, resolveIdentifier, resolvePath, setDevMode, setLivelinessChecking, setLivelynessChecking, splitJsonPath, types as t, toGenerator, toGeneratorFunction, tryReference, tryResolve, typecheck, types, unescapeJsonPath, unprotect, walk };\n","import { forwardRef, memo } from \"react\"\n\nimport { isUsingStaticRendering } from \"./staticRendering\"\nimport { useObserver } from \"./useObserver\"\n\nlet warnObserverOptionsDeprecated = true\nlet warnLegacyContextTypes = true\n\nconst hasSymbol = typeof Symbol === \"function\" && Symbol.for\nconst isFunctionNameConfigurable =\n    Object.getOwnPropertyDescriptor(() => {}, \"name\")?.configurable ?? false\n\n// Using react-is had some issues (and operates on elements, not on types), see #608 / #609\nconst ReactForwardRefSymbol = hasSymbol\n    ? Symbol.for(\"react.forward_ref\")\n    : typeof forwardRef === \"function\" && forwardRef((props: any) => null)[\"$$typeof\"]\n\nconst ReactMemoSymbol = hasSymbol\n    ? Symbol.for(\"react.memo\")\n    : typeof memo === \"function\" && memo((props: any) => null)[\"$$typeof\"]\n\n/**\n * @deprecated Observer options will be removed in the next major version of mobx-react-lite.\n * Look at the individual properties for alternatives.\n */\nexport interface IObserverOptions {\n    /**\n     * @deprecated Pass a `React.forwardRef` component to observer instead of using the options object\n     * e.g. `observer(React.forwardRef(fn))`\n     */\n    readonly forwardRef?: boolean\n}\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefRenderFunction<TRef, P>,\n    options: IObserverOptions & {\n        /**\n         * @deprecated Pass a `React.forwardRef` component to observer instead of using the options object\n         * e.g. `observer(React.forwardRef(fn))`\n         */\n        forwardRef: true\n    }\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\n\nexport function observer<P extends object>(\n    baseComponent: React.FunctionComponent<P>,\n    options?: IObserverOptions\n): React.FunctionComponent<P>\n\nexport function observer<P extends object, TRef = {}>(\n    baseComponent: React.ForwardRefExoticComponent<\n        React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n    >\n): React.MemoExoticComponent<\n    React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>\n>\nexport function observer<\n    C extends React.FunctionComponent<any> | React.ForwardRefRenderFunction<any>,\n    Options extends IObserverOptions\n>(\n    baseComponent: C,\n    options?: Options\n): Options extends { forwardRef: true }\n    ? C extends React.ForwardRefRenderFunction<infer TRef, infer P>\n        ? C &\n              React.MemoExoticComponent<\n                  React.ForwardRefExoticComponent<\n                      React.PropsWithoutRef<P> & React.RefAttributes<TRef>\n                  >\n              >\n        : never /* forwardRef set for a non forwarding component */\n    : C & { displayName: string }\n\n// n.b. base case is not used for actual typings or exported in the typing files\nexport function observer<P extends object, TRef = {}>(\n    baseComponent:\n        | React.ForwardRefRenderFunction<TRef, P>\n        | React.FunctionComponent<P>\n        | React.ForwardRefExoticComponent<React.PropsWithoutRef<P> & React.RefAttributes<TRef>>,\n    // TODO remove in next major\n    options?: IObserverOptions\n) {\n    if (process.env.NODE_ENV !== \"production\" && warnObserverOptionsDeprecated && options) {\n        warnObserverOptionsDeprecated = false\n        console.warn(\n            `[mobx-react-lite] \\`observer(fn, { forwardRef: true })\\` is deprecated, use \\`observer(React.forwardRef(fn))\\``\n        )\n    }\n\n    if (ReactMemoSymbol && baseComponent[\"$$typeof\"] === ReactMemoSymbol) {\n        throw new Error(\n            `[mobx-react-lite] You are trying to use \\`observer\\` on a function component wrapped in either another \\`observer\\` or \\`React.memo\\`. The observer already applies 'React.memo' for you.`\n        )\n    }\n\n    // The working of observer is explained step by step in this talk: https://www.youtube.com/watch?v=cPF4iBedoF0&feature=youtu.be&t=1307\n    if (isUsingStaticRendering()) {\n        return baseComponent\n    }\n\n    let useForwardRef = options?.forwardRef ?? false\n    let render = baseComponent\n\n    const baseComponentName = baseComponent.displayName || baseComponent.name\n\n    // If already wrapped with forwardRef, unwrap,\n    // so we can patch render and apply memo\n    if (ReactForwardRefSymbol && baseComponent[\"$$typeof\"] === ReactForwardRefSymbol) {\n        useForwardRef = true\n        render = baseComponent[\"render\"]\n        if (typeof render !== \"function\") {\n            throw new Error(\n                `[mobx-react-lite] \\`render\\` property of ForwardRef was not a function`\n            )\n        }\n    }\n\n    let observerComponent = (props: any, ref: React.Ref<TRef>) => {\n        return useObserver(() => render(props, ref), baseComponentName)\n    }\n\n    // Inherit original name and displayName, see #3438\n    ;(observerComponent as React.FunctionComponent).displayName = baseComponent.displayName\n\n    if (isFunctionNameConfigurable) {\n        Object.defineProperty(observerComponent, \"name\", {\n            value: baseComponent.name,\n            writable: true,\n            configurable: true\n        })\n    }\n\n    // Support legacy context: `contextTypes` must be applied before `memo`\n    if ((baseComponent as any).contextTypes) {\n        ;(observerComponent as React.FunctionComponent).contextTypes = (\n            baseComponent as any\n        ).contextTypes\n\n        if (process.env.NODE_ENV !== \"production\" && warnLegacyContextTypes) {\n            warnLegacyContextTypes = false\n            console.warn(\n                `[mobx-react-lite] Support for Legacy Context in function components will be removed in the next major release.`\n            )\n        }\n    }\n\n    if (useForwardRef) {\n        // `forwardRef` must be applied prior `memo`\n        // `forwardRef(observer(cmp))` throws:\n        // \"forwardRef requires a render function but received a `memo` component. Instead of forwardRef(memo(...)), use memo(forwardRef(...))\"\n        observerComponent = forwardRef(observerComponent)\n    }\n\n    // memo; we are not interested in deep updates\n    // in props; we assume that if deep objects are changed,\n    // this is in observables, which would have been tracked anyway\n    observerComponent = memo(observerComponent)\n\n    copyStaticProperties(baseComponent, observerComponent)\n\n    if (\"production\" !== process.env.NODE_ENV) {\n        Object.defineProperty(observerComponent, \"contextTypes\", {\n            set() {\n                throw new Error(\n                    `[mobx-react-lite] \\`${\n                        this.displayName || this.type?.displayName || this.type?.name || \"Component\"\n                    }.contextTypes\\` must be set before applying \\`observer\\`.`\n                )\n            }\n        })\n    }\n\n    return observerComponent\n}\n\n// based on https://github.com/mridgway/hoist-non-react-statics/blob/master/src/index.js\nconst hoistBlackList: any = {\n    $$typeof: true,\n    render: true,\n    compare: true,\n    type: true,\n    // Don't redefine `displayName`,\n    // it's defined as getter-setter pair on `memo` (see #3192).\n    displayName: true\n}\n\nfunction copyStaticProperties(base: any, target: any) {\n    Object.keys(base).forEach(key => {\n        if (!hoistBlackList[key]) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(base, key)!)\n        }\n    })\n}\n","// eslint-disable-next-line @typescript-eslint/no-extraneous-class\nclass NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter<V> {\n  callbacks = new Set<(arg: V) => void>()\n  currentMessage?: V\n\n  addCallback(callback: (arg: V) => void = () => {}): void {\n    this.callbacks.add(callback)\n    if (this.currentMessage) {\n      callback(this.currentMessage)\n    }\n  }\n\n  callback(message: V) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController.ts'\nimport AggregateStatusReporter from './AggregateStatusReporter.ts'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U, V> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: (arg: V) => void,\n) => Promise<U>\n\ninterface Entry<U, V> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter<V>\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U, V = string> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U, V>>\n  private fillCallback: FillCallback<T, U, V>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U, V>\n    cache: Cache<Entry<U, V>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U, V>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter<V>()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U, V> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: V) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch((error: unknown) => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      (error: unknown) => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: (arg: V) => void,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M20.5 11H19V7c0-1.1-.9-2-2-2h-4V3.5C13 2.12 11.88 1 10.5 1S8 2.12 8 3.5V5H4c-1.1 0-1.99.9-1.99 2v3.8H3.5c1.49 0 2.7 1.21 2.7 2.7s-1.21 2.7-2.7 2.7H2V20c0 1.1.9 2 2 2h3.8v-1.5c0-1.49 1.21-2.7 2.7-2.7s2.7 1.21 2.7 2.7V22H17c1.1 0 2-.9 2-2v-4h1.5c1.38 0 2.5-1.12 2.5-2.5S21.88 11 20.5 11\"\n}), 'Extension');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M16 1H4c-1.1 0-2 .9-2 2v14h2V3h12zm-1 4 6 6v10c0 1.1-.9 2-2 2H7.99C6.89 23 6 22.1 6 21l.01-14c0-1.1.89-2 1.99-2zm-1 7h5.5L14 6.5z\"\n}), 'FileCopy');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 9h-4V3H9v6H5l7 7zM5 18v2h14v-2z\"\n}), 'GetApp');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3z\"\n}), 'Launch');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M5 4v2h14V4zm0 10h4v6h6v-6h4l-7-7z\"\n}), 'Publish');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M18.4 10.6C16.55 8.99 14.15 8 11.5 8c-4.65 0-8.58 3.03-9.96 7.22L3.9 16c1.05-3.19 4.05-5.5 7.6-5.5 1.95 0 3.73.72 5.12 1.88L13 16h9V7z\"\n}), 'Redo');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.05.3-.09.63-.09.94s.02.64.07.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6\"\n}), 'Settings');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M18 16.08c-.76 0-1.44.3-1.96.77L8.91 12.7c.05-.23.09-.46.09-.7s-.04-.47-.09-.7l7.05-4.11c.54.5 1.25.81 2.04.81 1.66 0 3-1.34 3-3s-1.34-3-3-3-3 1.34-3 3c0 .24.04.47.09.7L8.04 9.81C7.5 9.31 6.79 9 6 9c-1.66 0-3 1.34-3 3s1.34 3 3 3c.79 0 1.5-.31 2.04-.81l7.12 4.16c-.05.21-.08.43-.08.65 0 1.61 1.31 2.92 2.92 2.92s2.92-1.31 2.92-2.92-1.31-2.92-2.92-2.92\"\n}), 'Share');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M11 21H5c-1.1 0-2-.9-2-2V5c0-1.1.9-2 2-2h6zm2 0h6c1.1 0 2-.9 2-2v-7h-8zm8-11V5c0-1.1-.9-2-2-2h-6v7z\"\n}), 'SpaceDashboard');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M2 20h20v-4H2zm2-3h2v2H4zM2 4v4h20V4zm4 3H4V5h2zm-4 7h20v-4H2zm2-3h2v2H4z\"\n}), 'Storage');","\"use client\";\n\nimport createSvgIcon from \"./utils/createSvgIcon.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nexport default createSvgIcon(/*#__PURE__*/_jsx(\"path\", {\n  d: \"M12.5 8c-2.65 0-5.05.99-6.9 2.6L2 7v9h9l-3.62-3.62c1.39-1.16 3.16-1.88 5.12-1.88 3.54 0 6.55 2.31 7.6 5.5l2.37-.78C21.08 11.03 17.15 8 12.5 8\"\n}), 'Undo');","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getAppBarUtilityClass(slot) {\n  return generateUtilityClass('MuiAppBar', slot);\n}\nconst appBarClasses = generateUtilityClasses('MuiAppBar', ['root', 'positionFixed', 'positionAbsolute', 'positionSticky', 'positionStatic', 'positionRelative', 'colorDefault', 'colorPrimary', 'colorSecondary', 'colorInherit', 'colorTransparent', 'colorError', 'colorInfo', 'colorSuccess', 'colorWarning']);\nexport default appBarClasses;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport composeClasses from '@mui/utils/composeClasses';\nimport { styled } from \"../zero-styled/index.js\";\nimport memoTheme from \"../utils/memoTheme.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\nimport capitalize from \"../utils/capitalize.js\";\nimport createSimplePaletteValueFilter from \"../utils/createSimplePaletteValueFilter.js\";\nimport Paper from \"../Paper/index.js\";\nimport { getAppBarUtilityClass } from \"./appBarClasses.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    color,\n    position,\n    classes\n  } = ownerState;\n  const slots = {\n    root: ['root', `color${capitalize(color)}`, `position${capitalize(position)}`]\n  };\n  return composeClasses(slots, getAppBarUtilityClass, classes);\n};\n\n// var2 is the fallback.\n// Ex. var1: 'var(--a)', var2: 'var(--b)'; return: 'var(--a, var(--b))'\nconst joinVars = (var1, var2) => var1 ? `${var1.replace(')', '')}, ${var2})` : var2;\nconst AppBarRoot = styled(Paper, {\n  name: 'MuiAppBar',\n  slot: 'Root',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[`position${capitalize(ownerState.position)}`], styles[`color${capitalize(ownerState.color)}`]];\n  }\n})(memoTheme(({\n  theme\n}) => ({\n  display: 'flex',\n  flexDirection: 'column',\n  width: '100%',\n  boxSizing: 'border-box',\n  // Prevent padding issue with the Modal and fixed positioned AppBar.\n  flexShrink: 0,\n  variants: [{\n    props: {\n      position: 'fixed'\n    },\n    style: {\n      position: 'fixed',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0,\n      '@media print': {\n        // Prevent the app bar to be visible on each printed page.\n        position: 'absolute'\n      }\n    }\n  }, {\n    props: {\n      position: 'absolute'\n    },\n    style: {\n      position: 'absolute',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0\n    }\n  }, {\n    props: {\n      position: 'sticky'\n    },\n    style: {\n      position: 'sticky',\n      zIndex: (theme.vars || theme).zIndex.appBar,\n      top: 0,\n      left: 'auto',\n      right: 0\n    }\n  }, {\n    props: {\n      position: 'static'\n    },\n    style: {\n      position: 'static'\n    }\n  }, {\n    props: {\n      position: 'relative'\n    },\n    style: {\n      position: 'relative'\n    }\n  }, {\n    props: {\n      color: 'inherit'\n    },\n    style: {\n      '--AppBar-color': 'inherit',\n      color: 'var(--AppBar-color)'\n    }\n  }, {\n    props: {\n      color: 'default'\n    },\n    style: {\n      '--AppBar-background': theme.vars ? theme.vars.palette.AppBar.defaultBg : theme.palette.grey[100],\n      '--AppBar-color': theme.vars ? theme.vars.palette.text.primary : theme.palette.getContrastText(theme.palette.grey[100]),\n      ...theme.applyStyles('dark', {\n        '--AppBar-background': theme.vars ? theme.vars.palette.AppBar.defaultBg : theme.palette.grey[900],\n        '--AppBar-color': theme.vars ? theme.vars.palette.text.primary : theme.palette.getContrastText(theme.palette.grey[900])\n      })\n    }\n  }, ...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(['contrastText'])).map(([color]) => ({\n    props: {\n      color\n    },\n    style: {\n      '--AppBar-background': (theme.vars ?? theme).palette[color].main,\n      '--AppBar-color': (theme.vars ?? theme).palette[color].contrastText\n    }\n  })), {\n    props: props => props.enableColorOnDark === true && !['inherit', 'transparent'].includes(props.color),\n    style: {\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)'\n    }\n  }, {\n    props: props => props.enableColorOnDark === false && !['inherit', 'transparent'].includes(props.color),\n    style: {\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)',\n      ...theme.applyStyles('dark', {\n        backgroundColor: theme.vars ? joinVars(theme.vars.palette.AppBar.darkBg, 'var(--AppBar-background)') : null,\n        color: theme.vars ? joinVars(theme.vars.palette.AppBar.darkColor, 'var(--AppBar-color)') : null\n      })\n    }\n  }, {\n    props: {\n      color: 'transparent'\n    },\n    style: {\n      '--AppBar-background': 'transparent',\n      '--AppBar-color': 'inherit',\n      backgroundColor: 'var(--AppBar-background)',\n      color: 'var(--AppBar-color)',\n      ...theme.applyStyles('dark', {\n        backgroundImage: 'none'\n      })\n    }\n  }]\n})));\nconst AppBar = /*#__PURE__*/React.forwardRef(function AppBar(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiAppBar'\n  });\n  const {\n    className,\n    color = 'primary',\n    enableColorOnDark = false,\n    position = 'fixed',\n    ...other\n  } = props;\n  const ownerState = {\n    ...props,\n    color,\n    position,\n    enableColorOnDark\n  };\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(AppBarRoot, {\n    square: true,\n    component: \"header\",\n    ownerState: ownerState,\n    elevation: 4,\n    className: clsx(classes.root, className, position === 'fixed' && 'mui-fixed'),\n    ref: ref,\n    ...other\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? AppBar.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'primary'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'inherit', 'primary', 'secondary', 'transparent', 'error', 'info', 'success', 'warning']), PropTypes.string]),\n  /**\n   * Shadow depth, corresponds to `dp` in the spec.\n   * It accepts values between 0 and 24 inclusive.\n   * @default 4\n   */\n  elevation: PropTypes.number,\n  /**\n   * If true, the `color` prop is applied in dark mode.\n   * @default false\n   */\n  enableColorOnDark: PropTypes.bool,\n  /**\n   * The positioning type. The behavior of the different options is described\n   * [in the MDN web docs](https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/position).\n   * Note: `sticky` is not universally supported and will fall back to `static` when unavailable.\n   * @default 'fixed'\n   */\n  position: PropTypes.oneOf(['absolute', 'fixed', 'relative', 'static', 'sticky']),\n  /**\n   * If `false`, rounded corners are enabled.\n   * @default true\n   */\n  square: PropTypes.bool,\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object])\n} : void 0;\nexport default AppBar;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport { globalCss } from \"../zero-styled/index.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\n\n// to determine if the global styles are static or dynamic\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst isDynamicSupport = typeof globalCss({}) === 'function';\nexport const html = (theme, enableColorScheme) => ({\n  WebkitFontSmoothing: 'antialiased',\n  // Antialiasing.\n  MozOsxFontSmoothing: 'grayscale',\n  // Antialiasing.\n  // Change from `box-sizing: content-box` so that `width`\n  // is not affected by `padding` or `border`.\n  boxSizing: 'border-box',\n  // Fix font resize problem in iOS\n  WebkitTextSizeAdjust: '100%',\n  // When used under CssVarsProvider, colorScheme should not be applied dynamically because it will generate the stylesheet twice for server-rendered applications.\n  ...(enableColorScheme && !theme.vars && {\n    colorScheme: theme.palette.mode\n  })\n});\nexport const body = theme => ({\n  color: (theme.vars || theme).palette.text.primary,\n  ...theme.typography.body1,\n  backgroundColor: (theme.vars || theme).palette.background.default,\n  '@media print': {\n    // Save printer ink.\n    backgroundColor: (theme.vars || theme).palette.common.white\n  }\n});\nexport const styles = (theme, enableColorScheme = false) => {\n  const colorSchemeStyles = {};\n  if (enableColorScheme && theme.colorSchemes && typeof theme.getColorSchemeSelector === 'function') {\n    Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {\n      const selector = theme.getColorSchemeSelector(key);\n      if (selector.startsWith('@')) {\n        // for @media (prefers-color-scheme), we need to target :root\n        colorSchemeStyles[selector] = {\n          ':root': {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      } else {\n        // else, it's likely that the selector already target an element with a class or data attribute\n        colorSchemeStyles[selector.replace(/\\s*&/, '')] = {\n          colorScheme: scheme.palette?.mode\n        };\n      }\n    });\n  }\n  let defaultStyles = {\n    html: html(theme, enableColorScheme),\n    '*, *::before, *::after': {\n      boxSizing: 'inherit'\n    },\n    'strong, b': {\n      fontWeight: theme.typography.fontWeightBold\n    },\n    body: {\n      margin: 0,\n      // Remove the margin in all browsers.\n      ...body(theme),\n      // Add support for document.body.requestFullScreen().\n      // Other elements, if background transparent, are not supported.\n      '&::backdrop': {\n        backgroundColor: (theme.vars || theme).palette.background.default\n      }\n    },\n    ...colorSchemeStyles\n  };\n  const themeOverrides = theme.components?.MuiCssBaseline?.styleOverrides;\n  if (themeOverrides) {\n    defaultStyles = [defaultStyles, themeOverrides];\n  }\n  return defaultStyles;\n};\n\n// `ecs` stands for enableColorScheme. This is internal logic to make it work with Pigment CSS, so shorter is better.\nconst SELECTOR = 'mui-ecs';\nconst staticStyles = theme => {\n  const result = styles(theme, false);\n  const baseStyles = Array.isArray(result) ? result[0] : result;\n  if (!theme.vars && baseStyles) {\n    baseStyles.html[`:root:has(${SELECTOR})`] = {\n      colorScheme: theme.palette.mode\n    };\n  }\n  if (theme.colorSchemes) {\n    Object.entries(theme.colorSchemes).forEach(([key, scheme]) => {\n      const selector = theme.getColorSchemeSelector(key);\n      if (selector.startsWith('@')) {\n        // for @media (prefers-color-scheme), we need to target :root\n        baseStyles[selector] = {\n          [`:root:not(:has(.${SELECTOR}))`]: {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      } else {\n        // else, it's likely that the selector already target an element with a class or data attribute\n        baseStyles[selector.replace(/\\s*&/, '')] = {\n          [`&:not(:has(.${SELECTOR}))`]: {\n            colorScheme: scheme.palette?.mode\n          }\n        };\n      }\n    });\n  }\n  return result;\n};\nconst GlobalStyles = globalCss(isDynamicSupport ? ({\n  theme,\n  enableColorScheme\n}) => styles(theme, enableColorScheme) : ({\n  theme\n}) => staticStyles(theme));\n\n/**\n * Kickstart an elegant, consistent, and simple baseline to build upon.\n */\nfunction CssBaseline(inProps) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiCssBaseline'\n  });\n  const {\n    children,\n    enableColorScheme = false\n  } = props;\n  return /*#__PURE__*/_jsxs(React.Fragment, {\n    children: [isDynamicSupport && /*#__PURE__*/_jsx(GlobalStyles, {\n      enableColorScheme: enableColorScheme\n    }), !isDynamicSupport && !enableColorScheme && /*#__PURE__*/_jsx(\"span\", {\n      className: SELECTOR,\n      style: {\n        display: 'none'\n      }\n    }), children]\n  });\n}\nprocess.env.NODE_ENV !== \"production\" ? CssBaseline.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * You can wrap a node.\n   */\n  children: PropTypes.node,\n  /**\n   * Enable `color-scheme` CSS property to use `theme.palette.mode`.\n   * For more details, check out https://developer.mozilla.org/en-US/docs/Web/CSS/Reference/Properties/color-scheme\n   * For browser support, check out https://caniuse.com/?search=color-scheme\n   * @default false\n   */\n  enableColorScheme: PropTypes.bool\n} : void 0;\nexport default CssBaseline;","'use client';\n\nimport * as React from 'react';\nimport PropTypes from 'prop-types';\nimport clsx from 'clsx';\nimport composeClasses from '@mui/utils/composeClasses';\nimport ButtonBase from \"../ButtonBase/index.js\";\nimport capitalize from \"../utils/capitalize.js\";\nimport fabClasses, { getFabUtilityClass } from \"./fabClasses.js\";\nimport rootShouldForwardProp from \"../styles/rootShouldForwardProp.js\";\nimport { styled } from \"../zero-styled/index.js\";\nimport memoTheme from \"../utils/memoTheme.js\";\nimport createSimplePaletteValueFilter from \"../utils/createSimplePaletteValueFilter.js\";\nimport { useDefaultProps } from \"../DefaultPropsProvider/index.js\";\nimport { jsx as _jsx } from \"react/jsx-runtime\";\nconst useUtilityClasses = ownerState => {\n  const {\n    color,\n    variant,\n    classes,\n    size\n  } = ownerState;\n  const slots = {\n    root: ['root', variant, `size${capitalize(size)}`, color === 'inherit' ? 'colorInherit' : color]\n  };\n  const composedClasses = composeClasses(slots, getFabUtilityClass, classes);\n  return {\n    ...classes,\n    // forward the focused, disabled, etc. classes to the ButtonBase\n    ...composedClasses\n  };\n};\nconst FabRoot = styled(ButtonBase, {\n  name: 'MuiFab',\n  slot: 'Root',\n  shouldForwardProp: prop => rootShouldForwardProp(prop) || prop === 'classes',\n  overridesResolver: (props, styles) => {\n    const {\n      ownerState\n    } = props;\n    return [styles.root, styles[ownerState.variant], styles[`size${capitalize(ownerState.size)}`], ownerState.color === 'inherit' && styles.colorInherit, styles[capitalize(ownerState.size)], styles[ownerState.color]];\n  }\n})(memoTheme(({\n  theme\n}) => ({\n  ...theme.typography.button,\n  minHeight: 36,\n  transition: theme.transitions.create(['background-color', 'box-shadow', 'border-color'], {\n    duration: theme.transitions.duration.short\n  }),\n  borderRadius: '50%',\n  padding: 0,\n  minWidth: 0,\n  width: 56,\n  height: 56,\n  zIndex: (theme.vars || theme).zIndex.fab,\n  boxShadow: (theme.vars || theme).shadows[6],\n  '&:active': {\n    boxShadow: (theme.vars || theme).shadows[12]\n  },\n  color: theme.vars ? theme.vars.palette.grey[900] : theme.palette.getContrastText?.(theme.palette.grey[300]),\n  backgroundColor: (theme.vars || theme).palette.grey[300],\n  '&:hover': {\n    backgroundColor: (theme.vars || theme).palette.grey.A100,\n    // Reset on touch devices, it doesn't add specificity\n    '@media (hover: none)': {\n      backgroundColor: (theme.vars || theme).palette.grey[300]\n    },\n    textDecoration: 'none'\n  },\n  [`&.${fabClasses.focusVisible}`]: {\n    boxShadow: (theme.vars || theme).shadows[6]\n  },\n  variants: [{\n    props: {\n      size: 'small'\n    },\n    style: {\n      width: 40,\n      height: 40\n    }\n  }, {\n    props: {\n      size: 'medium'\n    },\n    style: {\n      width: 48,\n      height: 48\n    }\n  }, {\n    props: {\n      variant: 'extended'\n    },\n    style: {\n      borderRadius: 48 / 2,\n      padding: '0 16px',\n      width: 'auto',\n      minHeight: 'auto',\n      minWidth: 48,\n      height: 48\n    }\n  }, {\n    props: {\n      variant: 'extended',\n      size: 'small'\n    },\n    style: {\n      width: 'auto',\n      padding: '0 8px',\n      borderRadius: 34 / 2,\n      minWidth: 34,\n      height: 34\n    }\n  }, {\n    props: {\n      variant: 'extended',\n      size: 'medium'\n    },\n    style: {\n      width: 'auto',\n      padding: '0 16px',\n      borderRadius: 40 / 2,\n      minWidth: 40,\n      height: 40\n    }\n  }, {\n    props: {\n      color: 'inherit'\n    },\n    style: {\n      color: 'inherit'\n    }\n  }]\n})), memoTheme(({\n  theme\n}) => ({\n  variants: [...Object.entries(theme.palette).filter(createSimplePaletteValueFilter(['dark', 'contrastText'])) // check all the used fields in the style below\n  .map(([color]) => ({\n    props: {\n      color\n    },\n    style: {\n      color: (theme.vars || theme).palette[color].contrastText,\n      backgroundColor: (theme.vars || theme).palette[color].main,\n      '&:hover': {\n        backgroundColor: (theme.vars || theme).palette[color].dark,\n        // Reset on touch devices, it doesn't add specificity\n        '@media (hover: none)': {\n          backgroundColor: (theme.vars || theme).palette[color].main\n        }\n      }\n    }\n  }))]\n})), memoTheme(({\n  theme\n}) => ({\n  [`&.${fabClasses.disabled}`]: {\n    color: (theme.vars || theme).palette.action.disabled,\n    boxShadow: (theme.vars || theme).shadows[0],\n    backgroundColor: (theme.vars || theme).palette.action.disabledBackground\n  }\n})));\nconst Fab = /*#__PURE__*/React.forwardRef(function Fab(inProps, ref) {\n  const props = useDefaultProps({\n    props: inProps,\n    name: 'MuiFab'\n  });\n  const {\n    children,\n    className,\n    color = 'default',\n    component = 'button',\n    disabled = false,\n    disableFocusRipple = false,\n    focusVisibleClassName,\n    size = 'large',\n    variant = 'circular',\n    ...other\n  } = props;\n  const ownerState = {\n    ...props,\n    color,\n    component,\n    disabled,\n    disableFocusRipple,\n    size,\n    variant\n  };\n  const classes = useUtilityClasses(ownerState);\n  return /*#__PURE__*/_jsx(FabRoot, {\n    className: clsx(classes.root, className),\n    component: component,\n    disabled: disabled,\n    focusRipple: !disableFocusRipple,\n    focusVisibleClassName: clsx(classes.focusVisible, focusVisibleClassName),\n    ownerState: ownerState,\n    ref: ref,\n    ...other,\n    classes: classes,\n    children: children\n  });\n});\nprocess.env.NODE_ENV !== \"production\" ? Fab.propTypes /* remove-proptypes */ = {\n  //  Warning \n  //  These PropTypes are generated from the TypeScript type definitions. \n  //     To update them, edit the d.ts file and run `pnpm proptypes`.     \n  // \n  /**\n   * The content of the component.\n   */\n  children: PropTypes.node,\n  /**\n   * Override or extend the styles applied to the component.\n   */\n  classes: PropTypes.object,\n  /**\n   * @ignore\n   */\n  className: PropTypes.string,\n  /**\n   * The color of the component.\n   * It supports both default and custom theme colors, which can be added as shown in the\n   * [palette customization guide](https://mui.com/material-ui/customization/palette/#custom-colors).\n   * @default 'default'\n   */\n  color: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['default', 'error', 'info', 'inherit', 'primary', 'secondary', 'success', 'warning']), PropTypes.string]),\n  /**\n   * The component used for the root node.\n   * Either a string to use a HTML element or a component.\n   */\n  component: PropTypes.elementType,\n  /**\n   * If `true`, the component is disabled.\n   * @default false\n   */\n  disabled: PropTypes.bool,\n  /**\n   * If `true`, the  keyboard focus ripple is disabled.\n   * @default false\n   */\n  disableFocusRipple: PropTypes.bool,\n  /**\n   * If `true`, the ripple effect is disabled.\n   */\n  disableRipple: PropTypes.bool,\n  /**\n   * @ignore\n   */\n  focusVisibleClassName: PropTypes.string,\n  /**\n   * The URL to link to when the button is clicked.\n   * If defined, an `a` element will be used as the root node.\n   */\n  href: PropTypes.string,\n  /**\n   * The size of the component.\n   * `small` is equivalent to the dense button styling.\n   * @default 'large'\n   */\n  size: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['small', 'medium', 'large']), PropTypes.string]),\n  /**\n   * The system prop that allows defining system overrides as well as additional CSS styles.\n   */\n  sx: PropTypes.oneOfType([PropTypes.arrayOf(PropTypes.oneOfType([PropTypes.func, PropTypes.object, PropTypes.bool])), PropTypes.func, PropTypes.object]),\n  /**\n   * The variant to use.\n   * @default 'circular'\n   */\n  variant: PropTypes /* @typescript-to-proptypes-ignore */.oneOfType([PropTypes.oneOf(['circular', 'extended']), PropTypes.string])\n} : void 0;\nexport default Fab;","import generateUtilityClasses from '@mui/utils/generateUtilityClasses';\nimport generateUtilityClass from '@mui/utils/generateUtilityClass';\nexport function getFabUtilityClass(slot) {\n  return generateUtilityClass('MuiFab', slot);\n}\nconst fabClasses = generateUtilityClasses('MuiFab', ['root', 'primary', 'secondary', 'extended', 'circular', 'focusVisible', 'disabled', 'colorInherit', 'sizeSmall', 'sizeMedium', 'sizeLarge', 'info', 'error', 'warning', 'success']);\nexport default fabClasses;","import { errorConstructors, errorFactories } from './errorConstructors.ts'\nimport NonError from './nonError.ts'\n\nconst errorProperties = [\n  { property: 'name', enumerable: false },\n  { property: 'message', enumerable: false },\n  { property: 'stack', enumerable: false },\n  { property: 'code', enumerable: true },\n  { property: 'cause', enumerable: false },\n  { property: 'errors', enumerable: false },\n] as const\n\nconst toJsonWasCalled = new WeakSet()\n\nfunction toJSON(from: { toJSON: () => unknown }) {\n  toJsonWasCalled.add(from)\n  const json = from.toJSON()\n  toJsonWasCalled.delete(from)\n  return json\n}\n\nfunction newError(name: string) {\n  const factory = errorFactories.get(name)\n  if (factory) {\n    return factory()\n  }\n\n  const ErrorConstructor = errorConstructors.get(name) ?? Error\n  if (name === 'AggregateError') {\n    return new AggregateError([])\n  }\n  return new ErrorConstructor()\n}\n\nexport function isErrorLike(value: unknown): value is Error {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as Error).name === 'string' &&\n    typeof (value as Error).message === 'string' &&\n    typeof (value as Error).stack === 'string'\n  )\n}\n\nfunction isMinimumViableSerializedError(\n  value: unknown,\n): value is { name: string; message: string } {\n  return (\n    !!value &&\n    typeof value === 'object' &&\n    typeof (value as { message?: unknown }).message === 'string' &&\n    !Array.isArray(value)\n  )\n}\n\ninterface DestroyCircularOptions {\n  from: Record<string, unknown>\n  seen: unknown[]\n  to?: Record<string, unknown> | Error | unknown[]\n  forceEnumerable?: boolean\n  maxDepth: number\n  depth: number\n  useToJSON?: boolean\n  serialize: boolean\n}\n\nfunction destroyCircular({\n  from,\n  seen,\n  to,\n  forceEnumerable,\n  maxDepth,\n  depth,\n  useToJSON,\n  serialize,\n}: DestroyCircularOptions): Record<string, unknown> {\n  if (!to) {\n    if (Array.isArray(from)) {\n      to = []\n    } else if (!serialize && isErrorLike(from)) {\n      to = newError(from.name)\n    } else {\n      to = {}\n    }\n  }\n\n  seen.push(from)\n\n  if (depth >= maxDepth) {\n    return to as Record<string, unknown>\n  }\n\n  if (\n    useToJSON &&\n    typeof (from as { toJSON?: unknown }).toJSON === 'function' &&\n    !toJsonWasCalled.has(from)\n  ) {\n    return toJSON(from as { toJSON: () => unknown }) as Record<string, unknown>\n  }\n\n  const continueDestroyCircular = (value: Record<string, unknown>) =>\n    destroyCircular({\n      from: value,\n      seen: [...seen],\n      forceEnumerable,\n      maxDepth,\n      depth,\n      useToJSON,\n      serialize,\n    })\n\n  for (const [key, value] of Object.entries(from)) {\n    if (\n      value &&\n      value instanceof Uint8Array &&\n      value.constructor.name === 'Buffer'\n    ) {\n      ;(to as Record<string, unknown>)[key] = serialize\n        ? '[object Buffer]'\n        : value\n      continue\n    }\n\n    if (\n      value !== null &&\n      typeof value === 'object' &&\n      typeof (value as { pipe?: unknown }).pipe === 'function'\n    ) {\n      ;(to as Record<string, unknown>)[key] = serialize\n        ? '[object Stream]'\n        : value\n      continue\n    }\n\n    if (typeof value === 'function') {\n      if (!serialize) {\n        ;(to as Record<string, unknown>)[key] = value\n      }\n      continue\n    }\n\n    if (!value || typeof value !== 'object') {\n      try {\n        ;(to as Record<string, unknown>)[key] = value\n      } catch {}\n      continue\n    }\n\n    if (!seen.includes(from[key])) {\n      depth++\n      ;(to as Record<string, unknown>)[key] = continueDestroyCircular(\n        from[key] as Record<string, unknown>,\n      )\n      continue\n    }\n\n    ;(to as Record<string, unknown>)[key] = '[Circular]'\n  }\n\n  if (serialize || to instanceof Error) {\n    for (const { property, enumerable } of errorProperties) {\n      const val = from[property]\n      if (val !== undefined && val !== null) {\n        Object.defineProperty(to, property, {\n          value:\n            isErrorLike(val) || Array.isArray(val)\n              ? continueDestroyCircular(\n                  val as unknown as Record<string, unknown>,\n                )\n              : val,\n          enumerable: forceEnumerable ? true : enumerable,\n          configurable: true,\n          writable: true,\n        })\n      }\n    }\n  }\n\n  return to as Record<string, unknown>\n}\n\nexport interface ErrorObject {\n  name?: string\n  message: string\n  stack?: string\n  code?: string\n  cause?: unknown\n}\n\nexport function serializeError(\n  value: unknown,\n  options: { maxDepth?: number; useToJSON?: boolean } = {},\n) {\n  const { maxDepth = Number.POSITIVE_INFINITY, useToJSON = true } = options\n\n  if (typeof value === 'object' && value !== null) {\n    return destroyCircular({\n      from: value as Record<string, unknown>,\n      seen: [],\n      forceEnumerable: true,\n      maxDepth,\n      depth: 0,\n      useToJSON,\n      serialize: true,\n    }) as unknown as ErrorObject\n  }\n\n  let normalized: unknown = value\n  if (typeof value === 'function') {\n    normalized = '<Function>'\n  }\n\n  return destroyCircular({\n    from: new NonError(normalized) as unknown as Record<string, unknown>,\n    seen: [],\n    forceEnumerable: true,\n    maxDepth,\n    depth: 0,\n    useToJSON,\n    serialize: true,\n  }) as unknown as ErrorObject\n}\n\nexport function deserializeError(\n  value: unknown,\n  options: { maxDepth?: number } = {},\n) {\n  const { maxDepth = Number.POSITIVE_INFINITY } = options\n\n  if (value instanceof Error) {\n    return value\n  }\n\n  if (isMinimumViableSerializedError(value)) {\n    return destroyCircular({\n      from: value as unknown as Record<string, unknown>,\n      seen: [],\n      to: newError((value as { name?: string }).name ?? 'Error'),\n      maxDepth,\n      depth: 0,\n      serialize: false,\n    }) as unknown as Error\n  }\n\n  return new NonError(value)\n}\n","import EventEmitter from './ee.ts'\nimport { deserializeError } from './serializeError/index.ts'\n\ninterface RpcMessageData {\n  uid: string\n  libRpc?: true\n  error?: string\n  method?: string\n  eventName?: string\n  data: unknown\n}\n\nlet counter = 0\n\nexport default class RpcClient extends EventEmitter {\n  protected calls = new Map<string, (data: unknown) => void>()\n  protected errors = new Map<string, (error: Error) => void>()\n\n  constructor(public worker: Worker) {\n    super()\n    this.worker.addEventListener(\n      'message',\n      (e: MessageEvent<RpcMessageData>) => {\n        this.handler(e)\n      },\n    )\n    this.worker.addEventListener('error', (e: ErrorEvent) => {\n      this.catch(e)\n    })\n  }\n\n  protected handler(e: MessageEvent<RpcMessageData>) {\n    const { uid, error, method, eventName, data, libRpc } = e.data\n    if (!libRpc) {\n      return\n    }\n    if (error) {\n      this.reject(uid, error)\n    } else if (method) {\n      this.resolve(uid, data)\n    } else if (eventName) {\n      this.emit(eventName, data)\n    }\n  }\n\n  protected catch(e: ErrorEvent) {\n    this.emit('error', {\n      message: e.message,\n      lineno: e.lineno,\n      filename: e.filename,\n    })\n  }\n\n  protected reject(uid: string, error: string | Error) {\n    const errorFn = this.errors.get(uid)\n    if (errorFn) {\n      errorFn(deserializeError(error))\n      this.clear(uid)\n    }\n  }\n\n  protected resolve(uid: string, data: unknown) {\n    const callFn = this.calls.get(uid)\n    if (callFn) {\n      callFn(data)\n      this.clear(uid)\n    }\n  }\n\n  protected clear(uid: string) {\n    this.calls.delete(uid)\n    this.errors.delete(uid)\n  }\n\n  call(\n    method: string,\n    data: unknown,\n    { transferables = [] }: { transferables?: Transferable[] } = {},\n  ) {\n    const uid = String(++counter)\n    return new Promise((resolve, reject) => {\n      this.calls.set(uid, resolve)\n      this.errors.set(uid, reject)\n      this.worker.postMessage(\n        { method, uid, data, libRpc: true },\n        transferables,\n      )\n    })\n  }\n}\n","import { ErrorObject, serializeError } from './serializeError/index.ts'\n\nfunction isTransferable(object: unknown): object is Transferable {\n  try {\n    return (\n      object instanceof ArrayBuffer ||\n      object instanceof ImageBitmap ||\n      object instanceof OffscreenCanvas ||\n      object instanceof MessagePort\n    )\n  } catch {\n    return false\n  }\n}\n\nfunction isObject(data: unknown): data is Record<string, unknown> {\n  return Object(data) === data\n}\n\nfunction peekTransferables(data: unknown) {\n  const result: Transferable[] = []\n  if (isTransferable(data)) {\n    result.push(data)\n  } else if (isObject(data)) {\n    for (const key of Object.keys(data)) {\n      const val = data[key]\n      if (isTransferable(val)) {\n        result.push(val)\n      }\n    }\n  }\n  return result\n}\n\nexport interface RpcResult {\n  __rpcResult: true\n  value: unknown\n  transferables: Transferable[]\n}\n\nexport function rpcResult(\n  value: unknown,\n  transferables: Transferable[],\n): RpcResult {\n  return { __rpcResult: true, value, transferables }\n}\n\ntype Procedure = (data: unknown) => Promise<unknown>\n\ninterface RpcMessageData {\n  method: string\n  uid: string\n  libRpc?: true\n  data: unknown\n}\n\nfunction isRpcResult(value: unknown): value is RpcResult {\n  return typeof value === 'object' && value !== null && '__rpcResult' in value\n}\n\nexport default class RpcServer {\n  protected methods: Record<string, Procedure>\n\n  constructor(methods: Record<string, Procedure>) {\n    this.methods = methods\n    self.addEventListener('message', (e: MessageEvent<RpcMessageData>) => {\n      this.handler(e)\n    })\n  }\n\n  protected handler(e: MessageEvent<RpcMessageData>) {\n    const { libRpc, method, uid, data } = e.data\n    if (!libRpc) {\n      return\n    }\n    const methodFn = this.methods[method]\n    if (methodFn) {\n      Promise.resolve(data)\n        .then(methodFn)\n        .then(\n          response => {\n            this.reply(uid, method, response)\n          },\n          (error: unknown) => {\n            this.throw(uid, serializeError(error))\n          },\n        )\n    } else {\n      this.throw(uid, `Unknown RPC method \"${method}\"`)\n    }\n  }\n\n  protected reply(uid: string, method: string, response: unknown) {\n    try {\n      if (isRpcResult(response)) {\n        const { value, transferables } = response\n        self.postMessage(\n          { uid, method, data: value, libRpc: true },\n          transferables,\n        )\n      } else {\n        const transferables = peekTransferables(response)\n        self.postMessage(\n          { uid, method, data: response, libRpc: true },\n          transferables,\n        )\n      }\n    } catch (e) {\n      this.throw(uid, serializeError(e))\n    }\n  }\n\n  protected throw(uid: string, error: ErrorObject | string) {\n    self.postMessage({ uid, error, libRpc: true })\n  }\n\n  emit(eventName: string, data: unknown, transferables?: Transferable[]) {\n    const transfer = transferables ?? peekTransferables(data)\n    self.postMessage({ eventName, data, libRpc: true }, transfer)\n  }\n}\n"],"names":["livelinessChecking","setLivelinessChecking","mode","getLivelinessChecking","setLivelynessChecking","Hook","getType","object","assertIsStateTreeNode","getStateTreeNode","type","getChildType","propertyName","onPatch","target","callback","assertIsFunction","onSnapshot","applyPatch","patch","assertArg","p","applyPatches","asArray","recordPatches","subject","filter","data","patches","inversePatches","publicData","disposer","recorder","recording","slice","reversedInversePatches","reverse","stop","undefined","resume","inversePatch","getRunningActionContext","push","replay","undo","protect","node","isRoot","fail","isProtectionEnabled","unprotect","isProtected","applySnapshot","snapshot","getSnapshot","applyPostProcess","freeze","hasParent","depth","assertIsNumber","parent","getParent","d","storedValue","hasParentOfType","assertIsType","is","getParentOfType","getRoot","root","getPath","path","getPathParts","splitJsonPath","resolvePath","assertIsString","resolveNodeByPath","value","resolveIdentifier","identifier","isValidIdentifier","identifierCache","resolve","normalizeIdentifier","getIdentifier","tryReference","getter","checkIfAlive","isStateTreeNode","isAlive","e","InvalidReferenceError","isValidReference","tryResolve","getRelativePath","base","getRelativePathBetweenNodes","clone","source","keepEnvironment","create","environment","detach","destroy","die","removeChild","subpath","observableIsAlive","addDisposer","getEnv","EMPTY_OBJECT","walk","processor","getChildren","forEach","child","getPropertyMembers","typeOrNode","t","isModelType","name","properties","getMembers","reflected","actions","volatile","views","flowActions","Object","getOwnPropertyNames","key","descriptor","getOwnPropertyDescriptor","get","isComputedProp","_isFlowAction","_isMSTAction","isObservableProp","cast","snapshotOrInstance","castToSnapshot","castToReferenceSnapshot","instance","getNodeId","nodeId","BaseNode","_escapedSubpath","_subpath","this","_subpathUponDeath","subpathUponDeath","_pathUponDeath","pathUponDeath","getValue","aliveAtom","_state","NodeLifeCycle","INITIALIZING","state","val","wasAlive","reportChanged","_hookSubscribers","fireInternalHook","emit","registerHook","hook","hookHandler","EventHandlers","register","_parent","constructor","baseSetParent","getReconciliationType","pathAtom","getEscapedPath","reportObserved","createAtom","escapeJsonPath","DEAD","isDetaching","DETACHING","baseFinalizeCreation","whenFinalized","devMode","CREATED","FINALIZED","fireHook","afterAttach","baseFinalizeDeath","clearAll","baseAboutToDie","beforeDestroy","ScalarNode","simpleType","initialSnapshot","super","createNewInstance","finalizeCreation","setParent","newParent","parentChanged","subpathChanged","toString","aboutToDie","finalizeDeath","prototype","action","nextNodeId","snapshotReactionOptions","onError","ObjectNode","identifierAttribute","unnormalizedIdentifier","middlewares","hasSnapshotPostProcessor","_applyPatches","createObservableInstanceIfNeeded","_applySnapshot","_autoUnbox","_isRunningAction","_hasSnapshotReaction","_observableInstanceState","_childNodes","_initialSnapshot","_cachedInitialSnapshot","_cachedInitialSnapshotCreated","_snapshotComputed","complexType","initialValue","computed","unbox","bind","IdentifierCache","initializeChildNodes","id","childNode","addNodeToCache","fireHooks","createObservableInstance","parentChain","unshift","preboot","finalizeNewInstance","trackAndCompute","_addSnapshotReaction","afterCreate","clearParent","beforeDetach","previousState","newEnv","newIdCache","splitCache","mergeCache","fn","_allowStateChangesInsideComputed","apply","_snapshotUponDeath","_getActualSnapshot","_getCachedInitialSnapshot","childNodes","processInitialSnapshot","isRunningAction","assertAlive","context","error","_getAssertAliveError","warnError","escapedPath","actionContext","getCurrentActionContext","parentActionEvent","actionFullPath","getChildNode","convertChildNodesToArray","assertWritable","afterCreationFinalization","self","createActionInvoker","parts","resolveNodeByPathParts","applyPatchLocally","length","addHiddenFinalProp","toJSON","_internalEventsEmit","_internalEventsClear","notifyDied","_internalEventsClearAll","onChange","_internalEventsRegister","emitSnapshot","handler","emitPatch","basePatch","_internalEventsHasSubscribers","localizedPatch","a","b","i","current","extend","substr","reversePatch","stripPatch","invertPatch","splitPatch","hasDisposer","_internalEventsHas","removeDisposer","_internalEventsUnregister","removeMiddleware","middleware","index","indexOf","splice","addMiddleWare","includeHooks","snapshotDisposer","reaction","_internalEvents","event","hasSubscribers","eventHandler","atTheBeginning","has","unregister","args","clear","validationCache","WeakMap","TypeFlags","cannotDetermineSubtype","$type","Symbol","BaseType","C","S","T","N","isType","typecheckInternal","instantiate","isAssignableFrom","validate","getStateTreeNodeSafe","valueType","typeCheckSuccess","typeCheckFailure","typeCache","cached","result","isValidSnapshot","set","thing","Type","TypeWithoutSTN","SnapshotType","CreationType","ComplexType","getDefaultSnapshot","isMatchingSnapshotId","tryToReconcileNode","newValue","isMutable","reconcile","newNode","getSubTypes","SimpleType","res","argNumber","runningActions","Map","createActionTrackingMiddleware","hooks","call","next","abort","onStart","onResume","async","onSuspend","delete","onSuccess","onFail","rootId","RunningAction","flowsPending","running","finish","onFinish","incFlowsPending","decFlowsPending","hasFlowsPending","createActionTrackingMiddleware2","middlewareHooks","parentRunningAction","newCall","env","parentCall","passesFilter","runningAction","serializeTheUnserializable","baseType","$MST_UNSERIALIZABLE","applyAction","runInAction","resolvedTarget","map","v","deserializeArgument","Date","baseApplyAction","recordActions","listener","onAction","attachAfter","addMiddleware","rawCall","sourceNode","info","arg","actionName","$MST_DATE","getTime","isPrimitive","isPlainObject","isArray","JSON","stringify","serializeArgument","currentActionContext","nextActionId","getNextActionId","runWithActionContext","baseIsRunningAction","previousContext","baseCall","originalFn","CollectedMiddlewares","isEmpty","runNextMiddleware","getNextMiddleware","nextInvoked","abortInvoked","call2","node2","tree","runMiddleWares","getParentActionContext","parentContext","parentActionContext","argsToArray","arguments","parentId","allParentIds","parentEvent","decorate","$mst_middleware","arrayIndex","inArrayIndex","n","array","_isActionContextThisOrChildOf","sameOrParent","includeSame","isActionContextChildOf","isActionContextThisOrChildOf","parentOrThis","prettyPrintValue","safeStringify","toErrorString","fullPath","join","pathPrefix","currentTypename","isSnapshotCompatible","message","isPrimitiveType","describe","getContextForPath","popContext","pop","EMPTY_ARRAY","isTypeCheckingEnabled","typecheck","errors","valueInString","substring","validationErrorsToString","identifierCacheId","cacheId","cache","observable","lastCacheModificationPerId","updateLastCacheModificationPerId","lcm","getLastCacheModificationPerId","modificationId","lastCacheUpdate","mobxShallow","values","nodes","remove","splitNode","newCache","basePath","entries","modified","some","candidate","matches","createObjectNode","existingNode","createScalarNode","isNode","$treenode","doubleDot","_","baseParts","targetParts","common","joinJsonPath","failIfResolveFails","pathParts","part","keys","Array","process$1","asyncAction","deprecated","flow","plainObjectString","_getGlobalState","useProxies","deep","proxy","Error","identity","isInteger","Number","isObservableArray","proto","getPrototypeOf","RegExp","includeDate","deepFreeze","propKey","isFrozen","isSerializable","defineProperty","isObservableObject","defineProperty$1","propName","enumerable","writable","configurable","addHiddenWritableProp","EventHandler","handlers","emitting","pendingUnregisters","f","eventHandlers","stringStartsWith","str","beginning","ids","hasOwnProperty","msg","console","warn","process","_devMode","setDevMode","typeName","min","max","canBeEmpty","s","setImmediateWithFallback","queueMicrotask","setImmediate","setTimeout","generator","spawner","runId","contextBase","wrap","Promise","reject","gen","init","onFulfilled","ret","cancelError","r","throw","onRejected","err","done","then","createFlowSpawner","castFlowReturn","toGeneratorFunction","toGenerator","op","oldValue","replace","unescapeJsonPath","getPathStr","split","shift","$preProcessorFailed","SnapshotProcessor","_subtype","_processors","flags","preProcessSnapshot","sn","preProcessor","preProcessSnapshotSafe","postProcessSnapshot","postProcessor","_fixNode","nodeType","snapshotProcessorType","methods","method","proxyNodeTypeMethods","oldGetSnapshot","isUnionType","processedInitialValue","processedSn","needsIdentifierError","tryCollectModelTypes","modelTypes","subtypes","subtypesArray","subtype","ModelType","MapIdentifierMode","MSTMap","ObservableMap","initialData","ref","enhancer","put","mapNode","mapType","identifierMode","YES","mapIdentifierAttribute","MapType","_subType","UNKNOWN","hookInitializers","_determineIdentifierMode","concat","reduce","NO","objNode","subType","_interceptReads","initializer","actionInvoker","intercept","willChange","observe","didChange","change","processIdentifier","expected","processed","oldSnapshot","currentKeys","from","isMapType","ArrayType","item","options","_getAdministration","dehancer","updatedNodes","reconcileArrayChildren","removedCount","added","addedNodes","removed","addedCount","childType","oldNodes","newValues","newPaths","nothingChanged","hasNewNode","oldNode","newPath","areSame","valueAsNode","oldMatch","j","getNewNode","oldNodeType","isArrayType","PRE_PROCESS_SNAPSHOT","POST_PROCESS_SNAPSHOT","objectTypeToString","defaultObjectOptions","initializers","propertyNames","opts","assign","declaredProps","keysList","alreadySeenKeys","Set","add","props","optional","string","number","boolean","DatePrimitive","getPrimitiveFactoryFromValue","toPropertiesObject","_getIdentifierAttribute","forAllProps","propType","Identifier","cloneAndEnhance","instantiateActions","action2","baseAction","specializedAction","boundAction","named","instantiateVolatileState","rest","instantiateViews","makeObservable","currentPreprocessor","currentPostprocessor","applySnapshotPreProcessor","chg","oldChildValue","adm","raw","getAtom","applySnapshotPostProcessor","preProcessedSnapshot","CoreType","checker","String","integer","Integer","float","Float","isFloat","finite","Finite","isFinite","Boolean","nullType","Null","undefinedType","Undefined","_DatePrimitive","Literal","literal","isLiteralType","Refinement","_predicate","_message","subtypeErrors","isRefinementType","Union","_types","_dispatcher","_eager","eager","dispatcher","factory","determineType","reconcileCurrentType","quickMatch","tryQuickMatch","snapshotLooksLikeType","find","tryMatchPrimitive","typesToCheck","isOptional","Optional","propValue","allErrors","applicableTypes","flat","union","optionsOrType","otherTypes","types","o","OptionalValue","_defaultValue","optionalValues","defaultInstanceOrSnapshot","getDefaultInstanceOrSnapshot","defaultValueOrFunction","checkOptionalPreconditions","undefinedAsOptionalValues","isOptionalType","optionalUndefinedType","optionalNullType","maybe","Late","_definition","getSubType","mustSucceed","ReferenceError","isLateType","Lazy","loadedType","pendingNodeList","when","shouldLoadPredicate","loadType","Frozen","untypedFrozenInstance","isFrozenType","StoredReference","targetType","resolvedReference","targetNode","updateResolvedReference","normalizedId","lastCacheModification","resolvedValue","m","setPrototypeOf","BaseReferenceType","onInvalidated","Reference","fireInvalidated","cause","storedRefNode","referenceId","refTargetNode","storedRefParentNode","storedRefParentValue","invalidTarget","invalidId","replaceRef","newRef","removeRef","addTargetNodeWatcher","refTargetValue","refTargetNodeHook","getInvalidationCause","refTargetDetachHookDisposer","refTargetDestroyHookDisposer","watchTargetNodeForInvalidations","customGetSet","onRefTargetDestroyedHookDisposer","startWatching","sync","refTargetNodeExists","IdentifierReferenceType","storedRef","compareByValue","CustomReferenceType","newIdentifier","reference","getSetOptions","isReferenceType","BaseIdentifierType","validType","identifierNumber","isIdentifierType","CustomType","Custom","isTargetType","typeError","getValidationMessage","toSnapshot","fromSnapshot","isSnapshot","valueToStore","enumeration","realOptions","option","model","compose","hasTypename","prev","cur","custom","safeReference","refType","ev","acceptsUndefined","maybeNull","refinement","predicate","frozen","late","nameOrType","maybeType","lazy","null","snapshotProcessor","processors","hasSymbol","for","isFunctionNameConfigurable","_b","_a","ReactForwardRefSymbol","forwardRef","ReactMemoSymbol","memo","observer","baseComponent","isUsingStaticRendering","useForwardRef","render","baseComponentName","displayName","observerComponent","useObserver","contextTypes","hoistBlackList","$$typeof","compare","NullSignal","AggregateAbortController","signals","abortController","AbortController","addSignal","signal","aborted","handleAborted","addEventListener","size","AggregateStatusReporter","callbacks","addCallback","currentMessage","elt","AbortablePromiseCache","fill","TypeError","fillCallback","isAbortException","exception","code","evict","entry","statusCallback","aborter","statusReporter","newEntry","promise","settled","catch","checkSinglePromise","checkForSingleAbort","AbortSignal","cacheEntry","cachedEntry","keyIter","deleteCount","createSvgIcon","_jsx","getAppBarUtilityClass","slot","generateUtilityClass","generateUtilityClasses","joinVars","var1","var2","AppBarRoot","styled","Paper","overridesResolver","styles","ownerState","capitalize","position","color","memoTheme","theme","display","flexDirection","width","boxSizing","flexShrink","variants","style","zIndex","vars","appBar","top","left","right","palette","AppBar","defaultBg","grey","text","primary","getContrastText","applyStyles","createSimplePaletteValueFilter","main","contrastText","enableColorOnDark","includes","backgroundColor","darkBg","darkColor","backgroundImage","React","inProps","useDefaultProps","className","other","classes","slots","composeClasses","useUtilityClasses","square","component","elevation","clsx","isDynamicSupport","globalCss","html","enableColorScheme","WebkitFontSmoothing","MozOsxFontSmoothing","WebkitTextSizeAdjust","colorScheme","body","typography","body1","background","default","white","colorSchemeStyles","colorSchemes","getColorSchemeSelector","scheme","selector","startsWith","defaultStyles","fontWeight","fontWeightBold","margin","themeOverrides","components","MuiCssBaseline","styleOverrides","SELECTOR","GlobalStyles","baseStyles","staticStyles","children","_jsxs","FabRoot","ButtonBase","shouldForwardProp","prop","rootShouldForwardProp","variant","colorInherit","button","minHeight","transition","transitions","duration","short","borderRadius","padding","minWidth","height","fab","boxShadow","shadows","A100","textDecoration","fabClasses","focusVisible","dark","disabled","disabledBackground","disableFocusRipple","focusVisibleClassName","composedClasses","getFabUtilityClass","focusRipple","errorProperties","property","toJsonWasCalled","WeakSet","newError","errorFactories","ErrorConstructor","errorConstructors","AggregateError","isErrorLike","stack","destroyCircular","seen","to","forceEnumerable","maxDepth","useToJSON","serialize","json","continueDestroyCircular","Uint8Array","pipe","deserializeError","POSITIVE_INFINITY","isMinimumViableSerializedError","NonError","counter","RpcClient","EventEmitter","worker","calls","uid","eventName","libRpc","lineno","filename","errorFn","callFn","transferables","postMessage","rpcResult","__rpcResult"],"sourceRoot":""}