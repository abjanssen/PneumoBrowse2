{"version":3,"file":"static/js/4933.dba65ffa.chunk.js","mappings":"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","sources":["webpack://@jbrowse/web/../../plugins/wiggle/src/MultiWiggleAdapter/MultiWiggleAdapter.ts"],"sourcesContent":["import { BaseFeatureDataAdapter } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport {\n  aggregateQuantitativeStats,\n  blankStats,\n} from '@jbrowse/core/data_adapters/BaseAdapter/stats'\nimport { SimpleFeature, max, min } from '@jbrowse/core/util'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { merge } from 'rxjs'\nimport { map } from 'rxjs/operators'\n\nimport type { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport type { Feature } from '@jbrowse/core/util'\nimport type {\n  AugmentedRegion as Region,\n  FileLocation,\n} from '@jbrowse/core/util/types'\n\ninterface WiggleOptions extends BaseOptions {\n  resolution?: number\n  staticBlocks?: Region[]\n  sources?: { name: string }[]\n}\n\nfunction getFilename(uri: string) {\n  const filename = uri.slice(uri.lastIndexOf('/') + 1)\n  return filename.slice(0, filename.lastIndexOf('.'))\n}\n\n/**\n * Extract filename from a config, only works for BigWigAdapter\n * Could try to generalize across more adapter types potentially\n */\nfunction getFilenameFromAdapterConfig(config: any) {\n  try {\n    // Handle BigWigAdapter specifically\n    if (config.type === 'BigWigAdapter' && config.bigWigLocation) {\n      const location = config.bigWigLocation as FileLocation\n      if ('uri' in location && location.uri) {\n        return getFilename(location.uri)\n      }\n      if ('localPath' in location && location.localPath) {\n        return getFilename(location.localPath)\n      }\n      if ('blob' in location && location.blob) {\n        const blob = location.blob as File\n        return blob.name ? getFilename(blob.name) : undefined\n      }\n    }\n\n    // Fallback for other adapter types or locations\n    return undefined\n  } catch (e) {\n    return undefined\n  }\n}\n\ninterface AdapterEntry {\n  dataAdapter: BaseFeatureDataAdapter\n  source: string\n  name: string\n  [key: string]: unknown\n}\n\ntype MaybeStats = { scoreMin: number; scoreMax: number } | undefined\n\nexport default class MultiWiggleAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = [\n    'hasResolution',\n    'hasLocalStats',\n    'hasGlobalStats',\n  ]\n\n  private adaptersP?: Promise<AdapterEntry[]>\n\n  public async getAdapters(): Promise<AdapterEntry[]> {\n    if (!this.adaptersP) {\n      this.adaptersP = this.getAdaptersImpl()\n    }\n    return this.adaptersP\n  }\n\n  private async getAdaptersImpl(): Promise<AdapterEntry[]> {\n    const getSubAdapter = this.getSubAdapter\n    if (!getSubAdapter) {\n      throw new Error('no getSubAdapter available')\n    }\n    let subConfs = this.getConf('subadapters')\n    if (!subConfs?.length) {\n      const entries = this.getConf('bigWigs') as string[]\n      subConfs = entries.map(entry => ({\n        type: 'BigWigAdapter',\n        source: getFilename(entry),\n        bigWigLocation: {\n          uri: entry,\n        },\n      }))\n    }\n\n    // There was confusion about whether source or name was required, and\n    // effort to remove one or the other was thwarted. Adapters like\n    // BigWigAdapter, even in the BigWigAdapter configSchema.ts, use a 'source'\n    // field though, while the word 'name' still allowed in the config too. To\n    // solve, we made name===source\n    return Promise.all(\n      subConfs.map(async (conf: any) => {\n        const dataAdapter = (await getSubAdapter(conf))\n          .dataAdapter as BaseFeatureDataAdapter\n        const source =\n          conf.source ||\n          conf.name ||\n          getFilenameFromAdapterConfig(conf) ||\n          dataAdapter.id\n        return {\n          ...conf,\n          dataAdapter,\n          source,\n        }\n      }),\n    )\n  }\n\n  // note: can't really have dis-agreeing refNames\n  public async getRefNames(opts?: BaseOptions) {\n    const adapters = await this.getAdapters()\n    const allNames = await Promise.all(\n      adapters.map(a => a.dataAdapter.getRefNames(opts)),\n    )\n    return [...new Set(allNames.flat())]\n  }\n\n  public async getGlobalStats(opts?: BaseOptions) {\n    const adapters = await this.getAdapters()\n    const stats = (\n      (await Promise.all(\n        // @ts-expect-error\n        adapters.map(adp => adp.dataAdapter.getGlobalStats?.(opts)),\n      )) as MaybeStats[]\n    ).filter(f => !!f)\n    return {\n      scoreMin: min(stats.map(s => s.scoreMin)),\n      scoreMax: max(stats.map(s => s.scoreMax)),\n    }\n  }\n\n  public getFeatures(region: Region, opts: WiggleOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      let adapters = await this.getAdapters()\n\n      // Filter adapters if sources filter is provided (e.g., from subtree filter)\n      if (opts.sources?.length) {\n        const sourceNames = new Set(opts.sources.map(s => s.name))\n        adapters = adapters.filter(adp => sourceNames.has(adp.source))\n      }\n\n      merge(\n        ...adapters.map(adp => {\n          const { source, dataAdapter } = adp\n          return dataAdapter.getFeatures(region, opts).pipe(\n            map(f => {\n              // BigWigAdapter sets source, so avoid expensive wrapping when possible\n              if (f.get('source')) {\n                return f\n              }\n              // Fallback for adapters that don't set source\n              const data = f.toJSON()\n              data.uniqueId = `${source}-${f.id()}`\n              data.source = source\n              return new SimpleFeature(data)\n            }),\n          )\n        }),\n      ).subscribe(observer)\n    }, opts.stopToken)\n  }\n\n  public async getRegionQuantitativeStats(\n    region: Region,\n    opts?: WiggleOptions,\n  ) {\n    const adapters = await this.getAdapters()\n    const allStats = await Promise.all(\n      adapters.map(async adp => {\n        const { dataAdapter } = adp\n        return dataAdapter.getRegionQuantitativeStats(region, opts)\n      }),\n    )\n    return aggregateQuantitativeStats(allStats.filter(Boolean))\n  }\n\n  // always render bigwig instead of calculating a feature density for it\n  async getMultiRegionFeatureDensityStats(_regions: Region[]) {\n    return {\n      featureDensity: 0,\n    }\n  }\n\n  /**\n   * Override to pass staticBlocks through to sub-adapters for caching.\n   */\n  async getMultiRegionQuantitativeStats(\n    regions: Region[] = [],\n    opts: WiggleOptions = {},\n  ) {\n    if (!regions.length) {\n      return blankStats()\n    }\n\n    const adapters = await this.getAdapters()\n\n    // Delegate to sub-adapters, passing staticBlocks through\n    const allStats = await Promise.all(\n      adapters.map(async adp => {\n        const { dataAdapter } = adp\n        return dataAdapter.getMultiRegionQuantitativeStats(regions, opts)\n      }),\n    )\n\n    return aggregateQuantitativeStats(allStats.filter(Boolean))\n  }\n\n  // in another adapter type, this could be dynamic depending on region or\n  // something, but it is static for this particular multi-wiggle adapter type\n  async getSources(_regions: Region[]) {\n    const adapters = await this.getAdapters()\n    return adapters.map(({ type, bigWigLocation, dataAdapter, ...rest }) => {\n      return {\n        ...rest,\n        name: rest.source,\n      }\n    })\n  }\n}\n"],"names":["getFilename","uri","filename","slice","lastIndexOf","MultiWiggleAdapter","BaseFeatureDataAdapter","getAdapters","this","adaptersP","getAdaptersImpl","getSubAdapter","Error","subConfs","getConf","length","map","entry","type","source","bigWigLocation","Promise","all","async","dataAdapter","conf","name","config","location","localPath","blob","undefined","e","getFilenameFromAdapterConfig","id","getRefNames","opts","adapters","allNames","a","Set","flat","getGlobalStats","stats","adp","filter","f","scoreMin","min","s","scoreMax","max","getFeatures","region","ObservableCreate","sources","sourceNames","has","merge","pipe","get","data","toJSON","uniqueId","SimpleFeature","subscribe","observer","stopToken","getRegionQuantitativeStats","allStats","aggregateQuantitativeStats","Boolean","getMultiRegionFeatureDensityStats","_regions","featureDensity","getMultiRegionQuantitativeStats","regions","blankStats","getSources","rest"],"sourceRoot":""}