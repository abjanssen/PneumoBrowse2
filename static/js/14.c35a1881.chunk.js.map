{"version":3,"file":"static/js/14.c35a1881.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BedpeAdapter/BedpeAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Region, Feature, SimpleFeature, isGzip } from '@jbrowse/core/util'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport { unzip } from '@gmod/bgzf-filehandle'\n\nexport function featureData(\n  line: string,\n  uniqueId: string,\n  flip: boolean,\n  names?: string[],\n) {\n  const l = line.split('\\t')\n  const ref1 = l[flip ? 3 : 0]!\n  const start1 = +l[flip ? 4 : 1]!\n  const end1 = +l[flip ? 5 : 2]!\n  const ref2 = l[!flip ? 3 : 0]!\n  const start2 = +l[!flip ? 4 : 1]!\n  const end2 = +l[!flip ? 5 : 2]!\n  const name = l[6]!\n  const score = +l[7]!\n  const strand1 = parseStrand(l[8]!)\n  const strand2 = parseStrand(l[9]!)\n  const extra = l.slice(10)\n  const rest = names\n    ? Object.fromEntries(names.slice(10).map((n, idx) => [n, extra[idx]]))\n    : extra\n  const ALT = ['DUP', 'TRA', 'INV', 'CNV', 'DEL'].includes(extra[0]!)\n    ? `<${extra[0]}>`\n    : undefined\n\n  return new SimpleFeature({\n    start: start1,\n    end: end1,\n    refName: ref1,\n    ...(ALT ? { ALT: [ALT] } : {}), // it's an array in VCF\n    strand: strand1,\n    name,\n    ...rest,\n    score,\n    uniqueId,\n    mate: { refName: ref2, start: start2, end: end2, strand: strand2 },\n  })\n}\n\nfunction parseStrand(strand: string) {\n  if (strand === '+') {\n    return 1\n  }\n  if (strand === '-') {\n    return -1\n  }\n  if (strand === '.') {\n    return 0\n  }\n  return undefined\n}\n\nexport default class BedpeAdapter extends BaseFeatureDataAdapter {\n  protected bedpeFeatures?: Promise<{\n    header: string\n    feats1: Record<string, string[]>\n    feats2: Record<string, string[]>\n    columnNames: string[]\n  }>\n\n  protected intervalTrees: Record<\n    string,\n    Promise<IntervalTree | undefined> | undefined\n  > = {}\n\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  private async loadDataP(opts: BaseOptions = {}) {\n    const pm = this.pluginManager\n    const bedLoc = this.getConf('bedpeLocation')\n    const buf = await openLocation(bedLoc, pm).readFile(opts)\n    const buffer = isGzip(buf) ? await unzip(buf) : buf\n    // 512MB  max chrome string length is 512MB\n    if (buffer.length > 536_870_888) {\n      throw new Error('Data exceeds maximum string length (512MB)')\n    }\n    const data = new TextDecoder('utf8', { fatal: true }).decode(buffer)\n    const lines = data.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const headerLines = []\n    let i = 0\n    for (; i < lines.length && lines[i]!.startsWith('#'); i++) {\n      headerLines.push(lines[i])\n    }\n    const header = headerLines.join('\\n')\n    const feats1 = {} as Record<string, string[]>\n    const feats2 = {} as Record<string, string[]>\n    for (; i < lines.length; i++) {\n      const line = lines[i]!\n      const cols = line.split('\\t')\n      const r1 = cols[0]!\n      const r2 = cols[3]!\n      if (!feats1[r1]) {\n        feats1[r1] = []\n      }\n      if (!feats2[r2]) {\n        feats2[r2] = []\n      }\n      feats1[r1].push(line)\n      feats2[r2].push(line)\n    }\n    const columnNames = this.getConf('columnNames')\n\n    return {\n      header,\n      feats1,\n      feats2,\n      columnNames,\n    }\n  }\n\n  private async loadData(opts: BaseOptions = {}) {\n    if (!this.bedpeFeatures) {\n      this.bedpeFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.bedpeFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.bedpeFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { feats1, feats2 } = await this.loadData(opts)\n    return [...new Set([...Object.keys(feats1), ...Object.keys(feats2)])]\n  }\n\n  async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  async getNames() {\n    const { header, columnNames } = await this.loadData()\n    if (columnNames.length) {\n      return columnNames\n    }\n    const defs = header.split(/\\n|\\r\\n|\\r/).filter(f => !!f)\n    const defline = defs.at(-1)\n    return defline?.includes('\\t')\n      ? defline\n          .slice(1)\n          .split('\\t')\n          .map(field => field.trim())\n      : undefined\n  }\n\n  private async loadFeatureTreeP(refName: string) {\n    const { feats1, feats2 } = await this.loadData()\n    const names = await this.getNames()\n    const intervalTree = new IntervalTree()\n    const ret1 =\n      feats1[refName]?.map((f, i) =>\n        featureData(f, `${this.id}-${refName}-${i}-r1`, false, names),\n      ) ?? []\n    const ret2 =\n      feats2[refName]?.map((f, i) =>\n        featureData(f, `${this.id}-${refName}-${i}-r2`, true, names),\n      ) ?? []\n\n    for (const obj of [...ret1, ...ret2]) {\n      intervalTree.insert([obj.get('start'), obj.get('end')], obj)\n    }\n\n    return intervalTree\n  }\n\n  private async loadFeatureTree(refName: string) {\n    if (!this.intervalTrees[refName]) {\n      this.intervalTrees[refName] = this.loadFeatureTreeP(refName).catch(\n        (e: unknown) => {\n          this.intervalTrees[refName] = undefined\n          throw e\n        },\n      )\n    }\n    return this.intervalTrees[refName]\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { start, end, refName } = query\n      const intervalTree = await this.loadFeatureTree(refName)\n      intervalTree?.search([start, end]).forEach(f => {\n        observer.next(f)\n      })\n      observer.complete()\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["featureData","line","uniqueId","flip","names","l","split","ref1","start1","end1","ref2","start2","end2","name","score","strand1","parseStrand","strand2","extra","slice","rest","Object","fromEntries","map","n","idx","ALT","includes","undefined","SimpleFeature","start","end","refName","strand","mate","BedpeAdapter","BaseFeatureDataAdapter","intervalTrees","loadDataP","opts","pm","this","pluginManager","bedLoc","getConf","buf","openLocation","readFile","buffer","isGzip","unzip","length","Error","lines","TextDecoder","fatal","decode","filter","f","headerLines","i","startsWith","push","header","join","feats1","feats2","cols","r1","r2","columnNames","loadData","bedpeFeatures","catch","e","getRefNames","Set","keys","getHeader","getNames","defline","at","field","trim","loadFeatureTreeP","intervalTree","IntervalTree","ret1","id","ret2","obj","insert","get","loadFeatureTree","getFeatures","query","ObservableCreate","async","search","forEach","observer","next","complete","signal","freeResources"],"sourceRoot":""}