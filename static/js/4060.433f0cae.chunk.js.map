{"version":3,"file":"static/js/4060.433f0cae.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/PileupRenderer/getAlignmentShapeColor.ts","../../../plugins/alignments/src/PileupRenderer/colorBy.ts","../../../plugins/alignments/src/PileupRenderer/util.ts","../../../plugins/alignments/src/PileupRenderer/renderAlignment.ts","../../../plugins/alignments/src/PileupRenderer/renderAlignmentShape.ts","../../../plugins/alignments/src/PileupRenderer/renderPerBaseQuality.ts","../../../plugins/alignments/src/PileupRenderer/renderPerBaseLettering.ts","../../../plugins/alignments/src/PileupRenderer/renderModifications.ts","../../../plugins/alignments/src/PileupRenderer/renderMethylation.ts","../../../plugins/alignments/src/PileupRenderer/renderMismatches.ts","../../../plugins/alignments/src/PileupRenderer/renderSoftClipping.ts","../../../plugins/alignments/src/PileupRenderer/makeImageData.ts","../../../plugins/alignments/src/shared/color.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts"],"sourcesContent":["import { readConfObject } from '@jbrowse/core/configuration'\n\nimport {\n  colorByInsertSize,\n  colorByMappingQuality,\n  colorByOrientation,\n  colorByStrand,\n  colorByStrandedRnaSeq,\n} from './colorBy'\nimport { fillColor } from '../shared/color'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function getAlignmentShapeColor({\n  colorType,\n  tag,\n  feature,\n  config,\n  defaultColor,\n  colorTagMap,\n}: {\n  colorType: string\n  tag: string\n  feature: Feature\n  defaultColor: boolean\n  config: AnyConfigurationModel\n  colorTagMap: Record<string, string>\n}) {\n  // first pass for simple color changes that change the color of the\n  // alignment\n  switch (colorType) {\n    case 'insertSize':\n      return colorByInsertSize(feature)\n    case 'strand':\n      return colorByStrand(feature)\n    case 'mappingQuality':\n      return colorByMappingQuality(feature)\n    case 'pairOrientation':\n      return colorByOrientation(feature, config)\n    case 'stranded':\n      return colorByStrandedRnaSeq(feature)\n    case 'xs':\n    case 'tag': {\n      const tags = feature.get('tags')\n      const val = tags ? tags[tag] : feature.get(tag)\n\n      if (tag === 'XS' || tag === 'TS') {\n        if (val === '-') {\n          return fillColor.color_rev_strand\n        } else if (val === '+') {\n          return fillColor.color_fwd_strand\n        } else {\n          return fillColor.color_nostrand\n        }\n      }\n      if (tag === 'ts') {\n        if (val === '-') {\n          return feature.get('strand') === -1\n            ? fillColor.color_fwd_strand\n            : fillColor.color_rev_strand\n        } else if (val === '+') {\n          return feature.get('strand') === -1\n            ? fillColor.color_rev_strand\n            : fillColor.color_fwd_strand\n        } else {\n          return fillColor.color_nostrand\n        }\n      }\n      return colorTagMap[val] || fillColor.color_nostrand\n    }\n    case 'insertSizeAndPairOrientation':\n      break\n\n    case 'modifications':\n    case 'methylation':\n      // this coloring is similar to igv.js, and is helpful to color negative\n      // strand reads differently because their c-g will be flipped (e.g. g-c\n      // read right to left)\n      return feature.get('flags') & 16 ? '#c8dcc8' : '#c8c8c8'\n\n    default:\n      return defaultColor\n        ? 'lightgrey'\n        : readConfObject(config, 'color', { feature })\n  }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\n\nimport { fillColor } from '../shared/color'\nimport { orientationTypes } from '../util'\n\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Feature } from '@jbrowse/core/util'\n\nexport function colorByInsertSize(feature: Feature) {\n  return feature.get('is_paired') &&\n    feature.get('refName') !== feature.get('next_ref')\n    ? '#555'\n    : `hsl(${Math.abs(feature.get('template_length')) / 10},50%,50%)`\n}\n\nexport function colorByMappingQuality(feature: Feature) {\n  return `hsl(${feature.get('score')},50%,50%)`\n}\n\nfunction getOrientation(feature: Feature, config: AnyConfigurationModel) {\n  const orientationType = readConfObject(config, 'orientationType') as\n    | 'fr'\n    | 'ff'\n    | 'rf'\n  const type = orientationTypes[orientationType]\n  const orientation = type[feature.get('pair_orientation') as string]!\n  return {\n    LR: 'color_pair_lr' as const,\n    RR: 'color_pair_rr' as const,\n    RL: 'color_pair_rl' as const,\n    LL: 'color_pair_ll' as const,\n  }[orientation]\n}\n\nexport function colorByStrand(feature: Feature) {\n  return feature.get('strand') === -1 ? '#8F8FD8' : '#EC8B8B'\n}\n\nexport function colorByOrientation(\n  feature: Feature,\n  config: AnyConfigurationModel,\n) {\n  return fillColor[getOrientation(feature, config) || 'color_nostrand']\n}\nfunction getStranded(feature: Feature) {\n  const flags = feature.get('flags')\n  const strand = feature.get('strand')\n\n  // is paired\n  if (flags & 1) {\n    // first-of-pair?\n    const flipper = flags & 64 ? -1 : 1\n\n    // proper pairing\n    if (flags & 2) {\n      return strand * flipper === 1 ? 'color_rev_strand' : 'color_fwd_strand'\n    }\n    // mate missing, separate color\n    if (flags & 8) {\n      return strand * flipper === 1\n        ? 'color_rev_missing_mate'\n        : 'color_fwd_missing_mate'\n    }\n    // same chrom without proper pairing gets separate color\n    if (feature.get('refName') === feature.get('next_ref')) {\n      return strand * flipper === 1\n        ? 'color_rev_strand_not_proper'\n        : 'color_fwd_strand_not_proper'\n    }\n    // abberant chrom\n\n    return strand === 1 ? 'color_fwd_diff_chr' : 'color_rev_diff_chr'\n  }\n  return 'color_unknown'\n}\n\nexport function colorByStrandedRnaSeq(feature: Feature) {\n  return fillColor[getStranded(feature)]\n}\n","import { measureText } from '@jbrowse/core/util'\n\nimport type { Feature } from '@jbrowse/core/util'\nimport type { Theme } from '@mui/material'\n\nexport function fillRect(\n  ctx: CanvasRenderingContext2D,\n  l: number,\n  t: number,\n  w: number,\n  h: number,\n  cw: number,\n  color?: string,\n) {\n  if (l + w < 0 || l > cw) {\n    return\n  }\n  if (color) {\n    ctx.fillStyle = color\n  }\n  ctx.fillRect(l, t, w, h)\n}\n\nexport function getColorBaseMap(theme: Theme) {\n  const { skip, deletion, insertion, hardclip, softclip, bases } = theme.palette\n  return {\n    A: bases.A.main,\n    C: bases.C.main,\n    G: bases.G.main,\n    T: bases.T.main,\n    deletion,\n    insertion,\n    hardclip,\n    softclip,\n    skip,\n  }\n}\n\nexport function getContrastBaseMap(theme: Theme) {\n  return Object.fromEntries(\n    Object.entries(getColorBaseMap(theme)).map(([key, value]) => [\n      key,\n      theme.palette.getContrastText(value),\n    ]),\n  )\n}\n\nexport function shouldDrawSNPsMuted(type?: string) {\n  return ['methylation', 'modifications'].includes(type || '')\n}\n\nexport function shouldDrawIndels() {\n  return true\n}\n\nexport interface LayoutFeature {\n  heightPx: number\n  topPx: number\n  feature: Feature\n}\n\n// get width and height of chars the height is an approximation: width letter M\n// is approximately the height\nexport function getCharWidthHeight() {\n  const charWidth = measureText('A')\n  const charHeight = measureText('M') - 2\n  return { charWidth, charHeight }\n}\n","import { getAlignmentShapeColor } from './getAlignmentShapeColor'\nimport { renderAlignmentShape } from './renderAlignmentShape'\nimport { renderModifications } from './renderModifications'\nimport { renderPerBaseLettering } from './renderPerBaseLettering'\nimport { renderPerBaseQuality } from './renderPerBaseQuality'\nimport { parseCigar } from '../MismatchParser'\nimport { renderMethylation } from './renderMethylation'\n\nimport type { ProcessedRenderArgs } from './types'\nimport type { LayoutFeature } from './util'\n\nexport function renderAlignment({\n  ctx,\n  feat,\n  renderArgs,\n  colorMap,\n  colorContrastMap,\n  charWidth,\n  charHeight,\n  defaultColor,\n  canvasWidth,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  renderArgs: ProcessedRenderArgs\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  charWidth: number\n  charHeight: number\n  defaultColor: boolean\n  canvasWidth: number\n}) {\n  const { config, bpPerPx, regions, colorBy, colorTagMap = {} } = renderArgs\n  const { tag = '', type: colorType = '' } = colorBy || {}\n  const { feature } = feat\n  const region = regions[0]!\n\n  ctx.fillStyle = getAlignmentShapeColor({\n    feature,\n    config,\n    tag,\n    defaultColor,\n    colorType,\n    colorTagMap,\n  })\n\n  renderAlignmentShape({ ctx, feat, renderArgs })\n\n  // second pass for color types that render per-base things that go over the\n  // existing drawing\n  switch (colorType) {\n    case 'perBaseQuality': {\n      const cigarOps = parseCigar(feature.get('CIGAR'))\n      renderPerBaseQuality({\n        ctx,\n        feat,\n        region,\n        bpPerPx,\n        canvasWidth,\n        cigarOps,\n      })\n      break\n    }\n\n    case 'perBaseLettering': {\n      const cigarOps = parseCigar(feature.get('CIGAR'))\n      renderPerBaseLettering({\n        ctx,\n        feat,\n        region,\n        bpPerPx,\n        colorMap,\n        colorContrastMap,\n        charWidth,\n        charHeight,\n        canvasWidth,\n        cigarOps,\n      })\n      break\n    }\n\n    case 'modifications': {\n      const cigarOps = parseCigar(feature.get('CIGAR'))\n      renderModifications({\n        ctx,\n        feat,\n        region,\n        bpPerPx,\n        renderArgs,\n        canvasWidth,\n        cigarOps,\n      })\n      break\n    }\n\n    case 'methylation': {\n      const cigarOps = parseCigar(feature.get('CIGAR'))\n      renderMethylation({\n        ctx,\n        feat,\n        region,\n        bpPerPx,\n        renderArgs,\n        canvasWidth,\n        cigarOps,\n      })\n      break\n    }\n  }\n}\n","import { bpSpanPx } from '@jbrowse/core/util'\n\nimport { parseCigar } from '../MismatchParser'\n\nimport type { ProcessedRenderArgs } from './types'\nimport type { LayoutFeature } from './util'\n\nexport function renderAlignmentShape({\n  ctx,\n  feat,\n  renderArgs,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  renderArgs: ProcessedRenderArgs\n}) {\n  const { regions, bpPerPx } = renderArgs\n  const { heightPx, topPx, feature } = feat\n  const region = regions[0]!\n  const s = feature.get('start')\n  const e = feature.get('end')\n  const CIGAR = feature.get('CIGAR') as string | undefined\n  const flip = region.reversed ? -1 : 1\n  const strand = feature.get('strand') * flip\n  const renderChevrons = bpPerPx < 10 && heightPx > 5\n  if (CIGAR?.includes('N')) {\n    const cigarOps = parseCigar(CIGAR)\n    if (strand === 1) {\n      let drawLen = 0\n      let drawStart = s\n      for (let i = 0; i < cigarOps.length; i += 2) {\n        const opLen = +cigarOps[i]!\n        const op = cigarOps[i + 1]!\n        if (op === 'M' || op === 'X' || op === '=' || op === 'D') {\n          drawLen += opLen\n        } else if (op === 'N') {\n          if (drawStart !== drawLen) {\n            const [leftPx, rightPx] = bpSpanPx(\n              drawStart,\n              drawStart + drawLen,\n              region,\n              bpPerPx,\n            )\n            const w = rightPx - leftPx\n            ctx.fillRect(leftPx, topPx, w, heightPx)\n          }\n          drawStart += drawLen + opLen\n          drawLen = 0\n        }\n      }\n\n      if (drawStart !== drawLen) {\n        const [leftPx, rightPx] = bpSpanPx(\n          drawStart,\n          drawStart + drawLen,\n          region,\n          bpPerPx,\n        )\n        const w = rightPx - leftPx\n\n        if (renderChevrons) {\n          ctx.beginPath()\n          ctx.moveTo(leftPx, topPx)\n          ctx.lineTo(leftPx, topPx + heightPx)\n          ctx.lineTo(rightPx, topPx + heightPx)\n          ctx.lineTo(rightPx + 5, topPx + heightPx / 2)\n          ctx.lineTo(rightPx, topPx)\n          ctx.closePath()\n          ctx.fill()\n        } else {\n          ctx.fillRect(leftPx, topPx, w, heightPx)\n        }\n      }\n    } else if (strand === -1) {\n      let drawLen = 0\n      let drawStart = e\n      for (let i = cigarOps.length - 2; i >= 0; i -= 2) {\n        const opLen = +cigarOps[i]!\n        const op = cigarOps[i + 1]!\n        if (op === 'M' || op === 'X' || op === '=' || op === 'D') {\n          drawLen += opLen\n        } else if (op === 'N') {\n          if (drawLen !== 0) {\n            const [leftPx, rightPx] = bpSpanPx(\n              drawStart - drawLen,\n              drawStart,\n              region,\n              bpPerPx,\n            )\n            ctx.fillRect(leftPx, topPx, rightPx - leftPx, heightPx)\n          }\n          drawStart -= drawLen + opLen\n          drawLen = 0\n        }\n      }\n\n      if (drawLen !== 0) {\n        const [leftPx, rightPx] = bpSpanPx(\n          drawStart - drawLen,\n          drawStart,\n          region,\n          bpPerPx,\n        )\n        const w = rightPx - leftPx\n\n        if (renderChevrons) {\n          ctx.beginPath()\n          ctx.moveTo(leftPx - 5, topPx + heightPx / 2)\n          ctx.lineTo(leftPx, topPx + heightPx)\n          ctx.lineTo(rightPx, topPx + heightPx)\n          ctx.lineTo(rightPx, topPx)\n          ctx.lineTo(leftPx, topPx)\n          ctx.closePath()\n          ctx.fill()\n        } else {\n          ctx.fillRect(leftPx, topPx, w, heightPx)\n        }\n      }\n    }\n  } else {\n    const [leftPx, rightPx] = bpSpanPx(s, e, region, bpPerPx)\n    if (bpPerPx < 10 && heightPx > 5) {\n      if (strand === -1) {\n        ctx.beginPath()\n        ctx.moveTo(leftPx - 5, topPx + heightPx / 2)\n        ctx.lineTo(leftPx, topPx + heightPx)\n        ctx.lineTo(rightPx, topPx + heightPx)\n        ctx.lineTo(rightPx, topPx)\n        ctx.lineTo(leftPx, topPx)\n        ctx.closePath()\n        ctx.fill()\n      } else {\n        ctx.beginPath()\n        ctx.moveTo(leftPx, topPx)\n        ctx.lineTo(leftPx, topPx + heightPx)\n        ctx.lineTo(rightPx, topPx + heightPx)\n        ctx.lineTo(rightPx + 5, topPx + heightPx / 2)\n        ctx.lineTo(rightPx, topPx)\n        ctx.closePath()\n        ctx.fill()\n      }\n    } else {\n      ctx.fillRect(leftPx, topPx, rightPx - leftPx, heightPx)\n    }\n  }\n}\n","import { bpSpanPx } from '@jbrowse/core/util'\n\nimport { fillRect } from './util'\n\nimport type { LayoutFeature } from './util'\nimport type { Region } from '@jbrowse/core/util'\n\nexport function renderPerBaseQuality({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  canvasWidth,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  canvasWidth: number\n  cigarOps: string[]\n}) {\n  const { feature, topPx, heightPx } = feat\n  const qual: string = feature.get('qual') || ''\n  const scores = qual.split(' ').map(val => +val)\n  const w = 1 / bpPerPx\n  const start = feature.get('start')\n  let soffset = 0 // sequence offset\n  let roffset = 0 // reference offset\n\n  for (let i = 0; i < cigarOps.length; i += 2) {\n    const len = +cigarOps[i]!\n    const op = cigarOps[i + 1]!\n    if (op === 'S' || op === 'I') {\n      soffset += len\n    } else if (op === 'D' || op === 'N') {\n      roffset += len\n    } else if (op === 'M' || op === 'X' || op === '=') {\n      for (let m = 0; m < len; m++) {\n        const score = scores[soffset + m]!\n        const start0 = start + roffset + m\n        const leftPx = bpSpanPx(start0, start0 + 1, region, bpPerPx)[0]\n        const c = `hsl(${score === 255 ? 150 : score * 1.5},55%,50%)`\n        fillRect(ctx, leftPx, topPx, w + 0.5, heightPx, canvasWidth, c)\n      }\n      soffset += len\n      roffset += len\n    }\n  }\n}\n","import { bpSpanPx } from '@jbrowse/core/util'\n\nimport { fillRect } from './util'\n\nimport type { LayoutFeature } from './util'\nimport type { Region } from '@jbrowse/core/util'\n\nexport function renderPerBaseLettering({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  colorMap,\n  colorContrastMap,\n  charWidth,\n  charHeight,\n  canvasWidth,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  charWidth: number\n  charHeight: number\n  canvasWidth: number\n  cigarOps: string[]\n}) {\n  const heightLim = charHeight - 2\n  const { feature, topPx, heightPx } = feat\n  const seq = feature.get('seq') as string | undefined\n  const w = 1 / bpPerPx\n  const start = feature.get('start')\n  let soffset = 0\n  let roffset = 0\n\n  if (!seq) {\n    return\n  }\n  for (let i = 0; i < cigarOps.length; i += 2) {\n    const len = +cigarOps[i]!\n    const op = cigarOps[i + 1]!\n    if (op === 'S' || op === 'I') {\n      soffset += len\n    } else if (op === 'D' || op === 'N') {\n      roffset += len\n    } else if (op === 'M' || op === 'X' || op === '=') {\n      for (let m = 0; m < len; m++) {\n        const letter = seq[soffset + m]!\n        const r = start + roffset + m\n        const [leftPx] = bpSpanPx(r, r + 1, region, bpPerPx)\n        const c = colorMap[letter]\n        fillRect(ctx, leftPx, topPx, w + 0.5, heightPx, canvasWidth, c)\n\n        if (w >= charWidth && heightPx >= heightLim) {\n          // normal SNP coloring\n          ctx.fillStyle = colorContrastMap[letter]!\n          ctx.fillText(\n            letter,\n            leftPx + (w - charWidth) / 2 + 1,\n            topPx + heightPx,\n          )\n        }\n      }\n      soffset += len\n      roffset += len\n    }\n  }\n}\n","import { bpSpanPx, max, sum } from '@jbrowse/core/util'\n\nimport { fillRect } from './util'\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition'\nimport { alphaColor } from '../shared/util'\n\nimport type { ProcessedRenderArgs } from './types'\nimport type { LayoutFeature } from './util'\nimport type { Region } from '@jbrowse/core/util'\n\n// render modifications stored in MM tag in BAM\nexport function renderModifications({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  renderArgs,\n  canvasWidth,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  renderArgs: ProcessedRenderArgs\n  canvasWidth: number\n  cigarOps: string[]\n}) {\n  const { feature, topPx, heightPx } = feat\n  const { colorBy, visibleModifications = {} } = renderArgs\n\n  const seq = feature.get('seq') as string | undefined\n\n  if (!seq) {\n    return\n  }\n  const start = feature.get('start')\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  const twoColor = colorBy?.modifications?.twoColor\n\n  getMaxProbModAtEachPosition(feature, cigarOps)?.forEach(\n    ({ allProbs, prob, type }, pos) => {\n      const r = start + pos\n      const [leftPx, rightPx] = bpSpanPx(r, r + 1, region, bpPerPx)\n      const mod = visibleModifications[type]\n      if (!mod) {\n        console.warn(`${type} not known yet`)\n        return\n      }\n      if (isolatedModification && mod.type !== isolatedModification) {\n        return\n      }\n      const col = mod.color || 'black'\n      const s = 1 - sum(allProbs)\n      if (twoColor && s > max(allProbs)) {\n        const c = alphaColor('blue', s)\n        const w = rightPx - leftPx + 0.5\n        fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c)\n      } else {\n        const c = alphaColor(col, prob)\n        const w = rightPx - leftPx + 0.5\n        fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c)\n      }\n    },\n  )\n}\n","import { bpSpanPx } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\n\nimport { fillRect } from './util'\nimport { getMethBins } from '../ModificationParser'\n\nimport type { ProcessedRenderArgs } from './types'\nimport type { LayoutFeature } from './util'\nimport type { Region } from '@jbrowse/core/util'\n\n// Color by methylation is slightly modified version of color by modifications\n// at reference CpG sites, with non-methylated CpG colored (looking only at the\n// MM tag can not tell you where reference CpG sites are)\nexport function renderMethylation({\n  ctx,\n  feat,\n  region,\n  bpPerPx,\n  renderArgs,\n  canvasWidth,\n  cigarOps,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  region: Region\n  bpPerPx: number\n  renderArgs: ProcessedRenderArgs\n  canvasWidth: number\n  cigarOps: string[]\n}) {\n  const { regionSequence } = renderArgs\n  const { feature, topPx, heightPx } = feat\n  if (!regionSequence) {\n    throw new Error('region sequence required for methylation')\n  }\n\n  const seq = feature.get('seq') as string | undefined\n  if (!seq) {\n    return\n  }\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const { methBins, methProbs, hydroxyMethBins, hydroxyMethProbs } =\n    getMethBins(feature, cigarOps)\n\n  function getCol(k: number) {\n    if (methBins[k]) {\n      const p = methProbs[k] || 0\n      return (\n        p > 0.5\n          ? colord('red').alpha((p - 0.5) * 2)\n          : colord('blue').alpha(1 - p * 2)\n      ).toHslString()\n    }\n    if (hydroxyMethBins[k]) {\n      const p = hydroxyMethProbs[k] || 0\n      return (\n        p > 0.5\n          ? colord('pink').alpha((p - 0.5) * 2)\n          : colord('purple').alpha(1 - p * 2)\n      ).toHslString()\n    }\n    return undefined\n  }\n  const r = regionSequence.toLowerCase()\n  for (let i = 0; i < fend - fstart; i++) {\n    const j = i + fstart\n\n    const l1 = r[j - region.start + 1]\n    const l2 = r[j - region.start + 2]\n\n    if (l1 === 'c' && l2 === 'g') {\n      if (bpPerPx > 2) {\n        const [leftPx, rightPx] = bpSpanPx(j, j + 2, region, bpPerPx)\n        const w = rightPx - leftPx + 0.5\n        const c = getCol(i) || getCol(i + 1) || 'blue'\n        fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c)\n      } else {\n        const [leftPx, rightPx] = bpSpanPx(j, j + 1, region, bpPerPx)\n        const w = rightPx - leftPx + 0.5\n        const c = getCol(i) || 'blue'\n        fillRect(ctx, leftPx, topPx, w, heightPx, canvasWidth, c)\n        const [leftPx2, rightPx2] = bpSpanPx(j + 1, j + 2, region, bpPerPx)\n        const w2 = rightPx2 - leftPx2 + 0.5\n        const c2 = getCol(i + 1) || 'blue'\n        fillRect(ctx, leftPx2, topPx, w2, heightPx, canvasWidth, c2)\n      }\n    }\n  }\n}\n","import { bpSpanPx, measureText } from '@jbrowse/core/util'\nimport { colord } from '@jbrowse/core/util/colord'\n\nimport { fillRect } from './util'\n\nimport type { ProcessedRenderArgs } from './types'\nimport type { LayoutFeature } from './util'\nimport type { Mismatch } from '../shared/types'\n\nexport function renderMismatches({\n  ctx,\n  feat,\n  renderArgs,\n  minSubfeatureWidth,\n  largeInsertionIndicatorScale,\n  mismatchAlpha,\n  charWidth,\n  charHeight,\n  colorMap,\n  colorContrastMap,\n  hideSmallIndels,\n  canvasWidth,\n  drawSNPsMuted,\n  drawIndels = true,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  renderArgs: ProcessedRenderArgs\n  colorMap: Record<string, string>\n  colorContrastMap: Record<string, string>\n  mismatchAlpha?: boolean\n  drawIndels?: boolean\n  drawSNPsMuted?: boolean\n  minSubfeatureWidth: number\n  largeInsertionIndicatorScale: number\n  hideSmallIndels: boolean\n  charWidth: number\n  charHeight: number\n  canvasWidth: number\n}) {\n  const { bpPerPx, regions } = renderArgs\n  const { heightPx, topPx, feature } = feat\n  const region = regions[0]!\n  const start = feature.get('start')\n\n  const pxPerBp = Math.min(1 / bpPerPx, 2)\n  const mismatches = feature.get('mismatches') as Mismatch[] | undefined\n  const heightLim = charHeight - 2\n\n  // extraHorizontallyFlippedOffset is used to draw interbase items, which are\n  // located to the left when forward and right when reversed\n  const extraHorizontallyFlippedOffset = region.reversed ? 1 / bpPerPx + 1 : -1\n\n  if (!mismatches) {\n    return\n  }\n\n  // two pass rendering: first pass, draw all the mismatches except wide\n  // insertion markers\n  for (const mismatch of mismatches) {\n    const mstart = start + mismatch.start\n    const mlen = mismatch.length\n    const mbase = mismatch.base\n    const [leftPx, rightPx] = bpSpanPx(mstart, mstart + mlen, region, bpPerPx)\n    const widthPx = Math.max(minSubfeatureWidth, rightPx - leftPx)\n    if (mismatch.type === 'mismatch') {\n      if (!drawSNPsMuted) {\n        const baseColor = colorMap[mismatch.base] || '#888'\n        const c =\n          mismatchAlpha && mismatch.qual !== undefined\n            ? colord(baseColor)\n                .alpha(Math.min(1, mismatch.qual / 50))\n                .toHslString()\n            : baseColor\n\n        fillRect(\n          ctx,\n          Math.round(leftPx),\n          topPx,\n          widthPx,\n          heightPx,\n          canvasWidth,\n          c,\n        )\n      }\n\n      if (widthPx >= charWidth && heightPx >= heightLim) {\n        // normal SNP coloring\n        const contrastColor = drawSNPsMuted\n          ? 'black'\n          : colorContrastMap[mismatch.base] || 'black'\n        ctx.fillStyle =\n          mismatchAlpha && mismatch.qual !== undefined\n            ? colord(contrastColor)\n                .alpha(Math.min(1, mismatch.qual / 50))\n                .toHslString()\n            : contrastColor\n        ctx.fillText(\n          mbase,\n          leftPx + (widthPx - charWidth) / 2 + 1,\n          topPx + heightPx,\n        )\n      }\n    } else if (mismatch.type === 'deletion' && drawIndels) {\n      const len = mismatch.length\n      if (!hideSmallIndels || len >= 10) {\n        fillRect(\n          ctx,\n          leftPx,\n          topPx,\n          Math.abs(leftPx - rightPx),\n          heightPx,\n          canvasWidth,\n          colorMap.deletion,\n        )\n        const txt = `${mismatch.length}`\n        const rwidth = measureText(txt, 10)\n        if (widthPx >= rwidth && heightPx >= heightLim) {\n          ctx.fillStyle = colorContrastMap.deletion!\n          ctx.fillText(\n            txt,\n            (leftPx + rightPx) / 2 - rwidth / 2,\n            topPx + heightPx,\n          )\n        }\n      }\n    } else if (mismatch.type === 'insertion' && drawIndels) {\n      const pos = leftPx + extraHorizontallyFlippedOffset\n      const len = +mismatch.base || mismatch.length\n      const insW = Math.max(0, Math.min(1.2, 1 / bpPerPx))\n      if (len < 10) {\n        if (!hideSmallIndels) {\n          fillRect(\n            ctx,\n            pos,\n            topPx,\n            insW,\n            heightPx,\n            canvasWidth,\n            colorMap.insertion,\n          )\n          if (1 / bpPerPx >= charWidth && heightPx >= heightLim) {\n            const l = Math.round(pos - insW)\n            fillRect(ctx, l, topPx, insW * 3, 1, canvasWidth)\n            fillRect(ctx, l, topPx + heightPx - 1, insW * 3, 1, canvasWidth)\n            ctx.fillText(`(${mismatch.base})`, pos + 3, topPx + heightPx)\n          }\n        }\n      }\n    } else if (mismatch.type === 'hardclip' || mismatch.type === 'softclip') {\n      const pos = leftPx + extraHorizontallyFlippedOffset\n      const c = colorMap[mismatch.type]\n      const clipW = Math.max(minSubfeatureWidth, pxPerBp)\n      fillRect(ctx, pos, topPx, clipW, heightPx, canvasWidth, c)\n      if (1 / bpPerPx >= charWidth && heightPx >= heightLim) {\n        const l = pos - clipW\n        fillRect(ctx, l, topPx, clipW * 3, 1, canvasWidth)\n        fillRect(ctx, l, topPx + heightPx - 1, clipW * 3, 1, canvasWidth)\n        ctx.fillText(`(${mismatch.base})`, pos + 3, topPx + heightPx)\n      }\n    } else if (mismatch.type === 'skip') {\n      // fix to avoid bad rendering note that this was also related to chrome\n      // bug https://bugs.chromium.org/p/chromium/issues/detail?id=1131528\n      //\n      // also affected firefox ref #1236 #2750\n      if (leftPx + widthPx > 0) {\n        // make small exons more visible when zoomed far out\n        const adjustPx = widthPx - (bpPerPx > 10 ? 1.5 : 0)\n        const l = Math.max(0, leftPx)\n        const t = topPx + heightPx / 2 - 1\n        const w = adjustPx + Math.min(leftPx, 0)\n        const h = 1\n        fillRect(ctx, l, t, w, h, canvasWidth, colorMap.skip)\n      }\n    }\n  }\n\n  // second pass, draw wide insertion markers on top\n  if (drawIndels) {\n    for (const mismatch of mismatches) {\n      const mstart = start + mismatch.start\n      const mlen = mismatch.length\n      const len = +mismatch.base || mismatch.length\n      if (mismatch.type === 'insertion' && len >= 10) {\n        const [leftPx] = bpSpanPx(mstart, mstart + mlen, region, bpPerPx)\n        const txt = `${len}`\n        if (bpPerPx > largeInsertionIndicatorScale) {\n          fillRect(\n            ctx,\n            leftPx - 1,\n            topPx,\n            2,\n            heightPx,\n            canvasWidth,\n            colorMap.insertion,\n          )\n        } else if (heightPx > charHeight) {\n          const rwidth = measureText(txt)\n          const padding = 5\n          fillRect(\n            ctx,\n            leftPx - rwidth / 2 - padding,\n            topPx,\n            rwidth + 2 * padding,\n            heightPx,\n            canvasWidth,\n            'purple',\n          )\n          ctx.fillStyle = colorContrastMap.insertion!\n          ctx.fillText(txt, leftPx - rwidth / 2, topPx + heightPx)\n        } else {\n          const padding = 2\n          fillRect(\n            ctx,\n            leftPx - padding,\n            topPx,\n            2 * padding,\n            heightPx,\n            canvasWidth,\n            colorMap.insertion,\n          )\n        }\n      }\n    }\n  }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { bpSpanPx } from '@jbrowse/core/util'\n\nimport { fillRect, getCharWidthHeight } from './util'\nimport { parseCigar } from '../MismatchParser'\n\nimport type { ProcessedRenderArgs } from './types'\nimport type { LayoutFeature } from './util'\nimport type { Mismatch } from '../shared/types'\nimport type { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport type { Theme } from '@mui/material'\n\nexport function renderSoftClipping({\n  ctx,\n  feat,\n  renderArgs,\n  config,\n  theme,\n  colorMap,\n  canvasWidth,\n}: {\n  ctx: CanvasRenderingContext2D\n  feat: LayoutFeature\n  renderArgs: ProcessedRenderArgs\n  config: AnyConfigurationModel\n  colorMap: Record<string, string>\n  theme: Theme\n  canvasWidth: number\n}) {\n  const { feature, topPx, heightPx } = feat\n  const { regions, bpPerPx } = renderArgs\n  const region = regions[0]!\n  const minFeatWidth = readConfObject(config, 'minSubfeatureWidth')\n  const mismatches = feature.get('mismatches') as Mismatch[] | undefined\n  const seq = feature.get('seq') as string | undefined\n  const { charWidth, charHeight } = getCharWidthHeight()\n\n  // Display all bases softclipped off in lightened colors\n  if (!(seq && mismatches)) {\n    return\n  }\n\n  const heightLim = charHeight - 2\n  let seqOffset = 0\n  let refOffset = 0\n  const CIGAR = feature.get('CIGAR')\n  const cigarOps = parseCigar(CIGAR)\n  for (let i = 0; i < cigarOps.length; i += 2) {\n    const op = cigarOps[i + 1]!\n    const len = +cigarOps[i]!\n    if (op === 'S') {\n      for (let k = 0; k < len; k++) {\n        const base = seq[seqOffset + k]!\n        const s0 = feature.get('start') - (i === 0 ? len : 0) + refOffset + k\n        const [leftPx, rightPx] = bpSpanPx(s0, s0 + 1, region, bpPerPx)\n        const widthPx = Math.max(minFeatWidth, rightPx - leftPx)\n\n        // Black accounts for IUPAC ambiguity code bases such as N that\n        // show in soft clipping\n        const baseColor = colorMap[base] || '#000000'\n        ctx.fillStyle = baseColor\n        fillRect(ctx, leftPx, topPx, widthPx, heightPx, canvasWidth)\n\n        if (widthPx >= charWidth && heightPx >= heightLim) {\n          ctx.fillStyle = theme.palette.getContrastText(baseColor)\n          ctx.fillText(\n            base,\n            leftPx + (widthPx - charWidth) / 2 + 1,\n            topPx + heightPx,\n          )\n        }\n      }\n      seqOffset += len\n    }\n    if (op === 'N') {\n      refOffset += len\n    }\n    if (op === 'M' || op === '=' || op === 'X') {\n      refOffset += len\n      seqOffset += len\n    }\n    if (op === 'H') {\n      // do nothing\n    }\n    if (op === 'D') {\n      refOffset += len\n    }\n    if (op === 'I') {\n      seqOffset += len\n    }\n  }\n}\n","import { readConfObject } from '@jbrowse/core/configuration'\nimport { createJBrowseTheme } from '@jbrowse/core/ui'\nimport { checkStopToken } from '@jbrowse/core/util/stopToken'\n\nimport { renderAlignment } from './renderAlignment'\nimport { renderMismatches } from './renderMismatches'\nimport { renderSoftClipping } from './renderSoftClipping'\nimport {\n  getCharWidthHeight,\n  getColorBaseMap,\n  getContrastBaseMap,\n  shouldDrawIndels,\n  shouldDrawSNPsMuted,\n} from './util'\n\nimport type { ProcessedRenderArgs } from './types'\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface LayoutFeature {\n  heightPx: number\n  topPx: number\n  feature: Feature\n}\n\nexport function makeImageData({\n  ctx,\n  layoutRecords,\n  canvasWidth,\n  renderArgs,\n}: {\n  ctx: CanvasRenderingContext2D\n  canvasWidth: number\n  layoutRecords: LayoutFeature[]\n  renderArgs: ProcessedRenderArgs\n}) {\n  const {\n    stopToken,\n    config,\n    showSoftClip,\n    colorBy,\n    theme: configTheme,\n  } = renderArgs\n  const mismatchAlpha = readConfObject(config, 'mismatchAlpha')\n  const minSubfeatureWidth = readConfObject(config, 'minSubfeatureWidth')\n  const largeInsertionIndicatorScale = readConfObject(\n    config,\n    'largeInsertionIndicatorScale',\n  )\n  const hideSmallIndels = readConfObject(config, 'hideSmallIndels') as boolean\n  const defaultColor = readConfObject(config, 'color') === '#f0f'\n  const theme = createJBrowseTheme(configTheme)\n  const colorMap = getColorBaseMap(theme)\n  const colorContrastMap = getContrastBaseMap(theme)\n  ctx.font = 'bold 10px Courier New,monospace'\n\n  const { charWidth, charHeight } = getCharWidthHeight()\n  const drawSNPsMuted = shouldDrawSNPsMuted(colorBy?.type)\n  const drawIndels = shouldDrawIndels()\n  let start = performance.now()\n  for (const feat of layoutRecords) {\n    if (performance.now() - start > 400) {\n      checkStopToken(stopToken)\n      start = performance.now()\n    }\n    renderAlignment({\n      ctx,\n      feat,\n      renderArgs,\n      defaultColor,\n      colorMap,\n      colorContrastMap,\n      charWidth,\n      charHeight,\n      canvasWidth,\n    })\n    renderMismatches({\n      ctx,\n      feat,\n      renderArgs,\n      hideSmallIndels,\n      mismatchAlpha,\n      drawSNPsMuted,\n      drawIndels,\n      largeInsertionIndicatorScale,\n      minSubfeatureWidth,\n      charWidth,\n      charHeight,\n      colorMap,\n      colorContrastMap,\n      canvasWidth,\n    })\n    if (showSoftClip) {\n      renderSoftClipping({\n        ctx,\n        feat,\n        renderArgs,\n        colorMap,\n        config,\n        theme,\n        canvasWidth,\n      })\n    }\n  }\n  return undefined\n}\n","import { orientationTypes, pairMap } from '../util'\n\nimport type { ChainStats } from './fetchChains'\n\nexport const fillColor = {\n  color_fwd_strand_not_proper: '#ECC8C8',\n  color_rev_strand_not_proper: '#BEBED8',\n  color_fwd_strand: '#EC8B8B',\n  color_rev_strand: '#8F8FD8',\n  color_fwd_missing_mate: '#D11919',\n  color_rev_missing_mate: '#1919D1',\n  color_fwd_diff_chr: '#000',\n  color_rev_diff_chr: '#969696',\n  color_pair_lr: '#c8c8c8',\n  color_pair_rr: 'navy',\n  color_pair_rl: 'teal',\n  color_pair_ll: 'green',\n  color_nostrand: '#c8c8c8',\n  color_interchrom: 'purple',\n  color_longinsert: 'red',\n  color_shortinsert: 'pink',\n  color_unknown: 'grey',\n}\n\n// manually calculated by running\n// const color = require('color')\n// Object.fromEntries(Object.entries(fillColor).map(([key,val])=>{\n//   return [key, color(val).darken('0.3').hex()]\n// }))\n// this avoids (expensive) use of Color module at runtime\nexport const strokeColor = {\n  color_fwd_strand_not_proper: '#CA6767',\n  color_rev_strand_not_proper: '#7272AA',\n  color_fwd_strand: '#DC2A2A',\n  color_rev_strand: '#4141BA',\n  color_fwd_missing_mate: '#921111',\n  color_rev_missing_mate: '#111192',\n  color_fwd_diff_chr: '#000000',\n  color_rev_diff_chr: '#696969',\n  color_pair_lr: '#8C8C8C',\n  color_pair_rr: '#00005A',\n  color_pair_rl: '#005A5A',\n  color_pair_ll: '#005A00',\n  color_nostrand: '#8C8C8C',\n  color_interchrom: '#5A005A',\n  color_longinsert: '#B30000',\n  color_shortinsert: '#FF3A5C',\n  color_unknown: 'grey',\n}\n\nexport function getPairedInsertSizeColor(\n  f1: { refName: string; tlen?: number },\n  f2: { refName: string },\n  stats?: ChainStats,\n) {\n  const sameRef = f1.refName === f2.refName\n  const tlen = Math.abs(f1.tlen || 0)\n  if (sameRef && tlen > (stats?.upper || 0)) {\n    return [fillColor.color_longinsert, strokeColor.color_longinsert] as const\n  } else if (sameRef && tlen < (stats?.lower || 0)) {\n    return [fillColor.color_shortinsert, strokeColor.color_shortinsert] as const\n  } else if (!sameRef) {\n    return [fillColor.color_interchrom, strokeColor.color_interchrom] as const\n  } else {\n    return undefined\n  }\n}\n\nconst defaultColor = [fillColor.color_unknown, fillColor.color_unknown] as const\n\n// return color scheme with both insert size and orientation coloring,\n// prioritzing orientation coloring\nexport function getPairedInsertSizeAndOrientationColor(\n  f1: { refName: string; pair_orientation?: string; tlen?: number },\n  f2: { refName: string },\n  stats?: ChainStats,\n) {\n  return (\n    getPairedOrientationColorOrDefault(f1) ||\n    getPairedInsertSizeColor(f1, f2, stats) ||\n    defaultColor\n  )\n}\n\nexport function getPairedOrientationColorOrDefault(f: {\n  pair_orientation?: string\n}) {\n  const type = orientationTypes.fr\n  const r = type[f.pair_orientation || ''] as keyof typeof pairMap\n  const type2 = pairMap[r] as keyof typeof fillColor\n  return r === 'LR'\n    ? undefined\n    : ([fillColor[type2], strokeColor[type2]] as const)\n}\n\nexport function getPairedOrientationColor(f: { pair_orientation?: string }) {\n  return getPairedOrientationColorOrDefault(f) || defaultColor\n}\n","import { getNextRefPos, parseCigar } from '../MismatchParser'\nimport { getModPositions, getModProbabilities } from '../ModificationParser'\nimport { getTagAlt } from '../util'\n\nimport type { Feature } from '@jbrowse/core/util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  cigarOps?: string[],\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const ops = cigarOps || parseCigar(feature.get('CIGAR'))\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n"],"names":["getAlignmentShapeColor","colorType","tag","feature","config","defaultColor","colorTagMap","get","Math","abs","colorByInsertSize","colorByStrand","colorByMappingQuality","fillColor","orientationType","readConfObject","LR","RR","RL","LL","orientationTypes","getOrientation","colorByOrientation","flags","strand","flipper","getStranded","colorByStrandedRnaSeq","tags","val","color_rev_strand","color_fwd_strand","color_nostrand","fillRect","ctx","l","t","w","h","cw","color","fillStyle","getColorBaseMap","theme","skip","deletion","insertion","hardclip","softclip","bases","palette","A","main","C","G","T","getCharWidthHeight","charWidth","measureText","charHeight","renderAlignment","feat","renderArgs","colorMap","colorContrastMap","canvasWidth","bpPerPx","regions","colorBy","type","region","heightPx","topPx","s","e","CIGAR","flip","reversed","renderChevrons","includes","cigarOps","parseCigar","drawLen","drawStart","i","length","opLen","op","leftPx","rightPx","bpSpanPx","beginPath","moveTo","lineTo","closePath","fill","renderAlignmentShape","scores","split","map","start","soffset","roffset","len","m","score","start0","renderPerBaseQuality","heightLim","seq","letter","r","fillText","renderPerBaseLettering","visibleModifications","isolatedModification","modifications","twoColor","getMaxProbModAtEachPosition","forEach","allProbs","prob","pos","mod","console","warn","col","sum","max","c","alphaColor","renderModifications","regionSequence","Error","fstart","fend","methBins","methProbs","hydroxyMethBins","hydroxyMethProbs","getMethBins","getCol","k","p","colord","alpha","toHslString","toLowerCase","j","l1","l2","leftPx2","rightPx2","renderMethylation","renderMismatches","minSubfeatureWidth","largeInsertionIndicatorScale","mismatchAlpha","hideSmallIndels","drawSNPsMuted","drawIndels","pxPerBp","min","mismatches","extraHorizontallyFlippedOffset","mismatch","mstart","mlen","mbase","base","widthPx","baseColor","undefined","qual","round","contrastColor","txt","rwidth","insW","clipW","adjustPx","padding","renderSoftClipping","minFeatWidth","seqOffset","refOffset","s0","getContrastText","makeImageData","layoutRecords","stopToken","showSoftClip","configTheme","createJBrowseTheme","Object","fromEntries","entries","key","value","getContrastBaseMap","font","performance","now","checkStopToken","color_fwd_strand_not_proper","color_rev_strand_not_proper","color_fwd_missing_mate","color_rev_missing_mate","color_fwd_diff_chr","color_rev_diff_chr","color_pair_lr","color_pair_rr","color_pair_rl","color_pair_ll","color_interchrom","color_longinsert","color_shortinsert","color_unknown","strokeColor","getPairedInsertSizeColor","f1","f2","stats","sameRef","refName","tlen","upper","lower","getPairedInsertSizeAndOrientationColor","getPairedOrientationColorOrDefault","f","fr","pair_orientation","type2","pairMap","getPairedOrientationColor","fstrand","mm","getTagAlt","ops","getModPositions","probabilities","getModProbabilities","maxProbModForPosition","probIndex","positions","ref","idx","getNextRefPos","old"],"sourceRoot":""}