{"version":3,"file":"static/js/9206.22a811a3.chunk.js","mappings":"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","sources":["../../../plugins/sequence/src/BgzipFastaAdapter/BgzipFastaAdapter.ts","../../../plugins/sequence/src/IndexedFastaAdapter/IndexedFastaAdapter.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AggregateAbortController.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AggregateStatusReporter.ts","../../../node_modules/@gmod/abortable-promise-cache/src/AbortablePromiseCache.ts","../../../node_modules/@gmod/indexedfasta/src/indexedFasta.ts","../../../node_modules/@gmod/indexedfasta/src/bgzipIndexedFasta.ts"],"sourcesContent":["import { BgzipIndexedFasta } from '@gmod/indexedfasta'\nimport { FileLocation } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport IndexedFasta from '../IndexedFastaAdapter/IndexedFastaAdapter'\n\nexport default class BgzipFastaAdapter extends IndexedFasta {\n  public async setupPre() {\n    const fastaLocation = this.getConf('fastaLocation')\n    const faiLocation = this.getConf('faiLocation')\n    const gziLocation = this.getConf('gziLocation')\n    const fastaOpts = {\n      fasta: openLocation(fastaLocation as FileLocation, this.pluginManager),\n      fai: openLocation(faiLocation as FileLocation, this.pluginManager),\n      gzi: openLocation(gziLocation as FileLocation, this.pluginManager),\n    }\n\n    return { fasta: new BgzipIndexedFasta(fastaOpts) }\n  }\n}\n","import { IndexedFasta } from '@gmod/indexedfasta'\nimport {\n  BaseSequenceAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { FileLocation, NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { SimpleFeature, Feature } from '@jbrowse/core/util'\nimport AbortablePromiseCache from '@gmod/abortable-promise-cache'\nimport QuickLRU from '@jbrowse/core/util/QuickLRU'\n\ninterface T {\n  refName: string\n  start: number\n  end: number\n  fasta: IndexedFasta\n}\n\nexport default class IndexedFastaAdapter extends BaseSequenceAdapter {\n  protected setupP?: Promise<{ fasta: IndexedFasta }>\n\n  private seqCache = new AbortablePromiseCache<T, string | undefined>({\n    cache: new QuickLRU({ maxSize: 200 }),\n    fill: async (args: T, signal?: AbortSignal) => {\n      const { refName, start, end, fasta } = args\n      return fasta.getSequence(refName, start, end, { ...args, signal })\n    },\n  })\n\n  public async getRefNames(opts?: BaseOptions) {\n    const { fasta } = await this.setup()\n    return fasta.getSequenceNames(opts)\n  }\n\n  public async getRegions(opts?: BaseOptions) {\n    const { fasta } = await this.setup()\n    const seqSizes = await fasta.getSequenceSizes(opts)\n    return Object.keys(seqSizes).map(refName => ({\n      refName,\n      start: 0,\n      end: seqSizes[refName]!,\n    }))\n  }\n\n  public async setupPre() {\n    const fastaLocation = this.getConf('fastaLocation') as FileLocation\n    const faiLocation = this.getConf('faiLocation') as FileLocation\n\n    return {\n      fasta: new IndexedFasta({\n        fasta: openLocation(fastaLocation, this.pluginManager),\n        fai: openLocation(faiLocation, this.pluginManager),\n      }),\n    }\n  }\n\n  public async getHeader() {\n    const loc = this.getConf('metadataLocation')\n    return loc.uri === '' || loc.uri === '/path/to/fa.metadata.yaml'\n      ? null\n      : openLocation(loc, this.pluginManager).readFile('utf8')\n  }\n\n  public async setup() {\n    if (!this.setupP) {\n      this.setupP = this.setupPre().catch((e: unknown) => {\n        this.setupP = undefined\n        throw e\n      })\n    }\n    return this.setupP\n  }\n\n  public getFeatures(region: NoAssemblyRegion, opts?: BaseOptions) {\n    const { refName, start, end } = region\n    return ObservableCreate<Feature>(async observer => {\n      const { fasta } = await this.setup()\n      const size = await fasta.getSequenceSize(refName, opts)\n      const regionEnd = Math.min(size, end)\n      const chunks = []\n      const chunkSize = 128000\n\n      const s = start - (start % chunkSize)\n      const e = end + (chunkSize - (end % chunkSize))\n      for (let chunkStart = s; chunkStart < e; chunkStart += chunkSize) {\n        const r = {\n          refName,\n          start: chunkStart,\n          end: chunkStart + chunkSize,\n        }\n        chunks.push(\n          this.seqCache.get(JSON.stringify(r), { ...r, fasta }, opts?.signal),\n        )\n      }\n      const seq = (await Promise.all(chunks))\n        .join('')\n        .slice(start - s)\n        .slice(0, end - start)\n      if (seq) {\n        observer.next(\n          new SimpleFeature({\n            id: `${refName} ${start}-${regionEnd}`,\n            data: { refName, start, end: regionEnd, seq },\n          }),\n        )\n      }\n      observer.complete()\n    })\n  }\n\n  /**\n   * called to provide a hint that data tied to a certain region\n   * will not be needed for the foreseeable future and can be purged\n   * from caches, etc\n   */\n  public freeResources(/* { region } */): void {}\n}\n","class NullSignal {}\n\n/**\n * aggregates a number of abort signals, will only fire the aggregated\n * abort if all of the input signals have been aborted\n */\nexport default class AggregateAbortController {\n  signals = new Set()\n  abortController = new AbortController()\n\n  /**\n   * @param {AbortSignal} [signal] optional AbortSignal to add. if falsy,\n   *  will be treated as a null-signal, and this abortcontroller will no\n   *  longer be abortable.\n   */\n  //@ts-ignore\n  addSignal(signal: AbortSignal = new NullSignal()): void {\n    if (this.signal.aborted) {\n      throw new Error('cannot add a signal, already aborted!')\n    }\n\n    // note that a NullSignal will never fire, so if we\n    // have one this thing will never actually abort\n    this.signals.add(signal)\n    if (signal.aborted) {\n      // handle the abort immediately if it is already aborted\n      // for some reason\n      this.handleAborted(signal)\n    } else if (typeof signal.addEventListener === 'function') {\n      signal.addEventListener('abort', () => {\n        this.handleAborted(signal)\n      })\n    }\n  }\n\n  handleAborted(signal: AbortSignal): void {\n    this.signals.delete(signal)\n    if (this.signals.size === 0) {\n      this.abortController.abort()\n    }\n  }\n\n  get signal(): AbortSignal {\n    return this.abortController.signal\n  }\n\n  abort(): void {\n    this.abortController.abort()\n  }\n}\n","export default class AggregateStatusReporter {\n  callbacks = new Set<Function>()\n  currentMessage: unknown\n\n  addCallback(callback: Function = () => {}): void {\n    this.callbacks.add(callback)\n    callback(this.currentMessage)\n  }\n\n  callback(message: unknown) {\n    this.currentMessage = message\n    for (const elt of this.callbacks) {\n      elt(message)\n    }\n  }\n}\n","import AggregateAbortController from './AggregateAbortController'\nimport AggregateStatusReporter from './AggregateStatusReporter'\n\ninterface Cache<U> {\n  delete: (key: string) => void\n  keys: () => Iterator<string>\n  get: (key: string) => U | undefined\n  set: (key: string, value: U) => void\n  has: (key: string) => boolean\n}\ntype FillCallback<T, U> = (\n  data: T,\n  signal?: AbortSignal,\n  statusCallback?: Function,\n) => Promise<U>\n\ninterface Entry<U> {\n  aborter: AggregateAbortController\n  settled: boolean\n  readonly aborted: boolean\n  statusReporter: AggregateStatusReporter\n  promise: Promise<U>\n}\nexport default class AbortablePromiseCache<T, U> {\n  /**\n   * @param {object} args constructor args\n   * @param {Function} args.fill fill callback, will be called with sig `fill(data, signal)`\n   * @param {object} args.cache backing store to use, must implement `get(key)`, `set(key, val)`,\n   *   `delete(key)`, and `keys() -> iterator`\n   */\n\n  private cache: Cache<Entry<U>>\n  private fillCallback: FillCallback<T, U>\n\n  constructor({\n    fill,\n    cache,\n  }: {\n    fill: FillCallback<T, U>\n    cache: Cache<Entry<U>>\n  }) {\n    if (typeof fill !== 'function') {\n      throw new TypeError('must pass a fill function')\n    }\n    if (typeof cache !== 'object') {\n      throw new TypeError('must pass a cache object')\n    }\n    if (\n      typeof cache.get !== 'function' ||\n      typeof cache.set !== 'function' ||\n      typeof cache.delete !== 'function'\n    ) {\n      throw new TypeError(\n        'cache must implement get(key), set(key, val), and and delete(key)',\n      )\n    }\n\n    this.cache = cache\n    this.fillCallback = fill\n  }\n\n  static isAbortException(exception: Error) {\n    return (\n      // DOMException\n      exception.name === 'AbortError' ||\n      // standard-ish non-DOM abort exception\n      //@ts-ignore\n      exception.code === 'ERR_ABORTED' ||\n      // stringified DOMException\n      exception.message === 'AbortError: aborted' ||\n      // stringified standard-ish exception\n      exception.message === 'Error: aborted'\n    )\n  }\n\n  evict(key: string, entry: Entry<U>) {\n    if (this.cache.get(key) === entry) {\n      this.cache.delete(key)\n    }\n  }\n\n  fill(key: string, data: T, signal?: AbortSignal, statusCallback?: Function) {\n    const aborter = new AggregateAbortController()\n    const statusReporter = new AggregateStatusReporter()\n    statusReporter.addCallback(statusCallback)\n    const newEntry: Entry<U> = {\n      aborter: aborter,\n      promise: this.fillCallback(data, aborter.signal, (message: unknown) => {\n        statusReporter.callback(message)\n      }),\n      settled: false,\n      statusReporter,\n      get aborted() {\n        return this.aborter.signal.aborted\n      },\n    }\n    newEntry.aborter.addSignal(signal)\n\n    // remove the fill from the cache when its abortcontroller fires, if still in there\n    newEntry.aborter.signal.addEventListener('abort', () => {\n      if (!newEntry.settled) {\n        this.evict(key, newEntry)\n      }\n    })\n\n    // chain off the cached promise to record when it settles\n    newEntry.promise\n      .then(\n        () => {\n          newEntry.settled = true\n        },\n        () => {\n          newEntry.settled = true\n\n          // if the fill throws an error (including abort) and is still in the cache, remove it\n          this.evict(key, newEntry)\n        },\n      )\n      .catch(error => {\n        // this will only be reached if there is some kind of\n        // bad bug in this library\n        console.error(error)\n        throw error\n      })\n\n    this.cache.set(key, newEntry)\n  }\n\n  static checkSinglePromise<U>(promise: Promise<U>, signal?: AbortSignal) {\n    // check just this signal for having been aborted, and abort the\n    // promise if it was, regardless of what happened with the cached\n    // response\n    function checkForSingleAbort() {\n      if (signal?.aborted) {\n        throw Object.assign(new Error('aborted'), { code: 'ERR_ABORTED' })\n      }\n    }\n\n    return promise.then(\n      result => {\n        checkForSingleAbort()\n        return result\n      },\n      error => {\n        checkForSingleAbort()\n        throw error\n      },\n    )\n  }\n\n  has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Callback for getting status of the pending async\n   *\n   * @callback statusCallback\n   * @param {any} status, current status string or message object\n   */\n\n  /**\n   * @param {any} key cache key to use for this request\n   * @param {any} data data passed as the first argument to the fill callback\n   * @param {AbortSignal} [signal] optional AbortSignal object that aborts the request\n   * @param {statusCallback} a callback to get the current status of a pending async operation\n   */\n  get(\n    key: string,\n    data: T,\n    signal?: AbortSignal,\n    statusCallback?: Function,\n  ): Promise<U> {\n    if (!signal && data instanceof AbortSignal) {\n      throw new TypeError(\n        'second get argument appears to be an AbortSignal, perhaps you meant to pass `null` for the fill data?',\n      )\n    }\n    const cacheEntry = this.cache.get(key)\n\n    if (cacheEntry) {\n      if (cacheEntry.aborted && !cacheEntry.settled) {\n        // if it's aborted but has not realized it yet, evict it and redispatch\n        this.evict(key, cacheEntry)\n        return this.get(key, data, signal, statusCallback)\n      }\n\n      if (cacheEntry.settled) {\n        // too late to abort, just return it\n        return cacheEntry.promise\n      }\n\n      // request is in-flight, add this signal to its list of signals,\n      // or if there is no signal, the aborter will become non-abortable\n      cacheEntry.aborter.addSignal(signal)\n      cacheEntry.statusReporter.addCallback(statusCallback)\n\n      return AbortablePromiseCache.checkSinglePromise(\n        cacheEntry.promise,\n        signal,\n      )\n    }\n\n    // if we got here, it is not in the cache. fill.\n    this.fill(key, data, signal, statusCallback)\n    return AbortablePromiseCache.checkSinglePromise(\n      //see https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#non-null-assertion-operator-postfix-\n\n      this.cache.get(key)!.promise,\n      signal,\n    )\n  }\n\n  /**\n   * delete the given entry from the cache. if it exists and its fill request has\n   * not yet settled, the fill will be signaled to abort.\n   *\n   * @param {any} key\n   */\n  delete(key: string) {\n    const cachedEntry = this.cache.get(key)\n    if (cachedEntry) {\n      if (!cachedEntry.settled) {\n        cachedEntry.aborter.abort()\n      }\n      this.cache.delete(key)\n    }\n  }\n\n  /**\n   * Clear all requests from the cache. Aborts any that have not settled.\n   * @returns {number} count of entries deleted\n   */\n  clear() {\n    // iterate without needing regenerator-runtime\n    const keyIter = this.cache.keys()\n    let deleteCount = 0\n    for (let result = keyIter.next(); !result.done; result = keyIter.next()) {\n      this.delete(result.value)\n      deleteCount += 1\n    }\n    return deleteCount\n  }\n}\n","import { LocalFile, GenericFilehandle } from 'generic-filehandle'\nimport { Buffer } from 'buffer'\n\ninterface BaseOpts {\n  signal?: AbortSignal\n}\n\ninterface IndexEntry {\n  offset: number\n  lineBytes: number\n  lineLength: number\n  length: number\n}\n\nfunction _faiOffset(idx: IndexEntry, pos: number) {\n  return (\n    idx.offset +\n    idx.lineBytes * Math.floor(pos / idx.lineLength) +\n    (pos % idx.lineLength)\n  )\n}\n\nasync function readFAI(fai: GenericFilehandle, opts?: BaseOpts) {\n  const text = await fai.readFile(opts)\n  if (!text?.length) {\n    throw new Error('No data read from FASTA index (FAI) file')\n  }\n\n  let idCounter = 0\n  let currSeq: { name: string; id: number } | undefined\n  const data = text\n    .toString('utf8')\n    .split(/\\r?\\n/)\n    .filter(line => /\\S/.test(line))\n    .map(line => line.split('\\t'))\n    .filter(row => row[0] !== '')\n    .map(row => {\n      if (!currSeq || currSeq.name !== row[0]) {\n        currSeq = { name: row[0], id: idCounter }\n        idCounter += 1\n      }\n\n      return {\n        id: currSeq.id,\n        name: row[0],\n        length: +row[1],\n        start: 0,\n        end: +row[1],\n        offset: +row[2],\n        lineLength: +row[3],\n        lineBytes: +row[4],\n      }\n    })\n\n  return {\n    name: Object.fromEntries(data.map(entry => [entry.name, entry])),\n    id: Object.fromEntries(data.map(entry => [entry.id, entry])),\n  }\n}\n\nexport default class IndexedFasta {\n  fasta: GenericFilehandle\n  fai: GenericFilehandle\n  indexes?: ReturnType<typeof readFAI>\n\n  constructor({\n    fasta,\n    fai,\n    path,\n    faiPath,\n  }: {\n    fasta?: GenericFilehandle\n    fai?: GenericFilehandle\n    path?: string\n    faiPath?: string\n  }) {\n    if (fasta) {\n      this.fasta = fasta\n    } else if (path) {\n      this.fasta = new LocalFile(path)\n    } else {\n      throw new Error('Need to pass filehandle for fasta or path to localfile')\n    }\n\n    if (fai) {\n      this.fai = fai\n    } else if (faiPath) {\n      this.fai = new LocalFile(faiPath)\n    } else if (path) {\n      this.fai = new LocalFile(`${path}.fai`)\n    } else {\n      throw new Error('Need to pass filehandle for  or path to localfile')\n    }\n  }\n\n  async _getIndexes(opts?: BaseOpts) {\n    if (!this.indexes) {\n      this.indexes = readFAI(this.fai, opts)\n    }\n    return this.indexes\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceNames(opts?: BaseOpts) {\n    return Object.keys((await this._getIndexes(opts)).name)\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSizes(opts?: BaseOpts) {\n    const returnObject = {} as Record<string, number>\n    const idx = await this._getIndexes(opts)\n    for (const val of Object.values(idx.id)) {\n      returnObject[val.name] = val.length\n    }\n    return returnObject\n  }\n\n  /**\n   * @returns {array[string]} array of string sequence\n   * names that are present in the index, in which the\n   * array index indicates the sequence ID, and the value\n   * is the sequence name\n   */\n  async getSequenceSize(seqName: string, opts?: BaseOpts) {\n    const idx = await this._getIndexes(opts)\n    return idx.name[seqName]?.length\n  }\n\n  /**\n   *\n   * @param {string} name\n   * @returns {Promise[boolean]} true if the file contains the given reference sequence name\n   */\n  async hasReferenceSequence(name: string, opts?: BaseOpts) {\n    return !!(await this._getIndexes(opts)).name[name]\n  }\n\n  /**\n   *\n   * @param {number} seqId\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesById(\n    seqId: number,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).id[seqId]\n    if (!indexEntry) {\n      return undefined\n    }\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  /**\n   * @param {string} seqName\n   * @param {number} min\n   * @param {number} max\n   */\n  async getResiduesByName(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    const indexEntry = (await this._getIndexes(opts)).name[seqName]\n    if (!indexEntry) {\n      return undefined\n    }\n\n    return this._fetchFromIndexEntry(indexEntry, min, max, opts)\n  }\n\n  //alias for getResiduesByName\n  async getSequence(\n    seqName: string,\n    min: number,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    return this.getResiduesByName(seqName, min, max, opts)\n  }\n\n  async _fetchFromIndexEntry(\n    indexEntry: IndexEntry,\n    min = 0,\n    max: number,\n    opts?: BaseOpts,\n  ) {\n    let end = max\n    if (min < 0) {\n      throw new TypeError('regionStart cannot be less than 0')\n    }\n    if (end === undefined || end > indexEntry.length) {\n      end = indexEntry.length\n    }\n    if (min >= end) {\n      return ''\n    }\n\n    const position = _faiOffset(indexEntry, min)\n    const readlen = _faiOffset(indexEntry, end) - position\n\n    const residues = Buffer.allocUnsafe(readlen)\n    await this.fasta.read(residues, 0, readlen, position, opts)\n    return residues.toString('utf8').replace(/\\s+/g, '')\n  }\n}\n","import { BgzfFilehandle } from '@gmod/bgzf-filehandle'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport IndexedFasta from './indexedFasta'\n\nexport default class BgzipIndexedFasta extends IndexedFasta {\n  constructor({\n    fasta,\n    path,\n    fai,\n    faiPath,\n    gzi,\n    gziPath,\n  }: {\n    fasta?: GenericFilehandle\n    path?: string\n    fai?: GenericFilehandle\n    faiPath?: string\n    gzi?: GenericFilehandle\n    gziPath?: string\n  }) {\n    super({ fasta, path, fai, faiPath })\n    if (fasta && gzi) {\n      // @ts-expect-error\n      this.fasta = new BgzfFilehandle({\n        filehandle: fasta,\n        gziFilehandle: gzi,\n      })\n    } else if (path && gziPath) {\n      // @ts-expect-error\n      this.fasta = new BgzfFilehandle({ path, gziPath })\n    }\n  }\n}\n"],"names":["BgzipFastaAdapter","IndexedFasta","setupPre","fastaLocation","this","getConf","faiLocation","gziLocation","fastaOpts","fasta","openLocation","pluginManager","fai","gzi","BgzipIndexedFasta","IndexedFastaAdapter","BaseSequenceAdapter","seqCache","AbortablePromiseCache","cache","QuickLRU","maxSize","fill","async","args","signal","refName","start","end","getSequence","getRefNames","opts","setup","getSequenceNames","getRegions","seqSizes","getSequenceSizes","Object","keys","map","getHeader","loc","uri","readFile","setupP","catch","e","undefined","getFeatures","region","ObservableCreate","size","getSequenceSize","regionEnd","Math","min","chunks","chunkSize","s","chunkStart","r","push","get","JSON","stringify","seq","Promise","all","join","slice","observer","next","SimpleFeature","id","data","complete","freeResources","NullSignal","AggregateAbortController","signals","Set","abortController","AbortController","addSignal","aborted","Error","add","handleAborted","addEventListener","delete","abort","AggregateStatusReporter","callbacks","addCallback","callback","currentMessage","message","elt","constructor","TypeError","set","fillCallback","isAbortException","exception","name","code","evict","key","entry","statusCallback","aborter","statusReporter","newEntry","promise","settled","then","error","console","checkSinglePromise","checkForSingleAbort","assign","result","has","AbortSignal","cacheEntry","cachedEntry","clear","keyIter","deleteCount","done","value","_faiOffset","idx","pos","offset","lineBytes","floor","lineLength","path","faiPath","_getIndexes","indexes","text","length","currSeq","idCounter","toString","split","filter","line","test","row","fromEntries","readFAI","returnObject","val","values","seqName","hasReferenceSequence","getResiduesById","seqId","max","indexEntry","_fetchFromIndexEntry","getResiduesByName","position","readlen","residues","allocUnsafe","read","replace","gziPath","super","filehandle","gziFilehandle"],"sourceRoot":""}