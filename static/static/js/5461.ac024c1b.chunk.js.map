{"version":3,"file":"static/js/5461.ac024c1b.chunk.js","mappings":"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","sources":["../../../plugins/alignments/src/SNPCoverageAdapter/generateCoverageBins.ts","../../../plugins/alignments/src/SNPCoverageAdapter/SNPCoverageAdapter.ts","../../../plugins/alignments/src/shared/getMaximumModificationAtEachPosition.ts"],"sourcesContent":["import { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { doesIntersect2, Feature, max, sum } from '@jbrowse/core/util'\n\n// locals\nimport { parseCigar } from '../MismatchParser'\nimport { getMethBins } from '../ModificationParser'\nimport {\n  ColorBy,\n  Mismatch,\n  PreBaseCoverageBin,\n  PreBaseCoverageBinSubtypes,\n  SkipMap,\n} from '../shared/types'\nimport { getMaxProbModAtEachPosition } from '../shared/getMaximumModificationAtEachPosition'\n\nfunction mismatchLen(mismatch: Mismatch) {\n  return !isInterbase(mismatch.type) ? mismatch.length : 1\n}\n\nfunction isInterbase(type: string) {\n  return type === 'softclip' || type === 'hardclip' || type === 'insertion'\n}\n\nfunction inc(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin[strand]++\n}\n\ninterface Opts {\n  bpPerPx?: number\n  colorBy?: ColorBy\n}\n\nfunction processDepth({\n  feature,\n  bins,\n  region,\n  regionSequence,\n}: {\n  feature: Feature\n  bins: PreBaseCoverageBin[]\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const regionLength = region.end - region.start\n  for (let j = fstart; j < fend + 1; j++) {\n    const i = j - region.start\n    if (i >= 0 && i < regionLength) {\n      if (bins[i] === undefined) {\n        bins[i] = {\n          depth: 0,\n          readsCounted: 0,\n          refbase: regionSequence[i],\n          ref: {\n            probabilities: [],\n            entryDepth: 0,\n            '-1': 0,\n            0: 0,\n            1: 0,\n          },\n          snps: {},\n          mods: {},\n          nonmods: {},\n          delskips: {},\n          noncov: {},\n        }\n      }\n      if (j !== fend) {\n        bins[i].depth++\n        bins[i].readsCounted++\n        bins[i].ref.entryDepth++\n        bins[i].ref[fstrand]++\n      }\n    }\n  }\n}\nfunction processSNPs({\n  feature,\n  region,\n  bins,\n  skipmap,\n}: {\n  region: Region\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  skipmap: SkipMap\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n\n  // normal SNP based coloring\n  for (const mismatch of mismatches) {\n    const mstart = fstart + mismatch.start\n    const mlen = mismatchLen(mismatch)\n    const mend = mstart + mlen\n    for (let j = mstart; j < mstart + mlen; j++) {\n      const epos = j - region.start\n      if (epos >= 0 && epos < bins.length) {\n        const bin = bins[epos]!\n        const { base, type } = mismatch\n        const interbase = isInterbase(type)\n\n        if (type === 'deletion' || type === 'skip') {\n          inc(bin, fstrand, 'delskips', type)\n          bin.depth--\n        } else if (!interbase) {\n          inc(bin, fstrand, 'snps', base)\n          bin.ref.entryDepth--\n          bin.ref[fstrand]--\n        } else {\n          inc(bin, fstrand, 'noncov', type)\n        }\n      }\n    }\n\n    if (mismatch.type === 'skip') {\n      // for upper case XS and TS: reports the literal strand of the genomic\n      // transcript\n      const tags = feature.get('tags')\n      const xs = tags?.XS || tags?.TS\n      // for lower case ts from minimap2: genomic transcript flipped by read\n      // strand\n      const ts = tags?.ts\n      const effectiveStrand =\n        xs === '+'\n          ? 1\n          : xs === '-'\n            ? -1\n            : (ts === '+' ? 1 : xs === '-' ? -1 : 0) * fstrand\n      const hash = `${mstart}_${mend}_${effectiveStrand}`\n      if (skipmap[hash] === undefined) {\n        skipmap[hash] = {\n          feature: feature,\n          start: mstart,\n          end: mend,\n          strand: fstrand,\n          effectiveStrand,\n          score: 0,\n        }\n      }\n      skipmap[hash].score++\n    }\n  }\n}\n\nfunction processReferenceCpGs({\n  feature,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fend = feature.get('end')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mismatches = (feature.get('mismatches') as Mismatch[] | undefined) ?? []\n  const r = regionSequence.toLowerCase()\n  if (seq) {\n    const cigarOps = parseCigar(feature.get('CIGAR'))\n    const { methBins, methProbs } = getMethBins(feature, cigarOps)\n    const dels = mismatches.filter(f => f.type === 'deletion')\n\n    // methylation based coloring takes into account both reference sequence\n    // CpG detection and reads\n    for (let i = 0; i < fend - fstart; i++) {\n      const j = i + fstart\n      const l1 = r[j - region.start + 1]\n      const l2 = r[j - region.start + 2]\n      if (l1 === 'c' && l2 === 'g') {\n        const bin0 = bins[j - region.start]\n        const bin1 = bins[j - region.start + 1]\n        const b0 = methBins[i]\n        const b1 = methBins[i + 1]\n        const p0 = methProbs[i]\n        const p1 = methProbs[i + 1]\n\n        // color\n        if (\n          (b0 && (p0 !== undefined ? p0 > 0.5 : true)) ||\n          (b1 && (p1 !== undefined ? p1 > 0.5 : true))\n        ) {\n          if (bin0) {\n            incWithProbabilities(bin0, fstrand, 'mods', 'cpg_meth', p0 || 0)\n            bin0.ref.entryDepth--\n            bin0.ref[fstrand]--\n          }\n          if (bin1) {\n            incWithProbabilities(bin1, fstrand, 'mods', 'cpg_meth', p1 || 0)\n            bin1.ref.entryDepth--\n            bin1.ref[fstrand]--\n          }\n        } else {\n          if (bin0) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j,\n                  j + 1,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin0,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p0 || 0),\n              )\n              bin0.ref.entryDepth--\n              bin0.ref[fstrand]--\n            }\n          }\n          if (bin1) {\n            if (\n              !dels.some(d =>\n                doesIntersect2(\n                  j + 1,\n                  j + 2,\n                  d.start + fstart,\n                  d.start + fstart + d.length,\n                ),\n              )\n            ) {\n              incWithProbabilities(\n                bin1,\n                fstrand,\n                'nonmods',\n                'cpg_unmeth',\n                1 - (p1 || 0),\n              )\n              bin1.ref.entryDepth--\n              bin1.ref[fstrand]--\n            }\n          }\n        }\n      }\n    }\n  }\n}\n\nfunction processModification({\n  feature,\n  colorBy,\n  region,\n  bins,\n  regionSequence,\n}: {\n  bins: PreBaseCoverageBin[]\n  feature: Feature\n  region: Region\n  colorBy?: ColorBy\n  regionSequence: string\n}) {\n  const fstart = feature.get('start')\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const fend = feature.get('end')\n  const twoColor = colorBy?.modifications?.twoColor\n  const isolatedModification = colorBy?.modifications?.isolatedModification\n  getMaxProbModAtEachPosition(feature)?.forEach(\n    ({ type, prob, allProbs }, pos) => {\n      if (isolatedModification && type !== isolatedModification) {\n        return\n      }\n      const epos = pos + fstart - region.start\n      if (epos >= 0 && epos < bins.length && pos + fstart < fend) {\n        if (bins[epos] === undefined) {\n          bins[epos] = {\n            depth: 0,\n            readsCounted: 0,\n            refbase: regionSequence[epos],\n            snps: {},\n            ref: {\n              probabilities: [],\n              entryDepth: 0,\n              '-1': 0,\n              0: 0,\n              1: 0,\n            },\n            mods: {},\n            nonmods: {},\n            delskips: {},\n            noncov: {},\n          }\n        }\n\n        const s = 1 - sum(allProbs)\n        const bin = bins[epos]\n        if (twoColor && s > max(allProbs)) {\n          incWithProbabilities(bin, fstrand, 'nonmods', `nonmod_${type}`, s)\n        } else {\n          incWithProbabilities(bin, fstrand, 'mods', `mod_${type}`, prob)\n        }\n      }\n    },\n  )\n}\n\nfunction incWithProbabilities(\n  bin: PreBaseCoverageBin,\n  strand: -1 | 0 | 1,\n  type: keyof PreBaseCoverageBinSubtypes,\n  field: string,\n  probability: number,\n) {\n  let thisBin = bin[type][field]\n  if (thisBin === undefined) {\n    thisBin = bin[type][field] = {\n      entryDepth: 0,\n      probabilities: [],\n      '-1': 0,\n      '0': 0,\n      '1': 0,\n    }\n  }\n  thisBin.entryDepth++\n  thisBin.probabilities.push(probability)\n  thisBin[strand]++\n}\n\nexport async function generateCoverageBins({\n  fetchSequence,\n  features,\n  region,\n  opts,\n}: {\n  features: Feature[]\n  region: Region\n  opts: Opts\n  fetchSequence: (arg: Region) => Promise<string>\n}) {\n  const { colorBy } = opts\n  const skipmap = {} as SkipMap\n  const bins = [] as PreBaseCoverageBin[]\n  const start2 = Math.max(0, region.start - 1)\n  const diff = region.start - start2\n  const regionSequence =\n    (await fetchSequence({\n      ...region,\n      start: start2,\n      end: region.end + 1,\n    })) || ''\n  for (const feature of features) {\n    processDepth({\n      feature,\n      bins,\n      region,\n      regionSequence: regionSequence.slice(diff),\n    })\n\n    if (colorBy?.type === 'modifications') {\n      processModification({\n        feature,\n        colorBy,\n        bins,\n        region,\n        regionSequence: regionSequence.slice(diff),\n      })\n    } else if (colorBy?.type === 'methylation') {\n      processReferenceCpGs({\n        feature,\n        bins,\n        region,\n        regionSequence,\n      })\n    }\n    processSNPs({ feature, skipmap, bins, region })\n  }\n\n  for (const bin of bins) {\n    // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition\n    if (bin) {\n      bin.mods = Object.fromEntries(\n        Object.entries(bin.mods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n      bin.nonmods = Object.fromEntries(\n        Object.entries(bin.nonmods).map(([key, val]) => {\n          return [\n            key,\n            {\n              ...val,\n              avgProbability: val.probabilities.length\n                ? sum(val.probabilities) / val.probabilities.length\n                : undefined,\n            },\n          ] as const\n        }),\n      )\n    }\n  }\n\n  return {\n    bins,\n    skipmap,\n  }\n}\n","import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\n\n// locals\nimport { fetchSequence } from '../util'\nimport { generateCoverageBins } from './generateCoverageBins'\n\nexport default class SNPCoverageAdapter extends BaseFeatureDataAdapter {\n  protected async configure() {\n    const subadapterConfig = this.getConf('subadapter')\n    const sequenceConf = subadapterConfig.sequenceAdapter\n    const dataAdapter = await this.getSubAdapter?.(subadapterConfig)\n\n    const sequenceAdapter = sequenceConf\n      ? await this.getSubAdapter?.(sequenceConf)\n      : undefined\n\n    if (!dataAdapter) {\n      throw new Error('Failed to get subadapter')\n    }\n\n    return {\n      subadapter: dataAdapter.dataAdapter as BaseFeatureDataAdapter,\n      sequenceAdapter: sequenceAdapter?.dataAdapter as\n        | BaseFeatureDataAdapter\n        | undefined,\n    }\n  }\n\n  async fetchSequence(region: Region) {\n    const { sequenceAdapter } = await this.configure()\n    if (!sequenceAdapter) {\n      return undefined\n    }\n    return fetchSequence(region, sequenceAdapter)\n  }\n\n  getFeatures(region: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { subadapter } = await this.configure()\n      const features = await firstValueFrom(\n        subadapter.getFeatures(region, opts).pipe(toArray()),\n      )\n\n      const { bins, skipmap } = await generateCoverageBins({\n        features,\n        region,\n        opts,\n        fetchSequence: (region: Region) => this.fetchSequence(region),\n      })\n\n      bins.forEach((bin, index) => {\n        const start = region.start + index\n        observer.next(\n          new SimpleFeature({\n            id: `${this.id}-${start}`,\n            data: {\n              score: bin.depth,\n              snpinfo: bin,\n              start,\n              end: start + 1,\n              refName: region.refName,\n            },\n          }),\n        )\n      })\n\n      // make fake features from the coverage\n      Object.entries(skipmap).forEach(([key, skip]) => {\n        observer.next(\n          new SimpleFeature({\n            id: key,\n            data: {\n              type: 'skip',\n              start: skip.start,\n              end: skip.end,\n              strand: skip.strand,\n              score: skip.score,\n              effectiveStrand: skip.effectiveStrand,\n            },\n          }),\n        )\n      })\n\n      observer.complete()\n    }, opts.signal)\n  }\n\n  async getMultiRegionFeatureDensityStats(\n    regions: Region[],\n    opts?: BaseOptions,\n  ) {\n    const { subadapter } = await this.configure()\n    return subadapter.getMultiRegionFeatureDensityStats(regions, opts)\n  }\n\n  async getRefNames(opts: BaseOptions = {}) {\n    const { subadapter } = await this.configure()\n    return subadapter.getRefNames(opts)\n  }\n\n  freeResources(/* { region } */): void {}\n}\n","import { Feature } from '@jbrowse/core/util'\n// locals\nimport { getModPositions, getModProbabilities } from '../ModificationParser'\nimport { getNextRefPos, parseCigar } from '../MismatchParser'\nimport { getTagAlt } from '../util'\n\ninterface MaximumProbabilityMod {\n  type: string\n  prob: number\n  allProbs: number[]\n}\n\nexport function getMaxProbModAtEachPosition(\n  feature: Feature,\n  cigarOps?: string[],\n) {\n  const fstrand = feature.get('strand') as -1 | 0 | 1\n  const seq = feature.get('seq') as string | undefined\n  const mm = (getTagAlt(feature, 'MM', 'Mm') as string) || ''\n  const ops = cigarOps || parseCigar(feature.get('CIGAR'))\n  if (seq) {\n    const modifications = getModPositions(mm, seq, fstrand)\n    const probabilities = getModProbabilities(feature)\n    const maxProbModForPosition = [] as MaximumProbabilityMod[]\n\n    let probIndex = 0\n    for (const { type, positions } of modifications) {\n      for (const { ref, idx } of getNextRefPos(ops, positions)) {\n        const prob =\n          probabilities?.[\n            probIndex + (fstrand === -1 ? positions.length - 1 - idx : idx)\n          ] || 0\n        if (!maxProbModForPosition[ref]) {\n          maxProbModForPosition[ref] = {\n            type,\n            prob,\n            allProbs: [prob],\n          }\n        } else {\n          const old = maxProbModForPosition[ref]\n          maxProbModForPosition[ref] = {\n            allProbs: [...old.allProbs, prob],\n            prob: Math.max(old.prob, prob),\n            type: old.prob > prob ? old.type : type,\n          }\n        }\n      }\n      probIndex += positions.length\n    }\n    return maxProbModForPosition\n  }\n  return undefined\n}\n"],"names":["mismatchLen","mismatch","isInterbase","type","length","inc","bin","strand","field","thisBin","undefined","entryDepth","probabilities","processDepth","feature","bins","region","regionSequence","fstart","get","fend","fstrand","regionLength","end","start","j","i","depth","readsCounted","refbase","ref","snps","mods","nonmods","delskips","noncov","processSNPs","skipmap","mismatches","mstart","mlen","mend","epos","base","interbase","tags","xs","XS","TS","ts","effectiveStrand","hash","score","processReferenceCpGs","seq","r","toLowerCase","cigarOps","parseCigar","methBins","methProbs","getMethBins","dels","filter","f","l1","l2","bin0","bin1","b0","b1","p0","p1","incWithProbabilities","some","d","doesIntersect2","processModification","colorBy","twoColor","modifications","isolatedModification","getMaxProbModAtEachPosition","forEach","prob","allProbs","pos","s","sum","max","probability","push","SNPCoverageAdapter","BaseFeatureDataAdapter","configure","subadapterConfig","this","getConf","sequenceConf","sequenceAdapter","dataAdapter","getSubAdapter","Error","subadapter","fetchSequence","getFeatures","opts","ObservableCreate","async","features","firstValueFrom","pipe","toArray","start2","Math","diff","slice","Object","fromEntries","entries","map","key","val","avgProbability","generateCoverageBins","index","observer","next","SimpleFeature","id","data","snpinfo","refName","skip","complete","signal","getMultiRegionFeatureDensityStats","regions","getRefNames","freeResources","mm","getTagAlt","ops","getModPositions","getModProbabilities","maxProbModForPosition","probIndex","positions","idx","getNextRefPos","old"],"sourceRoot":""}