{"version":3,"file":"static/js/6834.f4256ac7.chunk.js","mappings":"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","sources":["../../../plugins/bed/src/BigBedAdapter/BigBedAdapter.ts","../../../plugins/bed/src/generateRepeatMaskerFeature.ts","../../../plugins/bed/src/util.ts","../../../plugins/bed/src/generateBedMethylFeature.ts","../../../plugins/bed/src/generateUcscTranscript.ts"],"sourcesContent":["import { BigBed } from '@gmod/bbi'\nimport BED from '@gmod/bed'\nimport {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { Region } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport {\n  doesIntersect2,\n  max,\n  min,\n  Feature,\n  SimpleFeature,\n  SimpleFeatureSerialized,\n} from '@jbrowse/core/util'\nimport { firstValueFrom, Observer, toArray } from 'rxjs'\n\n// locals\nimport { featureData2 } from '../util'\n\nexport default class BigBedAdapter extends BaseFeatureDataAdapter {\n  private cachedP?: Promise<{\n    bigbed: BigBed\n    header: Awaited<ReturnType<BigBed['getHeader']>>\n    parser: BED\n  }>\n\n  public async configurePre(opts?: BaseOptions) {\n    const pm = this.pluginManager\n    const bigbed = new BigBed({\n      filehandle: openLocation(this.getConf('bigBedLocation'), pm),\n    })\n    const header = await bigbed.getHeader(opts)\n    const parser = new BED({\n      autoSql: header.autoSql,\n    })\n    return {\n      bigbed,\n      header,\n      parser,\n    }\n  }\n\n  public async configure(opts?: BaseOptions) {\n    if (!this.cachedP) {\n      this.cachedP = this.configurePre(opts).catch((e: unknown) => {\n        this.cachedP = undefined\n        throw e\n      })\n    }\n    return this.cachedP\n  }\n\n  public async getRefNames(opts?: BaseOptions) {\n    const { header } = await this.configure(opts)\n    return Object.keys(header.refsByName)\n  }\n\n  public async getData() {\n    const refNames = await this.getRefNames()\n    const features = []\n    for (const refName of refNames) {\n      const f = await firstValueFrom(\n        this.getFeatures({\n          assemblyName: 'unknown',\n          refName,\n          start: 0,\n          end: Number.MAX_SAFE_INTEGER,\n        }).pipe(toArray()),\n      )\n      features.push(f)\n    }\n    return features.flat()\n  }\n\n  async getHeader(opts?: BaseOptions) {\n    const { parser, header } = await this.configure(opts)\n    const { version, fileType } = header\n    const { fields, ...rest } = parser.autoSql\n    return {\n      version,\n      fileType,\n      autoSql: { ...rest },\n      fields: Object.fromEntries(\n        fields.map(({ name, comment }) => [name, comment]),\n      ),\n    }\n  }\n\n  public async getFeaturesHelper({\n    query,\n    opts,\n    observer,\n    allowRedispatch,\n    originalQuery = query,\n  }: {\n    query: Region\n    opts: BaseOptions\n    observer: Observer<Feature>\n    allowRedispatch: boolean\n    originalQuery?: Region\n  }) {\n    const { signal } = opts\n    const scoreColumn = this.getConf('scoreColumn')\n    const aggregateField = this.getConf('aggregateField')\n    const { parser, bigbed } = await this.configure(opts)\n    const feats = await bigbed.getFeatures(\n      query.refName,\n      query.start,\n      query.end,\n      {\n        signal,\n        basesPerSpan: query.end - query.start,\n      },\n    )\n    if (allowRedispatch && feats.length) {\n      let minStart = Number.POSITIVE_INFINITY\n      let maxEnd = Number.NEGATIVE_INFINITY\n      for (const feat of feats) {\n        if (feat.start < minStart) {\n          minStart = feat.start\n        }\n        if (feat.end > maxEnd) {\n          maxEnd = feat.end\n        }\n      }\n      if (maxEnd > query.end || minStart < query.start) {\n        await this.getFeaturesHelper({\n          query: {\n            ...query,\n            start: minStart,\n            end: maxEnd,\n          },\n          opts,\n          observer,\n          allowRedispatch: false,\n          originalQuery: query,\n        })\n        return\n      }\n    }\n\n    const parentAggregation = {} as Record<string, SimpleFeatureSerialized[]>\n\n    if (feats.some(f => f.uniqueId === undefined)) {\n      throw new Error('found uniqueId undefined')\n    }\n    for (const feat of feats) {\n      const line = `${query.refName}\\t${feat.start}\\t${feat.end}\\t${feat.rest}`\n      const data = parser.parseLine(line, { uniqueId: feat.uniqueId! })\n\n      const aggr = data[aggregateField]\n      if (!parentAggregation[aggr]) {\n        parentAggregation[aggr] = []\n      }\n      const {\n        uniqueId,\n        type,\n        chrom,\n        chromStart,\n        chromEnd,\n        description,\n        chromStarts: chromStarts2,\n        blockStarts: blockStarts2,\n        blockSizes: blockSizes2,\n        score: score2,\n        blockCount,\n        thickStart,\n        thickEnd,\n        strand,\n        ...rest\n      } = data\n\n      const f = featureData2({\n        ...rest,\n        scoreColumn,\n        line,\n        parser,\n        uniqueId,\n        start: feat.start,\n        end: feat.end,\n        refName: query.refName,\n      })\n      if (aggr) {\n        parentAggregation[aggr].push(f)\n      } else {\n        if (\n          doesIntersect2(f.start, f.end, originalQuery.start, originalQuery.end)\n        ) {\n          observer.next(\n            new SimpleFeature({\n              id: `${this.id}-${uniqueId}`,\n              data: f,\n            }),\n          )\n        }\n      }\n    }\n\n    Object.entries(parentAggregation).map(([name, subfeatures]) => {\n      const s = min(subfeatures.map(f => f.start))\n      const e = max(subfeatures.map(f => f.end))\n      if (doesIntersect2(s, e, originalQuery.start, originalQuery.end)) {\n        const { uniqueId, strand } = subfeatures[0]!\n        observer.next(\n          new SimpleFeature({\n            id: `${this.id}-${uniqueId}-parent`,\n            data: {\n              type: 'gene',\n              subfeatures,\n              strand,\n              name,\n              start: s,\n              end: e,\n              refName: query.refName,\n            },\n          }),\n        )\n      }\n    })\n    observer.complete()\n  }\n  public getFeatures(query: Region, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        await this.getFeaturesHelper({\n          query,\n          opts,\n          observer,\n          allowRedispatch: true,\n        })\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(): void {}\n}\n","export function isRepeatMaskerDescriptionField(desc?: string): desc is string {\n  const ret = desc?.trim().split(' ')\n  return [0, 1, 2, 3, 5, 6].every(s =>\n    ret?.[s] !== undefined ? !Number.isNaN(+ret[s]) : false,\n  )\n}\n\nfunction makeRepeatTrackDescription(description?: string) {\n  if (isRepeatMaskerDescriptionField(description)) {\n    const [\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    ] = description.trim().split(' ')\n    return {\n      bitsw_score,\n      percent_div,\n      percent_del,\n      percent_ins,\n      query_chr,\n      query_begin,\n      query_end,\n      query_remaining,\n      orientation,\n      matching_repeat_name,\n      matching_repeat_class,\n      matching_repeat_begin,\n      matching_repeat_end,\n      matching_repeat_remaining,\n      repeat_id,\n    }\n  }\n  return { description }\n}\n\nexport function generateRepeatMaskerFeature({\n  uniqueId,\n  refName,\n  start,\n  end,\n  description,\n  ...rest\n}: {\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n  description: string\n  [key: string]: unknown\n}) {\n  return {\n    ...rest,\n    ...makeRepeatTrackDescription(description),\n    uniqueId,\n    refName,\n    start,\n    end,\n  }\n}\n","import BED from '@gmod/bed'\nimport { SimpleFeatureSerialized } from '@jbrowse/core/util'\nimport {\n  generateBedMethylFeature,\n  isBedMethylFeature,\n} from './generateBedMethylFeature'\nimport {\n  generateUcscTranscript,\n  isUcscTranscript,\n} from './generateUcscTranscript'\nimport {\n  generateRepeatMaskerFeature,\n  isRepeatMaskerDescriptionField,\n} from './generateRepeatMaskerFeature'\n\nfunction stringToStrand(f: string) {\n  if (f === '-1') {\n    return -1\n  } else if (f === '+') {\n    return 1\n  } else {\n    return 0\n  }\n}\n\nfunction defaultParser(fields: string[], line: string) {\n  const obj = Object.fromEntries(\n    line.split('\\t').map((f, i) => [fields[i]!, f] as const),\n  )\n  const {\n    blockStarts,\n    blockCount,\n    chromStarts,\n    thickEnd,\n    thickStart,\n    blockSizes,\n    ...rest\n  } = obj\n\n  return {\n    ...rest,\n    blockStarts: arrayify(blockStarts),\n    chromStarts: arrayify(chromStarts),\n    blockSizes: arrayify(blockSizes),\n    thickStart: thickStart ? +thickStart : undefined,\n    thickEnd: thickEnd ? +thickEnd : undefined,\n    blockCount: blockCount ? +blockCount : undefined,\n  } as Record<string, unknown>\n}\n\nexport function makeBlocks({\n  start,\n  uniqueId,\n  refName,\n  chromStarts,\n  blockCount,\n  blockSizes,\n  blockStarts,\n}: {\n  blockCount: number\n  start: number\n  uniqueId: string\n  refName: string\n  chromStarts?: number[]\n  blockSizes?: number[]\n  blockStarts?: number[]\n}) {\n  if (blockCount) {\n    const subfeatures = []\n    const starts = chromStarts || blockStarts || []\n    for (let b = 0; b < blockCount; b++) {\n      const bmin = (starts[b] || 0) + start\n      const bsize = blockSizes?.[b]\n      if (bsize && bsize > 0) {\n        const bmax = bmin + bsize\n        subfeatures.push({\n          uniqueId: `${uniqueId}-${b}`,\n          start: bmin,\n          end: bmax,\n          refName,\n          type: 'block',\n        })\n      }\n    }\n    return subfeatures\n  }\n  return []\n}\n\nexport function featureData({\n  line,\n  colRef,\n  colStart,\n  colEnd,\n  scoreColumn,\n  parser,\n  uniqueId,\n  names,\n}: {\n  line: string\n  colRef: number\n  colStart: number\n  colEnd: number\n  scoreColumn: string\n  parser: BED\n  uniqueId: string\n  names?: string[]\n}) {\n  const splitLine = line.split('\\t')\n  const refName = splitLine[colRef]!\n  const start = +splitLine[colStart]!\n  const end = +splitLine[colEnd]! + (colStart === colEnd ? 1 : 0)\n\n  return featureData2({\n    line,\n    refName,\n    start,\n    end,\n    parser,\n    uniqueId,\n    scoreColumn,\n    names,\n  })\n}\n\nexport function featureData2({\n  line,\n  refName,\n  start,\n  end,\n  parser,\n  uniqueId,\n  scoreColumn,\n  names,\n}: {\n  line: string\n  refName: string\n  start: number\n  end: number\n  parser: BED\n  uniqueId: string\n  scoreColumn: string\n  names?: string[]\n}): SimpleFeatureSerialized {\n  const splitLine = line.split('\\t')\n  const data = names\n    ? defaultParser(names, line)\n    : parser.parseLine(line, { uniqueId })\n  const {\n    strand: strand2,\n    score: score2,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    ...rest\n  } = data\n\n  const {\n    chromStarts,\n    blockSizes,\n    blockStarts,\n    type,\n    blockCount,\n    thickStart,\n    thickEnd,\n    description,\n    ...rest2\n  } = rest\n  const score = scoreColumn ? +data[scoreColumn] : score2 ? +score2 : undefined\n  const strand = typeof strand2 === 'string' ? stringToStrand(strand2) : strand2\n\n  const subfeatures = makeBlocks({\n    start,\n    uniqueId,\n    refName,\n    chromStarts,\n    blockCount,\n    blockSizes,\n    blockStarts,\n  })\n\n  if (isBedMethylFeature({ splitLine, start, end })) {\n    return generateBedMethylFeature({\n      line,\n      uniqueId,\n      refName,\n      start,\n      end,\n    })\n  } else if (isRepeatMaskerDescriptionField(description)) {\n    return generateRepeatMaskerFeature({\n      ...rest2,\n      uniqueId,\n      description,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    })\n  } else if (isUcscTranscript({ strand, blockCount, thickStart })) {\n    return generateUcscTranscript({\n      ...rest,\n      description,\n      chromStarts,\n      thickStart,\n      thickEnd,\n      blockSizes,\n      blockCount,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      uniqueId,\n      subfeatures,\n    })\n  } else {\n    return {\n      ...rest,\n      uniqueId,\n      description,\n      type,\n      score,\n      start,\n      end,\n      strand,\n      refName,\n      subfeatures,\n    }\n  }\n}\n\nexport function arrayify(f?: string | number[]) {\n  return f !== undefined\n    ? typeof f === 'string'\n      ? f.split(',').map(f => +f)\n      : f\n    : undefined\n}\n","export function isBedMethylFeature({\n  splitLine,\n  start,\n  end,\n}: {\n  splitLine: string[]\n  start: number\n  end: number\n}) {\n  return +(splitLine[6] || 0) === start && +(splitLine[7] || 0) === end\n}\nexport function generateBedMethylFeature({\n  line,\n  uniqueId,\n  refName,\n  start,\n  end,\n}: {\n  line: string\n  uniqueId: string\n  refName: string\n  start: number\n  end: number\n}) {\n  // see\n  // https://github.com/nanoporetech/modkit?tab=readme-ov-file#description-of-bedmethyl-output\n  const [\n    ,\n    ,\n    ,\n    code,\n    ,\n    strand,\n    ,\n    ,\n    color,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  ] = line.split('\\t')\n  return {\n    uniqueId,\n    refName,\n    start,\n    end,\n    code,\n    score: fraction_modified,\n    strand,\n    color,\n    source: code,\n    n_valid_cov,\n    fraction_modified,\n    n_mod,\n    n_canonical,\n    n_other_mod,\n    n_delete,\n    n_fail,\n    n_diff,\n    n_nocall,\n  }\n}\n","import { MinimalFeature, TranscriptFeat } from './types'\n\nexport function isUcscTranscript({\n  thickStart,\n  blockCount,\n  strand,\n}: {\n  thickStart?: number\n  blockCount?: number\n  strand?: number\n}) {\n  return thickStart && blockCount && strand !== 0\n}\n\nexport function generateUcscTranscript(data: TranscriptFeat) {\n  const {\n    strand = 0,\n    chrom: _1,\n    chromStart: _2,\n    chromEnd: _3,\n    chromStarts,\n    blockStarts,\n    blockSizes,\n    uniqueId,\n    ...rest\n  } = data\n  const {\n    subfeatures: oldSubfeatures,\n    thickStart,\n    thickEnd,\n    blockCount,\n    refName,\n    ...rest2\n  } = rest\n\n  const subfeatures: MinimalFeature[] = []\n  const feats = oldSubfeatures\n    .filter(child => child.type === 'block')\n    .sort((a, b) => a.start - b.start)\n\n  for (const block of feats) {\n    const start = block.start\n    const end = block.end\n    if (thickStart >= end) {\n      // left-side UTR\n      subfeatures.push({\n        type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n        start,\n        end,\n        refName,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd >= end) {\n      // UTR | CDS\n      subfeatures.push(\n        {\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end: thickStart,\n          refName,\n        },\n        {\n          type: 'CDS',\n          start: thickStart,\n          end,\n          refName,\n        },\n      )\n    } else if (thickStart <= start && thickEnd >= end) {\n      // CDS\n      subfeatures.push({\n        type: 'CDS',\n        start,\n        end,\n        refName,\n      })\n    } else if (thickStart > start && thickStart < end && thickEnd < end) {\n      // UTR | CDS | UTR\n      subfeatures.push(\n        {\n          type: `${strand > 0 ? 'five' : 'three'}_prime_UTR`,\n          start,\n          end: thickStart,\n          refName,\n        },\n        {\n          type: 'CDS',\n          start: thickStart,\n          end: thickEnd,\n          refName,\n        },\n        {\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start: thickEnd,\n          end,\n          refName,\n        },\n      )\n    } else if (thickStart <= start && thickEnd > start && thickEnd < end) {\n      // CDS | UTR\n      subfeatures.push(\n        {\n          type: 'CDS',\n          start,\n          end: thickEnd,\n          refName,\n        },\n        {\n          type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n          start: thickEnd,\n          end,\n          refName,\n        },\n      )\n    } else if (thickEnd <= start) {\n      // right-side UTR\n      subfeatures.push({\n        type: `${strand > 0 ? 'three' : 'five'}_prime_UTR`,\n        start,\n        end,\n        refName,\n      })\n    }\n  }\n\n  return {\n    ...rest2,\n    uniqueId,\n    strand,\n    type: 'mRNA',\n    refName,\n    subfeatures,\n  }\n}\n"],"names":["BigBedAdapter","BaseFeatureDataAdapter","configurePre","opts","pm","this","pluginManager","bigbed","BigBed","filehandle","openLocation","getConf","header","getHeader","parser","BED","autoSql","configure","cachedP","catch","e","undefined","getRefNames","Object","keys","refsByName","getData","refNames","features","refName","f","firstValueFrom","getFeatures","assemblyName","start","end","Number","MAX_SAFE_INTEGER","pipe","toArray","push","flat","version","fileType","fields","rest","fromEntries","map","name","comment","getFeaturesHelper","query","observer","allowRedispatch","originalQuery","signal","scoreColumn","aggregateField","feats","basesPerSpan","length","minStart","POSITIVE_INFINITY","maxEnd","NEGATIVE_INFINITY","feat","parentAggregation","some","uniqueId","Error","line","data","parseLine","aggr","type","chrom","chromStart","chromEnd","description","chromStarts","chromStarts2","blockStarts","blockStarts2","blockSizes","blockSizes2","score","score2","blockCount","thickStart","thickEnd","strand","featureData2","doesIntersect2","next","SimpleFeature","id","entries","subfeatures","s","min","max","complete","ObservableCreate","async","error","freeResources","isRepeatMaskerDescriptionField","desc","ret","trim","split","every","isNaN","makeRepeatTrackDescription","bitsw_score","percent_div","percent_del","percent_ins","query_chr","query_begin","query_end","query_remaining","orientation","matching_repeat_name","matching_repeat_class","matching_repeat_begin","matching_repeat_end","matching_repeat_remaining","repeat_id","featureData","colRef","colStart","colEnd","names","splitLine","obj","i","arrayify","defaultParser","strand2","_1","_2","_3","rest2","starts","b","bmin","bsize","bmax","makeBlocks","isBedMethylFeature","code","color","n_valid_cov","fraction_modified","n_mod","n_canonical","n_other_mod","n_delete","n_fail","n_diff","n_nocall","source","generateBedMethylFeature","generateRepeatMaskerFeature","isUcscTranscript","oldSubfeatures","filter","child","sort","a","block","generateUcscTranscript"],"sourceRoot":""}