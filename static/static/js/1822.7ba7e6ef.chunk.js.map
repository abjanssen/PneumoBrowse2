{"version":3,"file":"static/js/1822.7ba7e6ef.chunk.js","mappings":"kNAcA,SAASA,EAAYC,GACnB,MAAMC,EAAWD,EAAIE,MAAMF,EAAIG,YAAY,KAAO,GAClD,OAAOF,EAASC,MAAM,EAAGD,EAASE,YAAY,KAChD,CAUe,MAAMC,UAA2BC,EAAAA,uBAC9C,oBAA6B,CAC3B,gBACA,gBACA,kBAGF,iBAAaC,GACX,MAAMC,EAAgBC,KAAKD,cAC3B,IAAKA,EACH,MAAM,IAAIE,MAAM,8BAElB,IAAIC,EAAWF,KAAKG,QAAQ,eAY5B,OAXKD,GAAUE,SAEbF,EADgBF,KAAKG,QAAQ,WACVE,KAAIC,IAAS,CAC9BC,KAAM,gBACNC,OAAQjB,EAAYe,GACpBG,eAAgB,CACdjB,IAAKc,QAKJI,QAAQC,IACbT,EAASG,KAAIO,UACX,MAAMC,SAAqBd,EAAce,IACtCD,YACH,MAAO,CACLL,OAAQM,EAAKC,MAAQF,EAAYG,MAC9BF,EACHD,cACD,IAGP,CAGA,iBAAaI,CAAYC,GACvB,MAAMC,QAAiBnB,KAAKF,cACtBsB,QAAiBV,QAAQC,IAC7BQ,EAASd,KAAIgB,GAAKA,EAAER,YAAYI,YAAYC,MAE9C,MAAO,IAAI,IAAII,IAAIF,EAASG,QAC9B,CAEA,oBAAaC,CAAeN,GAC1B,MAAMC,QAAiBnB,KAAKF,cACtB2B,SACGf,QAAQC,IAEbQ,EAASd,KAAIqB,GAAOA,EAAIb,YAAYW,iBAAiBN,OAEvDS,QAAOC,KAAOA,IAGhB,MAAO,CAAEC,UAFQC,EAAAA,EAAAA,KAAIL,EAAMpB,KAAI0B,GAAKA,EAAEF,YAEnBG,UADFC,EAAAA,EAAAA,KAAIR,EAAMpB,KAAI0B,GAAKA,EAAEC,YAExC,CAEOE,WAAAA,CAAYC,EAAgBjB,EAAsB,CAAC,GACxD,OAAOkB,EAAAA,EAAAA,mBAA0BxB,UAC/B,MAAMO,QAAiBnB,KAAKF,eAC5BuC,EAAAA,EAAAA,MACKlB,EAASd,KAAIqB,GACdA,EAAIb,YAAYqB,YAAYC,EAAQjB,GAAMoB,MACxCjC,EAAAA,EAAAA,IAAIkC,GAEFA,EAAEC,IAAI,UACFD,EACA,IAAIE,EAAAA,cAAc,IACbF,EAAEG,SACLC,SAAU,GAAGjB,EAAIlB,UAAU+B,EAAEvB,OAC7BR,OAAQkB,EAAIlB,eAKxBoC,UAAUC,EAAS,GACpB3B,EAAK4B,OACV,CAGA,uCAAMC,CAAkCC,GACtC,MAAO,CACLC,eAAgB,EAEpB,CAIA,gBAAMC,CAAWF,GAEf,aADuBhD,KAAKF,eACZO,KAAI,EAAGQ,cAAaL,SAAQO,UAASoC,MAAW,CAC9DpC,KAAMP,EACN4C,OAAQrC,KACLoC,KAEP,CAEOE,aAAAA,GAAuB,E","sources":["../../../plugins/wiggle/src/MultiWiggleAdapter/MultiWiggleAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { AugmentedRegion as Region } from '@jbrowse/core/util/types'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { SimpleFeature, Feature, min, max } from '@jbrowse/core/util'\nimport { merge } from 'rxjs'\nimport { map } from 'rxjs/operators'\n\ninterface WiggleOptions extends BaseOptions {\n  resolution?: number\n}\n\nfunction getFilename(uri: string) {\n  const filename = uri.slice(uri.lastIndexOf('/') + 1)\n  return filename.slice(0, filename.lastIndexOf('.'))\n}\n\ninterface AdapterEntry {\n  dataAdapter: BaseFeatureDataAdapter\n  source: string\n  [key: string]: unknown\n}\n\ntype MaybeStats = { scoreMin: number; scoreMax: number } | undefined\n\nexport default class MultiWiggleAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = [\n    'hasResolution',\n    'hasLocalStats',\n    'hasGlobalStats',\n  ]\n\n  public async getAdapters(): Promise<AdapterEntry[]> {\n    const getSubAdapter = this.getSubAdapter\n    if (!getSubAdapter) {\n      throw new Error('no getSubAdapter available')\n    }\n    let subConfs = this.getConf('subadapters')\n    if (!subConfs?.length) {\n      const entries = this.getConf('bigWigs') as string[]\n      subConfs = entries.map(entry => ({\n        type: 'BigWigAdapter',\n        source: getFilename(entry),\n        bigWigLocation: {\n          uri: entry,\n        },\n      }))\n    }\n\n    return Promise.all(\n      subConfs.map(async (conf: any) => {\n        const dataAdapter = (await getSubAdapter(conf))\n          .dataAdapter as BaseFeatureDataAdapter\n        return {\n          source: conf.name || dataAdapter.id,\n          ...conf,\n          dataAdapter,\n        }\n      }),\n    )\n  }\n\n  // note: can't really have dis-agreeing refNames\n  public async getRefNames(opts?: BaseOptions) {\n    const adapters = await this.getAdapters()\n    const allNames = await Promise.all(\n      adapters.map(a => a.dataAdapter.getRefNames(opts)),\n    )\n    return [...new Set(allNames.flat())]\n  }\n\n  public async getGlobalStats(opts?: BaseOptions) {\n    const adapters = await this.getAdapters()\n    const stats = (\n      (await Promise.all(\n        // @ts-expect-error\n        adapters.map(adp => adp.dataAdapter.getGlobalStats?.(opts)),\n      )) as MaybeStats[]\n    ).filter(f => !!f)\n    const scoreMin = min(stats.map(s => s.scoreMin))\n    const scoreMax = max(stats.map(s => s.scoreMax))\n    return { scoreMin, scoreMax }\n  }\n\n  public getFeatures(region: Region, opts: WiggleOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const adapters = await this.getAdapters()\n      merge(\n        ...adapters.map(adp =>\n          adp.dataAdapter.getFeatures(region, opts).pipe(\n            map(p =>\n              // add source field if it does not exist\n              p.get('source')\n                ? p\n                : new SimpleFeature({\n                    ...p.toJSON(),\n                    uniqueId: `${adp.source}-${p.id()}`,\n                    source: adp.source,\n                  }),\n            ),\n          ),\n        ),\n      ).subscribe(observer)\n    }, opts.signal)\n  }\n\n  // always render bigwig instead of calculating a feature density for it\n  async getMultiRegionFeatureDensityStats(_regions: Region[]) {\n    return {\n      featureDensity: 0,\n    }\n  }\n\n  // in another adapter type, this could be dynamic depending on region or\n  // something, but it is static for this particular multi-wiggle adapter type\n  async getSources(_regions: Region[]) {\n    const adapters = await this.getAdapters()\n    return adapters.map(({ dataAdapter, source, name, ...rest }) => ({\n      name: source,\n      __name: name,\n      ...rest,\n    }))\n  }\n\n  public freeResources(): void {}\n}\n"],"names":["getFilename","uri","filename","slice","lastIndexOf","MultiWiggleAdapter","BaseFeatureDataAdapter","getAdapters","getSubAdapter","this","Error","subConfs","getConf","length","map","entry","type","source","bigWigLocation","Promise","all","async","dataAdapter","conf","name","id","getRefNames","opts","adapters","allNames","a","Set","flat","getGlobalStats","stats","adp","filter","f","scoreMin","min","s","scoreMax","max","getFeatures","region","ObservableCreate","merge","pipe","p","get","SimpleFeature","toJSON","uniqueId","subscribe","observer","signal","getMultiRegionFeatureDensityStats","_regions","featureDensity","getSources","rest","__name","freeResources"],"sourceRoot":""}