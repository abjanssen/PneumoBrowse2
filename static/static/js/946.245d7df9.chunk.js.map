{"version":3,"file":"static/js/946.245d7df9.chunk.js","mappings":"iNAee,MAAMA,UAA8BC,EAAAA,uBACjD,eAAaC,GACX,MAAMC,QAAgBC,KAAKC,gBAAgBD,KAAKE,QAAQ,qBACxD,IAAKH,EACH,MAAM,IAAII,MAAM,4BAElB,OAAOJ,EAAQK,WACjB,CAEA,iBAAaC,GAEX,aADsBL,KAAKF,aACZO,aACjB,CAEOC,WAAAA,CAAYC,EAAeC,GAChC,OAAOC,EAAAA,EAAAA,mBAA0BC,UAC/B,MAAMC,QAAwBX,KAAKF,YAE7Bc,EAAWL,EAAMM,IADZ,IAELC,EAAaC,KAAKC,IAAI,EAAGT,EAAMU,MAF1B,KAIX,GAAIL,EAAW,GAAKE,EAAaF,EAE/B,YADAM,EAASC,WAIX,MAAMC,EAAMT,EAAgBL,YAC1B,IACKC,EACHU,MAAOH,EACPD,IAAKD,GAEPJ,GAEIa,QAAcC,EAAAA,EAAAA,GAAeF,EAAIG,MAAKC,EAAAA,EAAAA,OACtCC,EAAmBJ,EAAM,IAAIK,IAAI,QAAU,GAC3CC,EAAS3B,KAAKE,QAAQ,UACtB0B,EAAgB5B,KAAKE,QAAQ,iBAC7B2B,EAAgB7B,KAAKE,QAAQ,iBAC7B4B,EAAkB9B,KAAKE,QAAQ,mBAC/B6B,EAAK,IAAIC,OAAOL,EAAQ,KAAIG,EAAkB,IAAM,KAE1D,GAAIH,EAAQ,CACV,GAAIC,EAAe,CACjB,MAAMK,EAAUR,EAASS,SAASH,GAClC,IAAK,MAAMI,KAASF,EAAS,CAC3B,MAAMG,EAAItB,EAAaqB,EAAME,MACvBC,EAAIxB,EAAaqB,EAAME,MAAQF,EAAM,GAAGI,QAC1CC,EAAAA,EAAAA,gBAAeJ,EAAGE,EAAG/B,EAAMU,MAAOV,EAAMM,MAC1CK,EAASuB,KACP,IAAIC,EAAAA,cAAc,CAChBC,SAAU,GAAG3C,KAAK4C,MAAMR,KAAKD,EAAM,SACnCU,QAAStC,EAAMsC,QACf5B,MAAOmB,EACPvB,IAAKyB,EACLQ,KAAMX,EAAM,GACZY,OAAQ,IAIhB,CACF,CACA,GAAIlB,EAAe,CACjB,MAAMI,GAAUe,EAAAA,EAAAA,QAAOvB,GAAUS,SAASH,GAC1C,IAAK,MAAMI,KAASF,EAAS,CAC3B,MAAMK,EAAI1B,EAAWuB,EAAME,MACrBD,EAAIxB,EAAWuB,EAAME,MAAQF,EAAM,GAAGI,QACxCC,EAAAA,EAAAA,gBAAeJ,EAAGE,EAAG/B,EAAMU,MAAOV,EAAMM,MAC1CK,EAASuB,KACP,IAAIC,EAAAA,cAAc,CAChBC,SAAU,GAAG3C,KAAK4C,MAAMR,KAAKD,EAAM,SACnCU,QAAStC,EAAMsC,QACf5B,MAAOmB,EACPvB,IAAKyB,EACLQ,KAAMX,EAAM,GACZY,QAAS,IAIjB,CACF,CACF,CAEA7B,EAASC,UAAU,GAEvB,CAEO8B,aAAAA,GAAiB,E","sources":["../../../plugins/sequence/src/SequenceSearchAdapter/SequenceSearchAdapter.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport {\n  SimpleFeature,\n  Feature,\n  Region,\n  revcom,\n  doesIntersect2,\n} from '@jbrowse/core/util'\nimport { toArray } from 'rxjs/operators'\nimport { firstValueFrom } from 'rxjs'\n\nexport default class SequenceSearchAdapter extends BaseFeatureDataAdapter {\n  public async configure() {\n    const adapter = await this.getSubAdapter?.(this.getConf('sequenceAdapter'))\n    if (!adapter) {\n      throw new Error('Error getting subadapter')\n    }\n    return adapter.dataAdapter as BaseFeatureDataAdapter\n  }\n\n  public async getRefNames() {\n    const adapter = await this.configure()\n    return adapter.getRefNames()\n  }\n\n  public getFeatures(query: Region, opts: BaseOptions) {\n    return ObservableCreate<Feature>(async observer => {\n      const sequenceAdapter = await this.configure()\n      const hw = 10000\n      const queryEnd = query.end + hw\n      const queryStart = Math.max(0, query.start - hw)\n\n      if (queryEnd < 0 || queryStart > queryEnd) {\n        observer.complete()\n        return\n      }\n\n      const ret = sequenceAdapter.getFeatures(\n        {\n          ...query,\n          start: queryStart,\n          end: queryEnd,\n        },\n        opts,\n      )\n      const feats = await firstValueFrom(ret.pipe(toArray()))\n      const residues: string = feats[0]?.get('seq') || ''\n      const search = this.getConf('search') as string\n      const searchForward = this.getConf('searchForward')\n      const searchReverse = this.getConf('searchReverse')\n      const caseInsensitive = this.getConf('caseInsensitive')\n      const re = new RegExp(search, `g${caseInsensitive ? 'i' : ''}`)\n\n      if (search) {\n        if (searchForward) {\n          const matches = residues.matchAll(re)\n          for (const match of matches) {\n            const s = queryStart + match.index\n            const e = queryStart + match.index + match[0].length\n            if (doesIntersect2(s, e, query.start, query.end)) {\n              observer.next(\n                new SimpleFeature({\n                  uniqueId: `${this.id}-${s}-${match[0]}-pos`,\n                  refName: query.refName,\n                  start: s,\n                  end: e,\n                  name: match[0],\n                  strand: 1,\n                }),\n              )\n            }\n          }\n        }\n        if (searchReverse) {\n          const matches = revcom(residues).matchAll(re)\n          for (const match of matches) {\n            const e = queryEnd - match.index\n            const s = queryEnd - match.index - match[0].length\n            if (doesIntersect2(s, e, query.start, query.end)) {\n              observer.next(\n                new SimpleFeature({\n                  uniqueId: `${this.id}-${s}-${match[0]}-neg`,\n                  refName: query.refName,\n                  start: s,\n                  end: e,\n                  name: match[0],\n                  strand: -1,\n                }),\n              )\n            }\n          }\n        }\n      }\n\n      observer.complete()\n    })\n  }\n\n  public freeResources() {}\n}\n"],"names":["SequenceSearchAdapter","BaseFeatureDataAdapter","configure","adapter","this","getSubAdapter","getConf","Error","dataAdapter","getRefNames","getFeatures","query","opts","ObservableCreate","async","sequenceAdapter","queryEnd","end","queryStart","Math","max","start","observer","complete","ret","feats","firstValueFrom","pipe","toArray","residues","get","search","searchForward","searchReverse","caseInsensitive","re","RegExp","matches","matchAll","match","s","index","e","length","doesIntersect2","next","SimpleFeature","uniqueId","id","refName","name","strand","revcom","freeResources"],"sourceRoot":""}