{"version":3,"file":"static/js/3167.fb863b4e.chunk.js","mappings":"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","sources":["../../../plugins/comparative-adapters/src/PairwiseIndexedPAFAdapter/PairwiseIndexedPAFAdapter.ts","../../../plugins/comparative-adapters/src/SyntenyFeature/index.ts","../../../plugins/comparative-adapters/src/util.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { FileLocation, Region } from '@jbrowse/core/util/types'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport { Feature } from '@jbrowse/core/util'\nimport { AnyConfigurationModel } from '@jbrowse/core/configuration'\nimport { getSubAdapterType } from '@jbrowse/core/data_adapters/dataAdapterCache'\nimport PluginManager from '@jbrowse/core/PluginManager'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { TabixIndexedFile } from '@gmod/tabix'\n\n// locals\nimport { parsePAFLine } from '../util'\nimport SyntenyFeature from '../SyntenyFeature'\n\ninterface PAFOptions extends BaseOptions {\n  config?: AnyConfigurationModel\n}\n\nexport default class PAFAdapter extends BaseFeatureDataAdapter {\n  public static capabilities = ['getFeatures', 'getRefNames']\n\n  protected pif: TabixIndexedFile\n\n  public constructor(\n    config: AnyConfigurationModel,\n    getSubAdapter?: getSubAdapterType,\n    pluginManager?: PluginManager,\n  ) {\n    super(config, getSubAdapter, pluginManager)\n    const pifGzLoc = this.getConf('pifGzLocation') as FileLocation\n    const type = this.getConf(['index', 'indexType'])\n    const loc = this.getConf(['index', 'location'])\n    const pm = this.pluginManager\n\n    this.pif = new TabixIndexedFile({\n      filehandle: openLocation(pifGzLoc, pm),\n      csiFilehandle: type === 'CSI' ? openLocation(loc, pm) : undefined,\n      tbiFilehandle: type !== 'CSI' ? openLocation(loc, pm) : undefined,\n      chunkCacheSize: 50 * 2 ** 20,\n    })\n  }\n  async getHeader() {\n    return this.pif.getHeader()\n  }\n\n  getAssemblyNames(): string[] {\n    const assemblyNames = this.getConf('assemblyNames') as string[]\n    if (assemblyNames.length === 0) {\n      return [\n        this.getConf('queryAssembly') as string,\n        this.getConf('targetAssembly') as string,\n      ]\n    }\n    return assemblyNames\n  }\n\n  public async hasDataForRefName() {\n    return true\n  }\n\n  async getRefNames(opts: BaseOptions & { regions?: Region[] } = {}) {\n    const r1 = opts.regions?.[0]?.assemblyName\n    if (!r1) {\n      throw new Error('no assembly name provided')\n    }\n\n    const idx = this.getAssemblyNames().indexOf(r1)\n    const names = await this.pif.getReferenceSequenceNames(opts)\n    if (idx === 0) {\n      return names.filter(n => n.startsWith('q')).map(n => n.slice(1))\n    } else if (idx === 1) {\n      return names.filter(n => n.startsWith('t')).map(n => n.slice(1))\n    } else {\n      return []\n    }\n  }\n\n  getFeatures(query: Region, opts: PAFOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      const { assemblyName } = query\n\n      const assemblyNames = this.getAssemblyNames()\n      const index = assemblyNames.indexOf(assemblyName)\n      const flip = index === 0\n      const letter = flip ? 'q' : 't'\n\n      await this.pif.getLines(letter + query.refName, query.start, query.end, {\n        lineCallback: (line, fileOffset) => {\n          const r = parsePAFLine(line)\n          const refName = r.qname.slice(1)\n          const start = r.qstart\n          const end = r.qend\n          const mateName = r.tname\n          const mateStart = r.tstart\n          const mateEnd = r.tend\n\n          const { extra, strand } = r\n          const { numMatches = 0, blockLen = 1, cg, ...rest } = extra\n\n          observer.next(\n            new SyntenyFeature({\n              uniqueId: fileOffset + assemblyName,\n              assemblyName,\n              start,\n              end,\n              type: 'match',\n              refName,\n              strand,\n              ...rest,\n              CIGAR: extra.cg,\n              syntenyId: fileOffset,\n              identity: numMatches / blockLen,\n              numMatches,\n              blockLen,\n              mate: {\n                start: mateStart,\n                end: mateEnd,\n                refName: mateName,\n                assemblyName: assemblyNames[+flip],\n              },\n            }),\n          )\n        },\n        signal: opts.signal,\n      })\n\n      observer.complete()\n    })\n  }\n\n  freeResources(/* { query } */): void {}\n}\n","import { SimpleFeature } from '@jbrowse/core/util'\nimport { MismatchParser } from '@jbrowse/plugin-alignments'\n\n// locals\nconst { getMismatches } = MismatchParser\n\nexport default class SyntenyFeature extends SimpleFeature {\n  get(arg: string): any {\n    if (arg === 'mismatches') {\n      return getMismatches(this.get('CIGAR'))\n    }\n    return super.get(arg)\n  }\n}\n","import { BaseOptions } from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { GenericFilehandle } from 'generic-filehandle'\nimport { fetchAndMaybeUnzip } from '@jbrowse/core/util'\nimport type { Buffer } from 'buffer'\n\nimport { PAFRecord } from './PAFAdapter/util'\n\nexport function parseBed(text: string) {\n  return new Map(\n    text\n      .split(/\\n|\\r\\n|\\r/)\n      .filter(f => !!f || f.startsWith('#'))\n      .map(line => {\n        const [refName, start, end, name, score, strand] = line.split('\\t')\n        return [\n          name,\n          {\n            refName,\n            start: +start!,\n            end: +end!,\n            score: +score!,\n            name,\n            strand: strand === '-' ? -1 : 1,\n          },\n        ]\n      }),\n  )\n}\n\nexport async function readFile(file: GenericFilehandle, opts?: BaseOptions) {\n  const buf = await fetchAndMaybeUnzip(file, opts)\n  const decoder = new TextDecoder('utf8')\n  return decoder.decode(buf)\n}\n\nexport function zip(a: number[], b: number[]) {\n  return a.map((e, i) => [e, b[i]] as [number, number])\n}\n\nexport function parseLineByLine<T>(\n  buffer: Buffer,\n  cb: (line: string) => T | undefined,\n): T[] {\n  let blockStart = 0\n  const entries: T[] = []\n  const decoder = new TextDecoder('utf8')\n  while (blockStart < buffer.length) {\n    const n = buffer.indexOf('\\n', blockStart)\n    if (n === -1) {\n      break\n    }\n    const b = buffer.subarray(blockStart, n)\n    const line = decoder.decode(b).trim()\n    if (line) {\n      const entry = cb(line)\n      if (entry) {\n        entries.push(entry)\n      }\n    }\n\n    blockStart = n + 1\n  }\n  return entries\n}\n\nexport function parsePAFLine(line: string) {\n  const [\n    qname,\n    ,\n    qstart,\n    qend,\n    strand,\n    tname,\n    ,\n    tstart,\n    tend,\n    numMatches,\n    blockLen,\n    mappingQual,\n    ...fields\n  ] = line.split('\\t')\n\n  const rest = Object.fromEntries(\n    fields.map(field => {\n      const r = field.indexOf(':')\n      const fieldName = field.slice(0, r)\n      const fieldValue = field.slice(r + 3)\n      return [fieldName, fieldValue]\n    }),\n  )\n\n  return {\n    tname,\n    tstart: +tstart!,\n    tend: +tend!,\n    qname,\n    qstart: +qstart!,\n    qend: +qend!,\n    strand: strand === '-' ? -1 : 1,\n    extra: {\n      numMatches: +numMatches!,\n      blockLen: +blockLen!,\n      mappingQual: +mappingQual!,\n      ...rest,\n    },\n  } as PAFRecord\n}\n\nexport function flipCigar(cigar: string[]) {\n  const arr = []\n  for (let i = cigar.length - 2; i >= 0; i -= 2) {\n    arr.push(cigar[i])\n    const op = cigar[i + 1]\n    if (op === 'D') {\n      arr.push('I')\n    } else if (op === 'I') {\n      arr.push('D')\n    } else {\n      arr.push(op)\n    }\n  }\n  return arr\n}\n\nexport function swapIndelCigar(cigar: string) {\n  return cigar.replaceAll('D', 'K').replaceAll('I', 'D').replaceAll('K', 'I')\n}\n"],"names":["PAFAdapter","BaseFeatureDataAdapter","constructor","config","getSubAdapter","pluginManager","super","pifGzLoc","this","getConf","type","loc","pm","pif","TabixIndexedFile","filehandle","openLocation","csiFilehandle","undefined","tbiFilehandle","chunkCacheSize","getHeader","getAssemblyNames","assemblyNames","length","hasDataForRefName","getRefNames","opts","r1","regions","assemblyName","Error","idx","indexOf","names","getReferenceSequenceNames","filter","n","startsWith","map","slice","getFeatures","query","ObservableCreate","async","flip","letter","getLines","refName","start","end","lineCallback","line","fileOffset","r","parsePAFLine","qname","qstart","qend","mateName","tname","mateStart","tstart","mateEnd","tend","extra","strand","numMatches","blockLen","cg","rest","observer","next","SyntenyFeature","uniqueId","CIGAR","syntenyId","identity","mate","signal","complete","freeResources","getMismatches","MismatchParser","SimpleFeature","get","arg","parseBed","text","Map","split","f","name","score","readFile","file","buf","fetchAndMaybeUnzip","TextDecoder","decode","zip","a","b","e","i","parseLineByLine","buffer","cb","blockStart","entries","decoder","subarray","trim","entry","push","mappingQual","fields","Object","fromEntries","field","flipCigar","cigar","arr","op","swapIndelCigar","replaceAll"],"sourceRoot":""}