{"version":3,"file":"static/js/7809.41965eb6.chunk.js","mappings":"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","sources":["../../../plugins/gff3/src/Gff3Adapter/Gff3Adapter.ts","../../../plugins/gff3/src/featureData.ts"],"sourcesContent":["import {\n  BaseFeatureDataAdapter,\n  BaseOptions,\n} from '@jbrowse/core/data_adapters/BaseAdapter'\nimport { NoAssemblyRegion } from '@jbrowse/core/util/types'\nimport { openLocation } from '@jbrowse/core/util/io'\nimport { ObservableCreate } from '@jbrowse/core/util/rxjs'\nimport IntervalTree from '@flatten-js/interval-tree'\nimport SimpleFeature, { Feature } from '@jbrowse/core/util/simpleFeature'\nimport { parseStringSync } from 'gff-nostream'\nimport { fetchAndMaybeUnzip } from '@jbrowse/core/util'\n\nimport { featureData } from '../featureData'\n\ntype StatusCallback = (arg: string) => void\n\nexport default class Gff3Adapter extends BaseFeatureDataAdapter {\n  calculatedIntervalTreeMap: Record<string, IntervalTree> = {}\n\n  gffFeatures?: Promise<{\n    header: string\n    intervalTreeMap: Record<string, (sc?: StatusCallback) => IntervalTree>\n  }>\n\n  private async loadDataP(opts?: BaseOptions) {\n    const { statusCallback = () => {} } = opts || {}\n    const buffer = await fetchAndMaybeUnzip(\n      openLocation(this.getConf('gffLocation'), this.pluginManager),\n    )\n\n    const headerLines = []\n    const featureMap = {} as Record<string, string>\n    const decoder = new TextDecoder('utf8')\n    let blockStart = 0\n    let i = 0\n    while (blockStart < buffer.length) {\n      const n = buffer.indexOf('\\n', blockStart)\n      // could be a non-newline ended file, so subarray to end of file if n===-1\n      const b =\n        n === -1 ? buffer.subarray(blockStart) : buffer.subarray(blockStart, n)\n      const line = decoder.decode(b).trim()\n      if (line) {\n        if (line.startsWith('#')) {\n          headerLines.push(line)\n        } else if (line.startsWith('>')) {\n          break\n        } else {\n          const ret = line.indexOf('\\t')\n          const refName = line.slice(0, ret)\n          if (!featureMap[refName]) {\n            featureMap[refName] = ''\n          }\n          featureMap[refName] += `${line}\\n`\n        }\n      }\n      if (i++ % 10_000 === 0) {\n        statusCallback(\n          `Loading ${Math.floor(blockStart / 1_000_000).toLocaleString('en-US')}/${Math.floor(buffer.length / 1_000_000).toLocaleString('en-US')} MB`,\n        )\n      }\n\n      blockStart = n + 1\n    }\n\n    const intervalTreeMap = Object.fromEntries(\n      Object.entries(featureMap).map(([refName, lines]) => [\n        refName,\n        (sc?: (arg: string) => void) => {\n          if (!this.calculatedIntervalTreeMap[refName]) {\n            sc?.('Parsing GFF data')\n            const intervalTree = new IntervalTree()\n            parseStringSync(lines)\n              .flat()\n              .map(\n                (f, i) =>\n                  new SimpleFeature({\n                    data: featureData(f),\n                    id: `${this.id}-${refName}-${i}`,\n                  }),\n              )\n              .forEach(obj =>\n                intervalTree.insert([obj.get('start'), obj.get('end')], obj),\n              )\n            this.calculatedIntervalTreeMap[refName] = intervalTree\n          }\n          return this.calculatedIntervalTreeMap[refName]\n        },\n      ]),\n    )\n\n    return {\n      header: headerLines.join('\\n'),\n      intervalTreeMap,\n    }\n  }\n\n  private async loadData(opts: BaseOptions) {\n    if (!this.gffFeatures) {\n      this.gffFeatures = this.loadDataP(opts).catch((e: unknown) => {\n        this.gffFeatures = undefined\n        throw e\n      })\n    }\n\n    return this.gffFeatures\n  }\n\n  public async getRefNames(opts: BaseOptions = {}) {\n    const { intervalTreeMap } = await this.loadData(opts)\n    return Object.keys(intervalTreeMap)\n  }\n\n  public async getHeader(opts: BaseOptions = {}) {\n    const { header } = await this.loadData(opts)\n    return header\n  }\n\n  public getFeatures(query: NoAssemblyRegion, opts: BaseOptions = {}) {\n    return ObservableCreate<Feature>(async observer => {\n      try {\n        const { start, end, refName } = query\n        const { intervalTreeMap } = await this.loadData(opts)\n        intervalTreeMap[refName]?.(opts.statusCallback)\n          .search([start, end])\n          .forEach(f => {\n            observer.next(f)\n          })\n        observer.complete()\n      } catch (e) {\n        observer.error(e)\n      }\n    }, opts.signal)\n  }\n\n  public freeResources(/* { region } */) {}\n}\n","import { GFF3FeatureLineWithRefs } from 'gff-nostream'\n\ninterface GFF3Feature {\n  start: number\n  end: number\n  strand?: number\n  type: string | null\n  source: string | null\n  refName: string\n  derived_features: unknown[] | null\n  phase?: number\n  score?: number\n  subfeatures: GFF3Feature[] | undefined\n  [key: string]: unknown\n}\n\nexport function featureData(data: GFF3FeatureLineWithRefs): GFF3Feature {\n  const {\n    end,\n    start,\n    child_features,\n    derived_features,\n    attributes,\n    type,\n    source,\n    phase,\n    seq_id,\n    score,\n    strand,\n  } = data\n\n  let strand2: number | undefined\n  if (strand === '+') {\n    strand2 = 1\n  } else if (strand === '-') {\n    strand2 = -1\n  } else if (strand === '.') {\n    strand2 = 0\n  }\n\n  const defaultFields = new Set([\n    'start',\n    'end',\n    'seq_id',\n    'score',\n    'type',\n    'source',\n    'phase',\n    'strand',\n  ])\n  const dataAttributes = attributes || {}\n  const resultAttributes = {} as Record<string, unknown>\n  for (const a of Object.keys(dataAttributes)) {\n    let b = a.toLowerCase()\n    if (defaultFields.has(b)) {\n      // add \"suffix\" to tag name if it already exists\n      // reproduces behavior of NCList\n      b += '2'\n    }\n    if (dataAttributes[a] && a !== '_lineHash') {\n      let attr: string | string[] | undefined = dataAttributes[a]\n      if (Array.isArray(attr) && attr.length === 1) {\n        ;[attr] = attr\n      }\n      resultAttributes[b] = attr\n    }\n  }\n\n  return {\n    ...resultAttributes,\n    start: start! - 1,\n    end: end!,\n    strand: strand2,\n    type,\n    source,\n    refName: seq_id!,\n    derived_features,\n    phase: phase === null ? undefined : Number(phase),\n    score: score === null ? undefined : score,\n    subfeatures: child_features.flatMap(childLocs =>\n      childLocs.map(childLoc => featureData(childLoc)),\n    ),\n  }\n}\n"],"names":["Gff3Adapter","BaseFeatureDataAdapter","calculatedIntervalTreeMap","loadDataP","opts","statusCallback","buffer","fetchAndMaybeUnzip","openLocation","this","getConf","pluginManager","headerLines","featureMap","decoder","TextDecoder","blockStart","i","length","n","indexOf","b","subarray","line","decode","trim","startsWith","push","ret","refName","slice","Math","floor","toLocaleString","intervalTreeMap","Object","fromEntries","entries","map","lines","sc","intervalTree","IntervalTree","parseStringSync","flat","f","SimpleFeature","data","featureData","id","forEach","obj","insert","get","header","join","loadData","gffFeatures","catch","e","undefined","getRefNames","keys","getHeader","getFeatures","query","ObservableCreate","async","start","end","search","observer","next","complete","error","signal","freeResources","child_features","derived_features","attributes","type","source","phase","seq_id","score","strand","strand2","defaultFields","Set","dataAttributes","resultAttributes","a","toLowerCase","has","attr","Array","isArray","Number","subfeatures","flatMap","childLocs","childLoc"],"sourceRoot":""}